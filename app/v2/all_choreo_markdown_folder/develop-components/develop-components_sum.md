 # Bring Your Own Image (BYOI)

Choreo allows you to deploy and manage prebuilt container images from external container registries as Choreo components. This enables you to deploy and effectively manage your container images within the Choreo environment.

!!! info
    This feature is currently only available on [private data planes (PDPs)](../choreo-concepts/data-planes.md#private-data-planes) for the following component types:

    - Service
    - Web Application
    - Scheduled Task
    - Manual Task


## Prerequisites

Before you try out this guide, ensure you have the following:

- **A container registry**: Ensure you have a container registry containing the images you want to deploy. Choreo is compatible with various container registries, including but not limited to GCR (Google Container Registry), ACR (Azure Container Registry), GitHub Container Registry, and Docker Hub.

- **An image in the registry**: You need an image ready for deployment.

- **(Optional) An external build/CI pipeline**:  This is to initiate automatic deployments during the build process outside of Choreo.

When using a container registry to deploy a component, Choreo cannot create an image from the source code (Git) or initiate a new deployment when a new image is ready. However, you can use your existing build process to trigger a deployment on Choreo by sending an HTTP POST request to a webhook with the new image details.

This feature is currently only available on private data planes (PDPs). You can find this option under **Deploy an image from a container registry** in the **Select Source** step during component creation for service components, web applications, scheduled tasks, and manual tasks.

## Step 1: Register a container registry

To get started, establish a connection between your container registry and Choreo. 

!!! Info
    When you use your Choreo credentials, Choreo does not *pull* your images into its control plane. Instead, it functions as an orchestrator, facilitating your data plane's ability to retrieve images from an external container registry. Choreo passes on these credentials to the data plane for authentication and access.

To register your container registry, follow these steps:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the Choreo Console header, go to the **Organization** list and select your organization. 
3. In the left navigation menu, click **Settings**. This opens the organization settings page. 
4. Click the **Credentials** tab and then click the **Container Registries** tab. 
5. Click **+Add Registry** to configure the Git repository connection.
6. Specify a **Registry Display Name**.
7. Select the **Authentication Type**. Fill in the required information depending on your authentication type. For details on each authentication type, see [Authentication types](#authentication-types).
8. Click **Save**.

### Authentication types

Choreo provides the following authentication options:  

#### Public (anonymous) access
    
You can use this option to establish a connection with a container registry that permits unrestricted public or anonymous access (for example, Public Docker Hub). In this case, only the registry host information is necessary.

For example, the following are the Docker Hub registry hosts for reference:

| Vendor                           | Registry host                |
|----------------------------------|------------------------------|
|Docker Hub (public repositories)  | `registry.hub.docker.com`    |
|Docker Hub (private repositories) | `registry.docker.com`        |

\* If necessary, you can use other mirrors instead of the above.

#### Basic authentication

To use basic authentication to authenticate to the container registry, you must provide the username and password.

#### Docker config

You can provide a Docker config in JSON format to authenticate to the container registry. This option only allows you to register one container registry. That is, it **only allows a single registry under `auths`**.

You must provide the credentials directly within the configuration. Choreo cannot utilize references to executable authentication plugins.

Sample Docker config format:

```json
    {
    "auths": {
        "index.docker.io/v1/": {
        "auth": "c3R...zE2"
        }
    }
    }
```

#### Vendor-specific authentication

This option is specifically for private data planes, where your cloud provider manages authentication at the Kubernetes level. Choreo requires knowledge of the registry host because the data plane already possesses implicit (preconfigured) access to the registry.

Follow the guidelines below based on your container registry:

=== "ACR"
    **Azure Container Registry** 

    Recommended authentication options:

    * [**Service principal-based basic authentication**](https://learn.microsoft.com/en-us/azure/container-registry/container-registry-auth-service-principal)

    * **Vendor-specific authentication on Azure private data planes**
        
        Contact Choreo support to enable infrastructure-level private access to your registry from your Azure private data plane on AKS. If you are on a self-managed PDP on Azure, follow [this guide](https://learn.microsoft.com/en-us/azure/aks/cluster-container-registry-integration?toc=%2Fazure%2Fcontainer-registry%2Ftoc.json&bc=%2Fazure%2Fcontainer-registry%2Fbreadcrumb%2Ftoc.json&tabs=azure-cli).

=== "GAR"
    **Google Artifact Registry**

    Recommended authentication options:

    * [**Service account-based basic authentication**](https://cloud.google.com/artifact-registry/docs/docker/pushing-and-pulling#key)

        Use the service account key in JSON format ([`_json_key`](https://cloud.google.com/artifact-registry/docs/docker/authentication#:~:text=of%20the%20following%3A-,_json_key,-if%20you%20are)) as the username and specify the minified JSON contents of the service account key as the password.

         You can use `jq` as follows to minify the service account JSON key file:

         `jq -c . <service-account.json>`

    * **Vendor-specific authentication on GCP private data planes**

        Contact Choreo support to enable infrastructure-level private access to your registry from your GCP private data plane on GKE. If you are on a self-managed PDP on GCP, see [https://cloud.google.com/artifact-registry/docs/access-control#grant-project](https://cloud.google.com/artifact-registry/docs/access-control#grant-project).

=== "AWS ECR"
    **Elastic Container Registry**

    ECR does not allow the creation of static access passwords for basic authentication. The passwords (that is, access tokens) provided by AWS are only valid for 10 hours and must be manually regenerated. However, when an ECR is attached to an EKS cluster at an infrastructure level, this limitation does not apply because the authentication is handled by AWS internally. For details, see [https://docs.aws.amazon.com/AmazonECR/latest/userguide/registry_auth.html](https://docs.aws.amazon.com/AmazonECR/latest/userguide/registry_auth.html).

    Choreo recommends using ECR when you are exclusively on an AWS private data plane using the vendor-specific authentication option. Contact Choreo support to enable a private connection between your ECR and the underlying EKS clusters on your data plane. If you are on a self-managed PDP, you can follow [this guide](https://docs.aws.amazon.com/AmazonECR/latest/userguide/ECR_on_EKS.html).    

=== "Docker Hub (Private)"

    Recommended authentication options:

    * **Basic authentication**

          Use your Docker Hub username/password or an access token. You can generate an access token from your Docker Hub account settings and use it in place of the password. For details, see [https://docs.docker.com/docker-hub/access-tokens/](https://docs.docker.com/docker-hub/access-tokens/).

    * **Docker config**

          Sign in to the Docker CLI and copy the contents of the docker config JSON. Note that external credential stores and multiple repositories within the same config object are not supported. For more information, see [https://docs.docker.com/engine/reference/commandline/login/](https://docs.docker.com/engine/reference/commandline/login/).

=== "GHCR"
    **GitHub Container Registry**

    Recommended authentication option:

    * **Basic authentication using a PAT token**

          Create a personal access token (PAT) and use it in place of the password. You cannot use your own GitHub password. You must provide a [PAT token](https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry#authenticating-with-a-personal-access-token-classicn).
  
## Step 2: Create a component in Choreo

1. In the left navigation, click **Overview** and select your project. Alternatively, select your project from the **Project** list in the Choreo Console header. 
2. Under **Component Listing** click **+ Create**.
3. Select your component type (BYOI is only available for Service, Web Application, Scheduled Task, or Manual Task components). 
4. From the Create Component pane, select the **Container Registry** under the **Connect a Docker Image** section.
5. Under **Deploy an image from Container Registry/Docker Hub**, select the container registry you have registered in [Step 1](#step-1-register-a-container-registry).
6. Enter the full image URL. The image URL format in general is as follows:
   `[container-registry-host]/[repository-name]/[image-name]:[tag]`

    !!! tip
        When a public image from Docker Hub lacks a specified repository name, it typically defaults to `/library/`. For example, you can access the public Nginx image `https://hub.docker.com/_/nginx` as `registry.hub.docker.com/library/nginx:1.25`.

7. Enter a display name, a unique name, and a description for the component.
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.


## Step 3: Deploy the component in Choreo

To deploy the component and bring your image to Choreo, follow the steps given below: 

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Update Image & Deploy**. 
3. In the **Endpoint** pane that opens, you can see the endpoint ready to be deployed. Click the edit icon next to the endpoint name. Optionally, you can define the endpoints for your service when you manually deploy the service. For more information, see [Expose service endpoints](#step-4-expose-service-endpoints).
4. Change the **Network Visibility** to **Public**. This setting securely exposes the endpoint for consumption.
5. Click **Update**.

    !!! info
         In this example, you deploy a Ballerina service as a REST endpoint. Therefore, Choreo generated the REST endpoint automatically. If you deploy a non-Ballerina service, you must manually add the REST endpoint and set the network visibility to **Public**.

6. Select your update image option. Refer to the update options listed below.

    You have the capability of updating the image when you are deploying the component in Choreo in one of the following three ways:

    | Option                   |Description                                                                                             |
    |--------------------------|--------------------------------------------------------------------------------------------------------|
    | **Update Image Tag**     | This option allows you to update the tag of the image.                                                 |
    | **Update Image URL**     | With this option, you can change the image name, tag, and the image repository of the image URL.|
    | **Previous Images**      | This option allows you to select a previous image and redeploy the image.                               |

7. Click **Deploy**. This deploys the service to the development environment.

## Step 4: Expose service endpoints 

!!! info
    This section only applies to service components.

After creating a service component in Choreo, you have the option to define the endpoints for your service when manually deploying a new image.

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Update Image & Deploy**. 
3. In the **Endpoint** pane that opens, optionally, you can define the endpoints for your service when you manually deploy the service. 
4. Click  **Create/Update Endpoints**.
5. Under the **Edit endpoints.yaml** section, you can edit the endpoints YAML file in the provided editor. 
   Alternatively, you can upload the associated API specification/schema files (OpenAPI/GraphQL schemas). Instead of specifying the file path, you can also reference this file in the `endpoints.yaml` file by its file name, similar to the Git-based Choreo components. The endpoints template follows the standard definitions for defining endpoints in Choreo. For more details, see [Configure Endpoints](../develop-components/configure-endpoints.md).

## Auto-deploy images in Choreo with an external CI/build pipeline

Choreo does not have automatic detection and deployment for newly added images or tags in the linked container registry. To overcome this limitation, Choreo allows you to integrate your own CI pipelines and initiate deployments manually. This approach enables you to use your existing CI setup or build a pipeline for image creation and pushing. You can then trigger automatic deployments using a webhook.

Follow the steps below to configure your CI/build pipeline:

1. Build and push the container image associated with a Choreo component to your container registry.
2. In the left navigation menu, click **DevOps** and then click **External CI**.
3. Generate a token for your CI pipeline from the **Manage Tokens** section. 

    !!! note
        - The tokens are bound to a specific component.
        - It is recommended to reference the token from a secure location available to your CI pipeline. For example, use a GitHub secret if you are using GitHub Actions.

4. To trigger an automatic deployment to your development environment, you can initiate an HTTP POST request to the Choreo webhook endpoint with the updated image details. Alternatively, you can use the provided Webhook snippets. This action will seamlessly deploy the image to the development environment.



Services and integrations are exposed to other services, integrations, or applications through endpoints. A service or an integration can expose multiple endpoints, each representing a unique entry point into the service. For example, a service may expose a REST API endpoint and a GraphQL endpoint, each providing different ways to interact with the service. Endpoints provide specific details for how the service or the integration can be consumed. For instance, the port number, protocol, and the schema such as open API specification (OAS) or GraphQL schema. By defining these details, endpoints make it possible for other services, integrations, and applications to discover and interact with the service in a standardized way.

Choreo defines endpoints by combining port binding, protocol, endpoint name, network visibility, endpoint schema, and additional protocol-related fields. The following table describes each attribute of an endpoint.

| Field | Description |
| ----- | ----------- |
| Name | A unique identifier for the endpoint within the service component. |
| Port | The network port on which the endpoint is accessible. |
| Type | The endpoint protocol. Supported protocols: REST, GraphQL, gRPC, WS, UDP, and TCP. |
| Network Visibility | Determines the level of visibility of an endpoint. Possible values are: <ul><li>Project: Allows components within the same project to access the endpoint.</li><li>Organization: Allows any component within the same organization to access the endpoint but restricts access to components outside the organization.</li><li>Public: Allows any client to access the endpoint, regardless of location or organization.</li></ul> |
| Schema | Specifies the structure and format of the data exchanged through the endpoint. |
| Context (HTTP and GraphQL only) | A context path that you add to the endpoint's URL for routing purposes. |

## Configure endpoints
The method of defining endpoints depends on the buildpack.

* For `Ballerina` and `WSO2 MI` buildpacks, Choreo automatically detects the endpoint details for REST APIs.
* For all other buildpacks (Java, Python, NodeJS, Ruby, PHP, Go, Dockerfile, etc.), you can configure endpoints in one of the following ways:
  
    * **Using the Choreo Console**: If a `component.yaml` file is not present, you can define a basic endpoint configuration during component creation.
    * **Using the component.yaml file**: You can manually configure endpoint details by defining them in a `component.yaml` file, placing it inside the `.choreo` directory at the build context path, and committing it to the source repository.

You can override UI-defined and auto-generated endpoints by providing a `component.yaml` file in the `.choreo` directory, which will take priority over other configurations.

To learn about the `component.yaml` file, see [Overview of the component.yaml file](../develop-components/manage-component-source-configurations.md#overview-of-the-componentyaml-file).
!!! note
    Automatic endpoint generation is not supported for dynamic endpoint parameters such as variable ports. Therefore, you must use an `component.yaml` file to define dynamic endpoint parameters.

To learn about the `component.yaml` file, see [Overview of the component.yaml file](../develop-components/manage-component-source-configurations.md#overview-of-the-componentyaml-file).

## Expose endpoints as managed APIs

Exposing endpoints as managed APIs is crucial to ensure secure and controlled access to the services being exposed. When a user wants to expose their written service to the outside world or to the organization at large, there is an inherent security risk involved. To mitigate this risk, the Choreo platform is built with an internal (access within the organization only) or external (publicly accessible) gateway that is protected with Choreo API management making the services secure by design.

!!! note
    This feature is not available for gRPC, UDP, and TCP endpoints.

If you want to expose an endpoint as a managed API in Choreo, you need to set the network visibility to either Organization or Public. This allows the endpoint to be exposed through the Choreo API Gateway, which provides a number of benefits, including:

* Expose APIs to external and internal consumers
* Full lifecycle API Management
* API throttling
* Secure APIs with industry-standard authorization flows
* API analytics and monitoring

Once you deploy the service component, Choreo will expose the endpoint as a managed API through the Choreo API Gateway. You can then use the full lifecycle API management features provided by Choreo to test, deploy, maintain, monitor, and manage your API using the API management features.

## Understand the default component URL

The default URL of a component corresponds to the default endpoint of the component and is structured as follows:

`<domain>/<project-name>/<component-name>`

This URL does not include the default endpoint name. For all other endpoints, the URL structure includes the endpoint name, as follows:

`<domain>/<project-name>/<component-name>/<endpoint-name>`

If a component has multiple endpoints, Choreo allows you to change the endpoint corresponding to the default component URL. For a component with a single endpoint, the default URL automatically corresponds to that endpoint.

### Change the default endpoint of a component

To change the default endpoint of a component, follow the steps given below:

!!! note
     - You cannot change the default endpoint if it has associated published APIs. You must go to the **Lifecycle** page and unpublish the relevant APIs before updating the default endpoint. For instructions on unpublishing an API, see [Lifecycle Management](https://wso2.com/choreo/docs/api-management/lifecycle-management/).
     - Choreo does not allow you to change the default endpoint of a component if you create multiple deployment tracks within its current major version, or promote the component beyond its initial environment.

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to change the default endpoint.
3. In the left navigation menu, click **Deploy**.
4. On the **Deploy** page, go to the **Set Up** card and click **Configure & Deploy**.
5. In the **Environment Configurations** pane that opens, click **Next**.
6. In the **File Mount** pane that opens, click **Next**.
7. In the **Endpoint Details** pane that opens, click the **Default Endpoint** list, select the endpoint you want to set as the default endpoint, and then click **Update**.
8. Click **Deploy**. This deploys the component with the selected endpoint as the default, and the default URL will now correspond to this endpoint.  

### Edit a UI-Defined Endpoint
If you defined an endpoint during component creation, you can edit it later by following these steps:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to update the endpoint.
3. In the left navigation menu, click **Deploy**.
4. On the **Deploy** page, go to the **Set Up** card and click **Configure & Deploy**.
5. In the **Environment Configurations** pane that opens, click **Next**.
6. In the **File Mount** pane that opens, click **Next**.
7. In the **Endpoint Details** pane that opens, locate the endpoint you want to edit.
8. Click the **Edit** icon next to the endpoint, modify the editable fields, and click **Update**.
9. Click **Deploy** to apply the changes.

!!! note
     If you commit a `component.yaml` file, build the component, and proceed with deployment, the endpoints will be generated from the `component.yaml` file and will take priority. In this case, the endpoint cannot be edited through the UI. To modify the endpoint, you must update the`component.yaml` file.


# Configure Endpoints
{% include "configure-endpoints-body.md" %}

# Deploy a Containerized Application 

Using Choreo, you can easily deploy applications written in different language frameworks (such as Java, Go, NodeJS, Python, etc.) on shared or private data planes using containers.

Choreo supports deploying containerized applications for the following component types:

- Service
- Web Application
- Scheduled Task
- Manual Task
- Event Handler
- Test Runner

## Connect your repository to Choreo

To connect your GitHub repository to Choreo, you should authorize the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application to access your account or organization. When you attempt to connect your GitHub repository via the Component creation page, the Choreo Apps authorization prompt will appear.

* Connect GitHub Repository
    
    ![Connect GitHub Repository](../assets/img/develop-components/deploy/create-component-authz-github-page.png){.cInlineImage-threeQuarter}

* Authorize GitHub Application
    
    ![Authorize GitHub Application](../assets/img/develop-components/deploy/authz-choreo-github-app.png){.cInlineImage-half}

* Grant Repository Access

    ![Grant Repository Access](../assets/img/develop-components/deploy/github-repo-access.png){.cInlineImage-full}


    The **Choreo Apps** requires the following permission:
    
    - Read access to issues and metadata
    - Read and write access to code, pull requests, and repository hooks

!!! note
    You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. Choreo needs write access only to send pull requests to a user repository. Choreo does not directly push any changes to a repository.

Alternatively, you can connect a public repository without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. Select the **Third-Party GitHub Repository** and paste a public repository URL in the **Public Repository URL** field at the time of component creation.

!!! tip
     Authorizing the repository with the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application becomes essential if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component. If you own the repository, you can subsequently authorize it with the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application to enable **Auto Deploy**.

After granting access to the required repositories, you can choose a repository and an associated branch to connect to the Choreo component.
For the containerized application deployments, you should select the [**Component Directory**](https://docs.docker.com/build/building/context/#path-context), **Dockerfile** as the **Buildpack** and provide **Dockerfile Path** for the Docker build.

![Connected Dockerfile Repository](../assets/img/develop-components/deploy/create-component-connected-repo.png){.cInlineImage-full}

The following table describes the individual fields in the **Create Component** pane.

| **Field**               | **Description**                                                                                                                                                                      |
|-------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **GitHub Account**      | Your GitHub account or organization. If you want to add another GitHub account, you can expand the list and click **+ Add**.                                                            |
| **GitHub Repository**   | Depending on the repository access you provided, the list will show available repositories to be connected.                                                                                  |
| **Branch**              | The branch of the repository.                                                                                                                                                         |
| **Buildpack**        | Determines the implementation of the component: Any language or other language as a Docker container.                                                                                |
| **Dockerfile Path**     | The path to your Dockerfile. This path is defined relative to the repository root.<br/>For example, if the Dockerfile is at the repository root, the value for this field is `/Dockerfile`. |
| **Component Directory** | The component directory path. To include the repository root, leave the default `/` value.                                                                                          |
| **Port***               | The port at which your service is running.                                                                                                                                           |
| **OpenAPI Filepath***   | The path to an OpenAPI specification (in YAML/JSON) relative to the repository root. If you don't provide a path, the system automatically generates a default allow-all specification.    |

   
!!! note
 
    - Fields marked with **\*** are not visible for all component types.

    - To successfully build your container with Choreo, it is essential to explicitly define a User ID (`UID`) under the `USER` instruction in your Dockerfile. You can refer to the [sample Dockerfile](https://github.com/wso2/choreo-sample-apps/blob/main/go/rest-api/Dockerfile) for guidance.

    - To ensure that the defined USER instruction is valid, it must conform to the following conditions:
        
        - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
        - Usernames are not considered valid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

## Deploy the containerized component

Choreo will automatically apply deployment configurations and settings based on the component type you select during creation.
For example, if you select the **Service** component type, Choreo will deploy it as a Kubernetes deployment with appropriate scaling configurations.

You can run unit tests in the build pipeline by adding the relevant command to the Dockerfile.  For example: 

- [Go-based sample](https://github.com/wso2/choreo-sample-apps/blob/8c18c82db604adb43b89f669888a07cd6e31d7b7/go/rest-api/Dockerfile#L37)
- [Python-based sample](https://github.com/wso2/choreo-sample-apps/blob/8c18c82db604adb43b89f669888a07cd6e31d7b7/python/rest-api/Dockerfile#L15)

### Application configurations

You must provide any required configurations for running the application in the **Configs & Secrets** section of the component's **DevOps** page. Alternatively, you can also review the configurations when you manually deploy via the **Deploy** page.

After clicking the **Create** button, you can select the confidentiality of the configuration and specify how to mount it to the container.

![Application Configuration Page](../assets/img/develop-components/deploy/deploy-app-config-page.png){.cInlineImage-full}

![Create Configuration Mount Page](../assets/img/develop-components/deploy/deploy-app-config-type-mount-page.png){.cInlineImage-full}

#### Configuration types

* **ConfigMap**: Stores non-confidential data as key-value pairs.
* **Secret**: Stores and manages sensitive information, such as passwords, OAuth tokens, and ssh keys as key-value pairs.

#### Mount types

* **Environment Variables**: Mounts the selected ConfigMap or Secret as an environment variable in the container.
* **File Mount**: Mounts the selected ConfigMap or Secret as a file in the container. Here, the key is the file name, and the value is the file content.

The following image shows adding a **ConfigMap** with **File Mount** mount type to be read by the application.

![Configuration File Mount Page](../assets/img/develop-components/deploy/deploy-app-config-file-mount.png){.cInlineImage-full}

!!! note
    The JSON file includes ${DB_PASS} as an environment variable defined in a Secret. The application reads the JSON file and substitutes the placeholders with the corresponding environment variables.

### Deployment configurations

Choreo lets you configure deployment settings such as scaling, resource limits, and health checks based on your selected component type.

For more information about these configurations, see Choreo's [DevOps capabilities](../devops-and-ci-cd/view-runtime-details.md).

You can configure the **Endpoints** to expose your service using the **Service** Component in Choreo. See [Service Component Overview](../develop-components/develop-services/service-component-overview.md) for more information. 

### Build, deploy, and promote

After adding the application configuration, you can build and deploy it by clicking the **Deploy Manually** button. Choreo will start the build process with the selected commit in the **Build Area**. 

!!! note
    The **Auto Deploy on Commit** feature, which automatically builds and deploys the application upon pushing a code change to the repository, is enabled by default. To turn off this feature, navigate to the **Build Area** of the **Deploy** page.

Choreo scans your Dockerfile for security vulnerabilities during the build phase, and if there are no issues found, it proceeds with the build process. After building the image, it scans it again for vulnerabilities before deployment to the environment. You can view the build logs from the right-side panel, as shown in the image below.

![Build Logs Panel](../assets/img/develop-components/deploy/build-deploy-page-logs.png){.cInlineImage-full}

Once the build process is complete, Choreo will deploy the application automatically to the Development environment. To promote the build to higher environments, you can click the **Promote** button. The number of environment cards visible on the page may vary depending on your environment configurations.

### Troubleshoot security vulnerability scan failures (Trivy)

By default, Choreo utilizes the Aqua Trivy (OSS) image vulnerability scanner to detect security vulnerabilities in all Dockerfile-based build pipelines. The scanner will fail the pipeline if any **CRITICAL** CVEs (Common Vulnerabilities and Exposures) are detected. CVEs of other severity levels are recorded but does not fail the pipeline.

If you cannot fix a critical CVE immediately, you can opt to ignore it. To ignore a critical CVE, add a `trivyignore` (`<docker-build-context-path>/.trivyignore`) file to your build context path. In the file, add the CVEs you need the pipeline to ignore, one entry per line as follows:

```
CVE-2023-xxxx
CVE-2023-yyyy
```

You can add comments in the file by using `#` in front of the comment as follows: 

```
# comments can be added like this
CVE-2023-xxxx
```


# Deploy an Application with Buildpacks

Using Choreo, you can easily deploy applications written in different language frameworks (such as Java, Go, NodeJS, Python, Ruby, PHP, etc.) on shared or private data planes.

Choreo supports deploying applications with buildpacks for the following component types:

- Service
- Web Application
- Scheduled Task
- Manual Task
- Webhook
- Event Handler
- Test Runner

## Buildpacks
Buildpacks are a fundamental building block in modern application development. They convert your source code into a secure, efficient, production-ready container image without a Dockerfile. With Choreo, developers can take advantage of this powerful tool to effortlessly deploy their applications without the hassle of manual configuration.

Choreo uses [Google Buildpacks](https://cloud.google.com/docs/buildpacks/overview) as default buildpacks for Java, Go, NodeJS, Python, PHP, and Ruby. Choreo uses its own buildpacks for Ballerina and WSO2 MI.

## Develop a component

To develop a service component that exposes a Service in Go, you can follow the [Develop a Service ](develop-services/develop-a-service.md) guide.

Follow the guidelines below based on your language:

=== "Python"
    Supported Versions - 3.10.x, 3.11.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Reading Books List Service](https://github.com/wso2/choreo-samples/tree/main/reading-books-list-service-python)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-python-task)|

    ### Procfile
    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    
    !!! info 
        In **Python** projects, it is mandatory to have a `Procfile` with the `web` process type in the project root directory.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: python main.py` <br>
    `web: gunicorn --bind :8080 --workers 1 --threads 8 --timeout 0 main:app` <br>
    `web: flask run --host=0.0.0.0`

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Ballerina"

    Supported Versions - 2201.3.5, 2201.4.1, 2201.5.0, 2201.5.1, 201.6.0,  2201.7.0

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Echo Service](https://github.com/wso2/choreo-samples/tree/main/echo-service)|
    | Manual Task | [Covid19 Statistics To Email](https://github.com/wso2/choreo-samples/tree/main//covid19-statistics-to-email)|
    | Webhook | [Salesforce New Case To Google Sheet](https://github.com/wso2/choreo-samples/tree/main/sfdc-new-case-to-gsheet)|
    | Scheduled Task | [Shopify New Customers to HubSpot Create/Update Contact](https://github.com/wso2/choreo-samples/tree/main/shopify-new-customers-to-hubspot-contact)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Go"

    Supported Versions - 1.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Greeting Service](https://github.com/wso2/choreo-samples/tree/main/greeting-service-go)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-go-task)|
    | Web Application | [Hello World Web Application](https://github.com/wso2/choreo-samples/tree/main/hello-world-go-webapp)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== ".NET"
    Supported Versions - 6.x, 7.x, 8.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service | [Greeting Service](https://github.com/wso2/choreo-samples/tree/main/dotnet-greeter)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Java"
    Supported Versions
        - 8, 11, 17, 18 (OpenJDK Runtime Environment Temurin)

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Product Management Service](https://github.com/wso2/choreo-samples/tree/main/product-management-service)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-java-task)|

    !!! info

         When working on Java projects:

           - The `Main` class should be defined in the manifest file.
           - If Maven files such as `mvn.cmd` exist in the project without the `.mvn` directory, the build will fail. To ensure a successful build, you must either commit the `.mvn` directory along with any Maven files or not include any Maven files in the project if you choose not to commit the `.mvn` directory.
    
    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **Java** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: java -jar target/sample.jar` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "NodeJS"
    Supported Versions - 12.x.x, 14.x.x, 16.x.x, 18.x.x, 20.x.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Reading Books List Service](https://github.com/wso2/choreo-samples/tree/main/reading-books-list-service-nodejs)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-nodejs-task)|

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **NodeJS** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: node app.js` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "PHP"
    Supported Versions - 8.1.x, 8.2.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Hello World Service](https://github.com/wso2/choreo-samples/tree/main/hello-world-php-service)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-php-task)|
    | Web Application | [Hello World Web Application](https://github.com/wso2/choreo-samples/tree/main/hello-world-php-webapp)|

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **PHP** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web:php -S 0.0.0.0:8000 index.php` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Ruby"
    Supported Versions - 3.1.x, 3.2.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service | [Hello World Service](https://github.com/wso2/choreo-samples/tree/main/hello-world-ruby-service)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-ruby-task)|
    | Web Application | [Hello World Web Application](https://github.com/wso2/choreo-samples/tree/main/hello-world-ruby-webapp)|

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **Ruby** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: ruby app.rb` <br>
    `web:bundle exec ruby app.rb -p 8080` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "WSO2 MI"
    Supported Versions - 4.1.0.x, 4.2.0.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service |[Hello World Service](https://github.com/wso2/choreo-samples/tree/main/hello-world-mi)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Spring Boot"
    Supported Java Versions
        - 8, 11, 17, 18 (OpenJDK Runtime Environment Temurin)

    !!! info
         You can use this buildpack only with web applications. For other component types, use the **Java** buildpack. Additionally, if the generated artifact is a `WAR` file, it is necessary to include a **Procfile**.

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **Java** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: java -jar target/sample.war` <br>

### Configure build-time environment variables

You can configure the environment variables necessary to build the component using the **Build Configurations Editor** on the component **Build** page. 

!!! info
    The capability to configure build-time environment variables is not available for components created using **Ballerina** or **WSO2 MI** buildpacks.

During the build process, the build-time environment variables and their values are passed to the buildpack. Therefore, you can configure both buildpack-specific environment variables and those required for the component build.

For example, if you want to override the Maven command of the **Java** buildpack, you can use `GOOGLE_MAVEN_BUILD_ARGS` as the environment key and `clean install` as the value. 

For more examples, see [Google Cloud's buildpacks documentation](https://cloud.google.com/docs/buildpacks/service-specific-configs).


# Develop a Webhook

Choreo allows developers to design high-quality webhooks. To explore this capability, let's consider a scenario where a team of software engineers in an organization should be notified via email whenever someone creates a GitHub issue with the `bug` label in a specific repository.

In this tutorial, you will address the requirement by doing the following:

- Create a webhook by connecting to a forked GitHub repository where you have the webhook implementation that addresses the described requirement.
- Deploy the webhook to the development environment.
- Modify the webhook implementation to connect the webhook to GitHub, enabling it to act in response to selected GitHub-related events.
- Test the webhook.
- Promote the webhook to the production environment.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

## Step 1: Create a webhook component

To create a Webhook component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Webhook** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following information:

    | **Field**                     | **Description**    |
    |-------------------------------|--------------------|
    | **GitHub Account**            | Your account       |
    | **GitHub Repository**         | choreo-samples     |
    | **Branch**                    | main               |
    | **Component Path**              | `github-event-to-email-webhook` |

6. Select **Ballerina** as the build pack.
7. Provide a display name, a unique name and description for the component.
8. Click **Create**.

Choreo creates the Webhook component with the sample implementation and opens the component **Overview** page.

## Step 2: Deploy

To deploy the webhook to the development environment, follow these steps:

1. In the Choreo Console left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**.
3. In the **Configurations** pane, enter the following information:
    1. In the **webhookSecret** field, enter any value.

        !!! note
            Save this value for later use.

    2. In the **toEmail** field, enter the email address to send notification emails.
    3. Click **Deploy**.

    You can monitor the deployment progress in the **Console** pane that opens on the right of the page.

Once Choreo completes the deployment, the **Development** card indicates the **Deployment Status** as **Active**.

!!! note
    In the deployment card, you can click the icon corresponding to configurables to open the **Configurations** pane and edit configurations.

## Step 3: Connect the webhook to the GitHub repository

To allow the webhook to read the labels of issues in a specific GitHub repository, connect the webhook to the GitHub repository:

1. In the Choreo Console left navigation menu, click **Overview**.
2. On the **Overview** page, copy the invoke URL by clicking the copy icon within the **URL** field.
3. Go to your GitHub account and open the repository for which you want to generate notification emails.
4. In the top menu, click the **Settings** tab.
5. In the left navigation menu, click **Webhooks**.
6. Click **Add webhook** and enter the following information:

    | **Field**        | **Value**                                                          |
    |------------------|--------------------------------------------------------------------|
    | **Payload URL**  | The invoke URL you copied in Step 3, sub-step 1.                   |
    | **Content Type** | Select `application/json`                                          |
    | **Secret**       | The last webhook secret you configured in [Step 2](#step-2-deploy).| 

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Project Path** specifies the location of the project to build the component.

7. Under **Which events would you like to trigger this webhook?**, select **Let me select individual events**.
8. Select the **Issues** checkbox in the list of events displayed. This ensures that GitHub issues trigger the webhook.
9. Clear the **Pushes** checkbox to ensure that GitHub does not trigger your webhook when the team pushes changes to the selected GitHub repository.
10. Click **Add webhook** to save the configuration.

Now you have integrated Choreo with GitHub via the webhook you created and deployed. You can proceed to test the webhook.

## Step 4: Test

To test your webhook, create a GitHub issue with the `Bug` label in the repository that you connected to the webhook. You will receive an email similar to the following at the email address you provided in [Step 2](#step-2-deploy).

## Step 5: Promote

To promote the webhook to the Production environment, follow these steps:

1. On the **Deploy** page, go to the **Development** card and click **Promote**.
2. In the **Configuration Types** pane, leave the default selection (i.e., **Use default configuration values**) unchanged.

    !!! note
        If you have configured any default values for the configurable variables, selecting **Use default configuration values** allows you to proceed with those values. If not, specify values for the configurable variables.

3. Click **Next**.
4. In the **webhookSecret** field, enter any value.

    !!! note
        Save this value for later use.

5. In the **toEmail** field, enter the email address to send notification emails.
6. Click **Promote**.

    Once the component is promoted to production, the **Production** card displays the deployment status as **Active**.

Now you have successfully created, deployed, and tested a Webhook component and promoted it to production.


# Develop an External Consumer

An external consumer in Choreo is any client that can interact with services deployed in Choreo, as an entity hosted outside of the Choreo infrastructure. It is a generic component type that allows you to represent and manage any client, such as a mobile application, web application, server-to-server integration, bot, microservices, etc.

In this guide, you will:

 - Create an external consumer component.
 - Manage authentication for the external consumer.
 - Connect the external consumer to a service deployed in Choreo.
 
## Prerequisites

Before you try out this guide, complete the following steps:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

## Step 1: Create an external consumer component
 
To create an external consumer component, follow the steps given below:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **External Consumer** card. 
4. In the **Create an External Consumer** pane that opens, enter a display name, a unique name, and a description for the component.
5. Click **Create**. This creates the component and takes you to its **Overview** page.
   
## Step 2: Manage authentication for the external consumer

You can configure the external consumer to work with the Choreo built-in identity provider or any external identity provider that supports OIDC/OAuth 2.0.

Click the respective tab for details depending on the identity provider you want to configure: 

=== "Choreo built-in identity provider"

     Follow the steps given below to configure the built-in identity provider by generating authentication keys:

    !!! note
         Choreo built-in identity provider is configured by default. Therefore, this step is optional.

     1. In the **Overview** page of the component, under **Authentication Configurations**, click **Configure** corresponding to the environment for which you want to configure an identity provider.
     2. In the **Identity Provider** list, select **Choreo Built-In Identity Provider**.
     3. Click **Generate Keys**. 

        !!! Note
             If you see **Regenerate Secret** instead of **Generate Keys**, it indicates that OAuth keys are already generated for the component in the selected environment.

=== "An external identity provider"

     **Step 2.1: Create and configure an OIDC/OAuth 2.0 application in the external identity provider**

     1. Create an OIDC/OAuth 2.0 application in your external identity provider.
     2. Configure the OIDC/OAuth 2.0 application accordingly. (The access token type should be configured as JWT)

     **Step 2.2: Link the OIDC/OAuth 2.0 application to the Choreo component**

     3. In the **Overview** page of the component, under **Authentication Configurations**, click **Configure** corresponding to the environment for which you want to configure an identity provider.
     4. In the **Identity Provider** list, select your identity provider.
     5. Paste the **Client ID** of the OIDC/OAuth 2.0 application you created in your external identity provider.
     6. Click **Add Keys**.

## Step 3: Connect the external consumer to a service deployed in Choreo 

To establish connections from the external consumer to services deployed in Choreo, you can create connections. For step-by-step instructions on creating a connection, see [Create a Connection](./sharing-and-reusing/create-a-connection.md).


# Develop Components Using VS Code

The [Choreo VS Code extension](https://marketplace.visualstudio.com/items?itemName=WSO2.choreo) provides comprehensive component management capabilities to streamline local development within Choreo.

## Prerequisites

To ensure a smooth development experience with the Choreo extension, make sure you have the following:

1. [Visual Studio Code](https://code.visualstudio.com/download) installed with the [Choreo extension](https://marketplace.visualstudio.com/items?itemName=WSO2.choreo) version **2.0.0** or later.

2. A locally cloned GitHub repository to create new components or link to existing Choreo components.

3. [Git](https://git-scm.com) version 2.0.0 or later.

## Get started

To use the capabilities of the Choreo extension in the VS Code editor, you need an active [Choreo account](https://wso2.com/choreo/pricing/). If you already have an account, follow these steps to set up the extension:

1. Install the [Choreo VS Code extension](https://marketplace.visualstudio.com/items?itemName=WSO2.choreo) and wait for activation. On successful activation, the Choreo extension opens in the VS Code editor. 
2. Sign in to Choreo using one of the following methods:
    - In the Choreo activity pane, click **Sign In**.
       ![Sign in](../assets/img/develop-components/develop-using-vs-code/sign-in.png)
    - Use the `Sign In` command provided by the Choreo extension.

    This redirects you to an external URI to complete the authentication process. On successful sign-in, the Choreo activity pane displays your account details along with any components detected within the VS Code workspace.

## Create a new component

1. Open the source code directory where you want to build, deploy, and manage components using Choreo.
2. Create a new component using one of the following methods:
    - In the Choreo activity pane, click **Create Component**.
       ![Create Component Button](../assets/img/develop-components/develop-using-vs-code/create-component-btn.png)
    - Use the `Create New Component` command provided by the Choreo extension.

3. If the Choreo extension cannot determine the project context of the opened workspace, it prompts you to select the organization and the project to which the new component belongs.
4. Specify component details such as the name, type, buildpack, etc.

    ![Component Form](../assets/img/develop-components/develop-using-vs-code/component-form.png)
            
    On successful creation, the component details view opens, and the Choreo activity pane displays the new component.

    ![Component Details](../assets/img/develop-components/develop-using-vs-code/component-details-view.png)
     
    !!! tip
        Once the component is created, a `.choreo/context.yaml` file is generated in the root of the Git repository. For more details, see [Understand the project context](#understand-the-project-context).

The component details view allows you to manage your component by performing various actions such as the following:

 - Triggering builds for selected commits.
 - Viewing lists of builds and statuses.
 - Diagnosing build failures with build logs.
 - Deploying builds in available environments.
 - Accessing runtime logs and deployed component URLs.
 - Invoking deployed service endpoints.

## Understand the project context

Context files contain metadata related to the project, allowing the extension to establish an association between local directories and Choreo projects. These files, such as the `context.yaml`file, resides in the `/.choreo` directory within the root of the Git repository.

The Choreo extension scans the root of the opened Git repository to find the `context.yaml` file and lists the components of the associated project. This allows you to easily open and manage the components they are developing within the VS Code workspace.

A `context.yaml` file can contain multiple projects, whereas, a workspace opened via VS Code can have multiple `context.yaml` files with different project associations. In such cases, VS Code allows you to switch between these projects, add new project associations, or remove existing ones, allowing you as a developer to focus on components of a particular project at a time.

You can decide whether to commit the `context.yaml` file to the Git repository. Committing this file enables other team members working on the same repository to have a seamless developer experience with Choreo.

If the `context.yaml` file for a particular project is not committed to the Git repository or is unavailable for other reasons, you can easily regenerate it using one of the following methods:

 - In the Choreo activity pane, click **Link Directory**.
    ![Link Directory](../assets/img/develop-components/develop-using-vs-code/link-dir-btn.png)
 - Use the `Link Directory` command provided by the Choreo extension.

## Discover additional features

To access a range of functionalities provided by the Choreo extension, open the VS Code command palette and type `Choreo`.

## Troubleshoot issues

To troubleshoot Choreo extension issues, follow these steps:

1. To open the **OUTPUT** pane, go to the VS Code editor main menu, click **View**, and then click **Output**.

2. Select **Choreo** from the drop-down menu on the right-hand side to view the Choreo output for troubleshooting.

## Get help

For assistance with the Choreo VS Code extension, create [GitHub issues](https://github.com/wso2/choreo-vscode/issues).


# Develop Components With Git

Choreo enables you to develop components by connecting your GitHub, Bitbucket, or GitLab repository. You have the flexibility to either connect an existing repository or start with an empty repository and commit the source code later. By integrating your repositories with Choreo, you can automate tasks and optimize workflows across multiple systems, all within the Choreo platform.  Choreo currently supports GitHub, Bitbucket, and GitLab as Git providers. 

!!! tip
    Choreo supports both Bitbucket Server and Bitbucket Cloud. The currently supported Bitbucket Server version is 8.9.2.

In Choreo, you can connect a Git repository that contains Ballerina source code or a Docker project. To connect a Git repository to Choreo as a Docker project, your Git repository must include the following:

 - A Dockerfile: Specifies the instructions to build the Docker image. 
 - A build context: A set of files in the specified path used to build the image.

Once you connect your Git repository to Choreo, you can build, deploy, and manage your application easily. 

## Connect a Git repository to Choreo

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the Choreo Console header, go to the **Organization** list and select your organization. 
3. In the left navigation menu, click **Settings**. This opens the organization-level settings page. 
4. Click the **Credentials** tab. 
5. Click **+Add Credentials** to configure the Git repository connection.
6. Enter a **Credential Name**, select the Git provider, and enter the **Personal Access Token** you obtained from the Git provider.
7. Click **Save**.  

## Authorize GitHub with Choreo 

Authorizing Choreo as a GitHub application grants Choreo the following permissions to perform the respective actions on your behalf within the repository:

|Permission   | Read| Write| Description                                                           |
|-------------|-----|------|-----------------------------------------------------------------------|
|Issues       | Y   | N    | Read component ID label to filter the pull requests                   |
|Metadata     | Y   | N    | List repositories                                                     |
|Contents     | Y   | Y    | List branches and create a branch to commit sample code               |
|Pull Request | Y   | Y    | Create a pull request if you start with a Choreo sample               |
|Webhooks     | Y   | Y    | Trigger automatic deployment and configuration generation             |

### Add Git submodules to a project

Choreo provides [Git submodule](https://git-scm.com/book/en/v2/Git-Tools-Submodules) support when you connect your GitHub repository to Choreo. This allows you to manage and include external repositories effectively within Choreo build pipelines. Key benefits of this capability include:

  - **Code sharing without duplication**: Use submodules to maintain shared libraries across multiple projects, ensuring a single source of truth.
  - **Efficient third-party library management**: Manage third-party libraries as submodules to update them independently and track changes easily, avoiding direct code integration.

For example, when you [work with the Micro Integrator (MI) runtime in Choreo](./work-with-the-micro-integrator-runtime-in-choreo.md), you can use Git submodules to reuse MI templates and sequences across components without duplication.

!!! info "Note" 
    If you encounter an error stating that you cannot clone a submodule due to insufficient permissions, follow the instructions below to grant the necessary permissions:

      - For a personal account:

         1. Sign in to your personal GitHub account.
         2. In the upper-right corner, click your profile picture, and then click **Settings**.
         3. In the left navigation menu, go to the **Integrations** section and click **Applications**.
         4. Under the **Installed GitHub Apps** tab, click **Configure** corresponding to **choreo.dev**.
         5. Under **Repository Access**, grant access to the necessary repositories.

      - For an organization account:

         1. Sign in to your organization's GitHub account.
         2. In the upper-right corner, click your profile picture, and then click **Settings**.
         3. In the left navigation menu, go to the **Third-Party Access** section and click **GitHub Apps**.
         4. Click **Configure** corresponding to **choreo.dev**.
         5. Under **Repository Access**, grant access to the necessary repositories.

            !!! note
                Choreo currently does not support accessing private repositories in other organizations.

#### Automatically pull latest versions of Git submodules

Choreo lets you automatically pull the latest versions of Git submodules from their respective repositories. To enable this feature, follow these steps:

!!! note 
    Choreo currently supports this feature only for components where the buildpack is **WSO2 MI**.

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click the component for which you want to pull the latest versions of Git submodules.
3. In the left navigation menu, click **Build**.
4. On the **Build** page, click to edit **Build Configurations**.
5. Turn on the **Pull Latest Submodules** toggle.

    !!! info "Note"
        If you rebuild a previously built commit and it doesn’t reflect the latest changes, follow these steps to ensure the changes are applied to the deployed environment:

         1. In the Choreo Console left navigation menu, click **DevOps**, then click **Containers**.
         2. Click **Edit** to update the container settings.
         3. Select **Always** as the **Image Pull Policy**.
         4. Click **Save Changes**.

## Authorize Bitbucket with Choreo

Authorizing using a personal access token (PAT) from Bitbucket grants Choreo the following permissions to perform the respective actions on your behalf within the repository.

|Permission    | Read| Write| Description                                                        |
|--------------|-----|------|--------------------------------------------------------------------|
|Account       | Y   | N    | Get user information and workspace details                         |
|Repositories  | Y   | Y    | List branches and create a branch to commit sample code            |
|Pull Requests | Y   | Y    | Create a pull request if you start with a Choreo sample            |
|Webhooks      | Y   | Y    | Trigger automatic deployment and configuration generation          |

## Authorize self-managed GitLab with Choreo

Authorizing using a personal access token (PAT) obtained from your GitLab self-managed server grants Choreo the following permissions to perform the respective actions on your behalf within the repository.

|Permission    | Description                                                                         |
|--------------|-------------------------------------------------------------------------------------|
|API           | Grants full read/write access to the API, covering all groups and projects, as well as read/write access to the repository.|


 # Bring Your Own Image (BYOI)

Choreo allows you to deploy and manage prebuilt container images from external container registries as Choreo components. This enables you to deploy and effectively manage your container images within the Choreo environment.

!!! info
    This feature is currently only available on [private data planes (PDPs)](../choreo-concepts/data-planes.md#private-data-planes) for the following component types:

    - Service
    - Web Application
    - Scheduled Task
    - Manual Task


## Prerequisites

Before you try out this guide, ensure you have the following:

- **A container registry**: Ensure you have a container registry containing the images you want to deploy. Choreo is compatible with various container registries, including but not limited to GCR (Google Container Registry), ACR (Azure Container Registry), GitHub Container Registry, and Docker Hub.

- **An image in the registry**: You need an image ready for deployment.

- **(Optional) An external build/CI pipeline**:  This is to initiate automatic deployments during the build process outside of Choreo.

When using a container registry to deploy a component, Choreo cannot create an image from the source code (Git) or initiate a new deployment when a new image is ready. However, you can use your existing build process to trigger a deployment on Choreo by sending an HTTP POST request to a webhook with the new image details.

This feature is currently only available on private data planes (PDPs). You can find this option under **Deploy an image from a container registry** in the **Select Source** step during component creation for service components, web applications, scheduled tasks, and manual tasks.

## Step 1: Register a container registry

To get started, establish a connection between your container registry and Choreo. 

!!! Info
    When you use your Choreo credentials, Choreo does not *pull* your images into its control plane. Instead, it functions as an orchestrator, facilitating your data plane's ability to retrieve images from an external container registry. Choreo passes on these credentials to the data plane for authentication and access.

To register your container registry, follow these steps:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the Choreo Console header, go to the **Organization** list and select your organization. 
3. In the left navigation menu, click **Settings**. This opens the organization settings page. 
4. Click the **Credentials** tab and then click the **Container Registries** tab. 
5. Click **+Add Registry** to configure the Git repository connection.
6. Specify a **Registry Display Name**.
7. Select the **Authentication Type**. Fill in the required information depending on your authentication type. For details on each authentication type, see [Authentication types](#authentication-types).
8. Click **Save**.

### Authentication types

Choreo provides the following authentication options:  

#### Public (anonymous) access
    
You can use this option to establish a connection with a container registry that permits unrestricted public or anonymous access (for example, Public Docker Hub). In this case, only the registry host information is necessary.

For example, the following are the Docker Hub registry hosts for reference:

| Vendor                           | Registry host                |
|----------------------------------|------------------------------|
|Docker Hub (public repositories)  | `registry.hub.docker.com`    |
|Docker Hub (private repositories) | `registry.docker.com`        |

\* If necessary, you can use other mirrors instead of the above.

#### Basic authentication

To use basic authentication to authenticate to the container registry, you must provide the username and password.

#### Docker config

You can provide a Docker config in JSON format to authenticate to the container registry. This option only allows you to register one container registry. That is, it **only allows a single registry under `auths`**.

You must provide the credentials directly within the configuration. Choreo cannot utilize references to executable authentication plugins.

Sample Docker config format:

```json
    {
    "auths": {
        "index.docker.io/v1/": {
        "auth": "c3R...zE2"
        }
    }
    }
```

#### Vendor-specific authentication

This option is specifically for private data planes, where your cloud provider manages authentication at the Kubernetes level. Choreo requires knowledge of the registry host because the data plane already possesses implicit (preconfigured) access to the registry.

Follow the guidelines below based on your container registry:

=== "ACR"
    **Azure Container Registry** 

    Recommended authentication options:

    * [**Service principal-based basic authentication**](https://learn.microsoft.com/en-us/azure/container-registry/container-registry-auth-service-principal)

    * **Vendor-specific authentication on Azure private data planes**
        
        Contact Choreo support to enable infrastructure-level private access to your registry from your Azure private data plane on AKS. If you are on a self-managed PDP on Azure, follow [this guide](https://learn.microsoft.com/en-us/azure/aks/cluster-container-registry-integration?toc=%2Fazure%2Fcontainer-registry%2Ftoc.json&bc=%2Fazure%2Fcontainer-registry%2Fbreadcrumb%2Ftoc.json&tabs=azure-cli).

=== "GAR"
    **Google Artifact Registry**

    Recommended authentication options:

    * [**Service account-based basic authentication**](https://cloud.google.com/artifact-registry/docs/docker/pushing-and-pulling#key)

        Use the service account key in JSON format ([`_json_key`](https://cloud.google.com/artifact-registry/docs/docker/authentication#:~:text=of%20the%20following%3A-,_json_key,-if%20you%20are)) as the username and specify the minified JSON contents of the service account key as the password.

         You can use `jq` as follows to minify the service account JSON key file:

         `jq -c . <service-account.json>`

    * **Vendor-specific authentication on GCP private data planes**

        Contact Choreo support to enable infrastructure-level private access to your registry from your GCP private data plane on GKE. If you are on a self-managed PDP on GCP, see [https://cloud.google.com/artifact-registry/docs/access-control#grant-project](https://cloud.google.com/artifact-registry/docs/access-control#grant-project).

=== "AWS ECR"
    **Elastic Container Registry**

    ECR does not allow the creation of static access passwords for basic authentication. The passwords (that is, access tokens) provided by AWS are only valid for 10 hours and must be manually regenerated. However, when an ECR is attached to an EKS cluster at an infrastructure level, this limitation does not apply because the authentication is handled by AWS internally. For details, see [https://docs.aws.amazon.com/AmazonECR/latest/userguide/registry_auth.html](https://docs.aws.amazon.com/AmazonECR/latest/userguide/registry_auth.html).

    Choreo recommends using ECR when you are exclusively on an AWS private data plane using the vendor-specific authentication option. Contact Choreo support to enable a private connection between your ECR and the underlying EKS clusters on your data plane. If you are on a self-managed PDP, you can follow [this guide](https://docs.aws.amazon.com/AmazonECR/latest/userguide/ECR_on_EKS.html).    

=== "Docker Hub (Private)"

    Recommended authentication options:

    * **Basic authentication**

          Use your Docker Hub username/password or an access token. You can generate an access token from your Docker Hub account settings and use it in place of the password. For details, see [https://docs.docker.com/docker-hub/access-tokens/](https://docs.docker.com/docker-hub/access-tokens/).

    * **Docker config**

          Sign in to the Docker CLI and copy the contents of the docker config JSON. Note that external credential stores and multiple repositories within the same config object are not supported. For more information, see [https://docs.docker.com/engine/reference/commandline/login/](https://docs.docker.com/engine/reference/commandline/login/).

=== "GHCR"
    **GitHub Container Registry**

    Recommended authentication option:

    * **Basic authentication using a PAT token**

          Create a personal access token (PAT) and use it in place of the password. You cannot use your own GitHub password. You must provide a [PAT token](https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry#authenticating-with-a-personal-access-token-classicn).
  
## Step 2: Create a component in Choreo

1. In the left navigation, click **Overview** and select your project. Alternatively, select your project from the **Project** list in the Choreo Console header. 
2. Under **Component Listing** click **+ Create**.
3. Select your component type (BYOI is only available for Service, Web Application, Scheduled Task, or Manual Task components). 
4. From the Create Component pane, select the **Container Registry** under the **Connect a Docker Image** section.
5. Under **Deploy an image from Container Registry/Docker Hub**, select the container registry you have registered in [Step 1](#step-1-register-a-container-registry).
6. Enter the full image URL. The image URL format in general is as follows:
   `[container-registry-host]/[repository-name]/[image-name]:[tag]`

    !!! tip
        When a public image from Docker Hub lacks a specified repository name, it typically defaults to `/library/`. For example, you can access the public Nginx image `https://hub.docker.com/_/nginx` as `registry.hub.docker.com/library/nginx:1.25`.

7. Enter a display name, a unique name, and a description for the component.
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.


## Step 3: Deploy the component in Choreo

To deploy the component and bring your image to Choreo, follow the steps given below: 

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Update Image & Deploy**. 
3. In the **Endpoint** pane that opens, you can see the endpoint ready to be deployed. Click the edit icon next to the endpoint name. Optionally, you can define the endpoints for your service when you manually deploy the service. For more information, see [Expose service endpoints](#step-4-expose-service-endpoints).
4. Change the **Network Visibility** to **Public**. This setting securely exposes the endpoint for consumption.
5. Click **Update**.

    !!! info
         In this example, you deploy a Ballerina service as a REST endpoint. Therefore, Choreo generated the REST endpoint automatically. If you deploy a non-Ballerina service, you must manually add the REST endpoint and set the network visibility to **Public**.

6. Select your update image option. Refer to the update options listed below.

    You have the capability of updating the image when you are deploying the component in Choreo in one of the following three ways:

    | Option                   |Description                                                                                             |
    |--------------------------|--------------------------------------------------------------------------------------------------------|
    | **Update Image Tag**     | This option allows you to update the tag of the image.                                                 |
    | **Update Image URL**     | With this option, you can change the image name, tag, and the image repository of the image URL.|
    | **Previous Images**      | This option allows you to select a previous image and redeploy the image.                               |

7. Click **Deploy**. This deploys the service to the development environment.

## Step 4: Expose service endpoints 

!!! info
    This section only applies to service components.

After creating a service component in Choreo, you have the option to define the endpoints for your service when manually deploying a new image.

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Update Image & Deploy**. 
3. In the **Endpoint** pane that opens, optionally, you can define the endpoints for your service when you manually deploy the service. 
4. Click  **Create/Update Endpoints**.
5. Under the **Edit endpoints.yaml** section, you can edit the endpoints YAML file in the provided editor. 
   Alternatively, you can upload the associated API specification/schema files (OpenAPI/GraphQL schemas). Instead of specifying the file path, you can also reference this file in the `endpoints.yaml` file by its file name, similar to the Git-based Choreo components. The endpoints template follows the standard definitions for defining endpoints in Choreo. For more details, see [Configure Endpoints](../develop-components/configure-endpoints.md).

## Auto-deploy images in Choreo with an external CI/build pipeline

Choreo does not have automatic detection and deployment for newly added images or tags in the linked container registry. To overcome this limitation, Choreo allows you to integrate your own CI pipelines and initiate deployments manually. This approach enables you to use your existing CI setup or build a pipeline for image creation and pushing. You can then trigger automatic deployments using a webhook.

Follow the steps below to configure your CI/build pipeline:

1. Build and push the container image associated with a Choreo component to your container registry.
2. In the left navigation menu, click **DevOps** and then click **External CI**.
3. Generate a token for your CI pipeline from the **Manage Tokens** section. 

    !!! note
        - The tokens are bound to a specific component.
        - It is recommended to reference the token from a secure location available to your CI pipeline. For example, use a GitHub secret if you are using GitHub Actions.

4. To trigger an automatic deployment to your development environment, you can initiate an HTTP POST request to the Choreo webhook endpoint with the updated image details. Alternatively, you can use the provided Webhook snippets. This action will seamlessly deploy the image to the development environment.



Services and integrations are exposed to other services, integrations, or applications through endpoints. A service or an integration can expose multiple endpoints, each representing a unique entry point into the service. For example, a service may expose a REST API endpoint and a GraphQL endpoint, each providing different ways to interact with the service. Endpoints provide specific details for how the service or the integration can be consumed. For instance, the port number, protocol, and the schema such as open API specification (OAS) or GraphQL schema. By defining these details, endpoints make it possible for other services, integrations, and applications to discover and interact with the service in a standardized way.

Choreo defines endpoints by combining port binding, protocol, endpoint name, network visibility, endpoint schema, and additional protocol-related fields. The following table describes each attribute of an endpoint.

| Field | Description |
| ----- | ----------- |
| Name | A unique identifier for the endpoint within the service component. |
| Port | The network port on which the endpoint is accessible. |
| Type | The endpoint protocol. Supported protocols: REST, GraphQL, gRPC, WS, UDP, and TCP. |
| Network Visibility | Determines the level of visibility of an endpoint. Possible values are: <ul><li>Project: Allows components within the same project to access the endpoint.</li><li>Organization: Allows any component within the same organization to access the endpoint but restricts access to components outside the organization.</li><li>Public: Allows any client to access the endpoint, regardless of location or organization.</li></ul> |
| Schema | Specifies the structure and format of the data exchanged through the endpoint. |
| Context (HTTP and GraphQL only) | A context path that you add to the endpoint's URL for routing purposes. |

## Configure endpoints
The method of defining endpoints depends on the buildpack.

* For `Ballerina` and `WSO2 MI` buildpacks, Choreo automatically detects the endpoint details for REST APIs.
* For all other buildpacks (Java, Python, NodeJS, Ruby, PHP, Go, Dockerfile, etc.), you can configure endpoints in one of the following ways:
  
    * **Using the Choreo Console**: If a `component.yaml` file is not present, you can define a basic endpoint configuration during component creation.
    * **Using the component.yaml file**: You can manually configure endpoint details by defining them in a `component.yaml` file, placing it inside the `.choreo` directory at the build context path, and committing it to the source repository.

You can override UI-defined and auto-generated endpoints by providing a `component.yaml` file in the `.choreo` directory, which will take priority over other configurations.

To learn about the `component.yaml` file, see [Overview of the component.yaml file](../develop-components/manage-component-source-configurations.md#overview-of-the-componentyaml-file).
!!! note
    Automatic endpoint generation is not supported for dynamic endpoint parameters such as variable ports. Therefore, you must use an `component.yaml` file to define dynamic endpoint parameters.

To learn about the `component.yaml` file, see [Overview of the component.yaml file](../develop-components/manage-component-source-configurations.md#overview-of-the-componentyaml-file).

## Expose endpoints as managed APIs

Exposing endpoints as managed APIs is crucial to ensure secure and controlled access to the services being exposed. When a user wants to expose their written service to the outside world or to the organization at large, there is an inherent security risk involved. To mitigate this risk, the Choreo platform is built with an internal (access within the organization only) or external (publicly accessible) gateway that is protected with Choreo API management making the services secure by design.

!!! note
    This feature is not available for gRPC, UDP, and TCP endpoints.

If you want to expose an endpoint as a managed API in Choreo, you need to set the network visibility to either Organization or Public. This allows the endpoint to be exposed through the Choreo API Gateway, which provides a number of benefits, including:

* Expose APIs to external and internal consumers
* Full lifecycle API Management
* API throttling
* Secure APIs with industry-standard authorization flows
* API analytics and monitoring

Once you deploy the service component, Choreo will expose the endpoint as a managed API through the Choreo API Gateway. You can then use the full lifecycle API management features provided by Choreo to test, deploy, maintain, monitor, and manage your API using the API management features.

## Understand the default component URL

The default URL of a component corresponds to the default endpoint of the component and is structured as follows:

`<domain>/<project-name>/<component-name>`

This URL does not include the default endpoint name. For all other endpoints, the URL structure includes the endpoint name, as follows:

`<domain>/<project-name>/<component-name>/<endpoint-name>`

If a component has multiple endpoints, Choreo allows you to change the endpoint corresponding to the default component URL. For a component with a single endpoint, the default URL automatically corresponds to that endpoint.

### Change the default endpoint of a component

To change the default endpoint of a component, follow the steps given below:

!!! note
     - You cannot change the default endpoint if it has associated published APIs. You must go to the **Lifecycle** page and unpublish the relevant APIs before updating the default endpoint. For instructions on unpublishing an API, see [Lifecycle Management](https://wso2.com/choreo/docs/api-management/lifecycle-management/).
     - Choreo does not allow you to change the default endpoint of a component if you create multiple deployment tracks within its current major version, or promote the component beyond its initial environment.

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to change the default endpoint.
3. In the left navigation menu, click **Deploy**.
4. On the **Deploy** page, go to the **Set Up** card and click **Configure & Deploy**.
5. In the **Environment Configurations** pane that opens, click **Next**.
6. In the **File Mount** pane that opens, click **Next**.
7. In the **Endpoint Details** pane that opens, click the **Default Endpoint** list, select the endpoint you want to set as the default endpoint, and then click **Update**.
8. Click **Deploy**. This deploys the component with the selected endpoint as the default, and the default URL will now correspond to this endpoint.  

### Edit a UI-Defined Endpoint
If you defined an endpoint during component creation, you can edit it later by following these steps:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to update the endpoint.
3. In the left navigation menu, click **Deploy**.
4. On the **Deploy** page, go to the **Set Up** card and click **Configure & Deploy**.
5. In the **Environment Configurations** pane that opens, click **Next**.
6. In the **File Mount** pane that opens, click **Next**.
7. In the **Endpoint Details** pane that opens, locate the endpoint you want to edit.
8. Click the **Edit** icon next to the endpoint, modify the editable fields, and click **Update**.
9. Click **Deploy** to apply the changes.

!!! note
     If you commit a `component.yaml` file, build the component, and proceed with deployment, the endpoints will be generated from the `component.yaml` file and will take priority. In this case, the endpoint cannot be edited through the UI. To modify the endpoint, you must update the`component.yaml` file.


# Configure Endpoints
{% include "configure-endpoints-body.md" %}

# Deploy a Containerized Application 

Using Choreo, you can easily deploy applications written in different language frameworks (such as Java, Go, NodeJS, Python, etc.) on shared or private data planes using containers.

Choreo supports deploying containerized applications for the following component types:

- Service
- Web Application
- Scheduled Task
- Manual Task
- Event Handler
- Test Runner

## Connect your repository to Choreo

To connect your GitHub repository to Choreo, you should authorize the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application to access your account or organization. When you attempt to connect your GitHub repository via the Component creation page, the Choreo Apps authorization prompt will appear.

* Connect GitHub Repository
    
    ![Connect GitHub Repository](../assets/img/develop-components/deploy/create-component-authz-github-page.png){.cInlineImage-threeQuarter}

* Authorize GitHub Application
    
    ![Authorize GitHub Application](../assets/img/develop-components/deploy/authz-choreo-github-app.png){.cInlineImage-half}

* Grant Repository Access

    ![Grant Repository Access](../assets/img/develop-components/deploy/github-repo-access.png){.cInlineImage-full}


    The **Choreo Apps** requires the following permission:
    
    - Read access to issues and metadata
    - Read and write access to code, pull requests, and repository hooks

!!! note
    You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. Choreo needs write access only to send pull requests to a user repository. Choreo does not directly push any changes to a repository.

Alternatively, you can connect a public repository without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. Select the **Third-Party GitHub Repository** and paste a public repository URL in the **Public Repository URL** field at the time of component creation.

!!! tip
     Authorizing the repository with the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application becomes essential if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component. If you own the repository, you can subsequently authorize it with the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application to enable **Auto Deploy**.

After granting access to the required repositories, you can choose a repository and an associated branch to connect to the Choreo component.
For the containerized application deployments, you should select the [**Component Directory**](https://docs.docker.com/build/building/context/#path-context), **Dockerfile** as the **Buildpack** and provide **Dockerfile Path** for the Docker build.

![Connected Dockerfile Repository](../assets/img/develop-components/deploy/create-component-connected-repo.png){.cInlineImage-full}

The following table describes the individual fields in the **Create Component** pane.

| **Field**               | **Description**                                                                                                                                                                      |
|-------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **GitHub Account**      | Your GitHub account or organization. If you want to add another GitHub account, you can expand the list and click **+ Add**.                                                            |
| **GitHub Repository**   | Depending on the repository access you provided, the list will show available repositories to be connected.                                                                                  |
| **Branch**              | The branch of the repository.                                                                                                                                                         |
| **Buildpack**        | Determines the implementation of the component: Any language or other language as a Docker container.                                                                                |
| **Dockerfile Path**     | The path to your Dockerfile. This path is defined relative to the repository root.<br/>For example, if the Dockerfile is at the repository root, the value for this field is `/Dockerfile`. |
| **Component Directory** | The component directory path. To include the repository root, leave the default `/` value.                                                                                          |
| **Port***               | The port at which your service is running.                                                                                                                                           |
| **OpenAPI Filepath***   | The path to an OpenAPI specification (in YAML/JSON) relative to the repository root. If you don't provide a path, the system automatically generates a default allow-all specification.    |

   
!!! note
 
    - Fields marked with **\*** are not visible for all component types.

    - To successfully build your container with Choreo, it is essential to explicitly define a User ID (`UID`) under the `USER` instruction in your Dockerfile. You can refer to the [sample Dockerfile](https://github.com/wso2/choreo-sample-apps/blob/main/go/rest-api/Dockerfile) for guidance.

    - To ensure that the defined USER instruction is valid, it must conform to the following conditions:
        
        - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
        - Usernames are not considered valid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

## Deploy the containerized component

Choreo will automatically apply deployment configurations and settings based on the component type you select during creation.
For example, if you select the **Service** component type, Choreo will deploy it as a Kubernetes deployment with appropriate scaling configurations.

You can run unit tests in the build pipeline by adding the relevant command to the Dockerfile.  For example: 

- [Go-based sample](https://github.com/wso2/choreo-sample-apps/blob/8c18c82db604adb43b89f669888a07cd6e31d7b7/go/rest-api/Dockerfile#L37)
- [Python-based sample](https://github.com/wso2/choreo-sample-apps/blob/8c18c82db604adb43b89f669888a07cd6e31d7b7/python/rest-api/Dockerfile#L15)

### Application configurations

You must provide any required configurations for running the application in the **Configs & Secrets** section of the component's **DevOps** page. Alternatively, you can also review the configurations when you manually deploy via the **Deploy** page.

After clicking the **Create** button, you can select the confidentiality of the configuration and specify how to mount it to the container.

![Application Configuration Page](../assets/img/develop-components/deploy/deploy-app-config-page.png){.cInlineImage-full}

![Create Configuration Mount Page](../assets/img/develop-components/deploy/deploy-app-config-type-mount-page.png){.cInlineImage-full}

#### Configuration types

* **ConfigMap**: Stores non-confidential data as key-value pairs.
* **Secret**: Stores and manages sensitive information, such as passwords, OAuth tokens, and ssh keys as key-value pairs.

#### Mount types

* **Environment Variables**: Mounts the selected ConfigMap or Secret as an environment variable in the container.
* **File Mount**: Mounts the selected ConfigMap or Secret as a file in the container. Here, the key is the file name, and the value is the file content.

The following image shows adding a **ConfigMap** with **File Mount** mount type to be read by the application.

![Configuration File Mount Page](../assets/img/develop-components/deploy/deploy-app-config-file-mount.png){.cInlineImage-full}

!!! note
    The JSON file includes ${DB_PASS} as an environment variable defined in a Secret. The application reads the JSON file and substitutes the placeholders with the corresponding environment variables.

### Deployment configurations

Choreo lets you configure deployment settings such as scaling, resource limits, and health checks based on your selected component type.

For more information about these configurations, see Choreo's [DevOps capabilities](../devops-and-ci-cd/view-runtime-details.md).

You can configure the **Endpoints** to expose your service using the **Service** Component in Choreo. See [Service Component Overview](../develop-components/develop-services/service-component-overview.md) for more information. 

### Build, deploy, and promote

After adding the application configuration, you can build and deploy it by clicking the **Deploy Manually** button. Choreo will start the build process with the selected commit in the **Build Area**. 

!!! note
    The **Auto Deploy on Commit** feature, which automatically builds and deploys the application upon pushing a code change to the repository, is enabled by default. To turn off this feature, navigate to the **Build Area** of the **Deploy** page.

Choreo scans your Dockerfile for security vulnerabilities during the build phase, and if there are no issues found, it proceeds with the build process. After building the image, it scans it again for vulnerabilities before deployment to the environment. You can view the build logs from the right-side panel, as shown in the image below.

![Build Logs Panel](../assets/img/develop-components/deploy/build-deploy-page-logs.png){.cInlineImage-full}

Once the build process is complete, Choreo will deploy the application automatically to the Development environment. To promote the build to higher environments, you can click the **Promote** button. The number of environment cards visible on the page may vary depending on your environment configurations.

### Troubleshoot security vulnerability scan failures (Trivy)

By default, Choreo utilizes the Aqua Trivy (OSS) image vulnerability scanner to detect security vulnerabilities in all Dockerfile-based build pipelines. The scanner will fail the pipeline if any **CRITICAL** CVEs (Common Vulnerabilities and Exposures) are detected. CVEs of other severity levels are recorded but does not fail the pipeline.

If you cannot fix a critical CVE immediately, you can opt to ignore it. To ignore a critical CVE, add a `trivyignore` (`<docker-build-context-path>/.trivyignore`) file to your build context path. In the file, add the CVEs you need the pipeline to ignore, one entry per line as follows:

```
CVE-2023-xxxx
CVE-2023-yyyy
```

You can add comments in the file by using `#` in front of the comment as follows: 

```
# comments can be added like this
CVE-2023-xxxx
```


# Deploy an Application with Buildpacks

Using Choreo, you can easily deploy applications written in different language frameworks (such as Java, Go, NodeJS, Python, Ruby, PHP, etc.) on shared or private data planes.

Choreo supports deploying applications with buildpacks for the following component types:

- Service
- Web Application
- Scheduled Task
- Manual Task
- Webhook
- Event Handler
- Test Runner

## Buildpacks
Buildpacks are a fundamental building block in modern application development. They convert your source code into a secure, efficient, production-ready container image without a Dockerfile. With Choreo, developers can take advantage of this powerful tool to effortlessly deploy their applications without the hassle of manual configuration.

Choreo uses [Google Buildpacks](https://cloud.google.com/docs/buildpacks/overview) as default buildpacks for Java, Go, NodeJS, Python, PHP, and Ruby. Choreo uses its own buildpacks for Ballerina and WSO2 MI.

## Develop a component

To develop a service component that exposes a Service in Go, you can follow the [Develop a Service ](develop-services/develop-a-service.md) guide.

Follow the guidelines below based on your language:

=== "Python"
    Supported Versions - 3.10.x, 3.11.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Reading Books List Service](https://github.com/wso2/choreo-samples/tree/main/reading-books-list-service-python)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-python-task)|

    ### Procfile
    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    
    !!! info 
        In **Python** projects, it is mandatory to have a `Procfile` with the `web` process type in the project root directory.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: python main.py` <br>
    `web: gunicorn --bind :8080 --workers 1 --threads 8 --timeout 0 main:app` <br>
    `web: flask run --host=0.0.0.0`

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Ballerina"

    Supported Versions - 2201.3.5, 2201.4.1, 2201.5.0, 2201.5.1, 201.6.0,  2201.7.0

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Echo Service](https://github.com/wso2/choreo-samples/tree/main/echo-service)|
    | Manual Task | [Covid19 Statistics To Email](https://github.com/wso2/choreo-samples/tree/main//covid19-statistics-to-email)|
    | Webhook | [Salesforce New Case To Google Sheet](https://github.com/wso2/choreo-samples/tree/main/sfdc-new-case-to-gsheet)|
    | Scheduled Task | [Shopify New Customers to HubSpot Create/Update Contact](https://github.com/wso2/choreo-samples/tree/main/shopify-new-customers-to-hubspot-contact)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Go"

    Supported Versions - 1.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Greeting Service](https://github.com/wso2/choreo-samples/tree/main/greeting-service-go)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-go-task)|
    | Web Application | [Hello World Web Application](https://github.com/wso2/choreo-samples/tree/main/hello-world-go-webapp)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== ".NET"
    Supported Versions - 6.x, 7.x, 8.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service | [Greeting Service](https://github.com/wso2/choreo-samples/tree/main/dotnet-greeter)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Java"
    Supported Versions
        - 8, 11, 17, 18 (OpenJDK Runtime Environment Temurin)

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Product Management Service](https://github.com/wso2/choreo-samples/tree/main/product-management-service)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-java-task)|

    !!! info

         When working on Java projects:

           - The `Main` class should be defined in the manifest file.
           - If Maven files such as `mvn.cmd` exist in the project without the `.mvn` directory, the build will fail. To ensure a successful build, you must either commit the `.mvn` directory along with any Maven files or not include any Maven files in the project if you choose not to commit the `.mvn` directory.
    
    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **Java** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: java -jar target/sample.jar` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "NodeJS"
    Supported Versions - 12.x.x, 14.x.x, 16.x.x, 18.x.x, 20.x.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Reading Books List Service](https://github.com/wso2/choreo-samples/tree/main/reading-books-list-service-nodejs)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-nodejs-task)|

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **NodeJS** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: node app.js` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "PHP"
    Supported Versions - 8.1.x, 8.2.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Hello World Service](https://github.com/wso2/choreo-samples/tree/main/hello-world-php-service)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-php-task)|
    | Web Application | [Hello World Web Application](https://github.com/wso2/choreo-samples/tree/main/hello-world-php-webapp)|

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **PHP** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web:php -S 0.0.0.0:8000 index.php` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Ruby"
    Supported Versions - 3.1.x, 3.2.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service | [Hello World Service](https://github.com/wso2/choreo-samples/tree/main/hello-world-ruby-service)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-ruby-task)|
    | Web Application | [Hello World Web Application](https://github.com/wso2/choreo-samples/tree/main/hello-world-ruby-webapp)|

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **Ruby** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: ruby app.rb` <br>
    `web:bundle exec ruby app.rb -p 8080` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "WSO2 MI"
    Supported Versions - 4.1.0.x, 4.2.0.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service |[Hello World Service](https://github.com/wso2/choreo-samples/tree/main/hello-world-mi)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Spring Boot"
    Supported Java Versions
        - 8, 11, 17, 18 (OpenJDK Runtime Environment Temurin)

    !!! info
         You can use this buildpack only with web applications. For other component types, use the **Java** buildpack. Additionally, if the generated artifact is a `WAR` file, it is necessary to include a **Procfile**.

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **Java** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: java -jar target/sample.war` <br>

### Configure build-time environment variables

You can configure the environment variables necessary to build the component using the **Build Configurations Editor** on the component **Build** page. 

!!! info
    The capability to configure build-time environment variables is not available for components created using **Ballerina** or **WSO2 MI** buildpacks.

During the build process, the build-time environment variables and their values are passed to the buildpack. Therefore, you can configure both buildpack-specific environment variables and those required for the component build.

For example, if you want to override the Maven command of the **Java** buildpack, you can use `GOOGLE_MAVEN_BUILD_ARGS` as the environment key and `clean install` as the value. 

For more examples, see [Google Cloud's buildpacks documentation](https://cloud.google.com/docs/buildpacks/service-specific-configs).


# Develop a Webhook

Choreo allows developers to design high-quality webhooks. To explore this capability, let's consider a scenario where a team of software engineers in an organization should be notified via email whenever someone creates a GitHub issue with the `bug` label in a specific repository.

In this tutorial, you will address the requirement by doing the following:

- Create a webhook by connecting to a forked GitHub repository where you have the webhook implementation that addresses the described requirement.
- Deploy the webhook to the development environment.
- Modify the webhook implementation to connect the webhook to GitHub, enabling it to act in response to selected GitHub-related events.
- Test the webhook.
- Promote the webhook to the production environment.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

## Step 1: Create a webhook component

To create a Webhook component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Webhook** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following information:

    | **Field**                     | **Description**    |
    |-------------------------------|--------------------|
    | **GitHub Account**            | Your account       |
    | **GitHub Repository**         | choreo-samples     |
    | **Branch**                    | main               |
    | **Component Path**              | `github-event-to-email-webhook` |

6. Select **Ballerina** as the build pack.
7. Provide a display name, a unique name and description for the component.
8. Click **Create**.

Choreo creates the Webhook component with the sample implementation and opens the component **Overview** page.

## Step 2: Deploy

To deploy the webhook to the development environment, follow these steps:

1. In the Choreo Console left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**.
3. In the **Configurations** pane, enter the following information:
    1. In the **webhookSecret** field, enter any value.

        !!! note
            Save this value for later use.

    2. In the **toEmail** field, enter the email address to send notification emails.
    3. Click **Deploy**.

    You can monitor the deployment progress in the **Console** pane that opens on the right of the page.

Once Choreo completes the deployment, the **Development** card indicates the **Deployment Status** as **Active**.

!!! note
    In the deployment card, you can click the icon corresponding to configurables to open the **Configurations** pane and edit configurations.

## Step 3: Connect the webhook to the GitHub repository

To allow the webhook to read the labels of issues in a specific GitHub repository, connect the webhook to the GitHub repository:

1. In the Choreo Console left navigation menu, click **Overview**.
2. On the **Overview** page, copy the invoke URL by clicking the copy icon within the **URL** field.
3. Go to your GitHub account and open the repository for which you want to generate notification emails.
4. In the top menu, click the **Settings** tab.
5. In the left navigation menu, click **Webhooks**.
6. Click **Add webhook** and enter the following information:

    | **Field**        | **Value**                                                          |
    |------------------|--------------------------------------------------------------------|
    | **Payload URL**  | The invoke URL you copied in Step 3, sub-step 1.                   |
    | **Content Type** | Select `application/json`                                          |
    | **Secret**       | The last webhook secret you configured in [Step 2](#step-2-deploy).| 

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Project Path** specifies the location of the project to build the component.

7. Under **Which events would you like to trigger this webhook?**, select **Let me select individual events**.
8. Select the **Issues** checkbox in the list of events displayed. This ensures that GitHub issues trigger the webhook.
9. Clear the **Pushes** checkbox to ensure that GitHub does not trigger your webhook when the team pushes changes to the selected GitHub repository.
10. Click **Add webhook** to save the configuration.

Now you have integrated Choreo with GitHub via the webhook you created and deployed. You can proceed to test the webhook.

## Step 4: Test

To test your webhook, create a GitHub issue with the `Bug` label in the repository that you connected to the webhook. You will receive an email similar to the following at the email address you provided in [Step 2](#step-2-deploy).

## Step 5: Promote

To promote the webhook to the Production environment, follow these steps:

1. On the **Deploy** page, go to the **Development** card and click **Promote**.
2. In the **Configuration Types** pane, leave the default selection (i.e., **Use default configuration values**) unchanged.

    !!! note
        If you have configured any default values for the configurable variables, selecting **Use default configuration values** allows you to proceed with those values. If not, specify values for the configurable variables.

3. Click **Next**.
4. In the **webhookSecret** field, enter any value.

    !!! note
        Save this value for later use.

5. In the **toEmail** field, enter the email address to send notification emails.
6. Click **Promote**.

    Once the component is promoted to production, the **Production** card displays the deployment status as **Active**.

Now you have successfully created, deployed, and tested a Webhook component and promoted it to production.


# Develop an External Consumer

An external consumer in Choreo is any client that can interact with services deployed in Choreo, as an entity hosted outside of the Choreo infrastructure. It is a generic component type that allows you to represent and manage any client, such as a mobile application, web application, server-to-server integration, bot, microservices, etc.

In this guide, you will:

 - Create an external consumer component.
 - Manage authentication for the external consumer.
 - Connect the external consumer to a service deployed in Choreo.
 
## Prerequisites

Before you try out this guide, complete the following steps:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

## Step 1: Create an external consumer component
 
To create an external consumer component, follow the steps given below:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **External Consumer** card. 
4. In the **Create an External Consumer** pane that opens, enter a display name, a unique name, and a description for the component.
5. Click **Create**. This creates the component and takes you to its **Overview** page.
   
## Step 2: Manage authentication for the external consumer

You can configure the external consumer to work with the Choreo built-in identity provider or any external identity provider that supports OIDC/OAuth 2.0.

Click the respective tab for details depending on the identity provider you want to configure: 

=== "Choreo built-in identity provider"

     Follow the steps given below to configure the built-in identity provider by generating authentication keys:

    !!! note
         Choreo built-in identity provider is configured by default. Therefore, this step is optional.

     1. In the **Overview** page of the component, under **Authentication Configurations**, click **Configure** corresponding to the environment for which you want to configure an identity provider.
     2. In the **Identity Provider** list, select **Choreo Built-In Identity Provider**.
     3. Click **Generate Keys**. 

        !!! Note
             If you see **Regenerate Secret** instead of **Generate Keys**, it indicates that OAuth keys are already generated for the component in the selected environment.

=== "An external identity provider"

     **Step 2.1: Create and configure an OIDC/OAuth 2.0 application in the external identity provider**

     1. Create an OIDC/OAuth 2.0 application in your external identity provider.
     2. Configure the OIDC/OAuth 2.0 application accordingly. (The access token type should be configured as JWT)

     **Step 2.2: Link the OIDC/OAuth 2.0 application to the Choreo component**

     3. In the **Overview** page of the component, under **Authentication Configurations**, click **Configure** corresponding to the environment for which you want to configure an identity provider.
     4. In the **Identity Provider** list, select your identity provider.
     5. Paste the **Client ID** of the OIDC/OAuth 2.0 application you created in your external identity provider.
     6. Click **Add Keys**.

## Step 3: Connect the external consumer to a service deployed in Choreo 

To establish connections from the external consumer to services deployed in Choreo, you can create connections. For step-by-step instructions on creating a connection, see [Create a Connection](./sharing-and-reusing/create-a-connection.md).


# Develop Components Using VS Code

The [Choreo VS Code extension](https://marketplace.visualstudio.com/items?itemName=WSO2.choreo) provides comprehensive component management capabilities to streamline local development within Choreo.

## Prerequisites

To ensure a smooth development experience with the Choreo extension, make sure you have the following:

1. [Visual Studio Code](https://code.visualstudio.com/download) installed with the [Choreo extension](https://marketplace.visualstudio.com/items?itemName=WSO2.choreo) version **2.0.0** or later.

2. A locally cloned GitHub repository to create new components or link to existing Choreo components.

3. [Git](https://git-scm.com) version 2.0.0 or later.

## Get started

To use the capabilities of the Choreo extension in the VS Code editor, you need an active [Choreo account](https://wso2.com/choreo/pricing/). If you already have an account, follow these steps to set up the extension:

1. Install the [Choreo VS Code extension](https://marketplace.visualstudio.com/items?itemName=WSO2.choreo) and wait for activation. On successful activation, the Choreo extension opens in the VS Code editor. 
2. Sign in to Choreo using one of the following methods:
    - In the Choreo activity pane, click **Sign In**.
       ![Sign in](../assets/img/develop-components/develop-using-vs-code/sign-in.png)
    - Use the `Sign In` command provided by the Choreo extension.

    This redirects you to an external URI to complete the authentication process. On successful sign-in, the Choreo activity pane displays your account details along with any components detected within the VS Code workspace.

## Create a new component

1. Open the source code directory where you want to build, deploy, and manage components using Choreo.
2. Create a new component using one of the following methods:
    - In the Choreo activity pane, click **Create Component**.
       ![Create Component Button](../assets/img/develop-components/develop-using-vs-code/create-component-btn.png)
    - Use the `Create New Component` command provided by the Choreo extension.

3. If the Choreo extension cannot determine the project context of the opened workspace, it prompts you to select the organization and the project to which the new component belongs.
4. Specify component details such as the name, type, buildpack, etc.

    ![Component Form](../assets/img/develop-components/develop-using-vs-code/component-form.png)
            
    On successful creation, the component details view opens, and the Choreo activity pane displays the new component.

    ![Component Details](../assets/img/develop-components/develop-using-vs-code/component-details-view.png)
     
    !!! tip
        Once the component is created, a `.choreo/context.yaml` file is generated in the root of the Git repository. For more details, see [Understand the project context](#understand-the-project-context).

The component details view allows you to manage your component by performing various actions such as the following:

 - Triggering builds for selected commits.
 - Viewing lists of builds and statuses.
 - Diagnosing build failures with build logs.
 - Deploying builds in available environments.
 - Accessing runtime logs and deployed component URLs.
 - Invoking deployed service endpoints.

## Understand the project context

Context files contain metadata related to the project, allowing the extension to establish an association between local directories and Choreo projects. These files, such as the `context.yaml`file, resides in the `/.choreo` directory within the root of the Git repository.

The Choreo extension scans the root of the opened Git repository to find the `context.yaml` file and lists the components of the associated project. This allows you to easily open and manage the components they are developing within the VS Code workspace.

A `context.yaml` file can contain multiple projects, whereas, a workspace opened via VS Code can have multiple `context.yaml` files with different project associations. In such cases, VS Code allows you to switch between these projects, add new project associations, or remove existing ones, allowing you as a developer to focus on components of a particular project at a time.

You can decide whether to commit the `context.yaml` file to the Git repository. Committing this file enables other team members working on the same repository to have a seamless developer experience with Choreo.

If the `context.yaml` file for a particular project is not committed to the Git repository or is unavailable for other reasons, you can easily regenerate it using one of the following methods:

 - In the Choreo activity pane, click **Link Directory**.
    ![Link Directory](../assets/img/develop-components/develop-using-vs-code/link-dir-btn.png)
 - Use the `Link Directory` command provided by the Choreo extension.

## Discover additional features

To access a range of functionalities provided by the Choreo extension, open the VS Code command palette and type `Choreo`.

## Troubleshoot issues

To troubleshoot Choreo extension issues, follow these steps:

1. To open the **OUTPUT** pane, go to the VS Code editor main menu, click **View**, and then click **Output**.

2. Select **Choreo** from the drop-down menu on the right-hand side to view the Choreo output for troubleshooting.

## Get help

For assistance with the Choreo VS Code extension, create [GitHub issues](https://github.com/wso2/choreo-vscode/issues).


# Develop Components With Git

Choreo enables you to develop components by connecting your GitHub, Bitbucket, or GitLab repository. You have the flexibility to either connect an existing repository or start with an empty repository and commit the source code later. By integrating your repositories with Choreo, you can automate tasks and optimize workflows across multiple systems, all within the Choreo platform.  Choreo currently supports GitHub, Bitbucket, and GitLab as Git providers. 

!!! tip
    Choreo supports both Bitbucket Server and Bitbucket Cloud. The currently supported Bitbucket Server version is 8.9.2.

In Choreo, you can connect a Git repository that contains Ballerina source code or a Docker project. To connect a Git repository to Choreo as a Docker project, your Git repository must include the following:

 - A Dockerfile: Specifies the instructions to build the Docker image. 
 - A build context: A set of files in the specified path used to build the image.

Once you connect your Git repository to Choreo, you can build, deploy, and manage your application easily. 

## Connect a Git repository to Choreo

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the Choreo Console header, go to the **Organization** list and select your organization. 
3. In the left navigation menu, click **Settings**. This opens the organization-level settings page. 
4. Click the **Credentials** tab. 
5. Click **+Add Credentials** to configure the Git repository connection.
6. Enter a **Credential Name**, select the Git provider, and enter the **Personal Access Token** you obtained from the Git provider.
7. Click **Save**.  

## Authorize GitHub with Choreo 

Authorizing Choreo as a GitHub application grants Choreo the following permissions to perform the respective actions on your behalf within the repository:

|Permission   | Read| Write| Description                                                           |
|-------------|-----|------|-----------------------------------------------------------------------|
|Issues       | Y   | N    | Read component ID label to filter the pull requests                   |
|Metadata     | Y   | N    | List repositories                                                     |
|Contents     | Y   | Y    | List branches and create a branch to commit sample code               |
|Pull Request | Y   | Y    | Create a pull request if you start with a Choreo sample               |
|Webhooks     | Y   | Y    | Trigger automatic deployment and configuration generation             |

### Add Git submodules to a project

Choreo provides [Git submodule](https://git-scm.com/book/en/v2/Git-Tools-Submodules) support when you connect your GitHub repository to Choreo. This allows you to manage and include external repositories effectively within Choreo build pipelines. Key benefits of this capability include:

  - **Code sharing without duplication**: Use submodules to maintain shared libraries across multiple projects, ensuring a single source of truth.
  - **Efficient third-party library management**: Manage third-party libraries as submodules to update them independently and track changes easily, avoiding direct code integration.

For example, when you [work with the Micro Integrator (MI) runtime in Choreo](./work-with-the-micro-integrator-runtime-in-choreo.md), you can use Git submodules to reuse MI templates and sequences across components without duplication.

!!! info "Note" 
    If you encounter an error stating that you cannot clone a submodule due to insufficient permissions, follow the instructions below to grant the necessary permissions:

      - For a personal account:

         1. Sign in to your personal GitHub account.
         2. In the upper-right corner, click your profile picture, and then click **Settings**.
         3. In the left navigation menu, go to the **Integrations** section and click **Applications**.
         4. Under the **Installed GitHub Apps** tab, click **Configure** corresponding to **choreo.dev**.
         5. Under **Repository Access**, grant access to the necessary repositories.

      - For an organization account:

         1. Sign in to your organization's GitHub account.
         2. In the upper-right corner, click your profile picture, and then click **Settings**.
         3. In the left navigation menu, go to the **Third-Party Access** section and click **GitHub Apps**.
         4. Click **Configure** corresponding to **choreo.dev**.
         5. Under **Repository Access**, grant access to the necessary repositories.

            !!! note
                Choreo currently does not support accessing private repositories in other organizations.

#### Automatically pull latest versions of Git submodules

Choreo lets you automatically pull the latest versions of Git submodules from their respective repositories. To enable this feature, follow these steps:

!!! note 
    Choreo currently supports this feature only for components where the buildpack is **WSO2 MI**.

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click the component for which you want to pull the latest versions of Git submodules.
3. In the left navigation menu, click **Build**.
4. On the **Build** page, click to edit **Build Configurations**.
5. Turn on the **Pull Latest Submodules** toggle.

    !!! info "Note"
        If you rebuild a previously built commit and it doesn’t reflect the latest changes, follow these steps to ensure the changes are applied to the deployed environment:

         1. In the Choreo Console left navigation menu, click **DevOps**, then click **Containers**.
         2. Click **Edit** to update the container settings.
         3. Select **Always** as the **Image Pull Policy**.
         4. Click **Save Changes**.

## Authorize Bitbucket with Choreo

Authorizing using a personal access token (PAT) from Bitbucket grants Choreo the following permissions to perform the respective actions on your behalf within the repository.

|Permission    | Read| Write| Description                                                        |
|--------------|-----|------|--------------------------------------------------------------------|
|Account       | Y   | N    | Get user information and workspace details                         |
|Repositories  | Y   | Y    | List branches and create a branch to commit sample code            |
|Pull Requests | Y   | Y    | Create a pull request if you start with a Choreo sample            |
|Webhooks      | Y   | Y    | Trigger automatic deployment and configuration generation          |

## Authorize self-managed GitLab with Choreo

Authorizing using a personal access token (PAT) obtained from your GitLab self-managed server grants Choreo the following permissions to perform the respective actions on your behalf within the repository.

|Permission    | Description                                                                         |
|--------------|-------------------------------------------------------------------------------------|
|API           | Grants full read/write access to the API, covering all groups and projects, as well as read/write access to the repository.|


 # Bring Your Own Image (BYOI)

Choreo allows you to deploy and manage prebuilt container images from external container registries as Choreo components. This enables you to deploy and effectively manage your container images within the Choreo environment.

!!! info
    This feature is currently only available on [private data planes (PDPs)](../choreo-concepts/data-planes.md#private-data-planes) for the following component types:

    - Service
    - Web Application
    - Scheduled Task
    - Manual Task


## Prerequisites

Before you try out this guide, ensure you have the following:

- **A container registry**: Ensure you have a container registry containing the images you want to deploy. Choreo is compatible with various container registries, including but not limited to GCR (Google Container Registry), ACR (Azure Container Registry), GitHub Container Registry, and Docker Hub.

- **An image in the registry**: You need an image ready for deployment.

- **(Optional) An external build/CI pipeline**:  This is to initiate automatic deployments during the build process outside of Choreo.

When using a container registry to deploy a component, Choreo cannot create an image from the source code (Git) or initiate a new deployment when a new image is ready. However, you can use your existing build process to trigger a deployment on Choreo by sending an HTTP POST request to a webhook with the new image details.

This feature is currently only available on private data planes (PDPs). You can find this option under **Deploy an image from a container registry** in the **Select Source** step during component creation for service components, web applications, scheduled tasks, and manual tasks.

## Step 1: Register a container registry

To get started, establish a connection between your container registry and Choreo. 

!!! Info
    When you use your Choreo credentials, Choreo does not *pull* your images into its control plane. Instead, it functions as an orchestrator, facilitating your data plane's ability to retrieve images from an external container registry. Choreo passes on these credentials to the data plane for authentication and access.

To register your container registry, follow these steps:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the Choreo Console header, go to the **Organization** list and select your organization. 
3. In the left navigation menu, click **Settings**. This opens the organization settings page. 
4. Click the **Credentials** tab and then click the **Container Registries** tab. 
5. Click **+Add Registry** to configure the Git repository connection.
6. Specify a **Registry Display Name**.
7. Select the **Authentication Type**. Fill in the required information depending on your authentication type. For details on each authentication type, see [Authentication types](#authentication-types).
8. Click **Save**.

### Authentication types

Choreo provides the following authentication options:  

#### Public (anonymous) access
    
You can use this option to establish a connection with a container registry that permits unrestricted public or anonymous access (for example, Public Docker Hub). In this case, only the registry host information is necessary.

For example, the following are the Docker Hub registry hosts for reference:

| Vendor                           | Registry host                |
|----------------------------------|------------------------------|
|Docker Hub (public repositories)  | `registry.hub.docker.com`    |
|Docker Hub (private repositories) | `registry.docker.com`        |

\* If necessary, you can use other mirrors instead of the above.

#### Basic authentication

To use basic authentication to authenticate to the container registry, you must provide the username and password.

#### Docker config

You can provide a Docker config in JSON format to authenticate to the container registry. This option only allows you to register one container registry. That is, it **only allows a single registry under `auths`**.

You must provide the credentials directly within the configuration. Choreo cannot utilize references to executable authentication plugins.

Sample Docker config format:

```json
    {
    "auths": {
        "index.docker.io/v1/": {
        "auth": "c3R...zE2"
        }
    }
    }
```

#### Vendor-specific authentication

This option is specifically for private data planes, where your cloud provider manages authentication at the Kubernetes level. Choreo requires knowledge of the registry host because the data plane already possesses implicit (preconfigured) access to the registry.

Follow the guidelines below based on your container registry:

=== "ACR"
    **Azure Container Registry** 

    Recommended authentication options:

    * [**Service principal-based basic authentication**](https://learn.microsoft.com/en-us/azure/container-registry/container-registry-auth-service-principal)

    * **Vendor-specific authentication on Azure private data planes**
        
        Contact Choreo support to enable infrastructure-level private access to your registry from your Azure private data plane on AKS. If you are on a self-managed PDP on Azure, follow [this guide](https://learn.microsoft.com/en-us/azure/aks/cluster-container-registry-integration?toc=%2Fazure%2Fcontainer-registry%2Ftoc.json&bc=%2Fazure%2Fcontainer-registry%2Fbreadcrumb%2Ftoc.json&tabs=azure-cli).

=== "GAR"
    **Google Artifact Registry**

    Recommended authentication options:

    * [**Service account-based basic authentication**](https://cloud.google.com/artifact-registry/docs/docker/pushing-and-pulling#key)

        Use the service account key in JSON format ([`_json_key`](https://cloud.google.com/artifact-registry/docs/docker/authentication#:~:text=of%20the%20following%3A-,_json_key,-if%20you%20are)) as the username and specify the minified JSON contents of the service account key as the password.

         You can use `jq` as follows to minify the service account JSON key file:

         `jq -c . <service-account.json>`

    * **Vendor-specific authentication on GCP private data planes**

        Contact Choreo support to enable infrastructure-level private access to your registry from your GCP private data plane on GKE. If you are on a self-managed PDP on GCP, see [https://cloud.google.com/artifact-registry/docs/access-control#grant-project](https://cloud.google.com/artifact-registry/docs/access-control#grant-project).

=== "AWS ECR"
    **Elastic Container Registry**

    ECR does not allow the creation of static access passwords for basic authentication. The passwords (that is, access tokens) provided by AWS are only valid for 10 hours and must be manually regenerated. However, when an ECR is attached to an EKS cluster at an infrastructure level, this limitation does not apply because the authentication is handled by AWS internally. For details, see [https://docs.aws.amazon.com/AmazonECR/latest/userguide/registry_auth.html](https://docs.aws.amazon.com/AmazonECR/latest/userguide/registry_auth.html).

    Choreo recommends using ECR when you are exclusively on an AWS private data plane using the vendor-specific authentication option. Contact Choreo support to enable a private connection between your ECR and the underlying EKS clusters on your data plane. If you are on a self-managed PDP, you can follow [this guide](https://docs.aws.amazon.com/AmazonECR/latest/userguide/ECR_on_EKS.html).    

=== "Docker Hub (Private)"

    Recommended authentication options:

    * **Basic authentication**

          Use your Docker Hub username/password or an access token. You can generate an access token from your Docker Hub account settings and use it in place of the password. For details, see [https://docs.docker.com/docker-hub/access-tokens/](https://docs.docker.com/docker-hub/access-tokens/).

    * **Docker config**

          Sign in to the Docker CLI and copy the contents of the docker config JSON. Note that external credential stores and multiple repositories within the same config object are not supported. For more information, see [https://docs.docker.com/engine/reference/commandline/login/](https://docs.docker.com/engine/reference/commandline/login/).

=== "GHCR"
    **GitHub Container Registry**

    Recommended authentication option:

    * **Basic authentication using a PAT token**

          Create a personal access token (PAT) and use it in place of the password. You cannot use your own GitHub password. You must provide a [PAT token](https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry#authenticating-with-a-personal-access-token-classicn).
  
## Step 2: Create a component in Choreo

1. In the left navigation, click **Overview** and select your project. Alternatively, select your project from the **Project** list in the Choreo Console header. 
2. Under **Component Listing** click **+ Create**.
3. Select your component type (BYOI is only available for Service, Web Application, Scheduled Task, or Manual Task components). 
4. From the Create Component pane, select the **Container Registry** under the **Connect a Docker Image** section.
5. Under **Deploy an image from Container Registry/Docker Hub**, select the container registry you have registered in [Step 1](#step-1-register-a-container-registry).
6. Enter the full image URL. The image URL format in general is as follows:
   `[container-registry-host]/[repository-name]/[image-name]:[tag]`

    !!! tip
        When a public image from Docker Hub lacks a specified repository name, it typically defaults to `/library/`. For example, you can access the public Nginx image `https://hub.docker.com/_/nginx` as `registry.hub.docker.com/library/nginx:1.25`.

7. Enter a display name, a unique name, and a description for the component.
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.


## Step 3: Deploy the component in Choreo

To deploy the component and bring your image to Choreo, follow the steps given below: 

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Update Image & Deploy**. 
3. In the **Endpoint** pane that opens, you can see the endpoint ready to be deployed. Click the edit icon next to the endpoint name. Optionally, you can define the endpoints for your service when you manually deploy the service. For more information, see [Expose service endpoints](#step-4-expose-service-endpoints).
4. Change the **Network Visibility** to **Public**. This setting securely exposes the endpoint for consumption.
5. Click **Update**.

    !!! info
         In this example, you deploy a Ballerina service as a REST endpoint. Therefore, Choreo generated the REST endpoint automatically. If you deploy a non-Ballerina service, you must manually add the REST endpoint and set the network visibility to **Public**.

6. Select your update image option. Refer to the update options listed below.

    You have the capability of updating the image when you are deploying the component in Choreo in one of the following three ways:

    | Option                   |Description                                                                                             |
    |--------------------------|--------------------------------------------------------------------------------------------------------|
    | **Update Image Tag**     | This option allows you to update the tag of the image.                                                 |
    | **Update Image URL**     | With this option, you can change the image name, tag, and the image repository of the image URL.|
    | **Previous Images**      | This option allows you to select a previous image and redeploy the image.                               |

7. Click **Deploy**. This deploys the service to the development environment.

## Step 4: Expose service endpoints 

!!! info
    This section only applies to service components.

After creating a service component in Choreo, you have the option to define the endpoints for your service when manually deploying a new image.

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Update Image & Deploy**. 
3. In the **Endpoint** pane that opens, optionally, you can define the endpoints for your service when you manually deploy the service. 
4. Click  **Create/Update Endpoints**.
5. Under the **Edit endpoints.yaml** section, you can edit the endpoints YAML file in the provided editor. 
   Alternatively, you can upload the associated API specification/schema files (OpenAPI/GraphQL schemas). Instead of specifying the file path, you can also reference this file in the `endpoints.yaml` file by its file name, similar to the Git-based Choreo components. The endpoints template follows the standard definitions for defining endpoints in Choreo. For more details, see [Configure Endpoints](../develop-components/configure-endpoints.md).

## Auto-deploy images in Choreo with an external CI/build pipeline

Choreo does not have automatic detection and deployment for newly added images or tags in the linked container registry. To overcome this limitation, Choreo allows you to integrate your own CI pipelines and initiate deployments manually. This approach enables you to use your existing CI setup or build a pipeline for image creation and pushing. You can then trigger automatic deployments using a webhook.

Follow the steps below to configure your CI/build pipeline:

1. Build and push the container image associated with a Choreo component to your container registry.
2. In the left navigation menu, click **DevOps** and then click **External CI**.
3. Generate a token for your CI pipeline from the **Manage Tokens** section. 

    !!! note
        - The tokens are bound to a specific component.
        - It is recommended to reference the token from a secure location available to your CI pipeline. For example, use a GitHub secret if you are using GitHub Actions.

4. To trigger an automatic deployment to your development environment, you can initiate an HTTP POST request to the Choreo webhook endpoint with the updated image details. Alternatively, you can use the provided Webhook snippets. This action will seamlessly deploy the image to the development environment.



Services and integrations are exposed to other services, integrations, or applications through endpoints. A service or an integration can expose multiple endpoints, each representing a unique entry point into the service. For example, a service may expose a REST API endpoint and a GraphQL endpoint, each providing different ways to interact with the service. Endpoints provide specific details for how the service or the integration can be consumed. For instance, the port number, protocol, and the schema such as open API specification (OAS) or GraphQL schema. By defining these details, endpoints make it possible for other services, integrations, and applications to discover and interact with the service in a standardized way.

Choreo defines endpoints by combining port binding, protocol, endpoint name, network visibility, endpoint schema, and additional protocol-related fields. The following table describes each attribute of an endpoint.

| Field | Description |
| ----- | ----------- |
| Name | A unique identifier for the endpoint within the service component. |
| Port | The network port on which the endpoint is accessible. |
| Type | The endpoint protocol. Supported protocols: REST, GraphQL, gRPC, WS, UDP, and TCP. |
| Network Visibility | Determines the level of visibility of an endpoint. Possible values are: <ul><li>Project: Allows components within the same project to access the endpoint.</li><li>Organization: Allows any component within the same organization to access the endpoint but restricts access to components outside the organization.</li><li>Public: Allows any client to access the endpoint, regardless of location or organization.</li></ul> |
| Schema | Specifies the structure and format of the data exchanged through the endpoint. |
| Context (HTTP and GraphQL only) | A context path that you add to the endpoint's URL for routing purposes. |

## Configure endpoints
The method of defining endpoints depends on the buildpack.

* For `Ballerina` and `WSO2 MI` buildpacks, Choreo automatically detects the endpoint details for REST APIs.
* For all other buildpacks (Java, Python, NodeJS, Ruby, PHP, Go, Dockerfile, etc.), you can configure endpoints in one of the following ways:
  
    * **Using the Choreo Console**: If a `component.yaml` file is not present, you can define a basic endpoint configuration during component creation.
    * **Using the component.yaml file**: You can manually configure endpoint details by defining them in a `component.yaml` file, placing it inside the `.choreo` directory at the build context path, and committing it to the source repository.

You can override UI-defined and auto-generated endpoints by providing a `component.yaml` file in the `.choreo` directory, which will take priority over other configurations.

To learn about the `component.yaml` file, see [Overview of the component.yaml file](../develop-components/manage-component-source-configurations.md#overview-of-the-componentyaml-file).
!!! note
    Automatic endpoint generation is not supported for dynamic endpoint parameters such as variable ports. Therefore, you must use an `component.yaml` file to define dynamic endpoint parameters.

To learn about the `component.yaml` file, see [Overview of the component.yaml file](../develop-components/manage-component-source-configurations.md#overview-of-the-componentyaml-file).

## Expose endpoints as managed APIs

Exposing endpoints as managed APIs is crucial to ensure secure and controlled access to the services being exposed. When a user wants to expose their written service to the outside world or to the organization at large, there is an inherent security risk involved. To mitigate this risk, the Choreo platform is built with an internal (access within the organization only) or external (publicly accessible) gateway that is protected with Choreo API management making the services secure by design.

!!! note
    This feature is not available for gRPC, UDP, and TCP endpoints.

If you want to expose an endpoint as a managed API in Choreo, you need to set the network visibility to either Organization or Public. This allows the endpoint to be exposed through the Choreo API Gateway, which provides a number of benefits, including:

* Expose APIs to external and internal consumers
* Full lifecycle API Management
* API throttling
* Secure APIs with industry-standard authorization flows
* API analytics and monitoring

Once you deploy the service component, Choreo will expose the endpoint as a managed API through the Choreo API Gateway. You can then use the full lifecycle API management features provided by Choreo to test, deploy, maintain, monitor, and manage your API using the API management features.

## Understand the default component URL

The default URL of a component corresponds to the default endpoint of the component and is structured as follows:

`<domain>/<project-name>/<component-name>`

This URL does not include the default endpoint name. For all other endpoints, the URL structure includes the endpoint name, as follows:

`<domain>/<project-name>/<component-name>/<endpoint-name>`

If a component has multiple endpoints, Choreo allows you to change the endpoint corresponding to the default component URL. For a component with a single endpoint, the default URL automatically corresponds to that endpoint.

### Change the default endpoint of a component

To change the default endpoint of a component, follow the steps given below:

!!! note
     - You cannot change the default endpoint if it has associated published APIs. You must go to the **Lifecycle** page and unpublish the relevant APIs before updating the default endpoint. For instructions on unpublishing an API, see [Lifecycle Management](https://wso2.com/choreo/docs/api-management/lifecycle-management/).
     - Choreo does not allow you to change the default endpoint of a component if you create multiple deployment tracks within its current major version, or promote the component beyond its initial environment.

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to change the default endpoint.
3. In the left navigation menu, click **Deploy**.
4. On the **Deploy** page, go to the **Set Up** card and click **Configure & Deploy**.
5. In the **Environment Configurations** pane that opens, click **Next**.
6. In the **File Mount** pane that opens, click **Next**.
7. In the **Endpoint Details** pane that opens, click the **Default Endpoint** list, select the endpoint you want to set as the default endpoint, and then click **Update**.
8. Click **Deploy**. This deploys the component with the selected endpoint as the default, and the default URL will now correspond to this endpoint.  

### Edit a UI-Defined Endpoint
If you defined an endpoint during component creation, you can edit it later by following these steps:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to update the endpoint.
3. In the left navigation menu, click **Deploy**.
4. On the **Deploy** page, go to the **Set Up** card and click **Configure & Deploy**.
5. In the **Environment Configurations** pane that opens, click **Next**.
6. In the **File Mount** pane that opens, click **Next**.
7. In the **Endpoint Details** pane that opens, locate the endpoint you want to edit.
8. Click the **Edit** icon next to the endpoint, modify the editable fields, and click **Update**.
9. Click **Deploy** to apply the changes.

!!! note
     If you commit a `component.yaml` file, build the component, and proceed with deployment, the endpoints will be generated from the `component.yaml` file and will take priority. In this case, the endpoint cannot be edited through the UI. To modify the endpoint, you must update the`component.yaml` file.


# Configure Endpoints
{% include "configure-endpoints-body.md" %}

# Deploy a Containerized Application 

Using Choreo, you can easily deploy applications written in different language frameworks (such as Java, Go, NodeJS, Python, etc.) on shared or private data planes using containers.

Choreo supports deploying containerized applications for the following component types:

- Service
- Web Application
- Scheduled Task
- Manual Task
- Event Handler
- Test Runner

## Connect your repository to Choreo

To connect your GitHub repository to Choreo, you should authorize the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application to access your account or organization. When you attempt to connect your GitHub repository via the Component creation page, the Choreo Apps authorization prompt will appear.

* Connect GitHub Repository
    
    ![Connect GitHub Repository](../assets/img/develop-components/deploy/create-component-authz-github-page.png){.cInlineImage-threeQuarter}

* Authorize GitHub Application
    
    ![Authorize GitHub Application](../assets/img/develop-components/deploy/authz-choreo-github-app.png){.cInlineImage-half}

* Grant Repository Access

    ![Grant Repository Access](../assets/img/develop-components/deploy/github-repo-access.png){.cInlineImage-full}


    The **Choreo Apps** requires the following permission:
    
    - Read access to issues and metadata
    - Read and write access to code, pull requests, and repository hooks

!!! note
    You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. Choreo needs write access only to send pull requests to a user repository. Choreo does not directly push any changes to a repository.

Alternatively, you can connect a public repository without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. Select the **Third-Party GitHub Repository** and paste a public repository URL in the **Public Repository URL** field at the time of component creation.

!!! tip
     Authorizing the repository with the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application becomes essential if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component. If you own the repository, you can subsequently authorize it with the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application to enable **Auto Deploy**.

After granting access to the required repositories, you can choose a repository and an associated branch to connect to the Choreo component.
For the containerized application deployments, you should select the [**Component Directory**](https://docs.docker.com/build/building/context/#path-context), **Dockerfile** as the **Buildpack** and provide **Dockerfile Path** for the Docker build.

![Connected Dockerfile Repository](../assets/img/develop-components/deploy/create-component-connected-repo.png){.cInlineImage-full}

The following table describes the individual fields in the **Create Component** pane.

| **Field**               | **Description**                                                                                                                                                                      |
|-------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **GitHub Account**      | Your GitHub account or organization. If you want to add another GitHub account, you can expand the list and click **+ Add**.                                                            |
| **GitHub Repository**   | Depending on the repository access you provided, the list will show available repositories to be connected.                                                                                  |
| **Branch**              | The branch of the repository.                                                                                                                                                         |
| **Buildpack**        | Determines the implementation of the component: Any language or other language as a Docker container.                                                                                |
| **Dockerfile Path**     | The path to your Dockerfile. This path is defined relative to the repository root.<br/>For example, if the Dockerfile is at the repository root, the value for this field is `/Dockerfile`. |
| **Component Directory** | The component directory path. To include the repository root, leave the default `/` value.                                                                                          |
| **Port***               | The port at which your service is running.                                                                                                                                           |
| **OpenAPI Filepath***   | The path to an OpenAPI specification (in YAML/JSON) relative to the repository root. If you don't provide a path, the system automatically generates a default allow-all specification.    |

   
!!! note
 
    - Fields marked with **\*** are not visible for all component types.

    - To successfully build your container with Choreo, it is essential to explicitly define a User ID (`UID`) under the `USER` instruction in your Dockerfile. You can refer to the [sample Dockerfile](https://github.com/wso2/choreo-sample-apps/blob/main/go/rest-api/Dockerfile) for guidance.

    - To ensure that the defined USER instruction is valid, it must conform to the following conditions:
        
        - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
        - Usernames are not considered valid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

## Deploy the containerized component

Choreo will automatically apply deployment configurations and settings based on the component type you select during creation.
For example, if you select the **Service** component type, Choreo will deploy it as a Kubernetes deployment with appropriate scaling configurations.

You can run unit tests in the build pipeline by adding the relevant command to the Dockerfile.  For example: 

- [Go-based sample](https://github.com/wso2/choreo-sample-apps/blob/8c18c82db604adb43b89f669888a07cd6e31d7b7/go/rest-api/Dockerfile#L37)
- [Python-based sample](https://github.com/wso2/choreo-sample-apps/blob/8c18c82db604adb43b89f669888a07cd6e31d7b7/python/rest-api/Dockerfile#L15)

### Application configurations

You must provide any required configurations for running the application in the **Configs & Secrets** section of the component's **DevOps** page. Alternatively, you can also review the configurations when you manually deploy via the **Deploy** page.

After clicking the **Create** button, you can select the confidentiality of the configuration and specify how to mount it to the container.

![Application Configuration Page](../assets/img/develop-components/deploy/deploy-app-config-page.png){.cInlineImage-full}

![Create Configuration Mount Page](../assets/img/develop-components/deploy/deploy-app-config-type-mount-page.png){.cInlineImage-full}

#### Configuration types

* **ConfigMap**: Stores non-confidential data as key-value pairs.
* **Secret**: Stores and manages sensitive information, such as passwords, OAuth tokens, and ssh keys as key-value pairs.

#### Mount types

* **Environment Variables**: Mounts the selected ConfigMap or Secret as an environment variable in the container.
* **File Mount**: Mounts the selected ConfigMap or Secret as a file in the container. Here, the key is the file name, and the value is the file content.

The following image shows adding a **ConfigMap** with **File Mount** mount type to be read by the application.

![Configuration File Mount Page](../assets/img/develop-components/deploy/deploy-app-config-file-mount.png){.cInlineImage-full}

!!! note
    The JSON file includes ${DB_PASS} as an environment variable defined in a Secret. The application reads the JSON file and substitutes the placeholders with the corresponding environment variables.

### Deployment configurations

Choreo lets you configure deployment settings such as scaling, resource limits, and health checks based on your selected component type.

For more information about these configurations, see Choreo's [DevOps capabilities](../devops-and-ci-cd/view-runtime-details.md).

You can configure the **Endpoints** to expose your service using the **Service** Component in Choreo. See [Service Component Overview](../develop-components/develop-services/service-component-overview.md) for more information. 

### Build, deploy, and promote

After adding the application configuration, you can build and deploy it by clicking the **Deploy Manually** button. Choreo will start the build process with the selected commit in the **Build Area**. 

!!! note
    The **Auto Deploy on Commit** feature, which automatically builds and deploys the application upon pushing a code change to the repository, is enabled by default. To turn off this feature, navigate to the **Build Area** of the **Deploy** page.

Choreo scans your Dockerfile for security vulnerabilities during the build phase, and if there are no issues found, it proceeds with the build process. After building the image, it scans it again for vulnerabilities before deployment to the environment. You can view the build logs from the right-side panel, as shown in the image below.

![Build Logs Panel](../assets/img/develop-components/deploy/build-deploy-page-logs.png){.cInlineImage-full}

Once the build process is complete, Choreo will deploy the application automatically to the Development environment. To promote the build to higher environments, you can click the **Promote** button. The number of environment cards visible on the page may vary depending on your environment configurations.

### Troubleshoot security vulnerability scan failures (Trivy)

By default, Choreo utilizes the Aqua Trivy (OSS) image vulnerability scanner to detect security vulnerabilities in all Dockerfile-based build pipelines. The scanner will fail the pipeline if any **CRITICAL** CVEs (Common Vulnerabilities and Exposures) are detected. CVEs of other severity levels are recorded but does not fail the pipeline.

If you cannot fix a critical CVE immediately, you can opt to ignore it. To ignore a critical CVE, add a `trivyignore` (`<docker-build-context-path>/.trivyignore`) file to your build context path. In the file, add the CVEs you need the pipeline to ignore, one entry per line as follows:

```
CVE-2023-xxxx
CVE-2023-yyyy
```

You can add comments in the file by using `#` in front of the comment as follows: 

```
# comments can be added like this
CVE-2023-xxxx
```


# Deploy an Application with Buildpacks

Using Choreo, you can easily deploy applications written in different language frameworks (such as Java, Go, NodeJS, Python, Ruby, PHP, etc.) on shared or private data planes.

Choreo supports deploying applications with buildpacks for the following component types:

- Service
- Web Application
- Scheduled Task
- Manual Task
- Webhook
- Event Handler
- Test Runner

## Buildpacks
Buildpacks are a fundamental building block in modern application development. They convert your source code into a secure, efficient, production-ready container image without a Dockerfile. With Choreo, developers can take advantage of this powerful tool to effortlessly deploy their applications without the hassle of manual configuration.

Choreo uses [Google Buildpacks](https://cloud.google.com/docs/buildpacks/overview) as default buildpacks for Java, Go, NodeJS, Python, PHP, and Ruby. Choreo uses its own buildpacks for Ballerina and WSO2 MI.

## Develop a component

To develop a service component that exposes a Service in Go, you can follow the [Develop a Service ](develop-services/develop-a-service.md) guide.

Follow the guidelines below based on your language:

=== "Python"
    Supported Versions - 3.10.x, 3.11.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Reading Books List Service](https://github.com/wso2/choreo-samples/tree/main/reading-books-list-service-python)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-python-task)|

    ### Procfile
    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    
    !!! info 
        In **Python** projects, it is mandatory to have a `Procfile` with the `web` process type in the project root directory.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: python main.py` <br>
    `web: gunicorn --bind :8080 --workers 1 --threads 8 --timeout 0 main:app` <br>
    `web: flask run --host=0.0.0.0`

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Ballerina"

    Supported Versions - 2201.3.5, 2201.4.1, 2201.5.0, 2201.5.1, 201.6.0,  2201.7.0

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Echo Service](https://github.com/wso2/choreo-samples/tree/main/echo-service)|
    | Manual Task | [Covid19 Statistics To Email](https://github.com/wso2/choreo-samples/tree/main//covid19-statistics-to-email)|
    | Webhook | [Salesforce New Case To Google Sheet](https://github.com/wso2/choreo-samples/tree/main/sfdc-new-case-to-gsheet)|
    | Scheduled Task | [Shopify New Customers to HubSpot Create/Update Contact](https://github.com/wso2/choreo-samples/tree/main/shopify-new-customers-to-hubspot-contact)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Go"

    Supported Versions - 1.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Greeting Service](https://github.com/wso2/choreo-samples/tree/main/greeting-service-go)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-go-task)|
    | Web Application | [Hello World Web Application](https://github.com/wso2/choreo-samples/tree/main/hello-world-go-webapp)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== ".NET"
    Supported Versions - 6.x, 7.x, 8.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service | [Greeting Service](https://github.com/wso2/choreo-samples/tree/main/dotnet-greeter)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Java"
    Supported Versions
        - 8, 11, 17, 18 (OpenJDK Runtime Environment Temurin)

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Product Management Service](https://github.com/wso2/choreo-samples/tree/main/product-management-service)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-java-task)|

    !!! info

         When working on Java projects:

           - The `Main` class should be defined in the manifest file.
           - If Maven files such as `mvn.cmd` exist in the project without the `.mvn` directory, the build will fail. To ensure a successful build, you must either commit the `.mvn` directory along with any Maven files or not include any Maven files in the project if you choose not to commit the `.mvn` directory.
    
    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **Java** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: java -jar target/sample.jar` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "NodeJS"
    Supported Versions - 12.x.x, 14.x.x, 16.x.x, 18.x.x, 20.x.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Reading Books List Service](https://github.com/wso2/choreo-samples/tree/main/reading-books-list-service-nodejs)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-nodejs-task)|

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **NodeJS** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: node app.js` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "PHP"
    Supported Versions - 8.1.x, 8.2.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Hello World Service](https://github.com/wso2/choreo-samples/tree/main/hello-world-php-service)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-php-task)|
    | Web Application | [Hello World Web Application](https://github.com/wso2/choreo-samples/tree/main/hello-world-php-webapp)|

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **PHP** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web:php -S 0.0.0.0:8000 index.php` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Ruby"
    Supported Versions - 3.1.x, 3.2.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service | [Hello World Service](https://github.com/wso2/choreo-samples/tree/main/hello-world-ruby-service)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-ruby-task)|
    | Web Application | [Hello World Web Application](https://github.com/wso2/choreo-samples/tree/main/hello-world-ruby-webapp)|

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **Ruby** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: ruby app.rb` <br>
    `web:bundle exec ruby app.rb -p 8080` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "WSO2 MI"
    Supported Versions - 4.1.0.x, 4.2.0.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service |[Hello World Service](https://github.com/wso2/choreo-samples/tree/main/hello-world-mi)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Spring Boot"
    Supported Java Versions
        - 8, 11, 17, 18 (OpenJDK Runtime Environment Temurin)

    !!! info
         You can use this buildpack only with web applications. For other component types, use the **Java** buildpack. Additionally, if the generated artifact is a `WAR` file, it is necessary to include a **Procfile**.

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **Java** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: java -jar target/sample.war` <br>

### Configure build-time environment variables

You can configure the environment variables necessary to build the component using the **Build Configurations Editor** on the component **Build** page. 

!!! info
    The capability to configure build-time environment variables is not available for components created using **Ballerina** or **WSO2 MI** buildpacks.

During the build process, the build-time environment variables and their values are passed to the buildpack. Therefore, you can configure both buildpack-specific environment variables and those required for the component build.

For example, if you want to override the Maven command of the **Java** buildpack, you can use `GOOGLE_MAVEN_BUILD_ARGS` as the environment key and `clean install` as the value. 

For more examples, see [Google Cloud's buildpacks documentation](https://cloud.google.com/docs/buildpacks/service-specific-configs).


# Develop a Webhook

Choreo allows developers to design high-quality webhooks. To explore this capability, let's consider a scenario where a team of software engineers in an organization should be notified via email whenever someone creates a GitHub issue with the `bug` label in a specific repository.

In this tutorial, you will address the requirement by doing the following:

- Create a webhook by connecting to a forked GitHub repository where you have the webhook implementation that addresses the described requirement.
- Deploy the webhook to the development environment.
- Modify the webhook implementation to connect the webhook to GitHub, enabling it to act in response to selected GitHub-related events.
- Test the webhook.
- Promote the webhook to the production environment.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

## Step 1: Create a webhook component

To create a Webhook component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Webhook** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following information:

    | **Field**                     | **Description**    |
    |-------------------------------|--------------------|
    | **GitHub Account**            | Your account       |
    | **GitHub Repository**         | choreo-samples     |
    | **Branch**                    | main               |
    | **Component Path**              | `github-event-to-email-webhook` |

6. Select **Ballerina** as the build pack.
7. Provide a display name, a unique name and description for the component.
8. Click **Create**.

Choreo creates the Webhook component with the sample implementation and opens the component **Overview** page.

## Step 2: Deploy

To deploy the webhook to the development environment, follow these steps:

1. In the Choreo Console left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**.
3. In the **Configurations** pane, enter the following information:
    1. In the **webhookSecret** field, enter any value.

        !!! note
            Save this value for later use.

    2. In the **toEmail** field, enter the email address to send notification emails.
    3. Click **Deploy**.

    You can monitor the deployment progress in the **Console** pane that opens on the right of the page.

Once Choreo completes the deployment, the **Development** card indicates the **Deployment Status** as **Active**.

!!! note
    In the deployment card, you can click the icon corresponding to configurables to open the **Configurations** pane and edit configurations.

## Step 3: Connect the webhook to the GitHub repository

To allow the webhook to read the labels of issues in a specific GitHub repository, connect the webhook to the GitHub repository:

1. In the Choreo Console left navigation menu, click **Overview**.
2. On the **Overview** page, copy the invoke URL by clicking the copy icon within the **URL** field.
3. Go to your GitHub account and open the repository for which you want to generate notification emails.
4. In the top menu, click the **Settings** tab.
5. In the left navigation menu, click **Webhooks**.
6. Click **Add webhook** and enter the following information:

    | **Field**        | **Value**                                                          |
    |------------------|--------------------------------------------------------------------|
    | **Payload URL**  | The invoke URL you copied in Step 3, sub-step 1.                   |
    | **Content Type** | Select `application/json`                                          |
    | **Secret**       | The last webhook secret you configured in [Step 2](#step-2-deploy).| 

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Project Path** specifies the location of the project to build the component.

7. Under **Which events would you like to trigger this webhook?**, select **Let me select individual events**.
8. Select the **Issues** checkbox in the list of events displayed. This ensures that GitHub issues trigger the webhook.
9. Clear the **Pushes** checkbox to ensure that GitHub does not trigger your webhook when the team pushes changes to the selected GitHub repository.
10. Click **Add webhook** to save the configuration.

Now you have integrated Choreo with GitHub via the webhook you created and deployed. You can proceed to test the webhook.

## Step 4: Test

To test your webhook, create a GitHub issue with the `Bug` label in the repository that you connected to the webhook. You will receive an email similar to the following at the email address you provided in [Step 2](#step-2-deploy).

## Step 5: Promote

To promote the webhook to the Production environment, follow these steps:

1. On the **Deploy** page, go to the **Development** card and click **Promote**.
2. In the **Configuration Types** pane, leave the default selection (i.e., **Use default configuration values**) unchanged.

    !!! note
        If you have configured any default values for the configurable variables, selecting **Use default configuration values** allows you to proceed with those values. If not, specify values for the configurable variables.

3. Click **Next**.
4. In the **webhookSecret** field, enter any value.

    !!! note
        Save this value for later use.

5. In the **toEmail** field, enter the email address to send notification emails.
6. Click **Promote**.

    Once the component is promoted to production, the **Production** card displays the deployment status as **Active**.

Now you have successfully created, deployed, and tested a Webhook component and promoted it to production.


# Develop an External Consumer

An external consumer in Choreo is any client that can interact with services deployed in Choreo, as an entity hosted outside of the Choreo infrastructure. It is a generic component type that allows you to represent and manage any client, such as a mobile application, web application, server-to-server integration, bot, microservices, etc.

In this guide, you will:

 - Create an external consumer component.
 - Manage authentication for the external consumer.
 - Connect the external consumer to a service deployed in Choreo.
 
## Prerequisites

Before you try out this guide, complete the following steps:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

## Step 1: Create an external consumer component
 
To create an external consumer component, follow the steps given below:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **External Consumer** card. 
4. In the **Create an External Consumer** pane that opens, enter a display name, a unique name, and a description for the component.
5. Click **Create**. This creates the component and takes you to its **Overview** page.
   
## Step 2: Manage authentication for the external consumer

You can configure the external consumer to work with the Choreo built-in identity provider or any external identity provider that supports OIDC/OAuth 2.0.

Click the respective tab for details depending on the identity provider you want to configure: 

=== "Choreo built-in identity provider"

     Follow the steps given below to configure the built-in identity provider by generating authentication keys:

    !!! note
         Choreo built-in identity provider is configured by default. Therefore, this step is optional.

     1. In the **Overview** page of the component, under **Authentication Configurations**, click **Configure** corresponding to the environment for which you want to configure an identity provider.
     2. In the **Identity Provider** list, select **Choreo Built-In Identity Provider**.
     3. Click **Generate Keys**. 

        !!! Note
             If you see **Regenerate Secret** instead of **Generate Keys**, it indicates that OAuth keys are already generated for the component in the selected environment.

=== "An external identity provider"

     **Step 2.1: Create and configure an OIDC/OAuth 2.0 application in the external identity provider**

     1. Create an OIDC/OAuth 2.0 application in your external identity provider.
     2. Configure the OIDC/OAuth 2.0 application accordingly. (The access token type should be configured as JWT)

     **Step 2.2: Link the OIDC/OAuth 2.0 application to the Choreo component**

     3. In the **Overview** page of the component, under **Authentication Configurations**, click **Configure** corresponding to the environment for which you want to configure an identity provider.
     4. In the **Identity Provider** list, select your identity provider.
     5. Paste the **Client ID** of the OIDC/OAuth 2.0 application you created in your external identity provider.
     6. Click **Add Keys**.

## Step 3: Connect the external consumer to a service deployed in Choreo 

To establish connections from the external consumer to services deployed in Choreo, you can create connections. For step-by-step instructions on creating a connection, see [Create a Connection](./sharing-and-reusing/create-a-connection.md).


# Develop Components Using VS Code

The [Choreo VS Code extension](https://marketplace.visualstudio.com/items?itemName=WSO2.choreo) provides comprehensive component management capabilities to streamline local development within Choreo.

## Prerequisites

To ensure a smooth development experience with the Choreo extension, make sure you have the following:

1. [Visual Studio Code](https://code.visualstudio.com/download) installed with the [Choreo extension](https://marketplace.visualstudio.com/items?itemName=WSO2.choreo) version **2.0.0** or later.

2. A locally cloned GitHub repository to create new components or link to existing Choreo components.

3. [Git](https://git-scm.com) version 2.0.0 or later.

## Get started

To use the capabilities of the Choreo extension in the VS Code editor, you need an active [Choreo account](https://wso2.com/choreo/pricing/). If you already have an account, follow these steps to set up the extension:

1. Install the [Choreo VS Code extension](https://marketplace.visualstudio.com/items?itemName=WSO2.choreo) and wait for activation. On successful activation, the Choreo extension opens in the VS Code editor. 
2. Sign in to Choreo using one of the following methods:
    - In the Choreo activity pane, click **Sign In**.
       ![Sign in](../assets/img/develop-components/develop-using-vs-code/sign-in.png)
    - Use the `Sign In` command provided by the Choreo extension.

    This redirects you to an external URI to complete the authentication process. On successful sign-in, the Choreo activity pane displays your account details along with any components detected within the VS Code workspace.

## Create a new component

1. Open the source code directory where you want to build, deploy, and manage components using Choreo.
2. Create a new component using one of the following methods:
    - In the Choreo activity pane, click **Create Component**.
       ![Create Component Button](../assets/img/develop-components/develop-using-vs-code/create-component-btn.png)
    - Use the `Create New Component` command provided by the Choreo extension.

3. If the Choreo extension cannot determine the project context of the opened workspace, it prompts you to select the organization and the project to which the new component belongs.
4. Specify component details such as the name, type, buildpack, etc.

    ![Component Form](../assets/img/develop-components/develop-using-vs-code/component-form.png)
            
    On successful creation, the component details view opens, and the Choreo activity pane displays the new component.

    ![Component Details](../assets/img/develop-components/develop-using-vs-code/component-details-view.png)
     
    !!! tip
        Once the component is created, a `.choreo/context.yaml` file is generated in the root of the Git repository. For more details, see [Understand the project context](#understand-the-project-context).

The component details view allows you to manage your component by performing various actions such as the following:

 - Triggering builds for selected commits.
 - Viewing lists of builds and statuses.
 - Diagnosing build failures with build logs.
 - Deploying builds in available environments.
 - Accessing runtime logs and deployed component URLs.
 - Invoking deployed service endpoints.

## Understand the project context

Context files contain metadata related to the project, allowing the extension to establish an association between local directories and Choreo projects. These files, such as the `context.yaml`file, resides in the `/.choreo` directory within the root of the Git repository.

The Choreo extension scans the root of the opened Git repository to find the `context.yaml` file and lists the components of the associated project. This allows you to easily open and manage the components they are developing within the VS Code workspace.

A `context.yaml` file can contain multiple projects, whereas, a workspace opened via VS Code can have multiple `context.yaml` files with different project associations. In such cases, VS Code allows you to switch between these projects, add new project associations, or remove existing ones, allowing you as a developer to focus on components of a particular project at a time.

You can decide whether to commit the `context.yaml` file to the Git repository. Committing this file enables other team members working on the same repository to have a seamless developer experience with Choreo.

If the `context.yaml` file for a particular project is not committed to the Git repository or is unavailable for other reasons, you can easily regenerate it using one of the following methods:

 - In the Choreo activity pane, click **Link Directory**.
    ![Link Directory](../assets/img/develop-components/develop-using-vs-code/link-dir-btn.png)
 - Use the `Link Directory` command provided by the Choreo extension.

## Discover additional features

To access a range of functionalities provided by the Choreo extension, open the VS Code command palette and type `Choreo`.

## Troubleshoot issues

To troubleshoot Choreo extension issues, follow these steps:

1. To open the **OUTPUT** pane, go to the VS Code editor main menu, click **View**, and then click **Output**.

2. Select **Choreo** from the drop-down menu on the right-hand side to view the Choreo output for troubleshooting.

## Get help

For assistance with the Choreo VS Code extension, create [GitHub issues](https://github.com/wso2/choreo-vscode/issues).


# Develop Components With Git

Choreo enables you to develop components by connecting your GitHub, Bitbucket, or GitLab repository. You have the flexibility to either connect an existing repository or start with an empty repository and commit the source code later. By integrating your repositories with Choreo, you can automate tasks and optimize workflows across multiple systems, all within the Choreo platform.  Choreo currently supports GitHub, Bitbucket, and GitLab as Git providers. 

!!! tip
    Choreo supports both Bitbucket Server and Bitbucket Cloud. The currently supported Bitbucket Server version is 8.9.2.

In Choreo, you can connect a Git repository that contains Ballerina source code or a Docker project. To connect a Git repository to Choreo as a Docker project, your Git repository must include the following:

 - A Dockerfile: Specifies the instructions to build the Docker image. 
 - A build context: A set of files in the specified path used to build the image.

Once you connect your Git repository to Choreo, you can build, deploy, and manage your application easily. 

## Connect a Git repository to Choreo

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the Choreo Console header, go to the **Organization** list and select your organization. 
3. In the left navigation menu, click **Settings**. This opens the organization-level settings page. 
4. Click the **Credentials** tab. 
5. Click **+Add Credentials** to configure the Git repository connection.
6. Enter a **Credential Name**, select the Git provider, and enter the **Personal Access Token** you obtained from the Git provider.
7. Click **Save**.  

## Authorize GitHub with Choreo 

Authorizing Choreo as a GitHub application grants Choreo the following permissions to perform the respective actions on your behalf within the repository:

|Permission   | Read| Write| Description                                                           |
|-------------|-----|------|-----------------------------------------------------------------------|
|Issues       | Y   | N    | Read component ID label to filter the pull requests                   |
|Metadata     | Y   | N    | List repositories                                                     |
|Contents     | Y   | Y    | List branches and create a branch to commit sample code               |
|Pull Request | Y   | Y    | Create a pull request if you start with a Choreo sample               |
|Webhooks     | Y   | Y    | Trigger automatic deployment and configuration generation             |

### Add Git submodules to a project

Choreo provides [Git submodule](https://git-scm.com/book/en/v2/Git-Tools-Submodules) support when you connect your GitHub repository to Choreo. This allows you to manage and include external repositories effectively within Choreo build pipelines. Key benefits of this capability include:

  - **Code sharing without duplication**: Use submodules to maintain shared libraries across multiple projects, ensuring a single source of truth.
  - **Efficient third-party library management**: Manage third-party libraries as submodules to update them independently and track changes easily, avoiding direct code integration.

For example, when you [work with the Micro Integrator (MI) runtime in Choreo](./work-with-the-micro-integrator-runtime-in-choreo.md), you can use Git submodules to reuse MI templates and sequences across components without duplication.

!!! info "Note" 
    If you encounter an error stating that you cannot clone a submodule due to insufficient permissions, follow the instructions below to grant the necessary permissions:

      - For a personal account:

         1. Sign in to your personal GitHub account.
         2. In the upper-right corner, click your profile picture, and then click **Settings**.
         3. In the left navigation menu, go to the **Integrations** section and click **Applications**.
         4. Under the **Installed GitHub Apps** tab, click **Configure** corresponding to **choreo.dev**.
         5. Under **Repository Access**, grant access to the necessary repositories.

      - For an organization account:

         1. Sign in to your organization's GitHub account.
         2. In the upper-right corner, click your profile picture, and then click **Settings**.
         3. In the left navigation menu, go to the **Third-Party Access** section and click **GitHub Apps**.
         4. Click **Configure** corresponding to **choreo.dev**.
         5. Under **Repository Access**, grant access to the necessary repositories.

            !!! note
                Choreo currently does not support accessing private repositories in other organizations.

#### Automatically pull latest versions of Git submodules

Choreo lets you automatically pull the latest versions of Git submodules from their respective repositories. To enable this feature, follow these steps:

!!! note 
    Choreo currently supports this feature only for components where the buildpack is **WSO2 MI**.

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click the component for which you want to pull the latest versions of Git submodules.
3. In the left navigation menu, click **Build**.
4. On the **Build** page, click to edit **Build Configurations**.
5. Turn on the **Pull Latest Submodules** toggle.

    !!! info "Note"
        If you rebuild a previously built commit and it doesn’t reflect the latest changes, follow these steps to ensure the changes are applied to the deployed environment:

         1. In the Choreo Console left navigation menu, click **DevOps**, then click **Containers**.
         2. Click **Edit** to update the container settings.
         3. Select **Always** as the **Image Pull Policy**.
         4. Click **Save Changes**.

## Authorize Bitbucket with Choreo

Authorizing using a personal access token (PAT) from Bitbucket grants Choreo the following permissions to perform the respective actions on your behalf within the repository.

|Permission    | Read| Write| Description                                                        |
|--------------|-----|------|--------------------------------------------------------------------|
|Account       | Y   | N    | Get user information and workspace details                         |
|Repositories  | Y   | Y    | List branches and create a branch to commit sample code            |
|Pull Requests | Y   | Y    | Create a pull request if you start with a Choreo sample            |
|Webhooks      | Y   | Y    | Trigger automatic deployment and configuration generation          |

## Authorize self-managed GitLab with Choreo

Authorizing using a personal access token (PAT) obtained from your GitLab self-managed server grants Choreo the following permissions to perform the respective actions on your behalf within the repository.

|Permission    | Description                                                                         |
|--------------|-------------------------------------------------------------------------------------|
|API           | Grants full read/write access to the API, covering all groups and projects, as well as read/write access to the repository.|


 # Bring Your Own Image (BYOI)

Choreo allows you to deploy and manage prebuilt container images from external container registries as Choreo components. This enables you to deploy and effectively manage your container images within the Choreo environment.

!!! info
    This feature is currently only available on [private data planes (PDPs)](../choreo-concepts/data-planes.md#private-data-planes) for the following component types:

    - Service
    - Web Application
    - Scheduled Task
    - Manual Task


## Prerequisites

Before you try out this guide, ensure you have the following:

- **A container registry**: Ensure you have a container registry containing the images you want to deploy. Choreo is compatible with various container registries, including but not limited to GCR (Google Container Registry), ACR (Azure Container Registry), GitHub Container Registry, and Docker Hub.

- **An image in the registry**: You need an image ready for deployment.

- **(Optional) An external build/CI pipeline**:  This is to initiate automatic deployments during the build process outside of Choreo.

When using a container registry to deploy a component, Choreo cannot create an image from the source code (Git) or initiate a new deployment when a new image is ready. However, you can use your existing build process to trigger a deployment on Choreo by sending an HTTP POST request to a webhook with the new image details.

This feature is currently only available on private data planes (PDPs). You can find this option under **Deploy an image from a container registry** in the **Select Source** step during component creation for service components, web applications, scheduled tasks, and manual tasks.

## Step 1: Register a container registry

To get started, establish a connection between your container registry and Choreo. 

!!! Info
    When you use your Choreo credentials, Choreo does not *pull* your images into its control plane. Instead, it functions as an orchestrator, facilitating your data plane's ability to retrieve images from an external container registry. Choreo passes on these credentials to the data plane for authentication and access.

To register your container registry, follow these steps:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the Choreo Console header, go to the **Organization** list and select your organization. 
3. In the left navigation menu, click **Settings**. This opens the organization settings page. 
4. Click the **Credentials** tab and then click the **Container Registries** tab. 
5. Click **+Add Registry** to configure the Git repository connection.
6. Specify a **Registry Display Name**.
7. Select the **Authentication Type**. Fill in the required information depending on your authentication type. For details on each authentication type, see [Authentication types](#authentication-types).
8. Click **Save**.

### Authentication types

Choreo provides the following authentication options:  

#### Public (anonymous) access
    
You can use this option to establish a connection with a container registry that permits unrestricted public or anonymous access (for example, Public Docker Hub). In this case, only the registry host information is necessary.

For example, the following are the Docker Hub registry hosts for reference:

| Vendor                           | Registry host                |
|----------------------------------|------------------------------|
|Docker Hub (public repositories)  | `registry.hub.docker.com`    |
|Docker Hub (private repositories) | `registry.docker.com`        |

\* If necessary, you can use other mirrors instead of the above.

#### Basic authentication

To use basic authentication to authenticate to the container registry, you must provide the username and password.

#### Docker config

You can provide a Docker config in JSON format to authenticate to the container registry. This option only allows you to register one container registry. That is, it **only allows a single registry under `auths`**.

You must provide the credentials directly within the configuration. Choreo cannot utilize references to executable authentication plugins.

Sample Docker config format:

```json
    {
    "auths": {
        "index.docker.io/v1/": {
        "auth": "c3R...zE2"
        }
    }
    }
```

#### Vendor-specific authentication

This option is specifically for private data planes, where your cloud provider manages authentication at the Kubernetes level. Choreo requires knowledge of the registry host because the data plane already possesses implicit (preconfigured) access to the registry.

Follow the guidelines below based on your container registry:

=== "ACR"
    **Azure Container Registry** 

    Recommended authentication options:

    * [**Service principal-based basic authentication**](https://learn.microsoft.com/en-us/azure/container-registry/container-registry-auth-service-principal)

    * **Vendor-specific authentication on Azure private data planes**
        
        Contact Choreo support to enable infrastructure-level private access to your registry from your Azure private data plane on AKS. If you are on a self-managed PDP on Azure, follow [this guide](https://learn.microsoft.com/en-us/azure/aks/cluster-container-registry-integration?toc=%2Fazure%2Fcontainer-registry%2Ftoc.json&bc=%2Fazure%2Fcontainer-registry%2Fbreadcrumb%2Ftoc.json&tabs=azure-cli).

=== "GAR"
    **Google Artifact Registry**

    Recommended authentication options:

    * [**Service account-based basic authentication**](https://cloud.google.com/artifact-registry/docs/docker/pushing-and-pulling#key)

        Use the service account key in JSON format ([`_json_key`](https://cloud.google.com/artifact-registry/docs/docker/authentication#:~:text=of%20the%20following%3A-,_json_key,-if%20you%20are)) as the username and specify the minified JSON contents of the service account key as the password.

         You can use `jq` as follows to minify the service account JSON key file:

         `jq -c . <service-account.json>`

    * **Vendor-specific authentication on GCP private data planes**

        Contact Choreo support to enable infrastructure-level private access to your registry from your GCP private data plane on GKE. If you are on a self-managed PDP on GCP, see [https://cloud.google.com/artifact-registry/docs/access-control#grant-project](https://cloud.google.com/artifact-registry/docs/access-control#grant-project).

=== "AWS ECR"
    **Elastic Container Registry**

    ECR does not allow the creation of static access passwords for basic authentication. The passwords (that is, access tokens) provided by AWS are only valid for 10 hours and must be manually regenerated. However, when an ECR is attached to an EKS cluster at an infrastructure level, this limitation does not apply because the authentication is handled by AWS internally. For details, see [https://docs.aws.amazon.com/AmazonECR/latest/userguide/registry_auth.html](https://docs.aws.amazon.com/AmazonECR/latest/userguide/registry_auth.html).

    Choreo recommends using ECR when you are exclusively on an AWS private data plane using the vendor-specific authentication option. Contact Choreo support to enable a private connection between your ECR and the underlying EKS clusters on your data plane. If you are on a self-managed PDP, you can follow [this guide](https://docs.aws.amazon.com/AmazonECR/latest/userguide/ECR_on_EKS.html).    

=== "Docker Hub (Private)"

    Recommended authentication options:

    * **Basic authentication**

          Use your Docker Hub username/password or an access token. You can generate an access token from your Docker Hub account settings and use it in place of the password. For details, see [https://docs.docker.com/docker-hub/access-tokens/](https://docs.docker.com/docker-hub/access-tokens/).

    * **Docker config**

          Sign in to the Docker CLI and copy the contents of the docker config JSON. Note that external credential stores and multiple repositories within the same config object are not supported. For more information, see [https://docs.docker.com/engine/reference/commandline/login/](https://docs.docker.com/engine/reference/commandline/login/).

=== "GHCR"
    **GitHub Container Registry**

    Recommended authentication option:

    * **Basic authentication using a PAT token**

          Create a personal access token (PAT) and use it in place of the password. You cannot use your own GitHub password. You must provide a [PAT token](https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry#authenticating-with-a-personal-access-token-classicn).
  
## Step 2: Create a component in Choreo

1. In the left navigation, click **Overview** and select your project. Alternatively, select your project from the **Project** list in the Choreo Console header. 
2. Under **Component Listing** click **+ Create**.
3. Select your component type (BYOI is only available for Service, Web Application, Scheduled Task, or Manual Task components). 
4. From the Create Component pane, select the **Container Registry** under the **Connect a Docker Image** section.
5. Under **Deploy an image from Container Registry/Docker Hub**, select the container registry you have registered in [Step 1](#step-1-register-a-container-registry).
6. Enter the full image URL. The image URL format in general is as follows:
   `[container-registry-host]/[repository-name]/[image-name]:[tag]`

    !!! tip
        When a public image from Docker Hub lacks a specified repository name, it typically defaults to `/library/`. For example, you can access the public Nginx image `https://hub.docker.com/_/nginx` as `registry.hub.docker.com/library/nginx:1.25`.

7. Enter a display name, a unique name, and a description for the component.
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.


## Step 3: Deploy the component in Choreo

To deploy the component and bring your image to Choreo, follow the steps given below: 

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Update Image & Deploy**. 
3. In the **Endpoint** pane that opens, you can see the endpoint ready to be deployed. Click the edit icon next to the endpoint name. Optionally, you can define the endpoints for your service when you manually deploy the service. For more information, see [Expose service endpoints](#step-4-expose-service-endpoints).
4. Change the **Network Visibility** to **Public**. This setting securely exposes the endpoint for consumption.
5. Click **Update**.

    !!! info
         In this example, you deploy a Ballerina service as a REST endpoint. Therefore, Choreo generated the REST endpoint automatically. If you deploy a non-Ballerina service, you must manually add the REST endpoint and set the network visibility to **Public**.

6. Select your update image option. Refer to the update options listed below.

    You have the capability of updating the image when you are deploying the component in Choreo in one of the following three ways:

    | Option                   |Description                                                                                             |
    |--------------------------|--------------------------------------------------------------------------------------------------------|
    | **Update Image Tag**     | This option allows you to update the tag of the image.                                                 |
    | **Update Image URL**     | With this option, you can change the image name, tag, and the image repository of the image URL.|
    | **Previous Images**      | This option allows you to select a previous image and redeploy the image.                               |

7. Click **Deploy**. This deploys the service to the development environment.

## Step 4: Expose service endpoints 

!!! info
    This section only applies to service components.

After creating a service component in Choreo, you have the option to define the endpoints for your service when manually deploying a new image.

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Update Image & Deploy**. 
3. In the **Endpoint** pane that opens, optionally, you can define the endpoints for your service when you manually deploy the service. 
4. Click  **Create/Update Endpoints**.
5. Under the **Edit endpoints.yaml** section, you can edit the endpoints YAML file in the provided editor. 
   Alternatively, you can upload the associated API specification/schema files (OpenAPI/GraphQL schemas). Instead of specifying the file path, you can also reference this file in the `endpoints.yaml` file by its file name, similar to the Git-based Choreo components. The endpoints template follows the standard definitions for defining endpoints in Choreo. For more details, see [Configure Endpoints](../develop-components/configure-endpoints.md).

## Auto-deploy images in Choreo with an external CI/build pipeline

Choreo does not have automatic detection and deployment for newly added images or tags in the linked container registry. To overcome this limitation, Choreo allows you to integrate your own CI pipelines and initiate deployments manually. This approach enables you to use your existing CI setup or build a pipeline for image creation and pushing. You can then trigger automatic deployments using a webhook.

Follow the steps below to configure your CI/build pipeline:

1. Build and push the container image associated with a Choreo component to your container registry.
2. In the left navigation menu, click **DevOps** and then click **External CI**.
3. Generate a token for your CI pipeline from the **Manage Tokens** section. 

    !!! note
        - The tokens are bound to a specific component.
        - It is recommended to reference the token from a secure location available to your CI pipeline. For example, use a GitHub secret if you are using GitHub Actions.

4. To trigger an automatic deployment to your development environment, you can initiate an HTTP POST request to the Choreo webhook endpoint with the updated image details. Alternatively, you can use the provided Webhook snippets. This action will seamlessly deploy the image to the development environment.



Services and integrations are exposed to other services, integrations, or applications through endpoints. A service or an integration can expose multiple endpoints, each representing a unique entry point into the service. For example, a service may expose a REST API endpoint and a GraphQL endpoint, each providing different ways to interact with the service. Endpoints provide specific details for how the service or the integration can be consumed. For instance, the port number, protocol, and the schema such as open API specification (OAS) or GraphQL schema. By defining these details, endpoints make it possible for other services, integrations, and applications to discover and interact with the service in a standardized way.

Choreo defines endpoints by combining port binding, protocol, endpoint name, network visibility, endpoint schema, and additional protocol-related fields. The following table describes each attribute of an endpoint.

| Field | Description |
| ----- | ----------- |
| Name | A unique identifier for the endpoint within the service component. |
| Port | The network port on which the endpoint is accessible. |
| Type | The endpoint protocol. Supported protocols: REST, GraphQL, gRPC, WS, UDP, and TCP. |
| Network Visibility | Determines the level of visibility of an endpoint. Possible values are: <ul><li>Project: Allows components within the same project to access the endpoint.</li><li>Organization: Allows any component within the same organization to access the endpoint but restricts access to components outside the organization.</li><li>Public: Allows any client to access the endpoint, regardless of location or organization.</li></ul> |
| Schema | Specifies the structure and format of the data exchanged through the endpoint. |
| Context (HTTP and GraphQL only) | A context path that you add to the endpoint's URL for routing purposes. |

## Configure endpoints
The method of defining endpoints depends on the buildpack.

* For `Ballerina` and `WSO2 MI` buildpacks, Choreo automatically detects the endpoint details for REST APIs.
* For all other buildpacks (Java, Python, NodeJS, Ruby, PHP, Go, Dockerfile, etc.), you can configure endpoints in one of the following ways:
  
    * **Using the Choreo Console**: If a `component.yaml` file is not present, you can define a basic endpoint configuration during component creation.
    * **Using the component.yaml file**: You can manually configure endpoint details by defining them in a `component.yaml` file, placing it inside the `.choreo` directory at the build context path, and committing it to the source repository.

You can override UI-defined and auto-generated endpoints by providing a `component.yaml` file in the `.choreo` directory, which will take priority over other configurations.

To learn about the `component.yaml` file, see [Overview of the component.yaml file](../develop-components/manage-component-source-configurations.md#overview-of-the-componentyaml-file).
!!! note
    Automatic endpoint generation is not supported for dynamic endpoint parameters such as variable ports. Therefore, you must use an `component.yaml` file to define dynamic endpoint parameters.

To learn about the `component.yaml` file, see [Overview of the component.yaml file](../develop-components/manage-component-source-configurations.md#overview-of-the-componentyaml-file).

## Expose endpoints as managed APIs

Exposing endpoints as managed APIs is crucial to ensure secure and controlled access to the services being exposed. When a user wants to expose their written service to the outside world or to the organization at large, there is an inherent security risk involved. To mitigate this risk, the Choreo platform is built with an internal (access within the organization only) or external (publicly accessible) gateway that is protected with Choreo API management making the services secure by design.

!!! note
    This feature is not available for gRPC, UDP, and TCP endpoints.

If you want to expose an endpoint as a managed API in Choreo, you need to set the network visibility to either Organization or Public. This allows the endpoint to be exposed through the Choreo API Gateway, which provides a number of benefits, including:

* Expose APIs to external and internal consumers
* Full lifecycle API Management
* API throttling
* Secure APIs with industry-standard authorization flows
* API analytics and monitoring

Once you deploy the service component, Choreo will expose the endpoint as a managed API through the Choreo API Gateway. You can then use the full lifecycle API management features provided by Choreo to test, deploy, maintain, monitor, and manage your API using the API management features.

## Understand the default component URL

The default URL of a component corresponds to the default endpoint of the component and is structured as follows:

`<domain>/<project-name>/<component-name>`

This URL does not include the default endpoint name. For all other endpoints, the URL structure includes the endpoint name, as follows:

`<domain>/<project-name>/<component-name>/<endpoint-name>`

If a component has multiple endpoints, Choreo allows you to change the endpoint corresponding to the default component URL. For a component with a single endpoint, the default URL automatically corresponds to that endpoint.

### Change the default endpoint of a component

To change the default endpoint of a component, follow the steps given below:

!!! note
     - You cannot change the default endpoint if it has associated published APIs. You must go to the **Lifecycle** page and unpublish the relevant APIs before updating the default endpoint. For instructions on unpublishing an API, see [Lifecycle Management](https://wso2.com/choreo/docs/api-management/lifecycle-management/).
     - Choreo does not allow you to change the default endpoint of a component if you create multiple deployment tracks within its current major version, or promote the component beyond its initial environment.

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to change the default endpoint.
3. In the left navigation menu, click **Deploy**.
4. On the **Deploy** page, go to the **Set Up** card and click **Configure & Deploy**.
5. In the **Environment Configurations** pane that opens, click **Next**.
6. In the **File Mount** pane that opens, click **Next**.
7. In the **Endpoint Details** pane that opens, click the **Default Endpoint** list, select the endpoint you want to set as the default endpoint, and then click **Update**.
8. Click **Deploy**. This deploys the component with the selected endpoint as the default, and the default URL will now correspond to this endpoint.  

### Edit a UI-Defined Endpoint
If you defined an endpoint during component creation, you can edit it later by following these steps:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to update the endpoint.
3. In the left navigation menu, click **Deploy**.
4. On the **Deploy** page, go to the **Set Up** card and click **Configure & Deploy**.
5. In the **Environment Configurations** pane that opens, click **Next**.
6. In the **File Mount** pane that opens, click **Next**.
7. In the **Endpoint Details** pane that opens, locate the endpoint you want to edit.
8. Click the **Edit** icon next to the endpoint, modify the editable fields, and click **Update**.
9. Click **Deploy** to apply the changes.

!!! note
     If you commit a `component.yaml` file, build the component, and proceed with deployment, the endpoints will be generated from the `component.yaml` file and will take priority. In this case, the endpoint cannot be edited through the UI. To modify the endpoint, you must update the`component.yaml` file.


# Configure Endpoints
{% include "configure-endpoints-body.md" %}

# Deploy a Containerized Application 

Using Choreo, you can easily deploy applications written in different language frameworks (such as Java, Go, NodeJS, Python, etc.) on shared or private data planes using containers.

Choreo supports deploying containerized applications for the following component types:

- Service
- Web Application
- Scheduled Task
- Manual Task
- Event Handler
- Test Runner

## Connect your repository to Choreo

To connect your GitHub repository to Choreo, you should authorize the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application to access your account or organization. When you attempt to connect your GitHub repository via the Component creation page, the Choreo Apps authorization prompt will appear.

* Connect GitHub Repository
    
    ![Connect GitHub Repository](../assets/img/develop-components/deploy/create-component-authz-github-page.png){.cInlineImage-threeQuarter}

* Authorize GitHub Application
    
    ![Authorize GitHub Application](../assets/img/develop-components/deploy/authz-choreo-github-app.png){.cInlineImage-half}

* Grant Repository Access

    ![Grant Repository Access](../assets/img/develop-components/deploy/github-repo-access.png){.cInlineImage-full}


    The **Choreo Apps** requires the following permission:
    
    - Read access to issues and metadata
    - Read and write access to code, pull requests, and repository hooks

!!! note
    You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. Choreo needs write access only to send pull requests to a user repository. Choreo does not directly push any changes to a repository.

Alternatively, you can connect a public repository without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. Select the **Third-Party GitHub Repository** and paste a public repository URL in the **Public Repository URL** field at the time of component creation.

!!! tip
     Authorizing the repository with the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application becomes essential if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component. If you own the repository, you can subsequently authorize it with the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application to enable **Auto Deploy**.

After granting access to the required repositories, you can choose a repository and an associated branch to connect to the Choreo component.
For the containerized application deployments, you should select the [**Component Directory**](https://docs.docker.com/build/building/context/#path-context), **Dockerfile** as the **Buildpack** and provide **Dockerfile Path** for the Docker build.

![Connected Dockerfile Repository](../assets/img/develop-components/deploy/create-component-connected-repo.png){.cInlineImage-full}

The following table describes the individual fields in the **Create Component** pane.

| **Field**               | **Description**                                                                                                                                                                      |
|-------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **GitHub Account**      | Your GitHub account or organization. If you want to add another GitHub account, you can expand the list and click **+ Add**.                                                            |
| **GitHub Repository**   | Depending on the repository access you provided, the list will show available repositories to be connected.                                                                                  |
| **Branch**              | The branch of the repository.                                                                                                                                                         |
| **Buildpack**        | Determines the implementation of the component: Any language or other language as a Docker container.                                                                                |
| **Dockerfile Path**     | The path to your Dockerfile. This path is defined relative to the repository root.<br/>For example, if the Dockerfile is at the repository root, the value for this field is `/Dockerfile`. |
| **Component Directory** | The component directory path. To include the repository root, leave the default `/` value.                                                                                          |
| **Port***               | The port at which your service is running.                                                                                                                                           |
| **OpenAPI Filepath***   | The path to an OpenAPI specification (in YAML/JSON) relative to the repository root. If you don't provide a path, the system automatically generates a default allow-all specification.    |

   
!!! note
 
    - Fields marked with **\*** are not visible for all component types.

    - To successfully build your container with Choreo, it is essential to explicitly define a User ID (`UID`) under the `USER` instruction in your Dockerfile. You can refer to the [sample Dockerfile](https://github.com/wso2/choreo-sample-apps/blob/main/go/rest-api/Dockerfile) for guidance.

    - To ensure that the defined USER instruction is valid, it must conform to the following conditions:
        
        - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
        - Usernames are not considered valid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

## Deploy the containerized component

Choreo will automatically apply deployment configurations and settings based on the component type you select during creation.
For example, if you select the **Service** component type, Choreo will deploy it as a Kubernetes deployment with appropriate scaling configurations.

You can run unit tests in the build pipeline by adding the relevant command to the Dockerfile.  For example: 

- [Go-based sample](https://github.com/wso2/choreo-sample-apps/blob/8c18c82db604adb43b89f669888a07cd6e31d7b7/go/rest-api/Dockerfile#L37)
- [Python-based sample](https://github.com/wso2/choreo-sample-apps/blob/8c18c82db604adb43b89f669888a07cd6e31d7b7/python/rest-api/Dockerfile#L15)

### Application configurations

You must provide any required configurations for running the application in the **Configs & Secrets** section of the component's **DevOps** page. Alternatively, you can also review the configurations when you manually deploy via the **Deploy** page.

After clicking the **Create** button, you can select the confidentiality of the configuration and specify how to mount it to the container.

![Application Configuration Page](../assets/img/develop-components/deploy/deploy-app-config-page.png){.cInlineImage-full}

![Create Configuration Mount Page](../assets/img/develop-components/deploy/deploy-app-config-type-mount-page.png){.cInlineImage-full}

#### Configuration types

* **ConfigMap**: Stores non-confidential data as key-value pairs.
* **Secret**: Stores and manages sensitive information, such as passwords, OAuth tokens, and ssh keys as key-value pairs.

#### Mount types

* **Environment Variables**: Mounts the selected ConfigMap or Secret as an environment variable in the container.
* **File Mount**: Mounts the selected ConfigMap or Secret as a file in the container. Here, the key is the file name, and the value is the file content.

The following image shows adding a **ConfigMap** with **File Mount** mount type to be read by the application.

![Configuration File Mount Page](../assets/img/develop-components/deploy/deploy-app-config-file-mount.png){.cInlineImage-full}

!!! note
    The JSON file includes ${DB_PASS} as an environment variable defined in a Secret. The application reads the JSON file and substitutes the placeholders with the corresponding environment variables.

### Deployment configurations

Choreo lets you configure deployment settings such as scaling, resource limits, and health checks based on your selected component type.

For more information about these configurations, see Choreo's [DevOps capabilities](../devops-and-ci-cd/view-runtime-details.md).

You can configure the **Endpoints** to expose your service using the **Service** Component in Choreo. See [Service Component Overview](../develop-components/develop-services/service-component-overview.md) for more information. 

### Build, deploy, and promote

After adding the application configuration, you can build and deploy it by clicking the **Deploy Manually** button. Choreo will start the build process with the selected commit in the **Build Area**. 

!!! note
    The **Auto Deploy on Commit** feature, which automatically builds and deploys the application upon pushing a code change to the repository, is enabled by default. To turn off this feature, navigate to the **Build Area** of the **Deploy** page.

Choreo scans your Dockerfile for security vulnerabilities during the build phase, and if there are no issues found, it proceeds with the build process. After building the image, it scans it again for vulnerabilities before deployment to the environment. You can view the build logs from the right-side panel, as shown in the image below.

![Build Logs Panel](../assets/img/develop-components/deploy/build-deploy-page-logs.png){.cInlineImage-full}

Once the build process is complete, Choreo will deploy the application automatically to the Development environment. To promote the build to higher environments, you can click the **Promote** button. The number of environment cards visible on the page may vary depending on your environment configurations.

### Troubleshoot security vulnerability scan failures (Trivy)

By default, Choreo utilizes the Aqua Trivy (OSS) image vulnerability scanner to detect security vulnerabilities in all Dockerfile-based build pipelines. The scanner will fail the pipeline if any **CRITICAL** CVEs (Common Vulnerabilities and Exposures) are detected. CVEs of other severity levels are recorded but does not fail the pipeline.

If you cannot fix a critical CVE immediately, you can opt to ignore it. To ignore a critical CVE, add a `trivyignore` (`<docker-build-context-path>/.trivyignore`) file to your build context path. In the file, add the CVEs you need the pipeline to ignore, one entry per line as follows:

```
CVE-2023-xxxx
CVE-2023-yyyy
```

You can add comments in the file by using `#` in front of the comment as follows: 

```
# comments can be added like this
CVE-2023-xxxx
```


# Deploy an Application with Buildpacks

Using Choreo, you can easily deploy applications written in different language frameworks (such as Java, Go, NodeJS, Python, Ruby, PHP, etc.) on shared or private data planes.

Choreo supports deploying applications with buildpacks for the following component types:

- Service
- Web Application
- Scheduled Task
- Manual Task
- Webhook
- Event Handler
- Test Runner

## Buildpacks
Buildpacks are a fundamental building block in modern application development. They convert your source code into a secure, efficient, production-ready container image without a Dockerfile. With Choreo, developers can take advantage of this powerful tool to effortlessly deploy their applications without the hassle of manual configuration.

Choreo uses [Google Buildpacks](https://cloud.google.com/docs/buildpacks/overview) as default buildpacks for Java, Go, NodeJS, Python, PHP, and Ruby. Choreo uses its own buildpacks for Ballerina and WSO2 MI.

## Develop a component

To develop a service component that exposes a Service in Go, you can follow the [Develop a Service ](develop-services/develop-a-service.md) guide.

Follow the guidelines below based on your language:

=== "Python"
    Supported Versions - 3.10.x, 3.11.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Reading Books List Service](https://github.com/wso2/choreo-samples/tree/main/reading-books-list-service-python)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-python-task)|

    ### Procfile
    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    
    !!! info 
        In **Python** projects, it is mandatory to have a `Procfile` with the `web` process type in the project root directory.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: python main.py` <br>
    `web: gunicorn --bind :8080 --workers 1 --threads 8 --timeout 0 main:app` <br>
    `web: flask run --host=0.0.0.0`

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Ballerina"

    Supported Versions - 2201.3.5, 2201.4.1, 2201.5.0, 2201.5.1, 201.6.0,  2201.7.0

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Echo Service](https://github.com/wso2/choreo-samples/tree/main/echo-service)|
    | Manual Task | [Covid19 Statistics To Email](https://github.com/wso2/choreo-samples/tree/main//covid19-statistics-to-email)|
    | Webhook | [Salesforce New Case To Google Sheet](https://github.com/wso2/choreo-samples/tree/main/sfdc-new-case-to-gsheet)|
    | Scheduled Task | [Shopify New Customers to HubSpot Create/Update Contact](https://github.com/wso2/choreo-samples/tree/main/shopify-new-customers-to-hubspot-contact)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Go"

    Supported Versions - 1.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Greeting Service](https://github.com/wso2/choreo-samples/tree/main/greeting-service-go)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-go-task)|
    | Web Application | [Hello World Web Application](https://github.com/wso2/choreo-samples/tree/main/hello-world-go-webapp)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== ".NET"
    Supported Versions - 6.x, 7.x, 8.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service | [Greeting Service](https://github.com/wso2/choreo-samples/tree/main/dotnet-greeter)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Java"
    Supported Versions
        - 8, 11, 17, 18 (OpenJDK Runtime Environment Temurin)

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Product Management Service](https://github.com/wso2/choreo-samples/tree/main/product-management-service)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-java-task)|

    !!! info

         When working on Java projects:

           - The `Main` class should be defined in the manifest file.
           - If Maven files such as `mvn.cmd` exist in the project without the `.mvn` directory, the build will fail. To ensure a successful build, you must either commit the `.mvn` directory along with any Maven files or not include any Maven files in the project if you choose not to commit the `.mvn` directory.
    
    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **Java** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: java -jar target/sample.jar` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "NodeJS"
    Supported Versions - 12.x.x, 14.x.x, 16.x.x, 18.x.x, 20.x.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Reading Books List Service](https://github.com/wso2/choreo-samples/tree/main/reading-books-list-service-nodejs)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-nodejs-task)|

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **NodeJS** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: node app.js` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "PHP"
    Supported Versions - 8.1.x, 8.2.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Hello World Service](https://github.com/wso2/choreo-samples/tree/main/hello-world-php-service)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-php-task)|
    | Web Application | [Hello World Web Application](https://github.com/wso2/choreo-samples/tree/main/hello-world-php-webapp)|

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **PHP** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web:php -S 0.0.0.0:8000 index.php` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Ruby"
    Supported Versions - 3.1.x, 3.2.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service | [Hello World Service](https://github.com/wso2/choreo-samples/tree/main/hello-world-ruby-service)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-ruby-task)|
    | Web Application | [Hello World Web Application](https://github.com/wso2/choreo-samples/tree/main/hello-world-ruby-webapp)|

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **Ruby** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: ruby app.rb` <br>
    `web:bundle exec ruby app.rb -p 8080` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "WSO2 MI"
    Supported Versions - 4.1.0.x, 4.2.0.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service |[Hello World Service](https://github.com/wso2/choreo-samples/tree/main/hello-world-mi)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Spring Boot"
    Supported Java Versions
        - 8, 11, 17, 18 (OpenJDK Runtime Environment Temurin)

    !!! info
         You can use this buildpack only with web applications. For other component types, use the **Java** buildpack. Additionally, if the generated artifact is a `WAR` file, it is necessary to include a **Procfile**.

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **Java** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: java -jar target/sample.war` <br>

### Configure build-time environment variables

You can configure the environment variables necessary to build the component using the **Build Configurations Editor** on the component **Build** page. 

!!! info
    The capability to configure build-time environment variables is not available for components created using **Ballerina** or **WSO2 MI** buildpacks.

During the build process, the build-time environment variables and their values are passed to the buildpack. Therefore, you can configure both buildpack-specific environment variables and those required for the component build.

For example, if you want to override the Maven command of the **Java** buildpack, you can use `GOOGLE_MAVEN_BUILD_ARGS` as the environment key and `clean install` as the value. 

For more examples, see [Google Cloud's buildpacks documentation](https://cloud.google.com/docs/buildpacks/service-specific-configs).


# Develop a Webhook

Choreo allows developers to design high-quality webhooks. To explore this capability, let's consider a scenario where a team of software engineers in an organization should be notified via email whenever someone creates a GitHub issue with the `bug` label in a specific repository.

In this tutorial, you will address the requirement by doing the following:

- Create a webhook by connecting to a forked GitHub repository where you have the webhook implementation that addresses the described requirement.
- Deploy the webhook to the development environment.
- Modify the webhook implementation to connect the webhook to GitHub, enabling it to act in response to selected GitHub-related events.
- Test the webhook.
- Promote the webhook to the production environment.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

## Step 1: Create a webhook component

To create a Webhook component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Webhook** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following information:

    | **Field**                     | **Description**    |
    |-------------------------------|--------------------|
    | **GitHub Account**            | Your account       |
    | **GitHub Repository**         | choreo-samples     |
    | **Branch**                    | main               |
    | **Component Path**              | `github-event-to-email-webhook` |

6. Select **Ballerina** as the build pack.
7. Provide a display name, a unique name and description for the component.
8. Click **Create**.

Choreo creates the Webhook component with the sample implementation and opens the component **Overview** page.

## Step 2: Deploy

To deploy the webhook to the development environment, follow these steps:

1. In the Choreo Console left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**.
3. In the **Configurations** pane, enter the following information:
    1. In the **webhookSecret** field, enter any value.

        !!! note
            Save this value for later use.

    2. In the **toEmail** field, enter the email address to send notification emails.
    3. Click **Deploy**.

    You can monitor the deployment progress in the **Console** pane that opens on the right of the page.

Once Choreo completes the deployment, the **Development** card indicates the **Deployment Status** as **Active**.

!!! note
    In the deployment card, you can click the icon corresponding to configurables to open the **Configurations** pane and edit configurations.

## Step 3: Connect the webhook to the GitHub repository

To allow the webhook to read the labels of issues in a specific GitHub repository, connect the webhook to the GitHub repository:

1. In the Choreo Console left navigation menu, click **Overview**.
2. On the **Overview** page, copy the invoke URL by clicking the copy icon within the **URL** field.
3. Go to your GitHub account and open the repository for which you want to generate notification emails.
4. In the top menu, click the **Settings** tab.
5. In the left navigation menu, click **Webhooks**.
6. Click **Add webhook** and enter the following information:

    | **Field**        | **Value**                                                          |
    |------------------|--------------------------------------------------------------------|
    | **Payload URL**  | The invoke URL you copied in Step 3, sub-step 1.                   |
    | **Content Type** | Select `application/json`                                          |
    | **Secret**       | The last webhook secret you configured in [Step 2](#step-2-deploy).| 

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Project Path** specifies the location of the project to build the component.

7. Under **Which events would you like to trigger this webhook?**, select **Let me select individual events**.
8. Select the **Issues** checkbox in the list of events displayed. This ensures that GitHub issues trigger the webhook.
9. Clear the **Pushes** checkbox to ensure that GitHub does not trigger your webhook when the team pushes changes to the selected GitHub repository.
10. Click **Add webhook** to save the configuration.

Now you have integrated Choreo with GitHub via the webhook you created and deployed. You can proceed to test the webhook.

## Step 4: Test

To test your webhook, create a GitHub issue with the `Bug` label in the repository that you connected to the webhook. You will receive an email similar to the following at the email address you provided in [Step 2](#step-2-deploy).

## Step 5: Promote

To promote the webhook to the Production environment, follow these steps:

1. On the **Deploy** page, go to the **Development** card and click **Promote**.
2. In the **Configuration Types** pane, leave the default selection (i.e., **Use default configuration values**) unchanged.

    !!! note
        If you have configured any default values for the configurable variables, selecting **Use default configuration values** allows you to proceed with those values. If not, specify values for the configurable variables.

3. Click **Next**.
4. In the **webhookSecret** field, enter any value.

    !!! note
        Save this value for later use.

5. In the **toEmail** field, enter the email address to send notification emails.
6. Click **Promote**.

    Once the component is promoted to production, the **Production** card displays the deployment status as **Active**.

Now you have successfully created, deployed, and tested a Webhook component and promoted it to production.


# Develop an External Consumer

An external consumer in Choreo is any client that can interact with services deployed in Choreo, as an entity hosted outside of the Choreo infrastructure. It is a generic component type that allows you to represent and manage any client, such as a mobile application, web application, server-to-server integration, bot, microservices, etc.

In this guide, you will:

 - Create an external consumer component.
 - Manage authentication for the external consumer.
 - Connect the external consumer to a service deployed in Choreo.
 
## Prerequisites

Before you try out this guide, complete the following steps:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

## Step 1: Create an external consumer component
 
To create an external consumer component, follow the steps given below:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **External Consumer** card. 
4. In the **Create an External Consumer** pane that opens, enter a display name, a unique name, and a description for the component.
5. Click **Create**. This creates the component and takes you to its **Overview** page.
   
## Step 2: Manage authentication for the external consumer

You can configure the external consumer to work with the Choreo built-in identity provider or any external identity provider that supports OIDC/OAuth 2.0.

Click the respective tab for details depending on the identity provider you want to configure: 

=== "Choreo built-in identity provider"

     Follow the steps given below to configure the built-in identity provider by generating authentication keys:

    !!! note
         Choreo built-in identity provider is configured by default. Therefore, this step is optional.

     1. In the **Overview** page of the component, under **Authentication Configurations**, click **Configure** corresponding to the environment for which you want to configure an identity provider.
     2. In the **Identity Provider** list, select **Choreo Built-In Identity Provider**.
     3. Click **Generate Keys**. 

        !!! Note
             If you see **Regenerate Secret** instead of **Generate Keys**, it indicates that OAuth keys are already generated for the component in the selected environment.

=== "An external identity provider"

     **Step 2.1: Create and configure an OIDC/OAuth 2.0 application in the external identity provider**

     1. Create an OIDC/OAuth 2.0 application in your external identity provider.
     2. Configure the OIDC/OAuth 2.0 application accordingly. (The access token type should be configured as JWT)

     **Step 2.2: Link the OIDC/OAuth 2.0 application to the Choreo component**

     3. In the **Overview** page of the component, under **Authentication Configurations**, click **Configure** corresponding to the environment for which you want to configure an identity provider.
     4. In the **Identity Provider** list, select your identity provider.
     5. Paste the **Client ID** of the OIDC/OAuth 2.0 application you created in your external identity provider.
     6. Click **Add Keys**.

## Step 3: Connect the external consumer to a service deployed in Choreo 

To establish connections from the external consumer to services deployed in Choreo, you can create connections. For step-by-step instructions on creating a connection, see [Create a Connection](./sharing-and-reusing/create-a-connection.md).


# Develop Components Using VS Code

The [Choreo VS Code extension](https://marketplace.visualstudio.com/items?itemName=WSO2.choreo) provides comprehensive component management capabilities to streamline local development within Choreo.

## Prerequisites

To ensure a smooth development experience with the Choreo extension, make sure you have the following:

1. [Visual Studio Code](https://code.visualstudio.com/download) installed with the [Choreo extension](https://marketplace.visualstudio.com/items?itemName=WSO2.choreo) version **2.0.0** or later.

2. A locally cloned GitHub repository to create new components or link to existing Choreo components.

3. [Git](https://git-scm.com) version 2.0.0 or later.

## Get started

To use the capabilities of the Choreo extension in the VS Code editor, you need an active [Choreo account](https://wso2.com/choreo/pricing/). If you already have an account, follow these steps to set up the extension:

1. Install the [Choreo VS Code extension](https://marketplace.visualstudio.com/items?itemName=WSO2.choreo) and wait for activation. On successful activation, the Choreo extension opens in the VS Code editor. 
2. Sign in to Choreo using one of the following methods:
    - In the Choreo activity pane, click **Sign In**.
       ![Sign in](../assets/img/develop-components/develop-using-vs-code/sign-in.png)
    - Use the `Sign In` command provided by the Choreo extension.

    This redirects you to an external URI to complete the authentication process. On successful sign-in, the Choreo activity pane displays your account details along with any components detected within the VS Code workspace.

## Create a new component

1. Open the source code directory where you want to build, deploy, and manage components using Choreo.
2. Create a new component using one of the following methods:
    - In the Choreo activity pane, click **Create Component**.
       ![Create Component Button](../assets/img/develop-components/develop-using-vs-code/create-component-btn.png)
    - Use the `Create New Component` command provided by the Choreo extension.

3. If the Choreo extension cannot determine the project context of the opened workspace, it prompts you to select the organization and the project to which the new component belongs.
4. Specify component details such as the name, type, buildpack, etc.

    ![Component Form](../assets/img/develop-components/develop-using-vs-code/component-form.png)
            
    On successful creation, the component details view opens, and the Choreo activity pane displays the new component.

    ![Component Details](../assets/img/develop-components/develop-using-vs-code/component-details-view.png)
     
    !!! tip
        Once the component is created, a `.choreo/context.yaml` file is generated in the root of the Git repository. For more details, see [Understand the project context](#understand-the-project-context).

The component details view allows you to manage your component by performing various actions such as the following:

 - Triggering builds for selected commits.
 - Viewing lists of builds and statuses.
 - Diagnosing build failures with build logs.
 - Deploying builds in available environments.
 - Accessing runtime logs and deployed component URLs.
 - Invoking deployed service endpoints.

## Understand the project context

Context files contain metadata related to the project, allowing the extension to establish an association between local directories and Choreo projects. These files, such as the `context.yaml`file, resides in the `/.choreo` directory within the root of the Git repository.

The Choreo extension scans the root of the opened Git repository to find the `context.yaml` file and lists the components of the associated project. This allows you to easily open and manage the components they are developing within the VS Code workspace.

A `context.yaml` file can contain multiple projects, whereas, a workspace opened via VS Code can have multiple `context.yaml` files with different project associations. In such cases, VS Code allows you to switch between these projects, add new project associations, or remove existing ones, allowing you as a developer to focus on components of a particular project at a time.

You can decide whether to commit the `context.yaml` file to the Git repository. Committing this file enables other team members working on the same repository to have a seamless developer experience with Choreo.

If the `context.yaml` file for a particular project is not committed to the Git repository or is unavailable for other reasons, you can easily regenerate it using one of the following methods:

 - In the Choreo activity pane, click **Link Directory**.
    ![Link Directory](../assets/img/develop-components/develop-using-vs-code/link-dir-btn.png)
 - Use the `Link Directory` command provided by the Choreo extension.

## Discover additional features

To access a range of functionalities provided by the Choreo extension, open the VS Code command palette and type `Choreo`.

## Troubleshoot issues

To troubleshoot Choreo extension issues, follow these steps:

1. To open the **OUTPUT** pane, go to the VS Code editor main menu, click **View**, and then click **Output**.

2. Select **Choreo** from the drop-down menu on the right-hand side to view the Choreo output for troubleshooting.

## Get help

For assistance with the Choreo VS Code extension, create [GitHub issues](https://github.com/wso2/choreo-vscode/issues).


# Develop Components With Git

Choreo enables you to develop components by connecting your GitHub, Bitbucket, or GitLab repository. You have the flexibility to either connect an existing repository or start with an empty repository and commit the source code later. By integrating your repositories with Choreo, you can automate tasks and optimize workflows across multiple systems, all within the Choreo platform.  Choreo currently supports GitHub, Bitbucket, and GitLab as Git providers. 

!!! tip
    Choreo supports both Bitbucket Server and Bitbucket Cloud. The currently supported Bitbucket Server version is 8.9.2.

In Choreo, you can connect a Git repository that contains Ballerina source code or a Docker project. To connect a Git repository to Choreo as a Docker project, your Git repository must include the following:

 - A Dockerfile: Specifies the instructions to build the Docker image. 
 - A build context: A set of files in the specified path used to build the image.

Once you connect your Git repository to Choreo, you can build, deploy, and manage your application easily. 

## Connect a Git repository to Choreo

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the Choreo Console header, go to the **Organization** list and select your organization. 
3. In the left navigation menu, click **Settings**. This opens the organization-level settings page. 
4. Click the **Credentials** tab. 
5. Click **+Add Credentials** to configure the Git repository connection.
6. Enter a **Credential Name**, select the Git provider, and enter the **Personal Access Token** you obtained from the Git provider.
7. Click **Save**.  

## Authorize GitHub with Choreo 

Authorizing Choreo as a GitHub application grants Choreo the following permissions to perform the respective actions on your behalf within the repository:

|Permission   | Read| Write| Description                                                           |
|-------------|-----|------|-----------------------------------------------------------------------|
|Issues       | Y   | N    | Read component ID label to filter the pull requests                   |
|Metadata     | Y   | N    | List repositories                                                     |
|Contents     | Y   | Y    | List branches and create a branch to commit sample code               |
|Pull Request | Y   | Y    | Create a pull request if you start with a Choreo sample               |
|Webhooks     | Y   | Y    | Trigger automatic deployment and configuration generation             |

### Add Git submodules to a project

Choreo provides [Git submodule](https://git-scm.com/book/en/v2/Git-Tools-Submodules) support when you connect your GitHub repository to Choreo. This allows you to manage and include external repositories effectively within Choreo build pipelines. Key benefits of this capability include:

  - **Code sharing without duplication**: Use submodules to maintain shared libraries across multiple projects, ensuring a single source of truth.
  - **Efficient third-party library management**: Manage third-party libraries as submodules to update them independently and track changes easily, avoiding direct code integration.

For example, when you [work with the Micro Integrator (MI) runtime in Choreo](./work-with-the-micro-integrator-runtime-in-choreo.md), you can use Git submodules to reuse MI templates and sequences across components without duplication.

!!! info "Note" 
    If you encounter an error stating that you cannot clone a submodule due to insufficient permissions, follow the instructions below to grant the necessary permissions:

      - For a personal account:

         1. Sign in to your personal GitHub account.
         2. In the upper-right corner, click your profile picture, and then click **Settings**.
         3. In the left navigation menu, go to the **Integrations** section and click **Applications**.
         4. Under the **Installed GitHub Apps** tab, click **Configure** corresponding to **choreo.dev**.
         5. Under **Repository Access**, grant access to the necessary repositories.

      - For an organization account:

         1. Sign in to your organization's GitHub account.
         2. In the upper-right corner, click your profile picture, and then click **Settings**.
         3. In the left navigation menu, go to the **Third-Party Access** section and click **GitHub Apps**.
         4. Click **Configure** corresponding to **choreo.dev**.
         5. Under **Repository Access**, grant access to the necessary repositories.

            !!! note
                Choreo currently does not support accessing private repositories in other organizations.

#### Automatically pull latest versions of Git submodules

Choreo lets you automatically pull the latest versions of Git submodules from their respective repositories. To enable this feature, follow these steps:

!!! note 
    Choreo currently supports this feature only for components where the buildpack is **WSO2 MI**.

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click the component for which you want to pull the latest versions of Git submodules.
3. In the left navigation menu, click **Build**.
4. On the **Build** page, click to edit **Build Configurations**.
5. Turn on the **Pull Latest Submodules** toggle.

    !!! info "Note"
        If you rebuild a previously built commit and it doesn’t reflect the latest changes, follow these steps to ensure the changes are applied to the deployed environment:

         1. In the Choreo Console left navigation menu, click **DevOps**, then click **Containers**.
         2. Click **Edit** to update the container settings.
         3. Select **Always** as the **Image Pull Policy**.
         4. Click **Save Changes**.

## Authorize Bitbucket with Choreo

Authorizing using a personal access token (PAT) from Bitbucket grants Choreo the following permissions to perform the respective actions on your behalf within the repository.

|Permission    | Read| Write| Description                                                        |
|--------------|-----|------|--------------------------------------------------------------------|
|Account       | Y   | N    | Get user information and workspace details                         |
|Repositories  | Y   | Y    | List branches and create a branch to commit sample code            |
|Pull Requests | Y   | Y    | Create a pull request if you start with a Choreo sample            |
|Webhooks      | Y   | Y    | Trigger automatic deployment and configuration generation          |

## Authorize self-managed GitLab with Choreo

Authorizing using a personal access token (PAT) obtained from your GitLab self-managed server grants Choreo the following permissions to perform the respective actions on your behalf within the repository.

|Permission    | Description                                                                         |
|--------------|-------------------------------------------------------------------------------------|
|API           | Grants full read/write access to the API, covering all groups and projects, as well as read/write access to the repository.|


 # Bring Your Own Image (BYOI)

Choreo allows you to deploy and manage prebuilt container images from external container registries as Choreo components. This enables you to deploy and effectively manage your container images within the Choreo environment.

!!! info
    This feature is currently only available on [private data planes (PDPs)](../choreo-concepts/data-planes.md#private-data-planes) for the following component types:

    - Service
    - Web Application
    - Scheduled Task
    - Manual Task


## Prerequisites

Before you try out this guide, ensure you have the following:

- **A container registry**: Ensure you have a container registry containing the images you want to deploy. Choreo is compatible with various container registries, including but not limited to GCR (Google Container Registry), ACR (Azure Container Registry), GitHub Container Registry, and Docker Hub.

- **An image in the registry**: You need an image ready for deployment.

- **(Optional) An external build/CI pipeline**:  This is to initiate automatic deployments during the build process outside of Choreo.

When using a container registry to deploy a component, Choreo cannot create an image from the source code (Git) or initiate a new deployment when a new image is ready. However, you can use your existing build process to trigger a deployment on Choreo by sending an HTTP POST request to a webhook with the new image details.

This feature is currently only available on private data planes (PDPs). You can find this option under **Deploy an image from a container registry** in the **Select Source** step during component creation for service components, web applications, scheduled tasks, and manual tasks.

## Step 1: Register a container registry

To get started, establish a connection between your container registry and Choreo. 

!!! Info
    When you use your Choreo credentials, Choreo does not *pull* your images into its control plane. Instead, it functions as an orchestrator, facilitating your data plane's ability to retrieve images from an external container registry. Choreo passes on these credentials to the data plane for authentication and access.

To register your container registry, follow these steps:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the Choreo Console header, go to the **Organization** list and select your organization. 
3. In the left navigation menu, click **Settings**. This opens the organization settings page. 
4. Click the **Credentials** tab and then click the **Container Registries** tab. 
5. Click **+Add Registry** to configure the Git repository connection.
6. Specify a **Registry Display Name**.
7. Select the **Authentication Type**. Fill in the required information depending on your authentication type. For details on each authentication type, see [Authentication types](#authentication-types).
8. Click **Save**.

### Authentication types

Choreo provides the following authentication options:  

#### Public (anonymous) access
    
You can use this option to establish a connection with a container registry that permits unrestricted public or anonymous access (for example, Public Docker Hub). In this case, only the registry host information is necessary.

For example, the following are the Docker Hub registry hosts for reference:

| Vendor                           | Registry host                |
|----------------------------------|------------------------------|
|Docker Hub (public repositories)  | `registry.hub.docker.com`    |
|Docker Hub (private repositories) | `registry.docker.com`        |

\* If necessary, you can use other mirrors instead of the above.

#### Basic authentication

To use basic authentication to authenticate to the container registry, you must provide the username and password.

#### Docker config

You can provide a Docker config in JSON format to authenticate to the container registry. This option only allows you to register one container registry. That is, it **only allows a single registry under `auths`**.

You must provide the credentials directly within the configuration. Choreo cannot utilize references to executable authentication plugins.

Sample Docker config format:

```json
    {
    "auths": {
        "index.docker.io/v1/": {
        "auth": "c3R...zE2"
        }
    }
    }
```

#### Vendor-specific authentication

This option is specifically for private data planes, where your cloud provider manages authentication at the Kubernetes level. Choreo requires knowledge of the registry host because the data plane already possesses implicit (preconfigured) access to the registry.

Follow the guidelines below based on your container registry:

=== "ACR"
    **Azure Container Registry** 

    Recommended authentication options:

    * [**Service principal-based basic authentication**](https://learn.microsoft.com/en-us/azure/container-registry/container-registry-auth-service-principal)

    * **Vendor-specific authentication on Azure private data planes**
        
        Contact Choreo support to enable infrastructure-level private access to your registry from your Azure private data plane on AKS. If you are on a self-managed PDP on Azure, follow [this guide](https://learn.microsoft.com/en-us/azure/aks/cluster-container-registry-integration?toc=%2Fazure%2Fcontainer-registry%2Ftoc.json&bc=%2Fazure%2Fcontainer-registry%2Fbreadcrumb%2Ftoc.json&tabs=azure-cli).

=== "GAR"
    **Google Artifact Registry**

    Recommended authentication options:

    * [**Service account-based basic authentication**](https://cloud.google.com/artifact-registry/docs/docker/pushing-and-pulling#key)

        Use the service account key in JSON format ([`_json_key`](https://cloud.google.com/artifact-registry/docs/docker/authentication#:~:text=of%20the%20following%3A-,_json_key,-if%20you%20are)) as the username and specify the minified JSON contents of the service account key as the password.

         You can use `jq` as follows to minify the service account JSON key file:

         `jq -c . <service-account.json>`

    * **Vendor-specific authentication on GCP private data planes**

        Contact Choreo support to enable infrastructure-level private access to your registry from your GCP private data plane on GKE. If you are on a self-managed PDP on GCP, see [https://cloud.google.com/artifact-registry/docs/access-control#grant-project](https://cloud.google.com/artifact-registry/docs/access-control#grant-project).

=== "AWS ECR"
    **Elastic Container Registry**

    ECR does not allow the creation of static access passwords for basic authentication. The passwords (that is, access tokens) provided by AWS are only valid for 10 hours and must be manually regenerated. However, when an ECR is attached to an EKS cluster at an infrastructure level, this limitation does not apply because the authentication is handled by AWS internally. For details, see [https://docs.aws.amazon.com/AmazonECR/latest/userguide/registry_auth.html](https://docs.aws.amazon.com/AmazonECR/latest/userguide/registry_auth.html).

    Choreo recommends using ECR when you are exclusively on an AWS private data plane using the vendor-specific authentication option. Contact Choreo support to enable a private connection between your ECR and the underlying EKS clusters on your data plane. If you are on a self-managed PDP, you can follow [this guide](https://docs.aws.amazon.com/AmazonECR/latest/userguide/ECR_on_EKS.html).    

=== "Docker Hub (Private)"

    Recommended authentication options:

    * **Basic authentication**

          Use your Docker Hub username/password or an access token. You can generate an access token from your Docker Hub account settings and use it in place of the password. For details, see [https://docs.docker.com/docker-hub/access-tokens/](https://docs.docker.com/docker-hub/access-tokens/).

    * **Docker config**

          Sign in to the Docker CLI and copy the contents of the docker config JSON. Note that external credential stores and multiple repositories within the same config object are not supported. For more information, see [https://docs.docker.com/engine/reference/commandline/login/](https://docs.docker.com/engine/reference/commandline/login/).

=== "GHCR"
    **GitHub Container Registry**

    Recommended authentication option:

    * **Basic authentication using a PAT token**

          Create a personal access token (PAT) and use it in place of the password. You cannot use your own GitHub password. You must provide a [PAT token](https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry#authenticating-with-a-personal-access-token-classicn).
  
## Step 2: Create a component in Choreo

1. In the left navigation, click **Overview** and select your project. Alternatively, select your project from the **Project** list in the Choreo Console header. 
2. Under **Component Listing** click **+ Create**.
3. Select your component type (BYOI is only available for Service, Web Application, Scheduled Task, or Manual Task components). 
4. From the Create Component pane, select the **Container Registry** under the **Connect a Docker Image** section.
5. Under **Deploy an image from Container Registry/Docker Hub**, select the container registry you have registered in [Step 1](#step-1-register-a-container-registry).
6. Enter the full image URL. The image URL format in general is as follows:
   `[container-registry-host]/[repository-name]/[image-name]:[tag]`

    !!! tip
        When a public image from Docker Hub lacks a specified repository name, it typically defaults to `/library/`. For example, you can access the public Nginx image `https://hub.docker.com/_/nginx` as `registry.hub.docker.com/library/nginx:1.25`.

7. Enter a display name, a unique name, and a description for the component.
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.


## Step 3: Deploy the component in Choreo

To deploy the component and bring your image to Choreo, follow the steps given below: 

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Update Image & Deploy**. 
3. In the **Endpoint** pane that opens, you can see the endpoint ready to be deployed. Click the edit icon next to the endpoint name. Optionally, you can define the endpoints for your service when you manually deploy the service. For more information, see [Expose service endpoints](#step-4-expose-service-endpoints).
4. Change the **Network Visibility** to **Public**. This setting securely exposes the endpoint for consumption.
5. Click **Update**.

    !!! info
         In this example, you deploy a Ballerina service as a REST endpoint. Therefore, Choreo generated the REST endpoint automatically. If you deploy a non-Ballerina service, you must manually add the REST endpoint and set the network visibility to **Public**.

6. Select your update image option. Refer to the update options listed below.

    You have the capability of updating the image when you are deploying the component in Choreo in one of the following three ways:

    | Option                   |Description                                                                                             |
    |--------------------------|--------------------------------------------------------------------------------------------------------|
    | **Update Image Tag**     | This option allows you to update the tag of the image.                                                 |
    | **Update Image URL**     | With this option, you can change the image name, tag, and the image repository of the image URL.|
    | **Previous Images**      | This option allows you to select a previous image and redeploy the image.                               |

7. Click **Deploy**. This deploys the service to the development environment.

## Step 4: Expose service endpoints 

!!! info
    This section only applies to service components.

After creating a service component in Choreo, you have the option to define the endpoints for your service when manually deploying a new image.

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Update Image & Deploy**. 
3. In the **Endpoint** pane that opens, optionally, you can define the endpoints for your service when you manually deploy the service. 
4. Click  **Create/Update Endpoints**.
5. Under the **Edit endpoints.yaml** section, you can edit the endpoints YAML file in the provided editor. 
   Alternatively, you can upload the associated API specification/schema files (OpenAPI/GraphQL schemas). Instead of specifying the file path, you can also reference this file in the `endpoints.yaml` file by its file name, similar to the Git-based Choreo components. The endpoints template follows the standard definitions for defining endpoints in Choreo. For more details, see [Configure Endpoints](../develop-components/configure-endpoints.md).

## Auto-deploy images in Choreo with an external CI/build pipeline

Choreo does not have automatic detection and deployment for newly added images or tags in the linked container registry. To overcome this limitation, Choreo allows you to integrate your own CI pipelines and initiate deployments manually. This approach enables you to use your existing CI setup or build a pipeline for image creation and pushing. You can then trigger automatic deployments using a webhook.

Follow the steps below to configure your CI/build pipeline:

1. Build and push the container image associated with a Choreo component to your container registry.
2. In the left navigation menu, click **DevOps** and then click **External CI**.
3. Generate a token for your CI pipeline from the **Manage Tokens** section. 

    !!! note
        - The tokens are bound to a specific component.
        - It is recommended to reference the token from a secure location available to your CI pipeline. For example, use a GitHub secret if you are using GitHub Actions.

4. To trigger an automatic deployment to your development environment, you can initiate an HTTP POST request to the Choreo webhook endpoint with the updated image details. Alternatively, you can use the provided Webhook snippets. This action will seamlessly deploy the image to the development environment.



Services and integrations are exposed to other services, integrations, or applications through endpoints. A service or an integration can expose multiple endpoints, each representing a unique entry point into the service. For example, a service may expose a REST API endpoint and a GraphQL endpoint, each providing different ways to interact with the service. Endpoints provide specific details for how the service or the integration can be consumed. For instance, the port number, protocol, and the schema such as open API specification (OAS) or GraphQL schema. By defining these details, endpoints make it possible for other services, integrations, and applications to discover and interact with the service in a standardized way.

Choreo defines endpoints by combining port binding, protocol, endpoint name, network visibility, endpoint schema, and additional protocol-related fields. The following table describes each attribute of an endpoint.

| Field | Description |
| ----- | ----------- |
| Name | A unique identifier for the endpoint within the service component. |
| Port | The network port on which the endpoint is accessible. |
| Type | The endpoint protocol. Supported protocols: REST, GraphQL, gRPC, WS, UDP, and TCP. |
| Network Visibility | Determines the level of visibility of an endpoint. Possible values are: <ul><li>Project: Allows components within the same project to access the endpoint.</li><li>Organization: Allows any component within the same organization to access the endpoint but restricts access to components outside the organization.</li><li>Public: Allows any client to access the endpoint, regardless of location or organization.</li></ul> |
| Schema | Specifies the structure and format of the data exchanged through the endpoint. |
| Context (HTTP and GraphQL only) | A context path that you add to the endpoint's URL for routing purposes. |

## Configure endpoints
The method of defining endpoints depends on the buildpack.

* For `Ballerina` and `WSO2 MI` buildpacks, Choreo automatically detects the endpoint details for REST APIs.
* For all other buildpacks (Java, Python, NodeJS, Ruby, PHP, Go, Dockerfile, etc.), you can configure endpoints in one of the following ways:
  
    * **Using the Choreo Console**: If a `component.yaml` file is not present, you can define a basic endpoint configuration during component creation.
    * **Using the component.yaml file**: You can manually configure endpoint details by defining them in a `component.yaml` file, placing it inside the `.choreo` directory at the build context path, and committing it to the source repository.

You can override UI-defined and auto-generated endpoints by providing a `component.yaml` file in the `.choreo` directory, which will take priority over other configurations.

To learn about the `component.yaml` file, see [Overview of the component.yaml file](../develop-components/manage-component-source-configurations.md#overview-of-the-componentyaml-file).
!!! note
    Automatic endpoint generation is not supported for dynamic endpoint parameters such as variable ports. Therefore, you must use an `component.yaml` file to define dynamic endpoint parameters.

To learn about the `component.yaml` file, see [Overview of the component.yaml file](../develop-components/manage-component-source-configurations.md#overview-of-the-componentyaml-file).

## Expose endpoints as managed APIs

Exposing endpoints as managed APIs is crucial to ensure secure and controlled access to the services being exposed. When a user wants to expose their written service to the outside world or to the organization at large, there is an inherent security risk involved. To mitigate this risk, the Choreo platform is built with an internal (access within the organization only) or external (publicly accessible) gateway that is protected with Choreo API management making the services secure by design.

!!! note
    This feature is not available for gRPC, UDP, and TCP endpoints.

If you want to expose an endpoint as a managed API in Choreo, you need to set the network visibility to either Organization or Public. This allows the endpoint to be exposed through the Choreo API Gateway, which provides a number of benefits, including:

* Expose APIs to external and internal consumers
* Full lifecycle API Management
* API throttling
* Secure APIs with industry-standard authorization flows
* API analytics and monitoring

Once you deploy the service component, Choreo will expose the endpoint as a managed API through the Choreo API Gateway. You can then use the full lifecycle API management features provided by Choreo to test, deploy, maintain, monitor, and manage your API using the API management features.

## Understand the default component URL

The default URL of a component corresponds to the default endpoint of the component and is structured as follows:

`<domain>/<project-name>/<component-name>`

This URL does not include the default endpoint name. For all other endpoints, the URL structure includes the endpoint name, as follows:

`<domain>/<project-name>/<component-name>/<endpoint-name>`

If a component has multiple endpoints, Choreo allows you to change the endpoint corresponding to the default component URL. For a component with a single endpoint, the default URL automatically corresponds to that endpoint.

### Change the default endpoint of a component

To change the default endpoint of a component, follow the steps given below:

!!! note
     - You cannot change the default endpoint if it has associated published APIs. You must go to the **Lifecycle** page and unpublish the relevant APIs before updating the default endpoint. For instructions on unpublishing an API, see [Lifecycle Management](https://wso2.com/choreo/docs/api-management/lifecycle-management/).
     - Choreo does not allow you to change the default endpoint of a component if you create multiple deployment tracks within its current major version, or promote the component beyond its initial environment.

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to change the default endpoint.
3. In the left navigation menu, click **Deploy**.
4. On the **Deploy** page, go to the **Set Up** card and click **Configure & Deploy**.
5. In the **Environment Configurations** pane that opens, click **Next**.
6. In the **File Mount** pane that opens, click **Next**.
7. In the **Endpoint Details** pane that opens, click the **Default Endpoint** list, select the endpoint you want to set as the default endpoint, and then click **Update**.
8. Click **Deploy**. This deploys the component with the selected endpoint as the default, and the default URL will now correspond to this endpoint.  

### Edit a UI-Defined Endpoint
If you defined an endpoint during component creation, you can edit it later by following these steps:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to update the endpoint.
3. In the left navigation menu, click **Deploy**.
4. On the **Deploy** page, go to the **Set Up** card and click **Configure & Deploy**.
5. In the **Environment Configurations** pane that opens, click **Next**.
6. In the **File Mount** pane that opens, click **Next**.
7. In the **Endpoint Details** pane that opens, locate the endpoint you want to edit.
8. Click the **Edit** icon next to the endpoint, modify the editable fields, and click **Update**.
9. Click **Deploy** to apply the changes.

!!! note
     If you commit a `component.yaml` file, build the component, and proceed with deployment, the endpoints will be generated from the `component.yaml` file and will take priority. In this case, the endpoint cannot be edited through the UI. To modify the endpoint, you must update the`component.yaml` file.


# Configure Endpoints
{% include "configure-endpoints-body.md" %}

# Deploy a Containerized Application 

Using Choreo, you can easily deploy applications written in different language frameworks (such as Java, Go, NodeJS, Python, etc.) on shared or private data planes using containers.

Choreo supports deploying containerized applications for the following component types:

- Service
- Web Application
- Scheduled Task
- Manual Task
- Event Handler
- Test Runner

## Connect your repository to Choreo

To connect your GitHub repository to Choreo, you should authorize the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application to access your account or organization. When you attempt to connect your GitHub repository via the Component creation page, the Choreo Apps authorization prompt will appear.

* Connect GitHub Repository
    
    ![Connect GitHub Repository](../assets/img/develop-components/deploy/create-component-authz-github-page.png){.cInlineImage-threeQuarter}

* Authorize GitHub Application
    
    ![Authorize GitHub Application](../assets/img/develop-components/deploy/authz-choreo-github-app.png){.cInlineImage-half}

* Grant Repository Access

    ![Grant Repository Access](../assets/img/develop-components/deploy/github-repo-access.png){.cInlineImage-full}


    The **Choreo Apps** requires the following permission:
    
    - Read access to issues and metadata
    - Read and write access to code, pull requests, and repository hooks

!!! note
    You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. Choreo needs write access only to send pull requests to a user repository. Choreo does not directly push any changes to a repository.

Alternatively, you can connect a public repository without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. Select the **Third-Party GitHub Repository** and paste a public repository URL in the **Public Repository URL** field at the time of component creation.

!!! tip
     Authorizing the repository with the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application becomes essential if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component. If you own the repository, you can subsequently authorize it with the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application to enable **Auto Deploy**.

After granting access to the required repositories, you can choose a repository and an associated branch to connect to the Choreo component.
For the containerized application deployments, you should select the [**Component Directory**](https://docs.docker.com/build/building/context/#path-context), **Dockerfile** as the **Buildpack** and provide **Dockerfile Path** for the Docker build.

![Connected Dockerfile Repository](../assets/img/develop-components/deploy/create-component-connected-repo.png){.cInlineImage-full}

The following table describes the individual fields in the **Create Component** pane.

| **Field**               | **Description**                                                                                                                                                                      |
|-------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **GitHub Account**      | Your GitHub account or organization. If you want to add another GitHub account, you can expand the list and click **+ Add**.                                                            |
| **GitHub Repository**   | Depending on the repository access you provided, the list will show available repositories to be connected.                                                                                  |
| **Branch**              | The branch of the repository.                                                                                                                                                         |
| **Buildpack**        | Determines the implementation of the component: Any language or other language as a Docker container.                                                                                |
| **Dockerfile Path**     | The path to your Dockerfile. This path is defined relative to the repository root.<br/>For example, if the Dockerfile is at the repository root, the value for this field is `/Dockerfile`. |
| **Component Directory** | The component directory path. To include the repository root, leave the default `/` value.                                                                                          |
| **Port***               | The port at which your service is running.                                                                                                                                           |
| **OpenAPI Filepath***   | The path to an OpenAPI specification (in YAML/JSON) relative to the repository root. If you don't provide a path, the system automatically generates a default allow-all specification.    |

   
!!! note
 
    - Fields marked with **\*** are not visible for all component types.

    - To successfully build your container with Choreo, it is essential to explicitly define a User ID (`UID`) under the `USER` instruction in your Dockerfile. You can refer to the [sample Dockerfile](https://github.com/wso2/choreo-sample-apps/blob/main/go/rest-api/Dockerfile) for guidance.

    - To ensure that the defined USER instruction is valid, it must conform to the following conditions:
        
        - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
        - Usernames are not considered valid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

## Deploy the containerized component

Choreo will automatically apply deployment configurations and settings based on the component type you select during creation.
For example, if you select the **Service** component type, Choreo will deploy it as a Kubernetes deployment with appropriate scaling configurations.

You can run unit tests in the build pipeline by adding the relevant command to the Dockerfile.  For example: 

- [Go-based sample](https://github.com/wso2/choreo-sample-apps/blob/8c18c82db604adb43b89f669888a07cd6e31d7b7/go/rest-api/Dockerfile#L37)
- [Python-based sample](https://github.com/wso2/choreo-sample-apps/blob/8c18c82db604adb43b89f669888a07cd6e31d7b7/python/rest-api/Dockerfile#L15)

### Application configurations

You must provide any required configurations for running the application in the **Configs & Secrets** section of the component's **DevOps** page. Alternatively, you can also review the configurations when you manually deploy via the **Deploy** page.

After clicking the **Create** button, you can select the confidentiality of the configuration and specify how to mount it to the container.

![Application Configuration Page](../assets/img/develop-components/deploy/deploy-app-config-page.png){.cInlineImage-full}

![Create Configuration Mount Page](../assets/img/develop-components/deploy/deploy-app-config-type-mount-page.png){.cInlineImage-full}

#### Configuration types

* **ConfigMap**: Stores non-confidential data as key-value pairs.
* **Secret**: Stores and manages sensitive information, such as passwords, OAuth tokens, and ssh keys as key-value pairs.

#### Mount types

* **Environment Variables**: Mounts the selected ConfigMap or Secret as an environment variable in the container.
* **File Mount**: Mounts the selected ConfigMap or Secret as a file in the container. Here, the key is the file name, and the value is the file content.

The following image shows adding a **ConfigMap** with **File Mount** mount type to be read by the application.

![Configuration File Mount Page](../assets/img/develop-components/deploy/deploy-app-config-file-mount.png){.cInlineImage-full}

!!! note
    The JSON file includes ${DB_PASS} as an environment variable defined in a Secret. The application reads the JSON file and substitutes the placeholders with the corresponding environment variables.

### Deployment configurations

Choreo lets you configure deployment settings such as scaling, resource limits, and health checks based on your selected component type.

For more information about these configurations, see Choreo's [DevOps capabilities](../devops-and-ci-cd/view-runtime-details.md).

You can configure the **Endpoints** to expose your service using the **Service** Component in Choreo. See [Service Component Overview](../develop-components/develop-services/service-component-overview.md) for more information. 

### Build, deploy, and promote

After adding the application configuration, you can build and deploy it by clicking the **Deploy Manually** button. Choreo will start the build process with the selected commit in the **Build Area**. 

!!! note
    The **Auto Deploy on Commit** feature, which automatically builds and deploys the application upon pushing a code change to the repository, is enabled by default. To turn off this feature, navigate to the **Build Area** of the **Deploy** page.

Choreo scans your Dockerfile for security vulnerabilities during the build phase, and if there are no issues found, it proceeds with the build process. After building the image, it scans it again for vulnerabilities before deployment to the environment. You can view the build logs from the right-side panel, as shown in the image below.

![Build Logs Panel](../assets/img/develop-components/deploy/build-deploy-page-logs.png){.cInlineImage-full}

Once the build process is complete, Choreo will deploy the application automatically to the Development environment. To promote the build to higher environments, you can click the **Promote** button. The number of environment cards visible on the page may vary depending on your environment configurations.

### Troubleshoot security vulnerability scan failures (Trivy)

By default, Choreo utilizes the Aqua Trivy (OSS) image vulnerability scanner to detect security vulnerabilities in all Dockerfile-based build pipelines. The scanner will fail the pipeline if any **CRITICAL** CVEs (Common Vulnerabilities and Exposures) are detected. CVEs of other severity levels are recorded but does not fail the pipeline.

If you cannot fix a critical CVE immediately, you can opt to ignore it. To ignore a critical CVE, add a `trivyignore` (`<docker-build-context-path>/.trivyignore`) file to your build context path. In the file, add the CVEs you need the pipeline to ignore, one entry per line as follows:

```
CVE-2023-xxxx
CVE-2023-yyyy
```

You can add comments in the file by using `#` in front of the comment as follows: 

```
# comments can be added like this
CVE-2023-xxxx
```


# Deploy an Application with Buildpacks

Using Choreo, you can easily deploy applications written in different language frameworks (such as Java, Go, NodeJS, Python, Ruby, PHP, etc.) on shared or private data planes.

Choreo supports deploying applications with buildpacks for the following component types:

- Service
- Web Application
- Scheduled Task
- Manual Task
- Webhook
- Event Handler
- Test Runner

## Buildpacks
Buildpacks are a fundamental building block in modern application development. They convert your source code into a secure, efficient, production-ready container image without a Dockerfile. With Choreo, developers can take advantage of this powerful tool to effortlessly deploy their applications without the hassle of manual configuration.

Choreo uses [Google Buildpacks](https://cloud.google.com/docs/buildpacks/overview) as default buildpacks for Java, Go, NodeJS, Python, PHP, and Ruby. Choreo uses its own buildpacks for Ballerina and WSO2 MI.

## Develop a component

To develop a service component that exposes a Service in Go, you can follow the [Develop a Service ](develop-services/develop-a-service.md) guide.

Follow the guidelines below based on your language:

=== "Python"
    Supported Versions - 3.10.x, 3.11.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Reading Books List Service](https://github.com/wso2/choreo-samples/tree/main/reading-books-list-service-python)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-python-task)|

    ### Procfile
    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    
    !!! info 
        In **Python** projects, it is mandatory to have a `Procfile` with the `web` process type in the project root directory.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: python main.py` <br>
    `web: gunicorn --bind :8080 --workers 1 --threads 8 --timeout 0 main:app` <br>
    `web: flask run --host=0.0.0.0`

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Ballerina"

    Supported Versions - 2201.3.5, 2201.4.1, 2201.5.0, 2201.5.1, 201.6.0,  2201.7.0

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Echo Service](https://github.com/wso2/choreo-samples/tree/main/echo-service)|
    | Manual Task | [Covid19 Statistics To Email](https://github.com/wso2/choreo-samples/tree/main//covid19-statistics-to-email)|
    | Webhook | [Salesforce New Case To Google Sheet](https://github.com/wso2/choreo-samples/tree/main/sfdc-new-case-to-gsheet)|
    | Scheduled Task | [Shopify New Customers to HubSpot Create/Update Contact](https://github.com/wso2/choreo-samples/tree/main/shopify-new-customers-to-hubspot-contact)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Go"

    Supported Versions - 1.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Greeting Service](https://github.com/wso2/choreo-samples/tree/main/greeting-service-go)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-go-task)|
    | Web Application | [Hello World Web Application](https://github.com/wso2/choreo-samples/tree/main/hello-world-go-webapp)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== ".NET"
    Supported Versions - 6.x, 7.x, 8.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service | [Greeting Service](https://github.com/wso2/choreo-samples/tree/main/dotnet-greeter)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Java"
    Supported Versions
        - 8, 11, 17, 18 (OpenJDK Runtime Environment Temurin)

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Product Management Service](https://github.com/wso2/choreo-samples/tree/main/product-management-service)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-java-task)|

    !!! info

         When working on Java projects:

           - The `Main` class should be defined in the manifest file.
           - If Maven files such as `mvn.cmd` exist in the project without the `.mvn` directory, the build will fail. To ensure a successful build, you must either commit the `.mvn` directory along with any Maven files or not include any Maven files in the project if you choose not to commit the `.mvn` directory.
    
    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **Java** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: java -jar target/sample.jar` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "NodeJS"
    Supported Versions - 12.x.x, 14.x.x, 16.x.x, 18.x.x, 20.x.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Reading Books List Service](https://github.com/wso2/choreo-samples/tree/main/reading-books-list-service-nodejs)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-nodejs-task)|

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **NodeJS** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: node app.js` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "PHP"
    Supported Versions - 8.1.x, 8.2.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Hello World Service](https://github.com/wso2/choreo-samples/tree/main/hello-world-php-service)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-php-task)|
    | Web Application | [Hello World Web Application](https://github.com/wso2/choreo-samples/tree/main/hello-world-php-webapp)|

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **PHP** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web:php -S 0.0.0.0:8000 index.php` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Ruby"
    Supported Versions - 3.1.x, 3.2.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service | [Hello World Service](https://github.com/wso2/choreo-samples/tree/main/hello-world-ruby-service)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-ruby-task)|
    | Web Application | [Hello World Web Application](https://github.com/wso2/choreo-samples/tree/main/hello-world-ruby-webapp)|

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **Ruby** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: ruby app.rb` <br>
    `web:bundle exec ruby app.rb -p 8080` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "WSO2 MI"
    Supported Versions - 4.1.0.x, 4.2.0.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service |[Hello World Service](https://github.com/wso2/choreo-samples/tree/main/hello-world-mi)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Spring Boot"
    Supported Java Versions
        - 8, 11, 17, 18 (OpenJDK Runtime Environment Temurin)

    !!! info
         You can use this buildpack only with web applications. For other component types, use the **Java** buildpack. Additionally, if the generated artifact is a `WAR` file, it is necessary to include a **Procfile**.

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **Java** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: java -jar target/sample.war` <br>

### Configure build-time environment variables

You can configure the environment variables necessary to build the component using the **Build Configurations Editor** on the component **Build** page. 

!!! info
    The capability to configure build-time environment variables is not available for components created using **Ballerina** or **WSO2 MI** buildpacks.

During the build process, the build-time environment variables and their values are passed to the buildpack. Therefore, you can configure both buildpack-specific environment variables and those required for the component build.

For example, if you want to override the Maven command of the **Java** buildpack, you can use `GOOGLE_MAVEN_BUILD_ARGS` as the environment key and `clean install` as the value. 

For more examples, see [Google Cloud's buildpacks documentation](https://cloud.google.com/docs/buildpacks/service-specific-configs).


# Develop a Webhook

Choreo allows developers to design high-quality webhooks. To explore this capability, let's consider a scenario where a team of software engineers in an organization should be notified via email whenever someone creates a GitHub issue with the `bug` label in a specific repository.

In this tutorial, you will address the requirement by doing the following:

- Create a webhook by connecting to a forked GitHub repository where you have the webhook implementation that addresses the described requirement.
- Deploy the webhook to the development environment.
- Modify the webhook implementation to connect the webhook to GitHub, enabling it to act in response to selected GitHub-related events.
- Test the webhook.
- Promote the webhook to the production environment.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

## Step 1: Create a webhook component

To create a Webhook component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Webhook** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following information:

    | **Field**                     | **Description**    |
    |-------------------------------|--------------------|
    | **GitHub Account**            | Your account       |
    | **GitHub Repository**         | choreo-samples     |
    | **Branch**                    | main               |
    | **Component Path**              | `github-event-to-email-webhook` |

6. Select **Ballerina** as the build pack.
7. Provide a display name, a unique name and description for the component.
8. Click **Create**.

Choreo creates the Webhook component with the sample implementation and opens the component **Overview** page.

## Step 2: Deploy

To deploy the webhook to the development environment, follow these steps:

1. In the Choreo Console left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**.
3. In the **Configurations** pane, enter the following information:
    1. In the **webhookSecret** field, enter any value.

        !!! note
            Save this value for later use.

    2. In the **toEmail** field, enter the email address to send notification emails.
    3. Click **Deploy**.

    You can monitor the deployment progress in the **Console** pane that opens on the right of the page.

Once Choreo completes the deployment, the **Development** card indicates the **Deployment Status** as **Active**.

!!! note
    In the deployment card, you can click the icon corresponding to configurables to open the **Configurations** pane and edit configurations.

## Step 3: Connect the webhook to the GitHub repository

To allow the webhook to read the labels of issues in a specific GitHub repository, connect the webhook to the GitHub repository:

1. In the Choreo Console left navigation menu, click **Overview**.
2. On the **Overview** page, copy the invoke URL by clicking the copy icon within the **URL** field.
3. Go to your GitHub account and open the repository for which you want to generate notification emails.
4. In the top menu, click the **Settings** tab.
5. In the left navigation menu, click **Webhooks**.
6. Click **Add webhook** and enter the following information:

    | **Field**        | **Value**                                                          |
    |------------------|--------------------------------------------------------------------|
    | **Payload URL**  | The invoke URL you copied in Step 3, sub-step 1.                   |
    | **Content Type** | Select `application/json`                                          |
    | **Secret**       | The last webhook secret you configured in [Step 2](#step-2-deploy).| 

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Project Path** specifies the location of the project to build the component.

7. Under **Which events would you like to trigger this webhook?**, select **Let me select individual events**.
8. Select the **Issues** checkbox in the list of events displayed. This ensures that GitHub issues trigger the webhook.
9. Clear the **Pushes** checkbox to ensure that GitHub does not trigger your webhook when the team pushes changes to the selected GitHub repository.
10. Click **Add webhook** to save the configuration.

Now you have integrated Choreo with GitHub via the webhook you created and deployed. You can proceed to test the webhook.

## Step 4: Test

To test your webhook, create a GitHub issue with the `Bug` label in the repository that you connected to the webhook. You will receive an email similar to the following at the email address you provided in [Step 2](#step-2-deploy).

## Step 5: Promote

To promote the webhook to the Production environment, follow these steps:

1. On the **Deploy** page, go to the **Development** card and click **Promote**.
2. In the **Configuration Types** pane, leave the default selection (i.e., **Use default configuration values**) unchanged.

    !!! note
        If you have configured any default values for the configurable variables, selecting **Use default configuration values** allows you to proceed with those values. If not, specify values for the configurable variables.

3. Click **Next**.
4. In the **webhookSecret** field, enter any value.

    !!! note
        Save this value for later use.

5. In the **toEmail** field, enter the email address to send notification emails.
6. Click **Promote**.

    Once the component is promoted to production, the **Production** card displays the deployment status as **Active**.

Now you have successfully created, deployed, and tested a Webhook component and promoted it to production.


# Develop an External Consumer

An external consumer in Choreo is any client that can interact with services deployed in Choreo, as an entity hosted outside of the Choreo infrastructure. It is a generic component type that allows you to represent and manage any client, such as a mobile application, web application, server-to-server integration, bot, microservices, etc.

In this guide, you will:

 - Create an external consumer component.
 - Manage authentication for the external consumer.
 - Connect the external consumer to a service deployed in Choreo.
 
## Prerequisites

Before you try out this guide, complete the following steps:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

## Step 1: Create an external consumer component
 
To create an external consumer component, follow the steps given below:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **External Consumer** card. 
4. In the **Create an External Consumer** pane that opens, enter a display name, a unique name, and a description for the component.
5. Click **Create**. This creates the component and takes you to its **Overview** page.
   
## Step 2: Manage authentication for the external consumer

You can configure the external consumer to work with the Choreo built-in identity provider or any external identity provider that supports OIDC/OAuth 2.0.

Click the respective tab for details depending on the identity provider you want to configure: 

=== "Choreo built-in identity provider"

     Follow the steps given below to configure the built-in identity provider by generating authentication keys:

    !!! note
         Choreo built-in identity provider is configured by default. Therefore, this step is optional.

     1. In the **Overview** page of the component, under **Authentication Configurations**, click **Configure** corresponding to the environment for which you want to configure an identity provider.
     2. In the **Identity Provider** list, select **Choreo Built-In Identity Provider**.
     3. Click **Generate Keys**. 

        !!! Note
             If you see **Regenerate Secret** instead of **Generate Keys**, it indicates that OAuth keys are already generated for the component in the selected environment.

=== "An external identity provider"

     **Step 2.1: Create and configure an OIDC/OAuth 2.0 application in the external identity provider**

     1. Create an OIDC/OAuth 2.0 application in your external identity provider.
     2. Configure the OIDC/OAuth 2.0 application accordingly. (The access token type should be configured as JWT)

     **Step 2.2: Link the OIDC/OAuth 2.0 application to the Choreo component**

     3. In the **Overview** page of the component, under **Authentication Configurations**, click **Configure** corresponding to the environment for which you want to configure an identity provider.
     4. In the **Identity Provider** list, select your identity provider.
     5. Paste the **Client ID** of the OIDC/OAuth 2.0 application you created in your external identity provider.
     6. Click **Add Keys**.

## Step 3: Connect the external consumer to a service deployed in Choreo 

To establish connections from the external consumer to services deployed in Choreo, you can create connections. For step-by-step instructions on creating a connection, see [Create a Connection](./sharing-and-reusing/create-a-connection.md).


# Develop Components Using VS Code

The [Choreo VS Code extension](https://marketplace.visualstudio.com/items?itemName=WSO2.choreo) provides comprehensive component management capabilities to streamline local development within Choreo.

## Prerequisites

To ensure a smooth development experience with the Choreo extension, make sure you have the following:

1. [Visual Studio Code](https://code.visualstudio.com/download) installed with the [Choreo extension](https://marketplace.visualstudio.com/items?itemName=WSO2.choreo) version **2.0.0** or later.

2. A locally cloned GitHub repository to create new components or link to existing Choreo components.

3. [Git](https://git-scm.com) version 2.0.0 or later.

## Get started

To use the capabilities of the Choreo extension in the VS Code editor, you need an active [Choreo account](https://wso2.com/choreo/pricing/). If you already have an account, follow these steps to set up the extension:

1. Install the [Choreo VS Code extension](https://marketplace.visualstudio.com/items?itemName=WSO2.choreo) and wait for activation. On successful activation, the Choreo extension opens in the VS Code editor. 
2. Sign in to Choreo using one of the following methods:
    - In the Choreo activity pane, click **Sign In**.
       ![Sign in](../assets/img/develop-components/develop-using-vs-code/sign-in.png)
    - Use the `Sign In` command provided by the Choreo extension.

    This redirects you to an external URI to complete the authentication process. On successful sign-in, the Choreo activity pane displays your account details along with any components detected within the VS Code workspace.

## Create a new component

1. Open the source code directory where you want to build, deploy, and manage components using Choreo.
2. Create a new component using one of the following methods:
    - In the Choreo activity pane, click **Create Component**.
       ![Create Component Button](../assets/img/develop-components/develop-using-vs-code/create-component-btn.png)
    - Use the `Create New Component` command provided by the Choreo extension.

3. If the Choreo extension cannot determine the project context of the opened workspace, it prompts you to select the organization and the project to which the new component belongs.
4. Specify component details such as the name, type, buildpack, etc.

    ![Component Form](../assets/img/develop-components/develop-using-vs-code/component-form.png)
            
    On successful creation, the component details view opens, and the Choreo activity pane displays the new component.

    ![Component Details](../assets/img/develop-components/develop-using-vs-code/component-details-view.png)
     
    !!! tip
        Once the component is created, a `.choreo/context.yaml` file is generated in the root of the Git repository. For more details, see [Understand the project context](#understand-the-project-context).

The component details view allows you to manage your component by performing various actions such as the following:

 - Triggering builds for selected commits.
 - Viewing lists of builds and statuses.
 - Diagnosing build failures with build logs.
 - Deploying builds in available environments.
 - Accessing runtime logs and deployed component URLs.
 - Invoking deployed service endpoints.

## Understand the project context

Context files contain metadata related to the project, allowing the extension to establish an association between local directories and Choreo projects. These files, such as the `context.yaml`file, resides in the `/.choreo` directory within the root of the Git repository.

The Choreo extension scans the root of the opened Git repository to find the `context.yaml` file and lists the components of the associated project. This allows you to easily open and manage the components they are developing within the VS Code workspace.

A `context.yaml` file can contain multiple projects, whereas, a workspace opened via VS Code can have multiple `context.yaml` files with different project associations. In such cases, VS Code allows you to switch between these projects, add new project associations, or remove existing ones, allowing you as a developer to focus on components of a particular project at a time.

You can decide whether to commit the `context.yaml` file to the Git repository. Committing this file enables other team members working on the same repository to have a seamless developer experience with Choreo.

If the `context.yaml` file for a particular project is not committed to the Git repository or is unavailable for other reasons, you can easily regenerate it using one of the following methods:

 - In the Choreo activity pane, click **Link Directory**.
    ![Link Directory](../assets/img/develop-components/develop-using-vs-code/link-dir-btn.png)
 - Use the `Link Directory` command provided by the Choreo extension.

## Discover additional features

To access a range of functionalities provided by the Choreo extension, open the VS Code command palette and type `Choreo`.

## Troubleshoot issues

To troubleshoot Choreo extension issues, follow these steps:

1. To open the **OUTPUT** pane, go to the VS Code editor main menu, click **View**, and then click **Output**.

2. Select **Choreo** from the drop-down menu on the right-hand side to view the Choreo output for troubleshooting.

## Get help

For assistance with the Choreo VS Code extension, create [GitHub issues](https://github.com/wso2/choreo-vscode/issues).


# Develop Components With Git

Choreo enables you to develop components by connecting your GitHub, Bitbucket, or GitLab repository. You have the flexibility to either connect an existing repository or start with an empty repository and commit the source code later. By integrating your repositories with Choreo, you can automate tasks and optimize workflows across multiple systems, all within the Choreo platform.  Choreo currently supports GitHub, Bitbucket, and GitLab as Git providers. 

!!! tip
    Choreo supports both Bitbucket Server and Bitbucket Cloud. The currently supported Bitbucket Server version is 8.9.2.

In Choreo, you can connect a Git repository that contains Ballerina source code or a Docker project. To connect a Git repository to Choreo as a Docker project, your Git repository must include the following:

 - A Dockerfile: Specifies the instructions to build the Docker image. 
 - A build context: A set of files in the specified path used to build the image.

Once you connect your Git repository to Choreo, you can build, deploy, and manage your application easily. 

## Connect a Git repository to Choreo

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the Choreo Console header, go to the **Organization** list and select your organization. 
3. In the left navigation menu, click **Settings**. This opens the organization-level settings page. 
4. Click the **Credentials** tab. 
5. Click **+Add Credentials** to configure the Git repository connection.
6. Enter a **Credential Name**, select the Git provider, and enter the **Personal Access Token** you obtained from the Git provider.
7. Click **Save**.  

## Authorize GitHub with Choreo 

Authorizing Choreo as a GitHub application grants Choreo the following permissions to perform the respective actions on your behalf within the repository:

|Permission   | Read| Write| Description                                                           |
|-------------|-----|------|-----------------------------------------------------------------------|
|Issues       | Y   | N    | Read component ID label to filter the pull requests                   |
|Metadata     | Y   | N    | List repositories                                                     |
|Contents     | Y   | Y    | List branches and create a branch to commit sample code               |
|Pull Request | Y   | Y    | Create a pull request if you start with a Choreo sample               |
|Webhooks     | Y   | Y    | Trigger automatic deployment and configuration generation             |

### Add Git submodules to a project

Choreo provides [Git submodule](https://git-scm.com/book/en/v2/Git-Tools-Submodules) support when you connect your GitHub repository to Choreo. This allows you to manage and include external repositories effectively within Choreo build pipelines. Key benefits of this capability include:

  - **Code sharing without duplication**: Use submodules to maintain shared libraries across multiple projects, ensuring a single source of truth.
  - **Efficient third-party library management**: Manage third-party libraries as submodules to update them independently and track changes easily, avoiding direct code integration.

For example, when you [work with the Micro Integrator (MI) runtime in Choreo](./work-with-the-micro-integrator-runtime-in-choreo.md), you can use Git submodules to reuse MI templates and sequences across components without duplication.

!!! info "Note" 
    If you encounter an error stating that you cannot clone a submodule due to insufficient permissions, follow the instructions below to grant the necessary permissions:

      - For a personal account:

         1. Sign in to your personal GitHub account.
         2. In the upper-right corner, click your profile picture, and then click **Settings**.
         3. In the left navigation menu, go to the **Integrations** section and click **Applications**.
         4. Under the **Installed GitHub Apps** tab, click **Configure** corresponding to **choreo.dev**.
         5. Under **Repository Access**, grant access to the necessary repositories.

      - For an organization account:

         1. Sign in to your organization's GitHub account.
         2. In the upper-right corner, click your profile picture, and then click **Settings**.
         3. In the left navigation menu, go to the **Third-Party Access** section and click **GitHub Apps**.
         4. Click **Configure** corresponding to **choreo.dev**.
         5. Under **Repository Access**, grant access to the necessary repositories.

            !!! note
                Choreo currently does not support accessing private repositories in other organizations.

#### Automatically pull latest versions of Git submodules

Choreo lets you automatically pull the latest versions of Git submodules from their respective repositories. To enable this feature, follow these steps:

!!! note 
    Choreo currently supports this feature only for components where the buildpack is **WSO2 MI**.

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click the component for which you want to pull the latest versions of Git submodules.
3. In the left navigation menu, click **Build**.
4. On the **Build** page, click to edit **Build Configurations**.
5. Turn on the **Pull Latest Submodules** toggle.

    !!! info "Note"
        If you rebuild a previously built commit and it doesn’t reflect the latest changes, follow these steps to ensure the changes are applied to the deployed environment:

         1. In the Choreo Console left navigation menu, click **DevOps**, then click **Containers**.
         2. Click **Edit** to update the container settings.
         3. Select **Always** as the **Image Pull Policy**.
         4. Click **Save Changes**.

## Authorize Bitbucket with Choreo

Authorizing using a personal access token (PAT) from Bitbucket grants Choreo the following permissions to perform the respective actions on your behalf within the repository.

|Permission    | Read| Write| Description                                                        |
|--------------|-----|------|--------------------------------------------------------------------|
|Account       | Y   | N    | Get user information and workspace details                         |
|Repositories  | Y   | Y    | List branches and create a branch to commit sample code            |
|Pull Requests | Y   | Y    | Create a pull request if you start with a Choreo sample            |
|Webhooks      | Y   | Y    | Trigger automatic deployment and configuration generation          |

## Authorize self-managed GitLab with Choreo

Authorizing using a personal access token (PAT) obtained from your GitLab self-managed server grants Choreo the following permissions to perform the respective actions on your behalf within the repository.

|Permission    | Description                                                                         |
|--------------|-------------------------------------------------------------------------------------|
|API           | Grants full read/write access to the API, covering all groups and projects, as well as read/write access to the repository.|


 # Bring Your Own Image (BYOI)

Choreo allows you to deploy and manage prebuilt container images from external container registries as Choreo components. This enables you to deploy and effectively manage your container images within the Choreo environment.

!!! info
    This feature is currently only available on [private data planes (PDPs)](../choreo-concepts/data-planes.md#private-data-planes) for the following component types:

    - Service
    - Web Application
    - Scheduled Task
    - Manual Task


## Prerequisites

Before you try out this guide, ensure you have the following:

- **A container registry**: Ensure you have a container registry containing the images you want to deploy. Choreo is compatible with various container registries, including but not limited to GCR (Google Container Registry), ACR (Azure Container Registry), GitHub Container Registry, and Docker Hub.

- **An image in the registry**: You need an image ready for deployment.

- **(Optional) An external build/CI pipeline**:  This is to initiate automatic deployments during the build process outside of Choreo.

When using a container registry to deploy a component, Choreo cannot create an image from the source code (Git) or initiate a new deployment when a new image is ready. However, you can use your existing build process to trigger a deployment on Choreo by sending an HTTP POST request to a webhook with the new image details.

This feature is currently only available on private data planes (PDPs). You can find this option under **Deploy an image from a container registry** in the **Select Source** step during component creation for service components, web applications, scheduled tasks, and manual tasks.

## Step 1: Register a container registry

To get started, establish a connection between your container registry and Choreo. 

!!! Info
    When you use your Choreo credentials, Choreo does not *pull* your images into its control plane. Instead, it functions as an orchestrator, facilitating your data plane's ability to retrieve images from an external container registry. Choreo passes on these credentials to the data plane for authentication and access.

To register your container registry, follow these steps:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the Choreo Console header, go to the **Organization** list and select your organization. 
3. In the left navigation menu, click **Settings**. This opens the organization settings page. 
4. Click the **Credentials** tab and then click the **Container Registries** tab. 
5. Click **+Add Registry** to configure the Git repository connection.
6. Specify a **Registry Display Name**.
7. Select the **Authentication Type**. Fill in the required information depending on your authentication type. For details on each authentication type, see [Authentication types](#authentication-types).
8. Click **Save**.

### Authentication types

Choreo provides the following authentication options:  

#### Public (anonymous) access
    
You can use this option to establish a connection with a container registry that permits unrestricted public or anonymous access (for example, Public Docker Hub). In this case, only the registry host information is necessary.

For example, the following are the Docker Hub registry hosts for reference:

| Vendor                           | Registry host                |
|----------------------------------|------------------------------|
|Docker Hub (public repositories)  | `registry.hub.docker.com`    |
|Docker Hub (private repositories) | `registry.docker.com`        |

\* If necessary, you can use other mirrors instead of the above.

#### Basic authentication

To use basic authentication to authenticate to the container registry, you must provide the username and password.

#### Docker config

You can provide a Docker config in JSON format to authenticate to the container registry. This option only allows you to register one container registry. That is, it **only allows a single registry under `auths`**.

You must provide the credentials directly within the configuration. Choreo cannot utilize references to executable authentication plugins.

Sample Docker config format:

```json
    {
    "auths": {
        "index.docker.io/v1/": {
        "auth": "c3R...zE2"
        }
    }
    }
```

#### Vendor-specific authentication

This option is specifically for private data planes, where your cloud provider manages authentication at the Kubernetes level. Choreo requires knowledge of the registry host because the data plane already possesses implicit (preconfigured) access to the registry.

Follow the guidelines below based on your container registry:

=== "ACR"
    **Azure Container Registry** 

    Recommended authentication options:

    * [**Service principal-based basic authentication**](https://learn.microsoft.com/en-us/azure/container-registry/container-registry-auth-service-principal)

    * **Vendor-specific authentication on Azure private data planes**
        
        Contact Choreo support to enable infrastructure-level private access to your registry from your Azure private data plane on AKS. If you are on a self-managed PDP on Azure, follow [this guide](https://learn.microsoft.com/en-us/azure/aks/cluster-container-registry-integration?toc=%2Fazure%2Fcontainer-registry%2Ftoc.json&bc=%2Fazure%2Fcontainer-registry%2Fbreadcrumb%2Ftoc.json&tabs=azure-cli).

=== "GAR"
    **Google Artifact Registry**

    Recommended authentication options:

    * [**Service account-based basic authentication**](https://cloud.google.com/artifact-registry/docs/docker/pushing-and-pulling#key)

        Use the service account key in JSON format ([`_json_key`](https://cloud.google.com/artifact-registry/docs/docker/authentication#:~:text=of%20the%20following%3A-,_json_key,-if%20you%20are)) as the username and specify the minified JSON contents of the service account key as the password.

         You can use `jq` as follows to minify the service account JSON key file:

         `jq -c . <service-account.json>`

    * **Vendor-specific authentication on GCP private data planes**

        Contact Choreo support to enable infrastructure-level private access to your registry from your GCP private data plane on GKE. If you are on a self-managed PDP on GCP, see [https://cloud.google.com/artifact-registry/docs/access-control#grant-project](https://cloud.google.com/artifact-registry/docs/access-control#grant-project).

=== "AWS ECR"
    **Elastic Container Registry**

    ECR does not allow the creation of static access passwords for basic authentication. The passwords (that is, access tokens) provided by AWS are only valid for 10 hours and must be manually regenerated. However, when an ECR is attached to an EKS cluster at an infrastructure level, this limitation does not apply because the authentication is handled by AWS internally. For details, see [https://docs.aws.amazon.com/AmazonECR/latest/userguide/registry_auth.html](https://docs.aws.amazon.com/AmazonECR/latest/userguide/registry_auth.html).

    Choreo recommends using ECR when you are exclusively on an AWS private data plane using the vendor-specific authentication option. Contact Choreo support to enable a private connection between your ECR and the underlying EKS clusters on your data plane. If you are on a self-managed PDP, you can follow [this guide](https://docs.aws.amazon.com/AmazonECR/latest/userguide/ECR_on_EKS.html).    

=== "Docker Hub (Private)"

    Recommended authentication options:

    * **Basic authentication**

          Use your Docker Hub username/password or an access token. You can generate an access token from your Docker Hub account settings and use it in place of the password. For details, see [https://docs.docker.com/docker-hub/access-tokens/](https://docs.docker.com/docker-hub/access-tokens/).

    * **Docker config**

          Sign in to the Docker CLI and copy the contents of the docker config JSON. Note that external credential stores and multiple repositories within the same config object are not supported. For more information, see [https://docs.docker.com/engine/reference/commandline/login/](https://docs.docker.com/engine/reference/commandline/login/).

=== "GHCR"
    **GitHub Container Registry**

    Recommended authentication option:

    * **Basic authentication using a PAT token**

          Create a personal access token (PAT) and use it in place of the password. You cannot use your own GitHub password. You must provide a [PAT token](https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry#authenticating-with-a-personal-access-token-classicn).
  
## Step 2: Create a component in Choreo

1. In the left navigation, click **Overview** and select your project. Alternatively, select your project from the **Project** list in the Choreo Console header. 
2. Under **Component Listing** click **+ Create**.
3. Select your component type (BYOI is only available for Service, Web Application, Scheduled Task, or Manual Task components). 
4. From the Create Component pane, select the **Container Registry** under the **Connect a Docker Image** section.
5. Under **Deploy an image from Container Registry/Docker Hub**, select the container registry you have registered in [Step 1](#step-1-register-a-container-registry).
6. Enter the full image URL. The image URL format in general is as follows:
   `[container-registry-host]/[repository-name]/[image-name]:[tag]`

    !!! tip
        When a public image from Docker Hub lacks a specified repository name, it typically defaults to `/library/`. For example, you can access the public Nginx image `https://hub.docker.com/_/nginx` as `registry.hub.docker.com/library/nginx:1.25`.

7. Enter a display name, a unique name, and a description for the component.
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.


## Step 3: Deploy the component in Choreo

To deploy the component and bring your image to Choreo, follow the steps given below: 

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Update Image & Deploy**. 
3. In the **Endpoint** pane that opens, you can see the endpoint ready to be deployed. Click the edit icon next to the endpoint name. Optionally, you can define the endpoints for your service when you manually deploy the service. For more information, see [Expose service endpoints](#step-4-expose-service-endpoints).
4. Change the **Network Visibility** to **Public**. This setting securely exposes the endpoint for consumption.
5. Click **Update**.

    !!! info
         In this example, you deploy a Ballerina service as a REST endpoint. Therefore, Choreo generated the REST endpoint automatically. If you deploy a non-Ballerina service, you must manually add the REST endpoint and set the network visibility to **Public**.

6. Select your update image option. Refer to the update options listed below.

    You have the capability of updating the image when you are deploying the component in Choreo in one of the following three ways:

    | Option                   |Description                                                                                             |
    |--------------------------|--------------------------------------------------------------------------------------------------------|
    | **Update Image Tag**     | This option allows you to update the tag of the image.                                                 |
    | **Update Image URL**     | With this option, you can change the image name, tag, and the image repository of the image URL.|
    | **Previous Images**      | This option allows you to select a previous image and redeploy the image.                               |

7. Click **Deploy**. This deploys the service to the development environment.

## Step 4: Expose service endpoints 

!!! info
    This section only applies to service components.

After creating a service component in Choreo, you have the option to define the endpoints for your service when manually deploying a new image.

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Update Image & Deploy**. 
3. In the **Endpoint** pane that opens, optionally, you can define the endpoints for your service when you manually deploy the service. 
4. Click  **Create/Update Endpoints**.
5. Under the **Edit endpoints.yaml** section, you can edit the endpoints YAML file in the provided editor. 
   Alternatively, you can upload the associated API specification/schema files (OpenAPI/GraphQL schemas). Instead of specifying the file path, you can also reference this file in the `endpoints.yaml` file by its file name, similar to the Git-based Choreo components. The endpoints template follows the standard definitions for defining endpoints in Choreo. For more details, see [Configure Endpoints](../develop-components/configure-endpoints.md).

## Auto-deploy images in Choreo with an external CI/build pipeline

Choreo does not have automatic detection and deployment for newly added images or tags in the linked container registry. To overcome this limitation, Choreo allows you to integrate your own CI pipelines and initiate deployments manually. This approach enables you to use your existing CI setup or build a pipeline for image creation and pushing. You can then trigger automatic deployments using a webhook.

Follow the steps below to configure your CI/build pipeline:

1. Build and push the container image associated with a Choreo component to your container registry.
2. In the left navigation menu, click **DevOps** and then click **External CI**.
3. Generate a token for your CI pipeline from the **Manage Tokens** section. 

    !!! note
        - The tokens are bound to a specific component.
        - It is recommended to reference the token from a secure location available to your CI pipeline. For example, use a GitHub secret if you are using GitHub Actions.

4. To trigger an automatic deployment to your development environment, you can initiate an HTTP POST request to the Choreo webhook endpoint with the updated image details. Alternatively, you can use the provided Webhook snippets. This action will seamlessly deploy the image to the development environment.



Services and integrations are exposed to other services, integrations, or applications through endpoints. A service or an integration can expose multiple endpoints, each representing a unique entry point into the service. For example, a service may expose a REST API endpoint and a GraphQL endpoint, each providing different ways to interact with the service. Endpoints provide specific details for how the service or the integration can be consumed. For instance, the port number, protocol, and the schema such as open API specification (OAS) or GraphQL schema. By defining these details, endpoints make it possible for other services, integrations, and applications to discover and interact with the service in a standardized way.

Choreo defines endpoints by combining port binding, protocol, endpoint name, network visibility, endpoint schema, and additional protocol-related fields. The following table describes each attribute of an endpoint.

| Field | Description |
| ----- | ----------- |
| Name | A unique identifier for the endpoint within the service component. |
| Port | The network port on which the endpoint is accessible. |
| Type | The endpoint protocol. Supported protocols: REST, GraphQL, gRPC, WS, UDP, and TCP. |
| Network Visibility | Determines the level of visibility of an endpoint. Possible values are: <ul><li>Project: Allows components within the same project to access the endpoint.</li><li>Organization: Allows any component within the same organization to access the endpoint but restricts access to components outside the organization.</li><li>Public: Allows any client to access the endpoint, regardless of location or organization.</li></ul> |
| Schema | Specifies the structure and format of the data exchanged through the endpoint. |
| Context (HTTP and GraphQL only) | A context path that you add to the endpoint's URL for routing purposes. |

## Configure endpoints
The method of defining endpoints depends on the buildpack.

* For `Ballerina` and `WSO2 MI` buildpacks, Choreo automatically detects the endpoint details for REST APIs.
* For all other buildpacks (Java, Python, NodeJS, Ruby, PHP, Go, Dockerfile, etc.), you can configure endpoints in one of the following ways:
  
    * **Using the Choreo Console**: If a `component.yaml` file is not present, you can define a basic endpoint configuration during component creation.
    * **Using the component.yaml file**: You can manually configure endpoint details by defining them in a `component.yaml` file, placing it inside the `.choreo` directory at the build context path, and committing it to the source repository.

You can override UI-defined and auto-generated endpoints by providing a `component.yaml` file in the `.choreo` directory, which will take priority over other configurations.

To learn about the `component.yaml` file, see [Overview of the component.yaml file](../develop-components/manage-component-source-configurations.md#overview-of-the-componentyaml-file).
!!! note
    Automatic endpoint generation is not supported for dynamic endpoint parameters such as variable ports. Therefore, you must use an `component.yaml` file to define dynamic endpoint parameters.

To learn about the `component.yaml` file, see [Overview of the component.yaml file](../develop-components/manage-component-source-configurations.md#overview-of-the-componentyaml-file).

## Expose endpoints as managed APIs

Exposing endpoints as managed APIs is crucial to ensure secure and controlled access to the services being exposed. When a user wants to expose their written service to the outside world or to the organization at large, there is an inherent security risk involved. To mitigate this risk, the Choreo platform is built with an internal (access within the organization only) or external (publicly accessible) gateway that is protected with Choreo API management making the services secure by design.

!!! note
    This feature is not available for gRPC, UDP, and TCP endpoints.

If you want to expose an endpoint as a managed API in Choreo, you need to set the network visibility to either Organization or Public. This allows the endpoint to be exposed through the Choreo API Gateway, which provides a number of benefits, including:

* Expose APIs to external and internal consumers
* Full lifecycle API Management
* API throttling
* Secure APIs with industry-standard authorization flows
* API analytics and monitoring

Once you deploy the service component, Choreo will expose the endpoint as a managed API through the Choreo API Gateway. You can then use the full lifecycle API management features provided by Choreo to test, deploy, maintain, monitor, and manage your API using the API management features.

## Understand the default component URL

The default URL of a component corresponds to the default endpoint of the component and is structured as follows:

`<domain>/<project-name>/<component-name>`

This URL does not include the default endpoint name. For all other endpoints, the URL structure includes the endpoint name, as follows:

`<domain>/<project-name>/<component-name>/<endpoint-name>`

If a component has multiple endpoints, Choreo allows you to change the endpoint corresponding to the default component URL. For a component with a single endpoint, the default URL automatically corresponds to that endpoint.

### Change the default endpoint of a component

To change the default endpoint of a component, follow the steps given below:

!!! note
     - You cannot change the default endpoint if it has associated published APIs. You must go to the **Lifecycle** page and unpublish the relevant APIs before updating the default endpoint. For instructions on unpublishing an API, see [Lifecycle Management](https://wso2.com/choreo/docs/api-management/lifecycle-management/).
     - Choreo does not allow you to change the default endpoint of a component if you create multiple deployment tracks within its current major version, or promote the component beyond its initial environment.

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to change the default endpoint.
3. In the left navigation menu, click **Deploy**.
4. On the **Deploy** page, go to the **Set Up** card and click **Configure & Deploy**.
5. In the **Environment Configurations** pane that opens, click **Next**.
6. In the **File Mount** pane that opens, click **Next**.
7. In the **Endpoint Details** pane that opens, click the **Default Endpoint** list, select the endpoint you want to set as the default endpoint, and then click **Update**.
8. Click **Deploy**. This deploys the component with the selected endpoint as the default, and the default URL will now correspond to this endpoint.  

### Edit a UI-Defined Endpoint
If you defined an endpoint during component creation, you can edit it later by following these steps:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to update the endpoint.
3. In the left navigation menu, click **Deploy**.
4. On the **Deploy** page, go to the **Set Up** card and click **Configure & Deploy**.
5. In the **Environment Configurations** pane that opens, click **Next**.
6. In the **File Mount** pane that opens, click **Next**.
7. In the **Endpoint Details** pane that opens, locate the endpoint you want to edit.
8. Click the **Edit** icon next to the endpoint, modify the editable fields, and click **Update**.
9. Click **Deploy** to apply the changes.

!!! note
     If you commit a `component.yaml` file, build the component, and proceed with deployment, the endpoints will be generated from the `component.yaml` file and will take priority. In this case, the endpoint cannot be edited through the UI. To modify the endpoint, you must update the`component.yaml` file.


# Configure Endpoints
{% include "configure-endpoints-body.md" %}

# Deploy a Containerized Application 

Using Choreo, you can easily deploy applications written in different language frameworks (such as Java, Go, NodeJS, Python, etc.) on shared or private data planes using containers.

Choreo supports deploying containerized applications for the following component types:

- Service
- Web Application
- Scheduled Task
- Manual Task
- Event Handler
- Test Runner

## Connect your repository to Choreo

To connect your GitHub repository to Choreo, you should authorize the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application to access your account or organization. When you attempt to connect your GitHub repository via the Component creation page, the Choreo Apps authorization prompt will appear.

* Connect GitHub Repository
    
    ![Connect GitHub Repository](../assets/img/develop-components/deploy/create-component-authz-github-page.png){.cInlineImage-threeQuarter}

* Authorize GitHub Application
    
    ![Authorize GitHub Application](../assets/img/develop-components/deploy/authz-choreo-github-app.png){.cInlineImage-half}

* Grant Repository Access

    ![Grant Repository Access](../assets/img/develop-components/deploy/github-repo-access.png){.cInlineImage-full}


    The **Choreo Apps** requires the following permission:
    
    - Read access to issues and metadata
    - Read and write access to code, pull requests, and repository hooks

!!! note
    You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. Choreo needs write access only to send pull requests to a user repository. Choreo does not directly push any changes to a repository.

Alternatively, you can connect a public repository without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. Select the **Third-Party GitHub Repository** and paste a public repository URL in the **Public Repository URL** field at the time of component creation.

!!! tip
     Authorizing the repository with the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application becomes essential if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component. If you own the repository, you can subsequently authorize it with the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application to enable **Auto Deploy**.

After granting access to the required repositories, you can choose a repository and an associated branch to connect to the Choreo component.
For the containerized application deployments, you should select the [**Component Directory**](https://docs.docker.com/build/building/context/#path-context), **Dockerfile** as the **Buildpack** and provide **Dockerfile Path** for the Docker build.

![Connected Dockerfile Repository](../assets/img/develop-components/deploy/create-component-connected-repo.png){.cInlineImage-full}

The following table describes the individual fields in the **Create Component** pane.

| **Field**               | **Description**                                                                                                                                                                      |
|-------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **GitHub Account**      | Your GitHub account or organization. If you want to add another GitHub account, you can expand the list and click **+ Add**.                                                            |
| **GitHub Repository**   | Depending on the repository access you provided, the list will show available repositories to be connected.                                                                                  |
| **Branch**              | The branch of the repository.                                                                                                                                                         |
| **Buildpack**        | Determines the implementation of the component: Any language or other language as a Docker container.                                                                                |
| **Dockerfile Path**     | The path to your Dockerfile. This path is defined relative to the repository root.<br/>For example, if the Dockerfile is at the repository root, the value for this field is `/Dockerfile`. |
| **Component Directory** | The component directory path. To include the repository root, leave the default `/` value.                                                                                          |
| **Port***               | The port at which your service is running.                                                                                                                                           |
| **OpenAPI Filepath***   | The path to an OpenAPI specification (in YAML/JSON) relative to the repository root. If you don't provide a path, the system automatically generates a default allow-all specification.    |

   
!!! note
 
    - Fields marked with **\*** are not visible for all component types.

    - To successfully build your container with Choreo, it is essential to explicitly define a User ID (`UID`) under the `USER` instruction in your Dockerfile. You can refer to the [sample Dockerfile](https://github.com/wso2/choreo-sample-apps/blob/main/go/rest-api/Dockerfile) for guidance.

    - To ensure that the defined USER instruction is valid, it must conform to the following conditions:
        
        - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
        - Usernames are not considered valid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

## Deploy the containerized component

Choreo will automatically apply deployment configurations and settings based on the component type you select during creation.
For example, if you select the **Service** component type, Choreo will deploy it as a Kubernetes deployment with appropriate scaling configurations.

You can run unit tests in the build pipeline by adding the relevant command to the Dockerfile.  For example: 

- [Go-based sample](https://github.com/wso2/choreo-sample-apps/blob/8c18c82db604adb43b89f669888a07cd6e31d7b7/go/rest-api/Dockerfile#L37)
- [Python-based sample](https://github.com/wso2/choreo-sample-apps/blob/8c18c82db604adb43b89f669888a07cd6e31d7b7/python/rest-api/Dockerfile#L15)

### Application configurations

You must provide any required configurations for running the application in the **Configs & Secrets** section of the component's **DevOps** page. Alternatively, you can also review the configurations when you manually deploy via the **Deploy** page.

After clicking the **Create** button, you can select the confidentiality of the configuration and specify how to mount it to the container.

![Application Configuration Page](../assets/img/develop-components/deploy/deploy-app-config-page.png){.cInlineImage-full}

![Create Configuration Mount Page](../assets/img/develop-components/deploy/deploy-app-config-type-mount-page.png){.cInlineImage-full}

#### Configuration types

* **ConfigMap**: Stores non-confidential data as key-value pairs.
* **Secret**: Stores and manages sensitive information, such as passwords, OAuth tokens, and ssh keys as key-value pairs.

#### Mount types

* **Environment Variables**: Mounts the selected ConfigMap or Secret as an environment variable in the container.
* **File Mount**: Mounts the selected ConfigMap or Secret as a file in the container. Here, the key is the file name, and the value is the file content.

The following image shows adding a **ConfigMap** with **File Mount** mount type to be read by the application.

![Configuration File Mount Page](../assets/img/develop-components/deploy/deploy-app-config-file-mount.png){.cInlineImage-full}

!!! note
    The JSON file includes ${DB_PASS} as an environment variable defined in a Secret. The application reads the JSON file and substitutes the placeholders with the corresponding environment variables.

### Deployment configurations

Choreo lets you configure deployment settings such as scaling, resource limits, and health checks based on your selected component type.

For more information about these configurations, see Choreo's [DevOps capabilities](../devops-and-ci-cd/view-runtime-details.md).

You can configure the **Endpoints** to expose your service using the **Service** Component in Choreo. See [Service Component Overview](../develop-components/develop-services/service-component-overview.md) for more information. 

### Build, deploy, and promote

After adding the application configuration, you can build and deploy it by clicking the **Deploy Manually** button. Choreo will start the build process with the selected commit in the **Build Area**. 

!!! note
    The **Auto Deploy on Commit** feature, which automatically builds and deploys the application upon pushing a code change to the repository, is enabled by default. To turn off this feature, navigate to the **Build Area** of the **Deploy** page.

Choreo scans your Dockerfile for security vulnerabilities during the build phase, and if there are no issues found, it proceeds with the build process. After building the image, it scans it again for vulnerabilities before deployment to the environment. You can view the build logs from the right-side panel, as shown in the image below.

![Build Logs Panel](../assets/img/develop-components/deploy/build-deploy-page-logs.png){.cInlineImage-full}

Once the build process is complete, Choreo will deploy the application automatically to the Development environment. To promote the build to higher environments, you can click the **Promote** button. The number of environment cards visible on the page may vary depending on your environment configurations.

### Troubleshoot security vulnerability scan failures (Trivy)

By default, Choreo utilizes the Aqua Trivy (OSS) image vulnerability scanner to detect security vulnerabilities in all Dockerfile-based build pipelines. The scanner will fail the pipeline if any **CRITICAL** CVEs (Common Vulnerabilities and Exposures) are detected. CVEs of other severity levels are recorded but does not fail the pipeline.

If you cannot fix a critical CVE immediately, you can opt to ignore it. To ignore a critical CVE, add a `trivyignore` (`<docker-build-context-path>/.trivyignore`) file to your build context path. In the file, add the CVEs you need the pipeline to ignore, one entry per line as follows:

```
CVE-2023-xxxx
CVE-2023-yyyy
```

You can add comments in the file by using `#` in front of the comment as follows: 

```
# comments can be added like this
CVE-2023-xxxx
```


# Deploy an Application with Buildpacks

Using Choreo, you can easily deploy applications written in different language frameworks (such as Java, Go, NodeJS, Python, Ruby, PHP, etc.) on shared or private data planes.

Choreo supports deploying applications with buildpacks for the following component types:

- Service
- Web Application
- Scheduled Task
- Manual Task
- Webhook
- Event Handler
- Test Runner

## Buildpacks
Buildpacks are a fundamental building block in modern application development. They convert your source code into a secure, efficient, production-ready container image without a Dockerfile. With Choreo, developers can take advantage of this powerful tool to effortlessly deploy their applications without the hassle of manual configuration.

Choreo uses [Google Buildpacks](https://cloud.google.com/docs/buildpacks/overview) as default buildpacks for Java, Go, NodeJS, Python, PHP, and Ruby. Choreo uses its own buildpacks for Ballerina and WSO2 MI.

## Develop a component

To develop a service component that exposes a Service in Go, you can follow the [Develop a Service ](develop-services/develop-a-service.md) guide.

Follow the guidelines below based on your language:

=== "Python"
    Supported Versions - 3.10.x, 3.11.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Reading Books List Service](https://github.com/wso2/choreo-samples/tree/main/reading-books-list-service-python)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-python-task)|

    ### Procfile
    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    
    !!! info 
        In **Python** projects, it is mandatory to have a `Procfile` with the `web` process type in the project root directory.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: python main.py` <br>
    `web: gunicorn --bind :8080 --workers 1 --threads 8 --timeout 0 main:app` <br>
    `web: flask run --host=0.0.0.0`

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Ballerina"

    Supported Versions - 2201.3.5, 2201.4.1, 2201.5.0, 2201.5.1, 201.6.0,  2201.7.0

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Echo Service](https://github.com/wso2/choreo-samples/tree/main/echo-service)|
    | Manual Task | [Covid19 Statistics To Email](https://github.com/wso2/choreo-samples/tree/main//covid19-statistics-to-email)|
    | Webhook | [Salesforce New Case To Google Sheet](https://github.com/wso2/choreo-samples/tree/main/sfdc-new-case-to-gsheet)|
    | Scheduled Task | [Shopify New Customers to HubSpot Create/Update Contact](https://github.com/wso2/choreo-samples/tree/main/shopify-new-customers-to-hubspot-contact)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Go"

    Supported Versions - 1.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Greeting Service](https://github.com/wso2/choreo-samples/tree/main/greeting-service-go)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-go-task)|
    | Web Application | [Hello World Web Application](https://github.com/wso2/choreo-samples/tree/main/hello-world-go-webapp)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== ".NET"
    Supported Versions - 6.x, 7.x, 8.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service | [Greeting Service](https://github.com/wso2/choreo-samples/tree/main/dotnet-greeter)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Java"
    Supported Versions
        - 8, 11, 17, 18 (OpenJDK Runtime Environment Temurin)

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Product Management Service](https://github.com/wso2/choreo-samples/tree/main/product-management-service)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-java-task)|

    !!! info

         When working on Java projects:

           - The `Main` class should be defined in the manifest file.
           - If Maven files such as `mvn.cmd` exist in the project without the `.mvn` directory, the build will fail. To ensure a successful build, you must either commit the `.mvn` directory along with any Maven files or not include any Maven files in the project if you choose not to commit the `.mvn` directory.
    
    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **Java** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: java -jar target/sample.jar` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "NodeJS"
    Supported Versions - 12.x.x, 14.x.x, 16.x.x, 18.x.x, 20.x.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Reading Books List Service](https://github.com/wso2/choreo-samples/tree/main/reading-books-list-service-nodejs)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-nodejs-task)|

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **NodeJS** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: node app.js` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "PHP"
    Supported Versions - 8.1.x, 8.2.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Hello World Service](https://github.com/wso2/choreo-samples/tree/main/hello-world-php-service)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-php-task)|
    | Web Application | [Hello World Web Application](https://github.com/wso2/choreo-samples/tree/main/hello-world-php-webapp)|

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **PHP** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web:php -S 0.0.0.0:8000 index.php` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Ruby"
    Supported Versions - 3.1.x, 3.2.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service | [Hello World Service](https://github.com/wso2/choreo-samples/tree/main/hello-world-ruby-service)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-ruby-task)|
    | Web Application | [Hello World Web Application](https://github.com/wso2/choreo-samples/tree/main/hello-world-ruby-webapp)|

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **Ruby** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: ruby app.rb` <br>
    `web:bundle exec ruby app.rb -p 8080` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "WSO2 MI"
    Supported Versions - 4.1.0.x, 4.2.0.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service |[Hello World Service](https://github.com/wso2/choreo-samples/tree/main/hello-world-mi)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Spring Boot"
    Supported Java Versions
        - 8, 11, 17, 18 (OpenJDK Runtime Environment Temurin)

    !!! info
         You can use this buildpack only with web applications. For other component types, use the **Java** buildpack. Additionally, if the generated artifact is a `WAR` file, it is necessary to include a **Procfile**.

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **Java** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: java -jar target/sample.war` <br>

### Configure build-time environment variables

You can configure the environment variables necessary to build the component using the **Build Configurations Editor** on the component **Build** page. 

!!! info
    The capability to configure build-time environment variables is not available for components created using **Ballerina** or **WSO2 MI** buildpacks.

During the build process, the build-time environment variables and their values are passed to the buildpack. Therefore, you can configure both buildpack-specific environment variables and those required for the component build.

For example, if you want to override the Maven command of the **Java** buildpack, you can use `GOOGLE_MAVEN_BUILD_ARGS` as the environment key and `clean install` as the value. 

For more examples, see [Google Cloud's buildpacks documentation](https://cloud.google.com/docs/buildpacks/service-specific-configs).


# Develop a Webhook

Choreo allows developers to design high-quality webhooks. To explore this capability, let's consider a scenario where a team of software engineers in an organization should be notified via email whenever someone creates a GitHub issue with the `bug` label in a specific repository.

In this tutorial, you will address the requirement by doing the following:

- Create a webhook by connecting to a forked GitHub repository where you have the webhook implementation that addresses the described requirement.
- Deploy the webhook to the development environment.
- Modify the webhook implementation to connect the webhook to GitHub, enabling it to act in response to selected GitHub-related events.
- Test the webhook.
- Promote the webhook to the production environment.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

## Step 1: Create a webhook component

To create a Webhook component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Webhook** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following information:

    | **Field**                     | **Description**    |
    |-------------------------------|--------------------|
    | **GitHub Account**            | Your account       |
    | **GitHub Repository**         | choreo-samples     |
    | **Branch**                    | main               |
    | **Component Path**              | `github-event-to-email-webhook` |

6. Select **Ballerina** as the build pack.
7. Provide a display name, a unique name and description for the component.
8. Click **Create**.

Choreo creates the Webhook component with the sample implementation and opens the component **Overview** page.

## Step 2: Deploy

To deploy the webhook to the development environment, follow these steps:

1. In the Choreo Console left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**.
3. In the **Configurations** pane, enter the following information:
    1. In the **webhookSecret** field, enter any value.

        !!! note
            Save this value for later use.

    2. In the **toEmail** field, enter the email address to send notification emails.
    3. Click **Deploy**.

    You can monitor the deployment progress in the **Console** pane that opens on the right of the page.

Once Choreo completes the deployment, the **Development** card indicates the **Deployment Status** as **Active**.

!!! note
    In the deployment card, you can click the icon corresponding to configurables to open the **Configurations** pane and edit configurations.

## Step 3: Connect the webhook to the GitHub repository

To allow the webhook to read the labels of issues in a specific GitHub repository, connect the webhook to the GitHub repository:

1. In the Choreo Console left navigation menu, click **Overview**.
2. On the **Overview** page, copy the invoke URL by clicking the copy icon within the **URL** field.
3. Go to your GitHub account and open the repository for which you want to generate notification emails.
4. In the top menu, click the **Settings** tab.
5. In the left navigation menu, click **Webhooks**.
6. Click **Add webhook** and enter the following information:

    | **Field**        | **Value**                                                          |
    |------------------|--------------------------------------------------------------------|
    | **Payload URL**  | The invoke URL you copied in Step 3, sub-step 1.                   |
    | **Content Type** | Select `application/json`                                          |
    | **Secret**       | The last webhook secret you configured in [Step 2](#step-2-deploy).| 

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Project Path** specifies the location of the project to build the component.

7. Under **Which events would you like to trigger this webhook?**, select **Let me select individual events**.
8. Select the **Issues** checkbox in the list of events displayed. This ensures that GitHub issues trigger the webhook.
9. Clear the **Pushes** checkbox to ensure that GitHub does not trigger your webhook when the team pushes changes to the selected GitHub repository.
10. Click **Add webhook** to save the configuration.

Now you have integrated Choreo with GitHub via the webhook you created and deployed. You can proceed to test the webhook.

## Step 4: Test

To test your webhook, create a GitHub issue with the `Bug` label in the repository that you connected to the webhook. You will receive an email similar to the following at the email address you provided in [Step 2](#step-2-deploy).

## Step 5: Promote

To promote the webhook to the Production environment, follow these steps:

1. On the **Deploy** page, go to the **Development** card and click **Promote**.
2. In the **Configuration Types** pane, leave the default selection (i.e., **Use default configuration values**) unchanged.

    !!! note
        If you have configured any default values for the configurable variables, selecting **Use default configuration values** allows you to proceed with those values. If not, specify values for the configurable variables.

3. Click **Next**.
4. In the **webhookSecret** field, enter any value.

    !!! note
        Save this value for later use.

5. In the **toEmail** field, enter the email address to send notification emails.
6. Click **Promote**.

    Once the component is promoted to production, the **Production** card displays the deployment status as **Active**.

Now you have successfully created, deployed, and tested a Webhook component and promoted it to production.


# Develop an External Consumer

An external consumer in Choreo is any client that can interact with services deployed in Choreo, as an entity hosted outside of the Choreo infrastructure. It is a generic component type that allows you to represent and manage any client, such as a mobile application, web application, server-to-server integration, bot, microservices, etc.

In this guide, you will:

 - Create an external consumer component.
 - Manage authentication for the external consumer.
 - Connect the external consumer to a service deployed in Choreo.
 
## Prerequisites

Before you try out this guide, complete the following steps:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

## Step 1: Create an external consumer component
 
To create an external consumer component, follow the steps given below:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **External Consumer** card. 
4. In the **Create an External Consumer** pane that opens, enter a display name, a unique name, and a description for the component.
5. Click **Create**. This creates the component and takes you to its **Overview** page.
   
## Step 2: Manage authentication for the external consumer

You can configure the external consumer to work with the Choreo built-in identity provider or any external identity provider that supports OIDC/OAuth 2.0.

Click the respective tab for details depending on the identity provider you want to configure: 

=== "Choreo built-in identity provider"

     Follow the steps given below to configure the built-in identity provider by generating authentication keys:

    !!! note
         Choreo built-in identity provider is configured by default. Therefore, this step is optional.

     1. In the **Overview** page of the component, under **Authentication Configurations**, click **Configure** corresponding to the environment for which you want to configure an identity provider.
     2. In the **Identity Provider** list, select **Choreo Built-In Identity Provider**.
     3. Click **Generate Keys**. 

        !!! Note
             If you see **Regenerate Secret** instead of **Generate Keys**, it indicates that OAuth keys are already generated for the component in the selected environment.

=== "An external identity provider"

     **Step 2.1: Create and configure an OIDC/OAuth 2.0 application in the external identity provider**

     1. Create an OIDC/OAuth 2.0 application in your external identity provider.
     2. Configure the OIDC/OAuth 2.0 application accordingly. (The access token type should be configured as JWT)

     **Step 2.2: Link the OIDC/OAuth 2.0 application to the Choreo component**

     3. In the **Overview** page of the component, under **Authentication Configurations**, click **Configure** corresponding to the environment for which you want to configure an identity provider.
     4. In the **Identity Provider** list, select your identity provider.
     5. Paste the **Client ID** of the OIDC/OAuth 2.0 application you created in your external identity provider.
     6. Click **Add Keys**.

## Step 3: Connect the external consumer to a service deployed in Choreo 

To establish connections from the external consumer to services deployed in Choreo, you can create connections. For step-by-step instructions on creating a connection, see [Create a Connection](./sharing-and-reusing/create-a-connection.md).


# Develop Components Using VS Code

The [Choreo VS Code extension](https://marketplace.visualstudio.com/items?itemName=WSO2.choreo) provides comprehensive component management capabilities to streamline local development within Choreo.

## Prerequisites

To ensure a smooth development experience with the Choreo extension, make sure you have the following:

1. [Visual Studio Code](https://code.visualstudio.com/download) installed with the [Choreo extension](https://marketplace.visualstudio.com/items?itemName=WSO2.choreo) version **2.0.0** or later.

2. A locally cloned GitHub repository to create new components or link to existing Choreo components.

3. [Git](https://git-scm.com) version 2.0.0 or later.

## Get started

To use the capabilities of the Choreo extension in the VS Code editor, you need an active [Choreo account](https://wso2.com/choreo/pricing/). If you already have an account, follow these steps to set up the extension:

1. Install the [Choreo VS Code extension](https://marketplace.visualstudio.com/items?itemName=WSO2.choreo) and wait for activation. On successful activation, the Choreo extension opens in the VS Code editor. 
2. Sign in to Choreo using one of the following methods:
    - In the Choreo activity pane, click **Sign In**.
       ![Sign in](../assets/img/develop-components/develop-using-vs-code/sign-in.png)
    - Use the `Sign In` command provided by the Choreo extension.

    This redirects you to an external URI to complete the authentication process. On successful sign-in, the Choreo activity pane displays your account details along with any components detected within the VS Code workspace.

## Create a new component

1. Open the source code directory where you want to build, deploy, and manage components using Choreo.
2. Create a new component using one of the following methods:
    - In the Choreo activity pane, click **Create Component**.
       ![Create Component Button](../assets/img/develop-components/develop-using-vs-code/create-component-btn.png)
    - Use the `Create New Component` command provided by the Choreo extension.

3. If the Choreo extension cannot determine the project context of the opened workspace, it prompts you to select the organization and the project to which the new component belongs.
4. Specify component details such as the name, type, buildpack, etc.

    ![Component Form](../assets/img/develop-components/develop-using-vs-code/component-form.png)
            
    On successful creation, the component details view opens, and the Choreo activity pane displays the new component.

    ![Component Details](../assets/img/develop-components/develop-using-vs-code/component-details-view.png)
     
    !!! tip
        Once the component is created, a `.choreo/context.yaml` file is generated in the root of the Git repository. For more details, see [Understand the project context](#understand-the-project-context).

The component details view allows you to manage your component by performing various actions such as the following:

 - Triggering builds for selected commits.
 - Viewing lists of builds and statuses.
 - Diagnosing build failures with build logs.
 - Deploying builds in available environments.
 - Accessing runtime logs and deployed component URLs.
 - Invoking deployed service endpoints.

## Understand the project context

Context files contain metadata related to the project, allowing the extension to establish an association between local directories and Choreo projects. These files, such as the `context.yaml`file, resides in the `/.choreo` directory within the root of the Git repository.

The Choreo extension scans the root of the opened Git repository to find the `context.yaml` file and lists the components of the associated project. This allows you to easily open and manage the components they are developing within the VS Code workspace.

A `context.yaml` file can contain multiple projects, whereas, a workspace opened via VS Code can have multiple `context.yaml` files with different project associations. In such cases, VS Code allows you to switch between these projects, add new project associations, or remove existing ones, allowing you as a developer to focus on components of a particular project at a time.

You can decide whether to commit the `context.yaml` file to the Git repository. Committing this file enables other team members working on the same repository to have a seamless developer experience with Choreo.

If the `context.yaml` file for a particular project is not committed to the Git repository or is unavailable for other reasons, you can easily regenerate it using one of the following methods:

 - In the Choreo activity pane, click **Link Directory**.
    ![Link Directory](../assets/img/develop-components/develop-using-vs-code/link-dir-btn.png)
 - Use the `Link Directory` command provided by the Choreo extension.

## Discover additional features

To access a range of functionalities provided by the Choreo extension, open the VS Code command palette and type `Choreo`.

## Troubleshoot issues

To troubleshoot Choreo extension issues, follow these steps:

1. To open the **OUTPUT** pane, go to the VS Code editor main menu, click **View**, and then click **Output**.

2. Select **Choreo** from the drop-down menu on the right-hand side to view the Choreo output for troubleshooting.

## Get help

For assistance with the Choreo VS Code extension, create [GitHub issues](https://github.com/wso2/choreo-vscode/issues).


# Develop Components With Git

Choreo enables you to develop components by connecting your GitHub, Bitbucket, or GitLab repository. You have the flexibility to either connect an existing repository or start with an empty repository and commit the source code later. By integrating your repositories with Choreo, you can automate tasks and optimize workflows across multiple systems, all within the Choreo platform.  Choreo currently supports GitHub, Bitbucket, and GitLab as Git providers. 

!!! tip
    Choreo supports both Bitbucket Server and Bitbucket Cloud. The currently supported Bitbucket Server version is 8.9.2.

In Choreo, you can connect a Git repository that contains Ballerina source code or a Docker project. To connect a Git repository to Choreo as a Docker project, your Git repository must include the following:

 - A Dockerfile: Specifies the instructions to build the Docker image. 
 - A build context: A set of files in the specified path used to build the image.

Once you connect your Git repository to Choreo, you can build, deploy, and manage your application easily. 

## Connect a Git repository to Choreo

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the Choreo Console header, go to the **Organization** list and select your organization. 
3. In the left navigation menu, click **Settings**. This opens the organization-level settings page. 
4. Click the **Credentials** tab. 
5. Click **+Add Credentials** to configure the Git repository connection.
6. Enter a **Credential Name**, select the Git provider, and enter the **Personal Access Token** you obtained from the Git provider.
7. Click **Save**.  

## Authorize GitHub with Choreo 

Authorizing Choreo as a GitHub application grants Choreo the following permissions to perform the respective actions on your behalf within the repository:

|Permission   | Read| Write| Description                                                           |
|-------------|-----|------|-----------------------------------------------------------------------|
|Issues       | Y   | N    | Read component ID label to filter the pull requests                   |
|Metadata     | Y   | N    | List repositories                                                     |
|Contents     | Y   | Y    | List branches and create a branch to commit sample code               |
|Pull Request | Y   | Y    | Create a pull request if you start with a Choreo sample               |
|Webhooks     | Y   | Y    | Trigger automatic deployment and configuration generation             |

### Add Git submodules to a project

Choreo provides [Git submodule](https://git-scm.com/book/en/v2/Git-Tools-Submodules) support when you connect your GitHub repository to Choreo. This allows you to manage and include external repositories effectively within Choreo build pipelines. Key benefits of this capability include:

  - **Code sharing without duplication**: Use submodules to maintain shared libraries across multiple projects, ensuring a single source of truth.
  - **Efficient third-party library management**: Manage third-party libraries as submodules to update them independently and track changes easily, avoiding direct code integration.

For example, when you [work with the Micro Integrator (MI) runtime in Choreo](./work-with-the-micro-integrator-runtime-in-choreo.md), you can use Git submodules to reuse MI templates and sequences across components without duplication.

!!! info "Note" 
    If you encounter an error stating that you cannot clone a submodule due to insufficient permissions, follow the instructions below to grant the necessary permissions:

      - For a personal account:

         1. Sign in to your personal GitHub account.
         2. In the upper-right corner, click your profile picture, and then click **Settings**.
         3. In the left navigation menu, go to the **Integrations** section and click **Applications**.
         4. Under the **Installed GitHub Apps** tab, click **Configure** corresponding to **choreo.dev**.
         5. Under **Repository Access**, grant access to the necessary repositories.

      - For an organization account:

         1. Sign in to your organization's GitHub account.
         2. In the upper-right corner, click your profile picture, and then click **Settings**.
         3. In the left navigation menu, go to the **Third-Party Access** section and click **GitHub Apps**.
         4. Click **Configure** corresponding to **choreo.dev**.
         5. Under **Repository Access**, grant access to the necessary repositories.

            !!! note
                Choreo currently does not support accessing private repositories in other organizations.

#### Automatically pull latest versions of Git submodules

Choreo lets you automatically pull the latest versions of Git submodules from their respective repositories. To enable this feature, follow these steps:

!!! note 
    Choreo currently supports this feature only for components where the buildpack is **WSO2 MI**.

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click the component for which you want to pull the latest versions of Git submodules.
3. In the left navigation menu, click **Build**.
4. On the **Build** page, click to edit **Build Configurations**.
5. Turn on the **Pull Latest Submodules** toggle.

    !!! info "Note"
        If you rebuild a previously built commit and it doesn’t reflect the latest changes, follow these steps to ensure the changes are applied to the deployed environment:

         1. In the Choreo Console left navigation menu, click **DevOps**, then click **Containers**.
         2. Click **Edit** to update the container settings.
         3. Select **Always** as the **Image Pull Policy**.
         4. Click **Save Changes**.

## Authorize Bitbucket with Choreo

Authorizing using a personal access token (PAT) from Bitbucket grants Choreo the following permissions to perform the respective actions on your behalf within the repository.

|Permission    | Read| Write| Description                                                        |
|--------------|-----|------|--------------------------------------------------------------------|
|Account       | Y   | N    | Get user information and workspace details                         |
|Repositories  | Y   | Y    | List branches and create a branch to commit sample code            |
|Pull Requests | Y   | Y    | Create a pull request if you start with a Choreo sample            |
|Webhooks      | Y   | Y    | Trigger automatic deployment and configuration generation          |

## Authorize self-managed GitLab with Choreo

Authorizing using a personal access token (PAT) obtained from your GitLab self-managed server grants Choreo the following permissions to perform the respective actions on your behalf within the repository.

|Permission    | Description                                                                         |
|--------------|-------------------------------------------------------------------------------------|
|API           | Grants full read/write access to the API, covering all groups and projects, as well as read/write access to the repository.|


# Integrate Unit Tests into the Build Pipeline

Choreo allows you to integrate unit tests into the build pipeline, enabling code validation before deployment. This ensures early testing of code changes, reducing the risk of defects in production.

!!! note
        Currently, Choreo supports unit tests only for the `WSO2 MI` buildpack.

## How it works

### Step 1: Write tests

You can create unit tests in your source code using standard testing libraries. For step-by-step instructions on creating unit tests for WSO2 Micro Integrator projects, see [Creating a Unit Test Suite](https://mi.docs.wso2.com/en/latest/develop/creating-unit-test-suite/).

### Step 2: Enable unit tests

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click the component for which you want to enable unit tests.
3. In the left navigation menu, click **Build**.
4. On the **Build** page, click to edit **Build Configurations**.
5. Turn on the **Unit Test** toggle.
6. Click **Save**.

### Step 3: Trigger a new build

- On the **Build** page, click **Build Latest**.

This starts a new build with unit tests enabled. You can monitor its progress in the **Build Details** pane.

## View failed unit tests

If a unit test fails during the build, you can view its detailed logs for troubleshooting. Click **View Details** corresponding to the failed build, then expand the failed unit test step to view the logs.

## Explore a sample

To see unit tests in action within the build pipeline, try out the [WSO2 MI helloworld](https://github.com/wso2/choreo-samples/tree/main/hello-world-mi) sample. 


# Manage Component Source Configurations

In Choreo, you can configure service endpoints and connections via the `component.yaml` source configuration file. This file ensures that the configurations required to initialize endpoints and connections are defined, as they cannot be inferred from the source code. This guide provides an overview of how to configure and manage these settings effectively.

The source configuration file must be committed to your repository within the `.choreo` directory at the root of the project directory. This ensures the ability to version the configuration files alongside repository commits, enabling better tracking and management of configurations.

!!! note
    -  The `component-config.yaml` and `endpoints.yaml` files will eventually be deprecated and replaced by the `component.yaml` file. 
        - For details on how to seamlessly update to the latest `component.yaml` file`, see [Update to the latest source configuration file](#update-to-the-latest-source-configuration-file).
    - Choreo prioritizes configuration files in the following order: `component.yaml` takes the highest precedence, followed by `component-config.yaml`, and then `endpoints.yaml`.

## Overview of the `component.yaml` file 

**File location**:

```bash
<build-context-path>/.choreo/component.yaml
```

!!! note
    - For components built using **Buildpacks**, replace `build-context-path` with the `<project-directory>`. 
    For example, `<project-directory>/.choreo/component.yaml`.
    - For components built using **Docker**, replace `build-context-path` with the `<docker-context-path>`. 
    For example, `<docker-context-path>/.choreo/component.yaml`.

**Sample `component.yaml` file content**:

Click the respective tab to view the structure for your current configuration file version:

=== "Version 1.1"

    ``` yaml
    # +required The configuration file schema version
    schemaVersion: 1.1

    # +optional Incoming connection details for the component
    endpoints:
      # +required Unique name for the endpoint.
      # This name will be used when generating the managed API
      - name: greeter-sample
        # +optional Display name for the endpoint.
        displayName: Go Greeter Sample
        # +required Service section has the user service endpoint details
        service:
          # +optional Context (base path) of the API that gets exposed via the endpoint.
          basePath: /greeting-service
          # +required Numeric port value that gets exposed via the endpoint
          port: 9090
        # +required Type of traffic that the endpoint is accepting.
        # Allowed values: REST, GraphQL, WS, GRPC, TCP, UDP.
        type: REST
        # +optional Network level visibilities of the endpoint.
        # Accepted values: Project|Organization|Public(Default).
        networkVisibilities: 
          - Public
          - Organization
        # +optional Path to the schema definition file. Defaults to wild card route if not provided
        # This is only applicable to REST or WS endpoint types.
        # The path should be relative to the docker context.
        schemaFilePath: openapi.yaml
      
      # +optional Outgoing connection details for the component.
      dependencies:
        # +optional Defines the connection references from the Internal Marketplace.
        connectionReferences:
          # +required Name of the connection.
          - name: hr-connection
            # +required service identifer of the dependent component.
            resourceRef: service:/HRProject/UserComponent/v1/ad088/PUBLIC
      # +optional Defines runtime configurations
      configurations:
        # +optional List of environment variables to be injected into the component.
        env:
          # +required Name of the environment variable
          - name: HR_SERVICE_URL
            # +required value source
            # Allowed value sources: connectionRef
            valueFrom:
              # +required Choreo connection value source
              connectionRef:
                # +required Choreo connection name to refer the value from
                name: hr-connection
                # +required Choreo connection configuration key to refer the value from
                key: ServiceURL
    ```

    The descriptor-based approach of the `component.yaml` file simplifies and streamlines endpoint and connection configuration management. The use of versioned schemas ensures backward compatibility, providing a seamless transition with future updates.

    You can define the following root-level configurations via the `component.yaml` file:

    | Configuration        | Required     | Description                                                              |
    |----------------------|--------------|--------------------------------------------------------------------------|
    | **schemaVersion**    | Required     | The version of the `component.yaml` file. Defaults to the latest version.|
    | **endpoints**        | Optional     | The list of endpoint configurations.                                     |
    | **dependencies**     | Optional     | The list of dependency configurations.                                   |
    | **configurations**    | Optional     | The runtime configuration definitions.                                   |

    ### Endpoint configurations
    In the `endpoints` section of the `component.yaml` file, you can define multiple service endpoint configurations. Each endpoint must have a unique name and the required fields specified in the schema overview.

    !!! tip "Why have a unique name?"
          When you define multiple endpoints, the `endpoint.name` is appended to the Choreo-generated URL. A unique name ensures the endpoint is easily recognizable and readable within the URL.
          
    | Configuration        | Required     | Description                                                                                             |
    |----------------------|--------------|---------------------------------------------------------------------------------------------------------|
    | **name**             | Required     | A unique identifier for the endpoint within the service component. Avoid using excessively long names.  |
    | **displayName**      | Optional     | A display name for the endpoint.                                                                        |
    | **service**          | Required     | Service details for the endpoint.                                                                       |
    | **.basePath**        | Required     | The base path of the API exposed via this endpoint.                                                     |
    | **.port**            | Required     | The numeric port value exposed via this endpoint.                                                       |
    | **type**             | Required     | The type of traffic the endpoint accepts. For example, `REST`, `GraphQL`, `WS`, `gRPC`, `UDP`, or `TCP`.|
    | **networkVisibilities** | Required | The network-level visibility of the endpoint. For example, project, organization, or public.             |
    | **schemaFilePath** | Required | The file path to the swagger definition  or AsyncAPI 2.0 specification file. Defaults to the wildcard route if not specified. This field should be a relative path to the project path when using **Java**, **Python**, **NodeJS**, **Go**, **PHP**, **Ruby**, or **WSO2 MI** buildpacks. For REST or WebSocket endpoint types, when using the **Ballerina** or **Dockerfile** buildpack, the path should be relative to the component root or Docker context. |

    ### Dependency configurations

    In the `dependencies` section of the `component.yaml` file, you can define multiple connection configurations under `dependencies.connectionReferences`. You can use the connection reference generated in the inline developer guide when creating a connection. For instructions on copying [connection configurations](https://wso2.com/choreo/docs/develop-components/sharing-and-reusing/use-a-connection-in-your-service/), see the inline developer guide displayed during connection creation.

    You must include the following configurations in the `dependencies.connectionReferences` schema:

    | Configuration        | Required     | Description                                                                      |
    |----------------------|--------------|----------------------------------------------------------------------------------|
    | **name**             | Required     | The name given to the connection.                                                |
    | **resourceRef**      | Required     | A unique, human-readable identifier for the service you are connecting.          |


    !!! note
        Choreo automatically generates connection configurations when you create a connection. The properties such as **name** and **resourceRef** are automatically generated. The configurations required to establish the connection will be injected into Choreo-defined environment variables.

        To use custom environment variable names instead of Choreo's default ones, add the dependency as a `serviceReference` in your `component.yaml v1.1` file. You can copy the `serviceReference` section from the `component.yaml v1.0` tab and paste it under `dependencies` in your `component.yaml v1.1` file, which maintains backward compatibility with the v1.0 format.

    ### Runtime configurations
    In the `configurations` section of the `component.yaml` file, you can define runtime configurations for the component. These configurations currently support environment variable injection related to dependencies.
    
    | Configuration                 | Required     | Description                                                                       |
    |-------------------------------|--------------|-----------------------------------------------------------------------------------|
    | **env**                       | Optional     | An array of env variable configurations.                                          |
    | **name**                      | Required     | A unique name for the environment variable, starting with a letter or an underscore, and containing only letters, numbers, or underscores. |
    | **valueFrom**                 | Required     | The source of the environment variable value.                                     |
    | **connectionRef**             | Required     | Connection reference value source definition.                                     |
    | **name**                      | Required     | The name of the Choreo connection to reference the value from.                    |
    | **key**                       | Required     | The Choreo connection configuration key to reference the value from. For details on available keys, see [connection configurations](https://wso2.com/choreo/docs/develop-components/sharing-and-reusing/use-a-connection-in-your-service/) or the inline developer guide. |

    !!! note
        Runtime configurations are supported starting from `component.yaml v1.1`.

        When an environment variable value is specified using `connectionRef`, the connection's environment variable is renamed to the environment variable name defined in the `configurations` section. For example, in the sample `component.yaml` file given above, the `CHOREO_HR_CONNECTION_SERVICEURL` variable in the `hr-connection` is renamed to `HR_SERVICE_URL`.

=== "Version 1.0"

    ``` yaml
    # +required The configuration file schema version
    schemaVersion: 1.0

    # +optional Incoming connection details for the component
    endpoints:
      # +required Unique name for the endpoint.
      # This name will be used when generating the managed API
      - name: greeter-sample
        # +optional Display name for the endpoint.
        displayName: Go Greeter Sample
        # +required Service section has the user service endpoint details
        service:
          # +optional Context (base path) of the API that gets exposed via the endpoint.
          basePath: /greeting-service
          # +required Numeric port value that gets exposed via the endpoint
          port: 9090
        # +required Type of traffic that the endpoint is accepting.
        # Allowed values: REST, GraphQL, WS, GRPC, TCP, UDP.
        type: REST
        # +optional Network level visibilities of the endpoint.
        # Accepted values: Project|Organization|Public(Default).
        networkVisibilities: 
          - Public
          - Organization
        # +optional Path to the schema definition file. Defaults to wild card route if not provided
        # This is only applicable to REST or WS endpoint types.
        # The path should be relative to the docker context.
        schemaFilePath: openapi.yaml
      
    # +optional Outgoing connection details for the component.
    dependencies:
      # +optional Defines the service references from the Internal Marketplace.
      serviceReferences:
        # +required Name of the service reference.
        - name: choreo:///apifirst/HRProject/UserComponent/ad088/v1/PUBLIC
          # +required Name of the connection instance.
          connectionConfig: 19d2648b-d29c-4452-afdd-1b9311e81412
          # +required Environment variables injected into the component for connection configuration.
          env:
            # +required Key name of the connection configuration.
            - from: ServiceURL
              # +required Environment variable injected into the container.
              to: SERVICE_URL
    ```

    The descriptor-based approach of the `component.yaml` file simplifies and streamlines endpoint and connection configuration management. The use of versioned schemas ensures backward compatibility, providing a seamless transition with future updates.

    You can define the following root-level configurations via the `component.yaml` file:

    | Configuration        | Required     | Description                                                              |
    |----------------------|--------------|--------------------------------------------------------------------------|
    | **schemaVersion**    | Required     | The version of the `component.yaml` file. Defaults to the latest version.|
    | **endpoints**        | Optional     | The list of endpoint configurations.                                     |
    | **dependencies**     | Optional     | The list of dependency configurations.                                   |

    <h3> Endpoint configurations </h3>
    In the `endpoints` section of the `component.yaml` file, you can define multiple service endpoint configurations. Each endpoint must have a unique name and the required fields specified in the schema overview.

    !!! tip "Why have a unique name?"
          When you define multiple endpoints, the `endpoint.name` is appended to the Choreo-generated URL. A unique name ensures the endpoint is easily recognizable and readable within the URL.
          
    | Configuration           | Required     | Description                                                                                             |
    |-------------------------|--------------|---------------------------------------------------------------------------------------------------------|
    | **name**                | Required     | A unique identifier for the endpoint within the service component. Avoid using excessively long names.  |
    | **displayName**         | Optional     | A display name for the endpoint.                                                                        |
    | **service**             | Required     | Service details for the endpoint.                                                                       |
    | **.basePath**           | Required     | The base path of the API exposed via this endpoint.                                                     |
    | **.port**               | Required     | The numeric port value exposed via this endpoint.                                                       |
    | **type**                | Required     | The type of traffic the endpoint accepts. For example, `REST`, `GraphQL`, `gRPC`, `WS`, `UDP`, or `TCP`.|
    | **networkVisibilities** | Required     | The network-level visibility of the endpoint. For example, project, organization, or public.            |
    | **schemaFilePath**      | Required     | The file path to the swagger definition or AsyncAPI 2.0 specification file. Defaults to the wildcard route if not specified. This field should be a relative path to the project path when using **Java**, **Python**, **NodeJS**, **Go**, **PHP**, **Ruby**, or **WSO2 MI** buildpacks. For REST or WebSocket endpoint types, when using the **Ballerina** or **Dockerfile** buildpack, the path should be relative to the component root or Docker context. |

    <h3> Dependency configurations </h3>

    In the `dependencies` section of the `component.yaml` file, you can define multiple service connection configurations under `dependencies.serviceReferences`. You can use the service references generated in the inline developer guide when creating a service connection. For instructions on copying [connection configurations](https://wso2.com/choreo/docs/develop-components/sharing-and-reusing/use-a-connection-in-your-service/), see the inline developer guide displayed during connection creation.

    You must include the following configurations in the `dependencies.serviceReferences` schema:

    | Configuration        | Required     | Description                                                                      |
    |----------------------|--------------|----------------------------------------------------------------------------------|
    | **name**             | Required     | A unique name for the service reference.                                         |
    | **connectionConfig** | Required     | A unique name for the connection instance.                                       |
    | **env**              | Required     | The list of environment variable mappings to inject into the container.          |
    | **.from**            | Required     | The key name of the connection configuration.                                    |
    | **.to**              | Required     | The environment variable to inject into the container.                           |

    !!! note
        Choreo automatically generates connection configurations when you create a connection. The properties such as **name**, **connectionConfig**, and **env.from** are automatically generated. However, you must manually set the **env.to** value.

## Overview of the `component-config.yaml` file 

**File location**:

```bash
<build-context-path>/.choreo/component-config.yaml
```

**Sample `component-config.yaml` file content**:

```yaml
apiVersion: core.choreo.dev/v1beta1
kind: ComponentConfig
spec:
  # +optional Incoming connection details for the component (AKA endpoints).
  inbound:
    # +required Unique name for the endpoint.
    # This name will be used when generating the managed API
    - name: Greeting Service
      # +required Numeric port value that gets exposed via the endpoint
      port: 9090
      # +required Type of traffic that the endpoint is accepting.
      # Allowed values: REST, GraphQL, GRPC, TCP, UDP, WS.
      type: REST
      # +optional Network level visibility of the endpoint. Defaults to Public
      # Accepted values: Project|Organization|Public.
      networkVisibility: Public
      # +optional Context (base path) of the API that gets exposed via the endpoint.
      # This is mandatory if the endpoint type is set to REST, GraphQL or WS.
      context: /greeting
      # +optional The path to the schema definition file. Defaults to wildcard route if not specified.
      # This is only applicable to REST and WS endpoint types.
      # The path should be relative to the Docker context.
      schemaFilePath: greeting_openapi.yaml
  # +optional Outgoing connection details for the component.
  outbound:
    # +optional Defines the service references from the Internal Marketplace.
    serviceReferences:
      # +required Name of the service reference.
      - name: choreo:///apifirst/mttm/mmvhxd/ad088/v1.0/PUBLIC
        # +required Name of the connection instance.
        connectionConfig: 19d2648b-d29c-4452-afdd-1b9311e81412
        # +required Environment variables injected to the component for connection configuration.
        env:
          # +required Key name of the connection configuration.
          - from: ServiceURL
            # +required Environment variable injected to the container.
            to: SERVICE_URL
```

The `component-config.yaml` file complements and enhances the existing endpoint configuration process. It allows you to define how the endpoints (inbound connections) in your service are exposed and how your service connects to external services or components (outbound connections).

You can define the following root-level configurations via the `component-config.yaml` file:

| Configuration        | Required     | Description                                                                           |
|----------------------|--------------|---------------------------------------------------------------------------------------|
| **apiVersion**       | Required     | The version of the `component-config.yaml` file defaults to `core.choreo.dev/v1beta1`.|
| **kind**             | Required     | The resource type of the file defaults to `ComponentConfig`.                          |
| **spec.inbound**     | Optional     | The list of inbound connection configurations.                                        |
| **spec.outbound**    | Optional     | The list of outbound connection configurations.                                       |

#### Inbound connection configurations (`spec.inbound`)

In the `spec.inbound` configuration section, you can specify endpoints to set up inbound connections. To specify endpoints, you can follow the existing endpoints schema structure. For details on the endpoints schema structure, see the [endpoints schema documentation](#overview-of-the-endpointsyaml-file).

#### Outbound connection configurations (`spec.outbound`)

In the `spec.outbound` section, you can define `serviceReferences`. To define `serviceReferences`, you can use the service references generated in the Internal Marketplace when creating a service connection. To copy the [outbound connection configurations](../sharing-and-reusing/use-a-connection-in-your-service/#use-a-connection-in-your-service), see the inline developer guide displayed when you create a connection.

You must include the following configurations in the `serviceReferences` schema:

| Configuration        | Required     | Description                                                                      |
|----------------------|--------------|----------------------------------------------------------------------------------|
| **name**             | Required     | A unique name for the service reference.                                         |
| **connectionConfig** | Required     | A unique name for the connection instance.                                       |
| **env**              | Optional     | The list of environment variable mappings to inject into the container.          |
| **env.from**         | Required     | The key name of the connection configuration.                                    |
| **env.to**           | Required     | The environment variable to inject into the container.                           |

## Overview of the `endpoints.yaml` file

**File location**:

```bash
<build-context-path>/.choreo/endpoints.yaml
```

**Sample `endpoints.yaml` file content**:

```yaml
# +required Version of the endpoint configuration YAML
version: 0.1

# +required List of endpoints to create
endpoints:
  # +required Unique name for the endpoint.
  # This name will be used when generating the managed API
- name: Greeting Service
  # +required Numeric port value that gets exposed via this endpoint
  port: 9090
  # +required Type of the traffic this endpoint is accepting.
  # Allowed values: REST, GraphQL, GRPC, UDP, TCP, WS.
  type: REST
  # +optional Network level visibility of this endpoint. Defaults to Public
  # Accepted values: Project|Organization|Public.
  networkVisibility: Project
  # +optional Context (base path) of the API that is exposed via this endpoint.
  # This is mandatory if the endpoint type is set to REST, GraphQL or WS.
  context: /greeting
  # +optional Path to the schema definition file. Defaults to wild card route if not provided
  # This is only applicable to REST and WS endpoint types.
  # The path should be relative to the docker context.
  schemaFilePath: greeting_openapi.yaml
```

The `endpoints.yaml` configuration file allows you to define configurations for multiple endpoints necessary for Choreo service components. This schema is essential to identify the context, port binding, network exposure level, and other attributes required to generate a Choreo endpoint.

You can define the following root-level configurations via the `endpoints.yaml` file:

| Configuration        | Required     | Description                                                                       |
|----------------------|--------------|-----------------------------------------------------------------------------------|
| **version**          | Required     | The version of the `endpoints.yaml` file.                                         |
| **name**             | Required     | A unique name for the endpoint, which Choreo will use to generate the managed API.|
| **port**             | Required     | The numeric port value that gets exposed via this endpoint.                       |
| **type**             | Required     | The type of traffic this endpoint accepts, such as `REST`, `GraphQL`, `gRPC`, `WS`, `UDP`, or `TCP`. Currently, the MI preset supports only the `REST` type.                                         |
| **networkVisibility**| Required     | The network level visibility of this endpoint, which defaults to `Public` if not specified. Accepted values are `Project`, `Organization`, or `Public`.|
| **context**          | Required     | The context (base path) of the API that Choreo exposes via this endpoint.         |
| **schemaFilePath**   | Required     | The swagger definition file path. Defaults to the wildcard route if not provided. This field should be a relative path to the project path when using the **Java**, **Python**, **NodeJS**, **Go**, **PHP**, **Ruby**, and **WSO2 MI** buildpacks. For REST endpoint types, when using the **Ballerina** or **Dockerfile** buildpack, this field should be a relative path to the component root or Docker context.|

## Update to the latest source configuration file

With the upcoming deprecation of the `component-config.yaml` file and the `endpoints.yaml` file, Choreo provides a seamless process to move to the latest `component.yaml`  version of the `component.yaml` file. Follow these steps to transition seamlessly:

### Step 1: Identify whether your current source configuration file is outdated

You can determine whether you’re using an outdated configuration file in the following ways:

- **During a build:**
     - On the **Build** page, after triggering a build, a warning will appear if your source configuration file is outdated. Click **View Details** in the **Initialization** -> **Source Config Validation** step. You will see an information banner with an option to update the file.

- **In existing deployments:**
     - If an existing deployment uses a build with an outdated source configuration file, you will see a warning icon on the build card of the relevant environment card.


### Step 2: Generate the latest `component.yaml` file

- In either of the scenarios above, click **Update** to initiate the process of generating the latest `component.yaml` file. The updated file will retain your existing configurations to ensure a smooth update process.


### Step 3: Add the generated configuration file to your repository

1. Download the generated `component.yaml` file.
2. Replace the existing source configuration file in the `.choreo` folder within your source repository.
    - Ensure the file name is `component.yaml`.


### Step 4: Trigger a new build

1. Commit the new `component.yaml` file to your repository. Push changes to the remote Git repository.
2. Trigger a build using the latest commit.


### Step 5: Verify the update

Once the build is complete:

  - Deploy the build.
  - Confirm that the warning messages no longer appear.

You can benefit from the latest features and enhancements provided by the updated source configuration file.


# Manage Deployment Tracks for Choreo Components

Choreo allows you to create and manage dedicated [deployment tracks](../choreo-concepts/deployment-tracks.md) for components, facilitating independent version control and deployment. This capability also allows you to unlink deployment tracks from associated branches or relink them to different branches so that you can align with your preferred Git workflows, such as the feature branch workflow or GitFlow workflow.

!!! info
     Deployment track creation and management does not apply to API Proxy and [BYOI components](../develop-components/bring-your-own-image.md).

## Create a deployment track

**Prerequisites**:

 - Create a component in Choreo.

Follow the steps below to create a deployment track for a component:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to create a deployment track for.
3. On the header of the component overview page, click the **Deployment Track** drop-down list.
4. Click **+ Create New** to open the **Create Deployment Track** dialog.
5. In the **Create Deployment Track** dialog, do the following:
    1. Select a branch to associate with the deployment track.
    2. Optionally, specify a description for the deployment track. 
    3. To create a deployment track for a service component, specify a unique API version indicating the major and minor version numbers.
6. Click **Create**.

## Unlink a deployment track

If you want to detach a branch reference from a deployment track, you must unlink the branch.

!!! info
     When you unlink the branch of a deployment track, the active deployments are unaffected. However, while you can redeploy the existing deployment, you cannot perform a new deployment.

Follow the steps below to unlink a deployment track of a component:
  
1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to unlink a deployment track.
3. On the header of the component overview page, click the **Deployment Track** drop-down list and then click **View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
4. Click the edit icon corresponding to the deployment track you want to unlink.
5. In the **Edit Branch** dialog that opens, click the **Branch Name** list and select **None**.
6. Click **Save**.

## Link a deployment track

To associate a branch reference to an unlinked deployment track, you must link a branch.

!!! info
    To build and deploy the contents of the linked branch,  you must perform a manual build and deploy.

**Prerequisites**:

 - A minimum of two branches in your GitHub repository.

Follow the steps below to link a branch to an unlinked deployment track:
  
1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to associate a branch reference for.
3. On the header of the component overview page, click the **Deployment Track** drop-down list and then click **View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
4. Click **+ Link Branch** corresponding to the unlinked deployment track for which you want to associate a branch.
5. In the **Link Branch** dialog that opens, click the **Branch Name** list and select the branch you want to relink.
6. Click **Save**.

## Relink a deployment track

To switch the branch reference of a linked deployment track, you must relink to an appropriate branch.

!!! info
      If you unlink the existing branch of a deployment track and link a different branch, you must perform a manual build and deploy to build and deploy the contents of the recently linked branch.

**Prerequisites**:

 - A minimum of two branches in your GitHub repository.

Follow the steps below to switch the branch reference of a linked deployment track:
  
1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to relink a deployment track for.
3. On the header of the component overview page,  click the **Deployment Track** drop-down list and then click **View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
4. Click the **Edit Branch** icon corresponding to the deployment track you want to relink.
5. In the **Edit Branch** dialog that opens, click the **Branch Name** list and select the branch you want to relink.
6. Click **Save**.

Now that you understand how to create and manage deployment tracks for components, let’s explore a sample scenario to see how a developer can use deployment tracks to manage version releases in Choreo.

## Sample Scenario: Manage version releases with deployment tracks

Let’s consider the following version release scenario: 

- To initiate work on a new feature, a developer creates a new branch, named `feature-x` from either the `main` or `dev` branch.
- Once development is complete, the developer proceeds to merge the `feature-x` branch into the `dev` branch for testing.
- Upon successful testing in the `dev` branch, the developer proceeds to merge all the changes into the `main` branch for production deployment.

Following are the actions you need to take from a deployment track perspective to manage the version release:

1. To prepare for the new version release, unlink the `main` branch from the associated deployment track (let’s consider this as the deployment track 1).
2. Proceed to merge the `dev` branch containing the tested changes into the `main` branch.
3. Unlink the `dev` branch from the associated deployment track (let’s consider this as deployment track 2).
4. Link deployment track 2 containing the latest version of the service to the `main` branch for deployment.
5. To facilitate ongoing development and testing, create another deployment track (let’s consider this as deployment track 3) and link it to the `dev` branch.

!!! tip
     - As a developer, you can strategically unlink and relink deployment tracks to effectively manage different versions of your services within Choreo.
     - You can create new deployment tracks for ongoing development branches like `dev` to ensure a continuous development and release cycle.

## Delete a deployment track

If you no longer need a deployment track, you can delete it.

!!! note
    If the component exposes an endpoint or proxy and you want to delete the last version in the major version range, the recommended approach is to retire that version first. This allows consumers to transition to the next major version and prevents a sudden break in their experience.
    For example, if you have deployment tracks for v1.0 and v2.0, notify consumers to switch to v2.0 before deleting v1.0. Then, retire the APIs in v1.0 and proceed to delete the associated deployment track.




**Prerequisites**:

- At least 2 deployment tracks in a component.

Follow the steps below to delete a deployment track:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to delete a deployment track.
3. On the header of the component overview page, click the **Deployment Track** drop-down list.
4. Click **+ View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
5. Click the **Delete** icon corresponding to the deployment track you want to delete.
6. Click **Delete** to confirm the deletion.

# Manage the Micro Integrator Runtime Version in Your Integration Project

Choreo allows you to use a preferred WSO2 Micro Integrator (MI) runtime version in your integration project. Currently, Choreo supports MI product versions 4.1.0 and 4.2.0. You have the flexibility to deploy WSO2 updates within these specified versions. 

When you create an integration project, you can specify a required runtime version to gain control over the environment in which your integration runs. This version management capability empowers you to tailor your projects depending on your runtime requirements, enhancing the customization and adaptability of your integration workflows.

## Understand the version string

WSO2 Micro Integrator (MI) utilizes a versioning system consisting of three-digit numbers, such as `4.1.0` and `4.2.0`, following semantic versioning principles. The product remains committed to receiving updates from WSO2, including security fixes, bug resolutions, and enhancements. Within the Choreo platform, the MI runtime version is constructed by combining the product release version with its corresponding update level.

In Choreo, the MI runtime version is structured as a four-digit number, for example, `4.1.0.14` or `4.2.0.17`. The first three digits represent the product release version, while the last digit signifies the update level of the product. The fourth digit is optional and can be omitted.

![Version string](../assets/img/develop-components/micro-integrator/version-string.png)

## Version management in WSO2 Integration Studio

If you are using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/) to build and deploy integration artifacts in WSO2 Micro Integrator, you can create multiple runtime environments and execute projects on any selected environment. WSO2 Integration Studio also allows you to configure multiple Micro Integrator runtime environments, offering flexibility and customization in the execution of integration processes.

You can specify the Runtime version when you create an integration project in WSO2 Integration Studio. In the project creation wizard, specify the runtime version in the **Runtime version** field, as shown below.
![Specify Runtime version](../assets/img/develop-components/micro-integrator/specify_runtime_version.png)


An integration project is structured as a Maven project with multiple sub-modules. The root `pom.xml` file holds crucial information about the target runtime. The runtime version you configure when you create a new project is saved within the root `pom.xml` file. The version information is stored in the <project.runtime.version> element under the <properties> in the `pom.xml` file. If there is a need to update the runtime version, you have the flexibility to modify the value to a valid runtime version and ensure that the project runs in the required runtime environment.

![project runtime version](../assets/img/develop-components/micro-integrator/project-runtime-version.png)

You can establish multiple runtime environments by utilizing updated MI instances. With a valid WSO2 subscription, you can also access and download updates to set up an updated MI server locally. This update process allows you to select a preferred update level as the runtime version. Consequently, you can run your integration on a runtime with the latest updates, ensuring optimal performance and access to new features.

### Configure a Micro Integrator runtime environment in Integration Studio

If you are using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), follow these steps to set up a remote server instance with a Micro Integrator runtime environment to execute your integration project:

!!! info "Note"
    If you have not downloaded and installed WSO2 Integration Studio, you can follow the [installation instructions](https://apim.docs.wso2.com/en/latest/integrate/develop/installing-wso2-integration-studio/) in the WSO2 API Manager documentation.

1. Launch WSO2 Integration Studio and click **Add Server** in the **Getting Started** view.
   ![Add server](../assets/img/develop-components/micro-integrator/add-server.png)
2. In the **Define a New Server** dialog, click to expand the `WSO2` directory and select **WSO2 Remote Server**.
   ![Define a remote server instance](../assets/img/develop-components/micro-integrator/define-a-remote-server-instance.png)
3. Enter the WSO2 Micro Integrator Management API URL in the **Server URL** field and click **Test Connection**.

    !!! info "Note"
        The Management API of WSO2 Micro Integrator is an internal REST API introduced to substitute MI admin services. The default HTTPS port of the Management API of WSO2 Micro Integrator is `9164`. If you have not manually changed the default port, you must set the Management API URL as `https://localhost:9164/management`.  If you have changed the default HTTPS port, you must set the port number appropriately when specifying the **Server URL**. For more information on the default ports of WSO2 Micro Integrator, see [WSO2 Micro Integrator default ports](https://apim.docs.wso2.com/en/latest/install-and-setup/setup/reference/default-product-ports/#micro-integrator-ports) in the WSO2 API Manager documentation.

    ![Set server URL](../assets/img/develop-components/micro-integrator/set-server-url.png)
    
4. Click **Finish**.
5. In the **Add and Remove** dialog, select the integration components to move from the left side to the right side.
6. Click **Add >**.
7. Click **Finish**. 

Your integration project is now running in a remote server instance with the Micro Integrator runtime environment you require.
If you need to make changes to the integration project, expand the remote server instance, right-click on the deployed exporter project, and select **Redeploy** to apply the changes.

![Redeploy project](../assets/img/develop-components/micro-integrator/redeploy-project.png)

## Convention for version interpretation in Choreo deployments

You can use the following convention to indicate the required MI runtime version in your integration project:


| **Version format**           | **Example**       | **Description**   |
|------------------------------|-------------------|-------------------|
| Product version              | `4.1.0`, `4.2.0`  | Deploy on the latest update level of the mentioned product version.                 |
| Product version with update level  | `4.1.0.15`, `4.2.0.17` |  Deploy on the exact update level of the mentioned product version.    |
| GA version                   | `4.1.0.0`, `4.2.0.0` | Deploy on the exact GA version without any update.                  |
| Default version            | Empty value         | Deploy on the latest update level of the default product version.                  |


Choreo utilizes Alpine images for configuring and deploying the Micro Integrator runtime. This includes automated configuration of the JRE/JDK, customized to the compatibility of the chosen runtime version, simplifying the setup procedure.

## Migrate between runtime versions

Changing the runtime version in an integration project may become necessary during product version upgrades or when you want to apply updates. 

To change the runtime version of a MI Integration, follow the below steps.

### Update the runtime version in the integration project
    
To change the runtime version in the integration project, follow the steps below:
1. Open the project in Integration Studio.
2. Right-click on the project and select **Change Runtime MI Version**.
    ![Update Runtime version](../assets/img/develop-components/micro-integrator/click_change_runtime.png)
3.  Specify the new runtime version as shown below:
    ![Update Runtime version](../assets/img/develop-components/micro-integrator/update_runtime_version.png)
4. Alternatively, you can manually update the version by opening the root `pom.xml` file.  Open pom.xml and change the required runtime version in `<project.runtime.version>` element under `<properties>` section.

To test the changes locally, you must download and set up the runtime environment locally. Then, you must [configure the Integration Studio runtime environment](#configure-a-micro-integrator-runtime-environment-in-integration-studio) by directing it to the locally installed MI runtime. Once the setup is complete, you can deploy your integrations on the MI runtime environment and proceed to the testing phase.

After completing the tests to ensure everything works as expected, you can follow below steps to deploy the project in Choreo:

1. Commit and push the changes to your repository.
2. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
3. Select your project from the **Project** list in the header.
4. Select your MI integration component from the **Component** list in the header.
5. In the left navigation menu, click **Build**.
6. Select the latest commit and click **Build**.
7. In the left navigation menu, click **Deploy**.
8. Click on the **Configure and Deploy** and deploy the component.
9. Verify the Runtime version by checking the logs by selecting the **Runtime Logs** under the **Observability** section.

  You will see the runtime version in the logs as shown below:
  ![Runtime version in logs](../assets/img/develop-components/micro-integrator/runtime_version_in_logs.png)

Next, you must conduct additional testing in the development environment on Choreo before you promote the integration to production environments.

## Troubleshoot errors

The following error codes can help you troubleshoot errors that occur during the integration component build:

| **Error code** | **Description**            |
|----------------|----------------------------|
| 110 - 119      | Internal server error.     |
| 121            | Malformed runtime version. |
| 122            | The specified runtime version is not available. Either the product or update level is not available.    |
| 123            | Trivy security vulnerabilities found in the `libs` directory. |
| 124            | Trivy security vulnerabilities found in the `dropins` directory. |
| 125            | Trivy security vulnerabilities found in the `libs` or `dropins` directory. |
| 126            | Error building integration project. |


# Submit and Manage Workflow Approval Requests

In Choreo, if an administrator [configures a workflow to require approval](../administer/configure-approvals-for-choreo-workflows.md), you must submit a request to obtain approval to perform the task.

Upon submitting a workflow approval request, Choreo notifies all authorized assignees via email about the [review request](../administer/review-workflow-approval-requests.md). When an authorized assignee approves or rejects the request, you will receive an email with details of the decision.

The approach to request approval can vary depending on the workflow. 

## Request approval for environment promotion

**Prerequisites**:

- Ensure you have a component created, built, and deployed to the development environment.
- Ensure that an approval workflow is configured for environment promotion.
- Ensure you are promoting the component to a critical environment, such as production.

To request approval to promote a component from the development environment to production, follow these steps:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to deploy. This takes you to the **Overview** page of the component.
3. In the left navigation menu, click **Deploy**.
4. Go to the **Development** card and click **Request to Promote**.
5. In the **Request Approval** pane that opens, enter your request details and click **Submit**. This creates a request and notifies all authorized assignees via email about the request.

    !!! note
         When an environment promotion request for a specific component is pending review, Choreo restricts other developers from making the same request until the pending request is either approved or rejected.

When an authorized assignee approves the request, you will receive a confirmation email and can proceed to promote the component to production.

## Cancel a workflow approval request

If you want to cancel a workflow approval request that is already submitted, you can do so before the request is approved or rejected. 

When you submit a workflow approval request, the **Request to Promote** button changes to **Cancel Request**. To cancel an approval request, click **Cancel Request**. Upon confirming the cancellation, all configured approvers are notified immediately, and the request will no longer be pending.


# Work with the Micro Integrator Runtime in Choreo

WSO2 Micro Integrator (WSO2 MI) is a lightweight, high-performance integration runtime. It allows you to run integrations developed using WSO2 Integration Studio within Choreo. 

The topics on this page walk you through the key aspects you need to understand to use the WSO2 MI runtime effectively in Choreo.

## Integration types

Choreo supports the following WSO2 MI integrations that cater to different use cases and requirements. Each integration type serves a specific purpose. Therefore, it is essential to understand their differences to easily choose the most appropriate integration for your use case.

- **Service**: Exposes an integration as an API via HTTP, making it possible to create a RESTful interface for your integration services. This type is ideal for scenarios where you need to provide an API for external systems or clients to interact with your integration.
- **Event Handler**: Triggers an integration based on external events such as messages arriving on a queue or updates in a database. This type is well-suited for implementing event-driven architectures or responding to changes in your system's environment.
- **Scheduled Task**: Runs an integration automatically at predefined time intervals, ensuring that specific integration tasks occur at regular intervals. This type is ideal for batch processing, data synchronization, or periodic maintenance tasks.
- **Manual Task**: Initiates an integration via user action, giving you full control over when the integration executes. This type is useful for on-demand tasks, testing, or debugging purposes.

## Develop integrations with WSO2 Integration Studio

[WSO2 Integration Studio](https://wso2.com/integration/integration-studio/) is a powerful, Eclipse-based graphical development environment that enables you to build and deploy integration artifacts in WSO2 Micro Integrator. This comprehensive IDE offers a robust set of tools for designing and testing integration flows and crafting integration artifacts. By utilizing the visual, drag-and-drop capabilities of WSO2 Integration Studio, developers can significantly reduce the time and effort needed to construct and deploy integration flows.

In addition to streamlining the development process, Integration Studio offers features such as debugging, testing, and version control to ensure the quality and reliability of integration flows. By creating an Integration project and Composite Exporter project in WSO2 Integration Studio, developers can export their integration projects as a single deployment artifact, known as a composite application. This composite application encompasses all the components and configurations necessary for deploying the integration project to WSO2 Micro Integrator.

The Composite Exporter project simplifies the deployment process by allowing developers to package their integration projects as a single, self-contained artifact that can be easily deployed and managed. This approach enhances the consistency and reliability of integration projects while streamlining the overall deployment process.

To start developing integrations with WSO2 Micro Integrator, see [WSO2 Micro Integrator documentation - Developing Integration Solutions](https://mi.docs.wso2.com/en/latest/develop/intro-integration-development/).

## Integration project directory structure

An Integration Project in WSO2 Integration Studio is a multi-module Maven project that can contain multiple modules with WSO2 Synapse configurations and a composite application module to export all the configurations as a single deployable artifact.

An integration project directory structure includes the following key components:

 - WSO2 Synapse configurations: These modules contain the essential configurations for the integration project.
 - Composite Application module: This module is responsible for exporting all the Synapse configurations as a single deployable artifact.

Optionally, you can include the following components in your integration project:

 - OpenAPI definition file: You can add the OpenAPI definition file to any location within the project. When creating a component, you'll need to define the path to this file. Choreo will automatically generate an OpenAPI definition for you based on your integration project, if you don't provide one.
 - Java libraries: If your integration project requires additional Java libraries, you can add them to the libs directory located in the project root.
 - deployment.toml file: This optional configuration file allows you to customize the preconfigured settings of WSO2 MI instances running on Choreo. By including this file, you can tailor the behavior of your WSO2 MI instances to better suit your project's specific requirements.

Understanding the Integration Project directory structure is crucial for organizing your project and ensuring that all necessary components are included in the final deployable artifact.

## OpenAPI support

OpenAPI Support plays a crucial role in enhancing the functionality of integrations exposed as APIs. By providing an OpenAPI definition for your exposed integration, you can streamline testing and management processes, ensuring a more efficient and user-friendly experience. Choreo will automatically generate an OpenAPI definition for you based on your integration project, if you don't provide one, saving you time and effort.

To incorporate OpenAPI support, store the OpenAPI definition file within the repository hosting your Integration Studio project. When creating the project, simply point to the file's location in the repository. If needed, you can change the location of the OpenAPI definition file later via the deploy page.

![Open API file](../assets/img/develop-components/micro-integrator/openapi_file.png)

By leveraging OpenAPI Support, you can optimize the way you test and manage your integrations, resulting in a more efficient development process and a smoother user experience.

## Work with third-party libraries

The use of third-party libraries in your Micro Integrator project can offer several advantages, such as enhanced functionality, improved integration capabilities, optimized performance, and reduced development time.

Here are some of the benefits of adding third-party JARs to the Micro Integrator:

 - Increased functionality: Third-party libraries can extend the core Micro Integrator distribution, allowing for greater flexibility and customization of integration solutions.
 - Enhanced integration capabilities: Third-party libraries enable the Micro Integrator to interact with existing systems such as databases or other APIs, improving overall integration capabilities.
 - Optimized performance: By offering optimized implementations of common functions, third-party libraries can improve the performance of the Micro Integrator.
 - Efficient development: Developers can avoid re-implementing commonly used functions, reducing development time and increasing efficiency.

To incorporate third-party libraries into your Micro Integrator project, create a new directory called `libs` at the
root of your project. If your project root and GitHub repository root are not the same, place the `libs` directory in
the project root. After adding the required JAR files to the `libs` directory, the Micro Integrator runtime will
automatically include them when deploying the component. This process ensures that any dependencies needed by your
integration flow are available at runtime.

In addition to `jar` libraries, you may also need to incorporate OSGi bundle JARs into your project. To do this,
create another directory called `dropins` at the root of your project. Similarly, if the project root and GitHub
repository root differ, place the `dropins` directory in the project root. Within the `dropins` directory, add the OSGi
bundle JAR files. The OSGI runtime will pick up these bundles during deployment, enabling you to utilize their
functionality within your Micro Integrator project.

![Libs directory](../assets/img/develop-components/micro-integrator/libs_dir.png)

## Importing custom certificates to MI

The feature enables Choreo MI users to import certificates into the MI `client-truststore.jks` file. This functionality
proves valuable when users need to establish connections with servers or services utilizing SSL/TLS encryption and
possessing self-signed certificates or certificates issued by private certificate authorities (CAs) that are not
automatically trusted. Importing the certificate to the MI `client-truststore.jks` file enables MI clients to establish secure connections with
the server or service seamlessly, eliminating SSL/TLS errors or warnings.

Before importing the certificate, it is necessary to obtain the certificate file, which can be in PEM or DER format. You
can get the certificate from the server or service provider or export it from a web browser. Certificates should be
added to the `/wso2mi/certs/` folder. Users need to verify that the mount path for the certificate file aligns with this
specific path.

1. In the Choreo console, select the component you wish to add a certificate to.
2. From the left navigation click **Deploy**.
3. Click on the **Configs and Secrets** tab.
4. Click **Create**.
5. Select **ConfigMap** as the **Config Type** and **File Mount** as the **Mount Type**.
6. Click **Next**.
7. Specify the following values as mount configurations:

    | **Field**       | **Value**                                              |                                    
    |-----------------|--------------------------------------------------------|
    | **Config Name** | An appropriate name for the certificate.             |
    | **Mount path**  | `/wso2mi/certs/<filename>`. For example, `/wso2mi/certs/certificate.crt` |

8. Click **Upload File** and attach the certificate.
9. Click **Create**.

## Working with sensitive data using MI Secure Vault

MI Secure Vault is a feature that allows users to securely store sensitive data, such as passwords and tokens, and
provide access to that data to MI Integrations. This feature provides an added layer of security to your integrations by
reducing the risk of accidental exposure of sensitive data.

To use MI Secure Vault to work with sensitive data, follow these steps:

1. Select the component from the Choreo Console.
2. From the left navigation, click Deploy.
3. Click on the **Configure and Deploy**.
4. Click on the **Add Environment Configurations**
5. Specify the following values as configurations:

    | **Field**       | **Value**                                 |                                    
    |-------------------------------------------|--------------------------------------------------------|
    | **Name** | An appropriate name for the secret/alias. |
    | **Value**       | Value for the secret                      |

6. Select **Mark as a Secret**.
7. Click **Add**.
8. Click **Deploy**.
9. Once the secret has been created, you can access it in your integration code using the following syntax:

```xml
<property name="secret_value_1" expression="wso2:vault-lookup('user_pass')" scope="default" type="STRING"/>
```
This code retrieves the secret named "user_pass" from the MI Secure Vault and stores it in the property named "
secret_value_1". You can then use this property in your integration code to access the secret value.

For more information on these features, see the [Accessing secrets](https://mi.docs.wso2.com/en/latest/install-and-setup/setup/security/encrypting-plain-text/#step-3-accessing-secrets) section of the MI Secure Vault documentation. By using MI
Secure Vault to store and access sensitive data in your integrations, you can ensure that your integrations
remain secure and protect sensitive data from unauthorized access.


## Scan third-party libraries to identify security vulnerabilities

Scanning third-party libraries for security vulnerabilities is essential for identifying potential weaknesses in an application that could be exploited by attackers. Taking a proactive approach to security helps organizations detect and mitigate risks before they can be exploited, preventing data breaches, system compromises, and other security incidents.

Choreo incorporates a security vulnerability scanning process during deployment. It uses Trivy to scan and detect critical vulnerabilities in third-party libraries added to the integration component. If the scan uncovers any critical vulnerabilities, the deployment process is halted. The deployment pane displays the Trivy scan status and any security failures in the Library (Trivy) vulnerable scan step, which can be accessed by clicking on it. Once the vulnerability has been addressed, you can redeploy the component.

## Customize WSO2 Micro Integrator preconfigured settings

Customizing WSO2 Micro Integrator Preconfigured Settings is essential for ensuring that the integration solution works optimally within the specific context of your organization. While WSO2 MI comes with preconfigured settings designed for general use, these settings may not be suitable for every organization's unique requirements. Customizing these settings can help optimize performance and ensure compatibility with your organization's systems and applications.

To customize the preconfigured settings of WSO2 MI instances running on Choreo, define a `deployment.toml` file in the GitHub repository subpath of your Micro Integrator project:

![deployment.toml](../assets/img/develop-components/micro-integrator/config_file.png)

!!! note
    If you change critical configuration parameters such as port offset and hostname, it can break internal communication.
    Therefore, the recommended approach is to update only the necessary configuration parameters.

Given below is a sample `deployment.toml` file that can be used to configure the JMS transport. For more information on WSO2 MI
configuration parameters, see the [MI Configuration Catalog](https://mi.docs.wso2.com/en/latest/reference/config-catalog-mi/).

```
[[transport.jms.sender]]
name = "myQueueSender"
parameter.initial_naming_factory = "org.apache.activemq.jndi.ActiveMQInitialContextFactory"
parameter.provider_url = "$env{JMS_PROVIDER_URL}"
parameter.connection_factory_name = "QueueConnectionFactory"
parameter.connection_factory_type = "queue"
parameter.cache_level = "producer"

[[transport.jms.listener]]
name = "myQueueListener"
parameter.initial_naming_factory = "org.apache.activemq.jndi.ActiveMQInitialContextFactory"
parameter.provider_url = "$env{JMS_PROVIDER_URL}"
parameter.connection_factory_name = "QueueConnectionFactory"
parameter.connection_factory_type = "queue"
parameter.cache_level = "consumer"
```

## Environment variables

Using environment variables is a recommended practice when developing integration artifacts with WSO2 Integration Studio, as it improves configuration management, security, portability, and manageability. By leveraging environment variables, organizations can streamline the management and maintenance of their integrations, ensuring that updates can be implemented quickly and efficiently.

The component's Deploy page provides a user-friendly interface to manage environment variables across different environments. For information on managing environment variables for complex use cases, see [Configurations and secrets](../devops-and-ci-cd/manage-configurations-and-secrets.md).

![Environment variables](../assets/img/develop-components/micro-integrator/env_variables.png)

Environment variables offer several benefits:

 - Configuration management: They simplify the process of managing and updating configuration settings, making it easier to maintain consistency across different environments.
 - Security: Environment variables help protect sensitive information by storing it securely and separating it from the main codebase.
 - Portability: By using environment variables, you can ensure that your integration artifacts can be easily migrated and deployed across various environments with minimal changes.
 - Manageability: Environment variables offer a centralized way to manage configuration settings, making it easier to update and maintain your integrations over time.

For a comprehensive list of parameters that can be configured as environment variables, see [WSO2 Micro Integrator documentation - Injecting Parameters - Supported parameters](https://mi.docs.wso2.com/en/latest/develop/injecting-parameters/#supported-parameters).

## Configure logging

Configuring logging is crucial when developing and maintaining a software system, as it can significantly improve efficiency during the development, testing, and maintenance phases of the software development process. Logging captures events and messages that occur during an application's execution, providing valuable insights for troubleshooting and debugging issues.

With Micro Integrator instances, you can configure and customize logging according to your requirements. Logging configurations can be added to each MI instance's environment, allowing you to fine-tune logging depending on the specific environment or deployment scenario.

To configure logging in MI instances, follow the steps given below: 

!!! tip
     You can use environment variables with specific naming conventions.

1. Start the variable name with `logging_level_` followed by the package or class name.
2. Replace the dot character in the package name with an underscore.
3. Set the variable value to the required logging level for the corresponding package or class.

    For example, to enable wire logs, change the logging level of the `org.apache.synapse.transport.http.wire` package to `debug`. 

To configure logging, set the environment variable as follows:

1. In the left navigation menu, click **Deploy** and then click **Configs & Secrets**. 
2. Click **+ Create**. 
3. Select **ConfigMap** as the **Config Type** and **Environment Variables** as the **Mount Type**. 
4. Click **Next**. 
5. Specify the following values as mount configurations:

    | **Field**       | **Value**                                              |                                    
    |-----------------|--------------------------------------------------------|
    | **Config Name** | An appropriate name for the configuration.             |
    | **Name**        | `logging_level_org_apache_synapse_transport_http_wire` |
    | **Value**       | `debug`                                                |

6. Click **Create**.

## Connectors

WSO2 Micro Integrator (MI) Connectors are prebuilt connectors designed to simplify integration between WSO2 MI and various other systems. They enable seamless connections to databases, message brokers, REST APIs, and more, allowing you to perform actions such as sending messages, executing queries, or retrieving data. These connectors are easy to use, making it straightforward to incorporate them into your WSO2 MI integration flows. Micro Integrator connectors are versatile and can be utilized in various integration scenarios, including data integration, service-oriented architecture (SOA) integration, and event-driven architecture (EDA) integration.

WSO2 Integration Studio is a comprehensive development environment that facilitates the creation of integration flows using WSO2 Micro Integrator Connectors. With Integration Studio, you can design and implement integration flows that connect diverse systems and execute various actions, such as sending messages, executing queries, or retrieving data. You can build integration flows using either prebuilt connectors provided by WSO2 MI or custom connectors developed using the Connector Development Toolkit. Integration Studio offers a graphical user interface that simplifies the process of building and testing integration flows while also providing a set of tools for managing and deploying these flows in a WSO2 MI runtime environment.

For more information, see the following topics in the WSO2 Micro Integrator documentation.

- [Connectors Overview](https://mi.docs.wso2.com/en/latest/reference/connectors/connectors-overview/)
- [Adding Connectors](https://mi.docs.wso2.com/en/latest/develop/creating-artifacts/adding-connectors/)

## Deploying integrations in Choreo 

WSO2 MI buildpack is where you can deploy integrations developed with WSO2 Micro Integrator as an API. In this preset, you have three different ways to define endpoints. Choreo gives priory to the definition of endpoints in the below-mentioned order. 

1. **Using component.yaml file**
This is the most flexible method to define endpoints. You can configure the endpoint details with the `component.yaml` configuration file. Place this file in the `.choreo` directory in the project path of the component. 
If the Micro Integrator project has inbound endpoints, you can expose them via different endpoints using the `component.yaml`file.

    To learn about the `component.yaml` file, see [Overview of the component.yaml file](../develop-components/manage-component-source-configurations.md#overview-of-the-componentyaml-file).

3. **Auto generating endpoints**
If `component.yaml` is not provided and if the source Micro Integrator project has APIs, Choreo scans the project and generates the API endpoints. If the project has few APIs, an endpoint will be generated for each API. The visibility of this auto-generated endpoint is set to `Public` by default. You can change the visibility in the deployment flow.

4. **Provide default endpoints**
If `component.yaml` is not provided and if the source Micro Integrator project doesn't have APIs, Choreo generates a default endpoint which will expose the default micro integrator port (8290) with `Public` visibility and wildcard context.

!!! note
    If you are currently using `component-config.yaml` or `endpoints.yaml` configuration files, see the respective [migration guide](../develop-components/manage-component-source-configurations.md#migration-guide) for instructions on migrating to the recommended `component.yaml` configuration file.

## Explore Choreo examples on GitHub

For a hands-on experience with MI-based integrations in Choreo, we recommend exploring our samples in Choreo Console. You can filter out the samples based on the buildpack `WSO2 MI`. This will point you to the samples in the [Choreo samples GitHub repository](https://github.com/wso2/choreo-samples)

### [Choreo samples - GitHub Repository](https://github.com/wso2/choreo-samples)

- **Fork the Repository**: Start by forking the repository to your account.

- **Explore & run**: Navigate through the different integration scenarios. Each example has a README.md with setup and execution instructions.



# Develop a Manual Task

This guide walks you through the steps to develop, deploy, test, and observe a manual task using Choreo.

In this guide, you will:

- Develop a manual task to fetch the weather forecast for a specified location for the next 24 hours from the [OpenWeatherMap](https://openweathermap.org) API.
- Process the weather data into a specific format.
- Send the formatted data to a specified email address.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

    !!! info "Repository File Structure"
        The sample code for this guide is in the `<sample-repository-dir>/weather-to-email-integration` directory. The following table describes the key files in the repository:

        | **File Path**         | **File Content**                                                     |
        | --------------------- | -------------------------------------------------------------------- |
        | **Ballerina.toml**    | Contains metadata about the project                                  |
        | **Dependencies.toml** | Lists the dependencies required for the project                      |
        | **main.bal**          | Contains the entry point of the project, including the main function |
        | **types.bal**         | Contains custom data types used in the project                       |
        | **utils.bal**         | Contains utility functions and helper functions used in the project  |

3. Go to [OpenWeatherMap](https://openweathermap.org/) and sign up to obtain an API key. For details, see the [OpenWeatherMap documentation](https://openweathermap.org/appid#signup).

## Step 1: Create a manual task component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Manual Task** card.
6. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:

        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

7. Enter the following information:

    | **Field**             | **Description**                                      |
    | ----------------------| -----------------------------------------------------|
    | **Organization**      | Your GitHub account                                  |
    | **Repository**        | `choreo-samples`                                     |
    | **Branch**            | `main`                                               |
    | **Component Directory** | `weather-to-email-integration`                       |

8. Select **Ballerina** as the **Build Pack**.

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Component Directory** specifies the location of the project to build the component.

4. Enter a unique name and description for the component. You can use the following values:

    | **Field**          | **Value**                        |
    | ------------------ | -------------------------------- |
    | **Component Name** | `WeatherToEmail`                 |
    | **Description**    | `My first manual task`           |


8. Click **Create**. Choreo initializes the component with the sample implementation and opens the **Overview** page of the component.

## Step 2: Build the manual task

1. In the left navigation menu, click **Build**.
2. In the **Builds** pane, click **Build**. This opens the **Commits** pane, where you can see all the commits related to the component.
3. Select the latest commit and click **Build**. This triggers the build process and displays the build progress in the **Build Logs** pane.

    !!! info
        The build process may take some time. Once complete, the build status will be listed in the **Builds** pane. Here, you will see the build status as **Success**.

## Step 3: Deploy the manual task

1. In the left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane, specify values for the configurable variables:

    !!! tip
        The configurable variables populated here are defined in the sample Ballerina project used in this guide. To learn how to declare configurable variables in Ballerina, see the [Ballerina documentation on declaring configurable variables](https://ballerina.io/learn/by-example/configurable-variables/).

    | **Field**     | **Value**                                                               |
    | ------------- | ----------------------------------------------------------------------- |
    | **apiKey**    | The API key you obtained in the prerequisites section                   |
    | **latitude**  | Latitude of the location to get the weather forecast                    |
    | **longitude** | Longitude of the location to get the weather forecast                   |
    | **email**     | The email address to receive the formatted weather forecast information |

    !!! note
        If you use **Ballerina** as the buildpack and want to set a configurable variable as a secret, click the lock icon corresponding to the configurable variable. This marks it as a secret and conceals the input value.

        For example, if you set the **apiKey** as a secret, its input value will be concealed. To update the input value later, click **Update Secret Content** and specify a new value.

4. Click **Deploy**.

## Step 4: Execute the manual task

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the task.

    !!! info "Inject Dynamic Values into Your Application as Command-Line Arguments"
        If you want to inject dynamic values into your application as command-line arguments when you run a manual task, follow these steps:
        1. Click the drop-down icon next to **Run Now** and then click **Run with Arguments**.
        2. In the **Runtime Arguments** pane, enter the arguments you want to pass to your application.
        3. Click **Execute**. This triggers the task with the specified arguments.

        The capability to run a manual task with arguments is supported for the following buildpacks:

        === "Dockerfile"
            To explore a Dockerfile-based manual task with arguments, try out the [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/docker-hello-world-manual-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on Docker projects, the **Run with Arguments** capability is not supported if the Dockerfile contains `CMD`. In such scenarios, use `ENTRYPOINT` to define your default commands.

        === "Go"
            To explore a Go-based manual task with arguments, try out the [Hello World Go Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-go-task) sample. For instructions, see the `readme.md` file in the sample repository.

        === "Java"
            To explore a Java-based manual task with arguments, try out the [Hello World Java Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-java-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on Java projects:
                - The **Run with Arguments** capability is not supported if `Procfile` is available in the project.
                - The `Main` class should be defined in the `manifest` file.
                - If Maven files such as `mvn.cmd` exist in the project without the `.mvn` directory, the build will fail. To ensure a successful build, either commit the `.mvn` directory along with any Maven files or exclude Maven files if you choose not to commit the `.mvn` directory.

        === "NodeJS"
            To explore a NodeJS-based manual task with arguments, try out the [Hello World NodeJS Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-nodejs-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on NodeJS projects:
                - The **Run with Arguments** capability is not supported if `Procfile` is available in the project.
                - The project root must contain the `package.json` file with the `main` attribute defined.

        === "WSO2 MI"
            To explore a WSO2 MI-based manual task with arguments, try out the [Weather to Logs Task](https://github.com/wso2/choreo-samples/tree/main/weather-to-logs-mi-manual-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on WSO2 MI projects and deploying a WSO2 MI integration as a manual task in Choreo, use the WSO2 MI automation mode. For details, see [Running the Micro Integrator in Automation Mode](https://apim.docs.wso2.com/en/latest/install-and-setup/install/running-the-mi-in-automation-mode/).

        === "Ballerina"
            To explore a Ballerina manual task with arguments, try out the [Weather to Email Task](https://github.com/wso2/choreo-samples/tree/main/weather-to-email-integration) sample. For instructions, see the README.md file in the sample repository.

            !!! info
                If you want to pass arguments to Ballerina main functions, use the **Run with Arguments** capability. For details on the arguments you can pass, see the [Ballerina documentation](https://ballerina.io/learn/by-example/main-function/). You can also override configurable values in the same manner. For more information, see [Provide values to configurable variables](https://ballerina.io/learn/provide-values-to-configurable-variables/#provide-via-command-line-arguments).

## Step 5: Test the manual task

Once the task is triggered, an email with the subject `[WSO2 Choreo Demo] Next 24H Weather Forecast` is sent from `choreo.demo@gmail.com` to the email address specified as the **email** configurable variable value in [Step 3](#step-3-deploy-the-manual-task).

If the manual task ran successfully, you should receive an email similar to the following:

![Received email](../../assets/img/develop-components/develop-a-scheduled-integration/Received-email.png)

## Step 6: Observe the manual task

The observability view in Choreo displays graphs that depict details such as throughput, latency, diagnostic data, and logs to identify and troubleshoot anomalies in components you deploy.

1. In the left navigation menu, click **Observability**.
2. Observe the following:
    - The throughput and latencies of requests served over a given period.
    - The logs generated over a given period.
    - The flame graph (Diagnostics View) generated over a given period.
    - The low-code diagram.

To learn more about the observability details you can view via Choreo observability, see [Observability Overview](../../monitoring-and-insights/observability-overview.md).

## Step 7: Monitor executions

To track and monitor executions associated with the deployed manual task, go to the left navigation menu and click **Execute**.

!!! tip
    The **Execute** view is applicable to both scheduled and manual tasks.

You can view the following information:

- **Total executions**: The total number of executions within the past 30 days.

    ![Total Execution](../../assets/img/develop-components/develop-a-scheduled-integration/total_executions.png)

- **Execution history**: The currently active executions and those that are already complete. You can view information such as the execution ID, the revision of the execution, and the time it was triggered.

    ![Execution History](../../assets/img/develop-components/develop-a-scheduled-integration/execution_history.png)

- **Detailed execution logs**: Click on an execution to view detailed logs related to it.

    !!! info
        It may take a few minutes for the logs to appear. You may need to manually refresh to view the latest logs.

    ![Execution Logs](../../assets/img/develop-components/develop-a-scheduled-integration/execution_logs.png)


# Develop a Scheduled Task

Choreo is a versatile integration platform that allows you to create various types of integrations depending on your requirements. If you need to automatically run a specific integration at regular intervals, you can use Choreo to develop a scheduled task. This type of integration can automate the synchronization of data between different systems at specified intervals, reducing errors and improving productivity by eliminating the need for manual intervention.

This guide walks you through the steps to develop, deploy, test, and observe a scheduled task using Choreo.

In this guide, you will:

- Develop a scheduled task to fetch the weather forecast for a specified location for the next 24 hours from the [OpenWeatherMap](https://openweathermap.org) API.
- Process the weather data into a specific format.
- Send the formatted data to a specified email address at a specific time every day.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

    !!! info "Repository File Structure"
        The sample code for this guide is in the `<sample-repository-dir>/weather-to-email-scheduled-task` directory. The following table describes the key files in the repository:

        | **File Path**         | **File Content**                                                     |
        | --------------------- | -------------------------------------------------------------------- |
        | **Ballerina.toml**    | Contains metadata about the project                                  |
        | **Dependencies.toml** | Lists the dependencies required for the project                      |
        | **main.bal**          | Contains the entry point of the project, including the main function |
        | **types.bal**         | Contains custom data types used in the project                       |
        | **utils.bal**         | Contains utility functions and helper functions used in the project  |

3. Go to [OpenWeatherMap](https://openweathermap.org/) and sign up to obtain an API key. For details, see the [OpenWeatherMap documentation](https://openweathermap.org/appid#signup).

## Step 1: Create a scheduled task component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Scheduled Task** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following information:

    | **Field**             | **Description**                                |
    | --------------------- | ---------------------------------------------- |
    | **Organization**      | Your GitHub account                            |
    | **Repository**        | `choreo-samples`                               |
    | **Branch**            | `main`                                         |
    | **Component Directory** | `weather-to-email-scheduled-task`              |

6. Select **Ballerina** as the build pack.

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Component Directory** specifies the location of the project to build the component.

7. Enter a unique name and description for the component. You can use the following values:

    | **Field**          | **Value**                        |
    | ------------------ | -------------------------------- |
    | **Component Name** | `WeatherToEmail`                 |
    | **Description**    | `My first scheduled task`        |

8. Click **Create**. Choreo initializes the component with the sample implementation and opens the **Overview** page of the component.

Now you can proceed to build and deploy the scheduled task.

## Step 2: Build the scheduled task

1. In the left navigation menu, click **Build**.
2. In the **Builds** pane, click **Build**. This opens the **Commits** pane, where you can see all the commits related to the component.
3. Select the latest commit and click **Build**. This triggers the build process and displays the build progress in the **Build Logs** pane.

    !!! info
        The build process may take some time. Once complete, the build status will be listed in the **Builds** pane. Here, you will see the build status as **Success**.

## Step 3: Deploy the scheduled task

1. In the left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane, specify values for the configurable variables:

    !!! tip
        The configurable variables populated here are defined in the sample Ballerina project used in this guide. To learn how to declare configurable variables in Ballerina, see the [Ballerina documentation on declaring configurable variables](https://ballerina.io/learn/by-example/configurable-variables/).

    | **Field**     | **Value**                                                               |
    | ------------- | ----------------------------------------------------------------------- |
    | **apiKey**    | The API key you obtained in the prerequisites section                   |
    | **latitude**  | Latitude of the location to get the weather forecast                    |
    | **longitude** | Longitude of the location to get the weather forecast                   |
    | **email**     | The email address to receive the formatted weather forecast information |

    !!! note
        If you use **Ballerina** as the buildpack and want to set a configurable variable as a secret, click the lock icon corresponding to the configurable variable. This marks it as a secret and conceals the input value.

        For example, if you set the **apiKey** as a secret, its input value will be concealed. To update the input value later, click **Update Secret Content** and specify a new value.

4. Click **Next**.
5. Define a schedule to run the task. In this guide, set the schedule to receive the weather information daily at 8:00 AM UTC. Enter the following values:

    | **Field**            | **Value**                                             |
    | -------------------- | ----------------------------------------------------- |
    | **Select Time Zone** | Select a time zone to schedule the task               |
    | **Select Range**     | **Day**                                               |
    | **Every**            | `1`                                                   |
    | **At**               | `08:00`                                               |

    !!! tip
        To test and verify the task immediately, you can schedule the deployment to run in just a few minutes after you create it. However, to avoid unnecessary expenses, reschedule or stop the deployment once you test and verify.

6. Click **Deploy**. This deploys the scheduled task to the development environment and indicates the **Scheduled Status** as **Active** in the **Development** card.

You can test the scheduled task when it runs at the configured time.

## Step 4: Test the scheduled task

When the scheduled task runs at the configured time, an email with the subject `[WSO2 Choreo Demo] Next 24H Weather Forecast` is sent from `choreo.demo@gmail.com` to the email address specified as the **email** configurable variable value in [Step 3](#step-3-deploy-the-scheduled-task).

If the scheduled task ran successfully, you should receive an email similar to the following:

![Received email](../../assets/img/develop-components/develop-a-scheduled-integration/Received-email.png)

## Step 5: Observe the scheduled task

The observability view in Choreo displays graphs that depict details such as throughput, latency, diagnostic data, and logs to identify and troubleshoot anomalies in components you deploy.

1. In the left navigation menu, click **Observability**.
2. Observe the following:
    - The throughput and latencies of requests served over a given period.
    - The logs generated over a given period.
    - The flame graph (Diagnostics View) generated over a given period.
    - The low-code diagram.

To learn more about the observability details you can view via Choreo observability, see [Observability Overview](../../monitoring-and-insights/observability-overview.md).

## Step 6: Monitor executions

To track and monitor executions associated with the deployed scheduled task, go to the left navigation menu and click **Execute**.

!!! tip
    The **Execute** view is applicable to both scheduled and manual tasks.

You can view the following information:

- **Total executions**: The total number of executions within the past 30 days.

    ![Total Execution](../../assets/img/develop-components/develop-a-scheduled-integration/total_executions.png)

- **Execution history**: The currently active executions and those that are already complete. You can view information such as the execution ID, the revision of the execution, and the time it was triggered.

    ![Execution History](../../assets/img/develop-components/develop-a-scheduled-integration/execution_history.png)

- **Detailed execution logs**: Click on an execution to view detailed logs related to it.

    !!! info
        It may take a few minutes for the logs to appear. You may need to manually refresh to view the latest logs.

    ![Execution Logs](../../assets/img/develop-components/develop-a-scheduled-integration/execution_logs.png)


# Develop an Event Handler

An event handler executes predefined actions in response to specific events. Choreo simplifies the process of creating and deploying such integrations.

This guide walks you through the steps to create and deploy an Event Handler using WSO2 MI and Choreo.

In this guide, you will build a simple event handler that monitors RabbitMQ for new messages and displays them once they become available.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Set up RabbitMQ:
    - Use an existing RabbitMQ instance or start a new [RabbitMQ](https://www.rabbitmq.com/download.html) instance on a server that can be accessed via the internet.
    - Obtain the `username`, `hostname`, `password`, and `vhost` from the RabbitMQ instance to use later as environment variables.

3. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

## Step 1: Create an event handler component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Event Handler** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following information:

    | **Field**             | **Description**              |
    |-----------------------|----------------------------- |
    | **Organization**      | Your GitHub account          |
    | **Repository**        | `choreo-samples`             |
    | **Branch**            | `main`                       |
    | **Component Directory** | `mi-rabbitmq-listener`       |

6. Select **WSO2 MI** as the build pack. (since you are creating the REST API from a [WSO2 Integration Studio](https://wso2.com/micro-integrator/) project)

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Component Directory** specifies the location of the project to build the component.

7. Enter a unique name and description for the component. You can use the following values:

    | **Field**          | **Value**              |
    |--------------------|------------------------|
    | **Component Name** | `SalesOrderListener`   |
    | **Description**    | `RabbitMQ integration` |

8. Click **Create**.

## Step 2: Deploy the integration

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**.
3. In the **Configurations** pane, click **+ Add** corresponding to **Environment Variables** and add the following environment variables:

    !!! tip
        Use the values from your RabbitMQ instance as per the [Prerequisites](#prerequisites) section for the environment variables.

    | **Name**     | **Value**                                         |
    | ------------- |--------------------------------------------------|
    | **HOSTNAME**  | Hostname of your RabbitMQ server                 |
    | **VHOST**     | Virtual hostname of your RabbitMQ server         |
    | **USERNAME**  | Username for connecting to RabbitMQ              |
    | **PASSWORD**  | Password associated with the RabbitMQ username   |

4. Click **Deploy**. This deploys the event handler to the development environment and indicates the **Deployment Status** as **Active** in the **Development** card.

## Step 3: Test the integration

1. Send a sales order message to the **SalesOrderQueue** on the RabbitMQ server. You can send a sample sales order message similar to the following:

    ```json
    {
        "order_id": "12345",
        "customer_name": "John Doe",
        "product": "Widget",
        "quantity": 10,
        "total_amount": 100.00
    }
    ```

2. Observe the logs:
    - In the left navigation menu, click **Logs** and then click **Runtime Logs**. You will see the order message in the logs.

Now you have gained hands-on experience in creating, configuring, and deploying an event handler.


# Develop an Integration with Integration Studio

Choreo simplifies the process of building, deploying, and managing integration components, making it easy to expose integrations as APIs. This guide walks you through the steps to expose an integration created in WSO2 Integration Studio as an API in Choreo.

In this guide, you will:
- Create a component to expose a sample integration from the [Choreo samples repository](https://github.com/wso2/choreo-samples) as an API.
- Deploy, test, and observe the integration component.
- Publish the integration component as an API to the Choreo Developer Portal.

!!! note
    - To develop integrations for **Manual Task** and **Schedule Task** components in Choreo, use the **automation mode** in the WSO2 Micro Integrator. See [Running MI in Automation Mode](https://apim.docs.wso2.com/en/4.2.0/install-and-setup/install/running-the-mi-in-automation-mode/).
    - For other component types (Service, webhook, event-handler, etc.), use the **server mode**.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    - Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    - Enter a unique organization name. For example, `Stark Industries`.
    - Read and accept the privacy policy and terms of use.
    - Click **Create**. This creates the organization and opens the **Project Home** page.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

## Step 1: Create the integration component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the **Project Home** page.

2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following repository details:

    | **Field**             | **Description**              |
    |-----------------------|----------------------------- |
    | **Organization**      | Your GitHub account          |
    | **Repository**        | `choreo-samples`            |
    | **Branch**            | **`main`**                   |
    | **Component Directory** | `hello-world-mi`             |

6. Select WSO2 MI as the build pack (since you're creating the REST API from a [WSO2 Integration Studio](https://wso2.com/micro-integrator/) project).

7. Provide a unique name and description for the component:

    | **Field**          | **Value**              |
    |--------------------|------------------------|
    | **Component Name** | `Hello World`          |
    | **Description**    | `Hello World REST API` |

8. Click **Create**. Choreo initializes the component with the sample integration.

## Step 2: Deploy the integration component

1. In the Choreo Console left navigation menu, click **Deploy**.

2. Configure and deploy:
   - In the **Build Area** card, click **Configure & Deploy**.
   - In the **Configurations** pane, click **Next**. This displays the endpoint details ready for deployment.
   - Click **Deploy**. This deploys the integration component to the development environment.

    !!! tip
        - Choreo uses [endpoints](../../choreo-concepts/endpoint.md) to expose **Service** components to the network. Learn more about configuring endpoints in [Configure Endpoints](../configure-endpoints.md).
        - Automatic deployment is enabled by default, so only the first deployment needs to be done manually.

   The **Development** card shows the **Deployment Status** as **Active** when the integration is successfully deployed.

## Step 3: Test the integration

1. In the Choreo Console left navigation menu, click **Test** and then click **Console**.
2. In the OpenAPI Console, select **Development** from the environment drop-down list.
3. Expand the **GET /integration** operation.
4. Click **Try it out**, then click **Execute**. This sends a request to your deployed integration.
5. Check the response:
    - In the **Response body** section, observe the response. If the integration works as expected, you should see:
     
     ```json
     {"Hello" : "Integration"}
     ```

## Step 4: Observe the integration

1. Click **Observability** in the left navigation menu to monitor the performance of the integration component.

2. View metrics:
   - Observe throughput and latencies of requests over time.
   - View logs generated during a specific period.
   - Analyze the flame graph (Diagnostics View) for performance insights.

   For more details, see [Observability Overview](../../monitoring-and-insights/observability-overview.md).

## Step 5: Publish the integration component

1. In the Choreo Console left navigation menu, click **Manage** and then click **Lifecycle**.
2. The **Lifecycle Management** pane shows the current lifecycle stage as **Created**.
3. Click **Publish**. This changes the lifecycle stage to **Published** and exposes the integration as an API in the Choreo Developer Portal.
   - To view the published API, click **Go to Devportal**. In the Developer Portal, you can manage subscriptions and generate access tokens for testing.

Now you have successfully exposed an integration designed in WSO2 Integration Studio as a REST API in Choreo!


# Develop an API Proxy from a GitHub Repository Source

An API proxy acts as an intermediary between an existing API and Choreo, intercepting all requests made to the API. It also functions as a managed API, allowing you to apply essential API management features such as security policies and rate limiting.

In this guide, you will:

- Create an API proxy component to expose an existing API.
- Deploy the API proxy.
- Test the API proxy to verify its functionality.
- Manage the API.
- Consume the API.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample proxy source](https://github.com/wso2/choreo-samples/tree/main/department-api-proxy-from-github).  

## Step 1: Create an API proxy

You can create an API proxy either by selecting the source from a GitHub repository, uploading an OpenAPI specification file, or providing an OpenAPI specification URL. This guide demonstrates how to create an API proxy using a GitHub repository as the source.

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **API Proxy** card. This opens the **Create an API Proxy** pane.

4. Click on **Authorize With GitHub** card under **Connect a Git Repository** section to connect your GitHub account.
    - If you haven’t connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
         - Read and write access to code and pull requests.
         - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.    

5. Enter the following repository details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **Repository**         | choreo-samples     |
    | **Branch**             | **`main`**         |
    | **API Directory**      | /department-api-proxy-from-github |

    !!! note
        To select the relevant directory, click on the **Edit** action next to the **API Directory** input field. Then, enter `department-api-proxy-from-github` as the directory name to quickly search and locate the correct directory.

6. Specify the following values as Proxy Metadata:

    !!! info
        The **Context** field must be unique and cannot be changed after creation.**Version** and **Target** are mandatory fields. **Target** can be changed at any time after the creation.

    | **Field**       | **Value**                                  |
    |-----------------|--------------------------------------------|
    | **Context**     | `department-service`                                   |
    | **Version**     | `v1.0`                                      |
    | **Target**      | `https://samples.choreoapps.dev/company/hr`|

7. Specify the following values as Component Details:

    !!! info
        The **Component Name** field must be unique and cannot be changed after creation. This value is automatically generated, but you can edit it if necessary.
        **Component Display Name** is a required field.

    | **Field**       | **Value**                                  |
    |-----------------|--------------------------------------------|
    | **Component Display Name**| `Department Service`                    |
    | **Component Name**        | `department-service`                    |
    | **Description**           | `This is a sample proxy for department service`     |    

8. Click **Create**. This creates the API proxy component and takes you to the **Build** page.

!!! note
    When you create an API proxy from a GitHub repository source, the GitHub source serves as the single source of truth. Therefore, any modifications, such as adding or deleting resources, must be made through the GitHub repository.

## Step 2: Build

!!! info
    The initial build starts automatically when you create the API proxy, and you will be redirected to the **Build** page. In this case, you can skip the steps below. If you need to manually trigger a build later, follow these steps.

1. On the project home page, click on the `Department Service` component you created. This takes you to the component overview page.
2. In the left navigation menu, click **Build**.
3. On the **Build** page, click **Build Latest**.

!!! note
    The build process may take some time. You can track progress in the **Build Details** pane. Once complete, the build status changes to **Success**.

## Step 3: Deploy the API proxy

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**. This opens the **Configure & Deploy** pane.
3. Select **External** as the **API Access Mode** and click **Deploy**. The **Development** card indicates the **Deployment Status** as **Active** when the API proxy is successfully deployed.

Now you are ready to test the API proxy.

## Step 4: Test the API proxy

Choreo allows you to test your API proxy using either the [integrated OpenAPI Console](../../testing/test-rest-endpoints-via-the-openapi-console.md) or [cURL](../../testing/test-apis-with-curl.md). In this guide, you will use the OpenAPI Console.

!!! tip
    Choreo enables OAuth 2.0 to secure APIs by default. Therefore, you need an access token to invoke an API.

    - Choreo automatically generates a key to test the API via the OpenAPI Console. To view the key, click the show key icon in the **Security Header** field.
    - To disable security for the entire API or a specific resource:
        1. In the left navigation menu, click **Deploy**.
        2. Go to the **Build Area** card and click **Security Settings**.
        3. In the **Security Settings** pane:
            - To disable security for the entire API, clear the **OAuth2** checkbox.
            - To disable security for a specific resource, expand the relevant resource and turn off the **Security** toggle.
        4. Click **Apply**.

1. In the left navigation menu, click **Test** and then click **OpenAPI Console**.
2. Select **Development** from the environment drop-down list.
3. Expand the `GET /department/{departmentId}` resource and click **Try it Out**.
4. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

    ![API proxy response](../../assets/img/develop-components/develop-a-rest-api-proxy/rest-api-proxy-response.png){.cInlineImage-full}

    This indicates that your API proxy is working as expected.

## Step 5: Manage the API proxy

Now that you have a tested API proxy, you can publish it and make it available for application developers to consume. In this guide, you will apply rate limiting to the API and publish it.

### Step 5.1: Apply rate limiting to the API proxy

1. In the left navigation menu, click **Deploy**.
2. Go to the required environment card and click the settings icon corresponding to **API Configuration**.
3. In the **CORS, Rate Limiting and Resiliency** pane, click **Rate Limiting** to expand the section.
4. Select **API Level** as the **Rate Limiting Level**.
5. Specify appropriate values for the **Request Limit** and **Time Unit** fields. You can proceed with the default values.
6. Click **Apply**. This applies the rate limiting level to the API proxy and redeploys it.

### Step 5.2: Publish the API proxy

1. In the left navigation menu, click **Lifecycle** under **Manage**. This takes you to the **Lifecycle** page.
2. Click **Publish**.
3. In the **Publish API** dialog, click **Confirm** to proceed with publishing the API. If you want to change the display name, make the necessary changes and then click **Confirm**. This changes the API lifecycle state to **Published**.

## Step 6: Invoke the API

To generate credentials for the published API and invoke it via the Choreo Developer Portal, follow these steps:

1. In the **Lifecycle** page, click **Go to Devportal**. This takes you to the `Department Service` in the Choreo Developer Portal.

2. **Invoke the API**:
    1. In the Developer Portal left navigation menu, click **Try Out**.
    2. In the **Endpoint** list, select **Development** as the environment to try out the API.
    3. Click **Get Test Key** to generate an access token.
    4. Expand the `GET /department/{departmentId}` resource and click **Try it out**.
    5. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

        ![Try out response](../../assets/img/develop-components/develop-a-rest-api-proxy/try-out-response.png){.cInlineImage-full}

Now, you have gained hands-on experience creating, deploying, testing, and publishing an API proxy using Choreo.


# Develop an API Proxy from Scratch

An API proxy acts as an intermediary between an existing API and Choreo, intercepting all requests made to the API. It also functions as a managed API, allowing you to apply essential API management features such as security policies and rate limiting.

In this guide, you will:

- Create an API proxy component to expose an existing API.
- Deploy the API proxy.
- Test the API proxy to verify its functionality.
- Manage the API.
- Consume the API.

## Prerequisites

- If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

## Step 1: Create an API proxy

To create an API proxy, you can either upload an OpenAPI specification or provide an OpenAPI specification URL. In this guide, you will specify a URL to an OpenAPI definition of a sample API.

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **API Proxy** card. This opens the **Create an API Proxy** pane.
4. Select **Creare from Scratch** option. 
5. Specify the following values as Proxy Metadata:

    | **Field**       | **Value**                                  |
    |-----------------|--------------------------------------------|
    | **Context**     | `department-service`                                   |
    | **Version**     | `v1.0`                                      |
    | **Target**      | `https://samples.choreoapps.dev/company/hr` |

6. Enter following details for the Component Details:

    !!! info
        The **Component Name** field must be unique and cannot be changed after creation.

    | **Field**                 | **Value**          |
    |---------------------------|--------------------|
    | **Component Display Name**| `Department Service`          |
    | **Component Name**        | `department-service`          |
    | **Description**           | `Sample proxy for department service`     |

7. Click **Create**. This creates the API proxy component and takes you to the **Deploy** page.

## Step 2: Define resources for the API proxy

To add a new resource that retrieves a department by the department ID, follow these steps:

1. In the left navigation menu, click **Develop** and then click **Resources**.
2. Select **GET** as the **HTTP Verb** and enter `/department/{departmentId}` as the **URI Pattern**.
3. Click **+** to add the resource.
4. Expand the added resource and specify the following values:

    | **Field**        | **Value**                            |
    |------------------|--------------------------------------|
    | **Operation ID** | `findDepartment`                     |
    | **Description**  | `Find a department by department ID` |

5. Remove the five default resources that start with `/*` by clicking the delete icon corresponding to each resource.
6. Click **Save**.

## Step 3: Deploy the API proxy

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**. This opens the **Configure & Deploy** pane.
3. Select **External** as the API access mode and click **Deploy**. The **Development** card indicates the **Deployment Status** as **Active** when the API proxy is successfully deployed.

Now you are ready to test the API proxy.

## Step 4: Test the API proxy

Choreo allows you to test your API proxy using either the [integrated OpenAPI Console](../../testing/test-rest-endpoints-via-the-openapi-console.md) or [cURL](../testing/test-apis-with-curl.md). In this guide, you will use the OpenAPI Console.

!!! tip
    Choreo enables OAuth 2.0 to secure APIs by default. Therefore, you need an access token to invoke an API.

    - Choreo automatically generates a key to test the API via the OpenAPI Console. To view the key, click the show key icon in the **Security Header** field.
    - To disable security for the entire API or a specific resource:
        1. In the left navigation menu, click **Deploy**.
        2. Go to the **Build Area** card and click **Security Settings**.
        3. In the **Security Settings** pane:
            - To disable security for the entire API, clear the **OAuth2** checkbox.
            - To disable security for a specific resource, expand the relevant resource and turn off the **Security** toggle.
        4. Click **Apply**.

1. In the left navigation menu, click **Test** and then click **OpenAPI Console**.
2. Select **Development** from the environment drop-down list.
3. Expand the `GET /department/{departmentId}` resource and click **Try it Out**.
4. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

    ![API proxy response](../../assets/img/develop-components/develop-a-rest-api-proxy/rest-api-proxy-response.png){.cInlineImage-full}

    This indicates that your API proxy is working as expected.

## Step 5: Manage the API proxy

Now that you have a tested API proxy, you can publish it and make it available for application developers to consume. In this guide, you will apply rate limiting to the API and publish it.

### Step 5.1: Apply rate limiting to the API proxy

1. In the left navigation menu, click **Deploy**.
2. Go to the required environment card and click the settings icon corresponding to **CORS, Rate Limiting and Resiliency**.
3. In the **CORS, Rate Limiting and Resiliency** pane, click **Rate Limiting** to expand the section.
4. Select **API Level** as the **Rate Limiting Level**.
5. Specify appropriate values for the **Request Limit** and **Time Unit** fields. You can proceed with the default values.
6. Click **Apply**. This applies the rate limiting level to the API proxy and redeploys it.

### Step 5.2: Publish the API proxy

1. In the left navigation menu, click **Lifecycle** under **Manage**. This takes you to the **Lifecycle** page.
2. Click **Publish**.
3. In the **Publish API** dialog, click **Confirm** to proceed with publishing the API. If you want to change the display name, make the necessary changes and then click **Confirm**. This changes the API lifecycle state to **Published**.

## Step 6: Invoke the API

To generate credentials for the published API and invoke it via the Choreo Developer Portal, follow these steps:

1. In the **Lifecycle** page, click **Go to Devportal**. This takes you to the `Department Service` in the Choreo Developer Portal.

2. **Invoke the API**:
    1. In the Developer Portal left navigation menu, click **Try Out**.
    2. In the **Endpoint** list, select **Development** as the environment to try out the API.
    3. Click **Get Test Key** to generate an access token.
    4. Expand the `GET /department/{departmentId}` resource and click **Try it out**.
    5. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

        ![Try out response](../../assets/img/develop-components/develop-a-rest-api-proxy/try-out-response.png){.cInlineImage-full}

Now, you have gained hands-on experience creating, deploying, testing, and publishing an API proxy using Choreo.

# Develop a Ballerina Service

Choreo allows you to develop and deploy applications using your preferred programming language. This guide demonstrates how to deploy a service component that exposes a REST API using the [Ballerina language](https://ballerina.io/). No prior knowledge of Ballerina is required to follow this guide.

A REST API is a web service that adheres to Representational State Transfer (REST) principles, using HTTP methods to access and manage resources. This guide walks you through building a Ballerina service component, deploying it on Choreo, and testing it with an HTTP client application.

In this guide, you will:

 - Build a simple greeting service using a sample implementation. The service has a single resource named `greet` that accepts a query parameter as input.
 - Deploy the service in Choreo.
 - Test the service.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    - Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    - Enter a unique organization name. For example, `Stark Industries`.
    - Read and accept the privacy policy and terms of use.
    - Click **Create**. This creates the organization and opens the **Project Home** page.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample greetings service](https://github.com/wso2/choreo-samples/tree/main/greeting-service) implementation in Ballerina.

### Learn the repository file structure

It’s important to understand the purpose of key files in the sample service. The table below provides an overview of each file in the greeter service:

!!! note
    The file paths are relative to `<sample-repository-dir>/greeting-service`.

| **Filepath**              | **Description**                                                |
|---------------------------|---------------------------------------------------------------|
| `service.bal`             | The greetings service code written in Ballerina.               |
| `tests/service_test.bal`  | Test files related to the `service.bal` file.                  |
| `Ballerina.toml`          | The Ballerina configuration file.                              |

Let’s get started!

## Step 1: Create a service component

To create a Ballerina service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the **Project Home** page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect your GitHub account. If you haven’t connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Provide the following repository details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **Repository**         | choreo-samples     |
    | **Branch**             | **`main`**         |
    |**Component Directory** | `/greeting-service` |

6. Select **Ballerina** as the buildpack.

7. Provide a display name, a unique name, and a description for the service component:

    !!! info
        The **Component Name** field specifies a unique identifier for the component. This name cannot be changed after creation.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Ballerina Greetings`   |
    | **Component Name**        | `ballerina-greetings`   |
    | **Description**           | Send greetings          |

8. Click **Create**. This creates the component and takes you to the **Overview** page.

You have successfully created a service that exposes a REST API written in Ballerina. Next, let’s build and deploy the service.

## Step 2: Build and deploy

Now that you’ve connected the source repository and configured the endpoint details, it’s time to build and deploy the service.

!!! note
    If you’re rebuilding the Ballerina service component after changing the Ballerina version, ensure that the version in the `Ballerina.toml` file matches the version in the `Dependencies.toml` file.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service may take a while. Track the progress via the logs in the **Build Details** pane. Once complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps:

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane, click **Next** to skip the configuration.
4. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service may take a while. Once deployed, the **Development** environment card shows the **Deployment Status** as **Active**.

Once deployed, you can test, manage, and observe the service like any other component in Choreo.

For detailed instructions, see the following sections:
- [Step 3: Test](../../testing/test-rest-endpoints-via-the-openapi-console.md)
- [Step 4: Manage](../../api-management/lifecycle-management.md)

## Manage the deployment

To view Kubernetes-level insights for detailed diagnosis of this Ballerina REST API, see Choreo’s [DevOps capabilities](../../devops-and-ci-cd/view-runtime-details.md).


# Develop a Service with Docker

Choreo allows you to create and deploy applications in any language. This guide demonstrates how to develop and deploy a containerized service component using a Dockerfile.

In this guide, you will:

 - Create a containerized service component using a sample service implementation. The sample service has a single resource named `greet` that accepts a query parameter as input.
 - Deploy the service in Choreo using a Dockerfile. The service will run on port 9090.
 - Test the service.

If you want to create a service component that exposes a Ballerina service, see [Develop a Ballerina Service](develop-a-ballerina-service.md).

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    - Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    - Enter a unique organization name. For example, `Stark Industries`.
    - Read and accept the privacy policy and terms of use.
    - Click **Create**. This creates the organization and opens the **Project Home** page.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample greetings service](https://github.com/wso2/choreo-samples/tree/main/greeting-service-go) implementation with the Dockerfile.

### Learn the repository file structure

It’s important to understand the purpose of key files in the sample service. The table below provides an overview of each file in the greeter service:

!!! note
    The file paths are relative to `<sample-repository-dir>/greeting-service-go`.

| **Filepath**               | **Description**                                                              |
|----------------------------|------------------------------------------------------------------------------|
| `main.go`                  | The Go-based greeter service code.                                           |
| `Dockerfile`               | The Dockerfile to build the container image of the application.              |
| `.choreo/component.yaml`   | Choreo-specific configuration that provides information about how Choreo exposes the service. |
| `openapi.yaml`             | The OpenAPI contract of the greeter service. This is required to publish the service as a managed API. This file is referenced by the `.choreo/component.yaml` file. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints. The greeter service runs on port 9090. To securely expose the service through Choreo, you must provide the port and other required information in the `component.yaml` file. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

In the greeter sample, the `component.yaml` file is located in the `greeting-service-go/.choreo/` directory.

## Step 1: Create a service component from a Dockerfile

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/cloud-native-app-developer) and sign in. This opens the **Project Home** page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect your GitHub account. If you haven’t connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
         - Read and write access to code and pull requests.
         - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following repository details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **Repository**         | choreo-samples     |
    | **Branch**             | `main`         |
    | **Component Directory** | `/greeting-service-go`         |

6. Select **Docker** as the buildpack.
7. Enter the following details:

    | **Field**                | **Value**                        |
    |--------------------------|----------------------------------|
    | **Dockerfile**           | `/greeting-service-go/Dockerfile`|

    !!! info
        1. To successfully build your container with Choreo, explicitly define a user ID (UID) under the `USER` instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-sample-apps/blob/main/go/greeter/Dockerfile).
           - A valid User ID is a numeric value between 10000-20000 (e.g., `10001` or `10500`).
           - Usernames are invalid and should not be used (e.g., `my-custom-user-12221` or `my-custom-user`).

        2. The Dockerfile used in this guide is a multi-stage Dockerfile, which keeps the final image size small and allows building the application with specific versions of tools and libraries.

8. Provide a display name, a unique name, and a description for the service component:

    !!! info
        The **Component Name** field specifies a unique identifier for the component. This name cannot be changed after creation.

    | **Field**                 | **Value**          |
    |---------------------------|--------------------|
    | **Component Display Name**| `Greetings`        |
    | **Component Name**        | `greetings`        |
    | **Description**           | Send greetings     |

9. Click **Create**. This creates the component and takes you to the **Overview** page.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you’ve connected the source repository and configured the endpoint details, it’s time to build the service and create an image. Then, you can deploy the image and test the greeter service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service may take a while. Track the progress via the logs in the **Build Details** pane. Once complete, the build status changes to **Success**.

    You can access the following scans under **Build**:
    - **Dockerfile Scan**: Choreo checks if a non-root user ID is assigned to the Docker container for security. If no non-root user is specified, the build will fail.
    - **Container (Trivy) Vulnerability Scan**: This detects vulnerabilities in the final Docker image. If critical vulnerabilities are found, the build will fail.

    !!! info
        If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps:

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service may take a while. Once deployed, the **Development** environment card shows the **Deployment Status** as **Active**.

Once deployed, you can [test](../../testing/test-rest-endpoints-via-the-openapi-console.md), [manage](../../api-management/lifecycle-management.md), and [observe](../../monitoring-and-insights/observability-overview.md) the service like any other component in Choreo.

To view Kubernetes-level insights for detailed diagnosis of this Dockerfile-based REST API, see [Choreo's DevOps capabilities](../../devops-and-ci-cd/view-runtime-details.md).


# Develop a Service

Choreo allows you to create and deploy applications in your preferred programming language. 

In this guide, you will:

- Build a simple greeting service using a sample service implementation. The sample implementation will have a single resource named `greet` that accepts a single query parameter as input.
- Deploy the service in Choreo using a `Go` buildpack. The service will run on port 9090.
- Test the service.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample greetings service](https://github.com/wso2/choreo-samples/tree/main/greeting-service-go) implementation in `Go`.

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the greeter service:

!!! note 
    The specified file paths are relative to `<sample-repository-dir>/greeting-service-go`.

| **Filepath**             | **Description**                                                               |
|--------------------------|-------------------------------------------------------------------------------|
| `main.go`                | The Go-based greeter service code.                                            |
| `.choreo/component.yaml` | Choreo-specific configuration that provides information about how Choreo exposes the service. |
| `openapi.yaml`           | The OpenAPI contract of the greeter service. This is required to publish the service as a managed API. This `openapi.yaml` file is referenced by the `.choreo/component.yaml` file. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints. To run the greeter service on port 9090 and securely expose it through Choreo, you must provide the port and other required information in the `component.yaml` file. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

In the greeter sample, the `component.yaml` file is located in the `greeting-service-go/.choreo/` directory.

## Step 1: Create a service component

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Public Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Under **Connect a Git Repository**, enter the following details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **GitHub Repository**  | choreo-samples     |
    | **Branch**             | main               |
    | **Component Directory** | `/greeting-service-go` |

6. Select **Go** as the buildpack.
7. Enter the following details:

    | **Field**                | **Value**              |
    |--------------------------|------------------------|
    | **Language Version**     | 1.x                    |

8. Provide component display name, name and description:

    !!! info
        The **Component Name** field must be unique and cannot be changed after creation.

    | **Field**                 | **Value**          |
    |---------------------------|--------------------|
    | **Component Display Name**| Greetings          |
    | **Component Name**        | greetings          |
    | **Description**           | Send greetings     |

9. Click **Create**. This creates the component and lists it under **Component Listing** on the project home page.

You have successfully created the service. The next step is to build and deploy it.

## Step 2: Build and deploy

Now that you have connected the source repository and configured the endpoint details, it's time to build and deploy the greeter service.

### Step 2.1: Build

1. On the project home page, click on the `Greetings` component you created. This takes you to the component overview page.
2. In the left navigation menu, click **Build**.
3. On the **Build** page, click **Build Latest**.

    !!! note
        The build process may take some time. You can track progress in the **Build Details** pane. Once complete, the build status changes to **Success**.

### Step 2.2: Deploy

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take some time. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

Once you have successfully deployed the service, you can [test](../../testing/test-rest-endpoints-via-the-openapi-console.md), [manage](../../api-management/lifecycle-management.md), and [observe](../../monitoring-and-insights/observability-overview.md) it like any other component type in Choreo.


# Expose a Ballerina GraphQL Endpoint via a Service

Choreo offers the flexibility to develop and deploy applications in a language of your preference. This guide shows you how to deploy a service component that exposes a GraphQL API using the Ballerina language in Choreo. No prior knowledge of the Ballerina language is required to follow this guide. 

GraphQL API is a query language and runtime that provides a single endpoint for retrieving flexible and efficient data in a strongly-typed and self-documenting way. By following this guide, you will build a service component in Ballerina and deploy it on Choreo for any GraphQL client application to utilize it.

This guide shows how to build a simple reading list service and deploy it in Choreo using Ballerina. The GraphQL endpoint you create in this guide has two operations: **Query** and **Mutation**. The Query type operations read the data in the data source, and the Mutation operations update the data in the data source. The reading list service has two queries and three mutations as follows:

### Queries

**Retrieve the reading list**

This resource accepts an optional filter, `status`, which filters the reading list by reading status. Accepted values for status are `reading`, `read`, and `to_read`.

**Sample request**:
```
$ curl -X POST -H "Content-Type: application/json" -d '{"query": "query {allBooks (status: \"reading\") { id title author status }}"}' http://localhost:8090
```

**Sample response**
```
$ {
  "data": {
    "allBooks": [
      {
        "id": 1,
        "title": "Sample Book",
        "author": "Test Author",
        "status": "to_read"
      }
    ]
  }
}
```

**Retrieve a book item from the reading list**

This resource accepts a filter, `id`, which will select the book item from the reading list by book id.  The id is an Integer value. 

**Sample request**
```
$ curl -X POST -H "Content-Type: application/json" -d '{"query": "query {book (id: 1) { id title author status }}"}' http://localhost:8090
```

**Sample response**
```
$ {
  "data": {
    "book": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "to_read"
    }
  }
}
```

### Mutations

**Add a book item to the reading list**

This remote function accepts a book record as the input and consists of the title and the author. When you add a new book to the reading list, the method updates the reading status of the newly added book to `to_read`. This method returns the added book item upon successful execution.


**Sample request**

```
$ curl -X POST -H "Content-type: application/json" -d '{ "query": "mutation { addBook(book: {title: \"Sample Book\", author: \"Test Author\"}) { id title author status } }" }' 'http://localhost:8090'
```

**Sample response**

```
$ {
  "data": {
    "addBook": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "to_read"
    }
  }
}
```

**Update the reading status of a book**

This remote function requires `id` and `status` as inputs to update the reading status of the selected book. The `id` refers to the id of the book. It is an integer.  The `status` refers to the reading status that needs to be updated. This method returns the updated book item upon successful execution.

**Sample request**

```
$ curl -X POST -H "Content-type: application/json" -d '{ "query": "mutation { setStatus(id: 1, status: \"reading\") { id title author status } }" }' 'http://localhost:8090'
```

**Sample response**

```
$ {
  "data": {
    "setStatus": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "reading"
    }
  }
}
```

**Delete a book item from the reading list**

This remote function requires the `id` as the input to delete the book item from the reading list. This method returns the removed book item upon successful execution.

**Sample request**

```
$ curl -X POST -H "Content-type: application/json" -d '{ "query": "mutation { deleteBook(id: 1) { id title author status } }" }' 'http://localhost:8090'
```

**Sample response**
```
$ {
  "data": {
    "deleteBook": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "reading"
    }
  }
}
```

Our next step is to set up the resources that you will require to follow the guide, including the sample reading list application and the Choreo GitHub app.

## Prerequisites

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample GraphQL service](https://github.com/wso2/choreo-samples/tree/main/reading-list-graphql) implementation for this guide.

Let's get started!

## Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the reading list service.

!!! note
    The following file paths are relative to the path `<sample-repository-dir>/reading-list-graphql`.

|Filepath                 | Description                                                     |
|-------------------------|-----------------------------------------------------------------|
| `service.bal`           | The reading list service code written in the Ballerina language.|
| `Ballerina.toml`        | The Ballerina configuration file.                               |
| `.choreo/component.yaml`| The configuration file with endpoint details.                   |

## Step 1: Create a service component 

To create a Ballerina service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**| `reading-list-graphql`    |.

6. Select **Ballerina** as the buildpack.

7. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Ballerina Reading List`|
    | **Component Name**        | `ballerina-reading-list`|
    | **Description**           | Manage a reading list   |

8. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service component that exposes a GraphQL API written in the Ballerina language. Next, let's build and deploy the service.

## Step 2: Build and deploy

Now that we have connected the source repository, it's time to build and deploy the reading list service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Configurations** pane that opens, click **Next** to skip the configuration.
4. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.
To build and deploy the service, follow the steps below:

Once you have successfully deployed your service, you can test, manage, and observe it like any other component type in Choreo.

For detailed instructions, see the following sections:

- [Step 3: Test](https://wso2.com/choreo/docs/testing/test-graphql-endpoints-via-the-graphql-console/)
- [Step 4: Manage](https://wso2.com/choreo/docs/manage/api-management/)


# Expose a gRPC Endpoint via a Service

Choreo allows you to create and deploy applications in your preferred programming language. One powerful option is gRPC, a high-performance and language-agnostic remote procedure call (RPC) framework. It utilizes [Protocol Buffers](https://github.com/protocolbuffers/protobuf) to define services and generate client/server code.

In this guide, you will learn to use Choreo to create a service component that exposes a gRPC server implemented in [Go](https://go.dev/), enabling efficient and scalable communication with any gRPC client application. No prior knowledge of the Go language is necessary to follow this guide.

By following this guide, you will:

- Create a simple gRPC server using a Service component.
- Link the containerized gRPC service to the Choreo component using the Dockerfile. 
    The greeter service has a single RPC method named `sayHello`. Following is the proto file the server and the client application are using:

    ```proto
    syntax = "proto3";
    option go_package = "github.com/wso2/choreo-samples/go-grpc/pkg";

    service greeter {
      rpc SayHello (HelloRequest) returns (HelloReply) {}
    }

    message HelloRequest {
      string name = 1;
    }

    message HelloReply {
      string message = 1;
    }
    ```

- Deploy the gRPC server component in Choreo. 
- Create a gRPC client using a Manual Trigger component. 
- Deploy the gRPC client.
- Invoke the gRPC server using a gRPC client and check the response through the Choreo log view.


## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample service](https://github.com/wso2/choreo-samples/tree/main/go-grpc) implementation for this guide.

Let's get started!

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the greeter service.

!!! note 
    The following file paths are relative to the path `<sample-repository-dir>/go-grpc`.

|File Path                |Description                                                                                   |
|-------------------------|----------------------------------------------------------------------------------------------|
| `main.go`               | The greeter service code written in the Go language.                                         |
| `greeter_client/main.go`| The greeter client application written in the Go language.                                   |
| `Dockerfile.server`     | The Dockerfile to build the container image of the server application.                       |
| `Dockerfile.client`     | The Dockerfile to build the container image of the client application.                       |
| `.choreo/component.yaml`| The Choreo-specific configuration that provides information about how Choreo exposes the service.|
| `pkg/greeter.proto`     | The interface definition of the gRPC service. This is used to generate the server and client stubs for the Go application.|

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints.

Let's run the gRPC server service component on port 8080. To securely expose the service through Choreo, you must provide the port and other required information to Choreo. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

Choreo looks for an `component.yaml` file inside the `.choreo` directory to configure the endpoint details of the containerized component. Ensure the `.choreo` directory is at the root of the Docker build context path.

In the gRPC server sample, the `component.yaml` file is at `go-grpc/.choreo/component.yaml`, where the build context path is `go-grpc`.

## Step 1: Create a service component with a gRPC endpoint

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
6. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

7. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory** | `go-grpc`                  |

8. Select **Docker** as the buildpack.
9. Enter the following information:
    
    | **Field**                | **Value**                  |
    |--------------------------|----------------------------|
    | **Dockerfile**           | `go-grpc/Dockerfile.server`|

    !!! info
        1.  To successfully build your container with Choreo, it is essential to explicitly define a User ID (UID) under the USER instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-samples/blob/main/go-grpc/Dockerfile.server).
        To ensure that the defined USER instruction is valid, it must conform to the following conditions:
            - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
            - Usernames are considered invalid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

        2. The Dockerfile utilized in this guide is a multi-stage Dockerfile, which is designed to keep the final image size small and provides the ability to build the application with a specific version of tools and libraries.

4. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go gRPC Server`        |
    | **Component Name**        | `go-grpc-server`        |
    | **Description**           | Send greetings          |
    
10. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you have connected the source repository, and configured the endpoint details, it's time to build the service and create an image. Then you can deploy the image and test the greeter service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

    You can access the following scans under **Build**. 

      - **The Dockerfile scan**: Choreo performs a scan to check if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
      - **Container (Trivy) vulnerability scan**: This detects vulnerabilities in the final docker image. 
      - **Container (Trivy) vulnerability scan**: The details of the vulnerabilities open in a separate pane. If this scan detects critical vulnerabilities, the build will fail.
     
        !!! info
            If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Environment Configurations** pane that opens, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

6. Once you have successfully deployed your service, navigate to the component overview page and copy the gRPC service URL. You need to provide that URL when setting up the client application later in this guide.

You have successfully deployed the gRPC server. Currently, the gRPC service is only accessible by the components deployed within the same project.

## Step 3: Invoke the gRPC service

Let's invoke the gRPC service that you created above, using a gRPC client. 

### Step 3.1: Create a manual task for the gRPC client

To create a manual task component, follow these steps:

1. On the Choreo Console header, click the **Project** list and select the project where you created the gRPC service component. This opens the project home page.
2. Go to the **Component Listing** section and click **+ Create**.
3. Click the **Manual Task** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**       | `go/grpc`                  |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                  |
    |--------------------------|----------------------------|
    | **Dockerfile**           | `go/grpc/Dockerfile.client`|

8. Enter a display name, a unique name, and a description for the component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go gRPC Client`        |
    | **Component Name**        | `go-grpc-client`        |
    | **Description**           | `Receive greetings`     |


9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

### Step 3.2: Build the gRPC client component

To build the component, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 3.3: Setup environment variables and deploy the gRPC client

The client application, in this case, the gRPC client, requires the server URL of the gRPC server service. This is read from the client application as an environment variable. Follow the steps below to configure the environment variable for the client application:

1. On the Choreo Console left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane that opens, click **+ Add**.
4. Specify the following name and value to configure the environment variable for the client application:

    | **Field**       | **Value**               |
    |-----------------|-------------------------|
    | **Name**        | `GREETER_SERVICE`       |
    | **Value**       | Paste the URL value copied after deploying the gRPC service via [step 2.2](#step-22-deploy) above.  Make sure to **drop the `http://` or `grpc://` part and the trailing `/` from the URL when copying**. For example, if the URL is `http://go-grpc-server-3192360657:8080/`, add only `go-grpc-server-3192360657:8080`.|

5.  Click **Add** and then click **Next**.
6.  Click **Deploy**.

### Step 3.4: Execute the gRPC client component

To execute the gRPC client, follow these steps:

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the gRPC client and generates logs.
   You can trigger multiple runs to generate multiple logs.

For details on what you can monitor via the execute page, see [Monitor executions](../develop-integrations/develop-a-manual-task.md#step-7-monitor-executions). 


# Expose a Prism-Based Mock Server Using an OpenAPI Specification

Choreo supports deploying [Prism-based](https://docs.stoplight.io/docs/prism/674b27b261c3c-prism-overview) mock servers using OpenAPI specifications. With the Choreo Prism mock service component, you can serve multiple mock servers, each based on a different OpenAPI specification, as separate endpoints.

By default, these mock servers serve static content generated from the examples in the configured OpenAPI Specification (OAS). 

## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [Prism mock service](https://github.com/wso2/choreo-samples/tree/main/prism-mock-service) artifacts for this guide.

## Step 1: Create a Prism mock service component

To create a Prism mock service component, follow these steps:
    
1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, you can paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    |**Component Directory**  | `prism-mock-service`    |

6. Select **Prism Mock** as the buildpack.
7. Enter a display name, a unique name, and a description for the service component.
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

8. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

## Step 2: Build and deploy the component

Now that you have successfully created the Prism mock service, it's time to build and deploy it.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**. This builds the service from the latest commit.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

Once you have successfully deployed the service, you can [test](../../testing/test-rest-endpoints-via-the-openapi-console.md), [manage](../../api-management/lifecycle-management.md), and [observe](../../monitoring-and-insights/observability-overview.md) it like any other component type in Choreo.

## Serve dynamic content

The Prism mock service can serve dynamic content according to the schema definitions in the OpenAPI specification. To use the Prism mock service with dynamic content, clients must add the `prefer:dynamic=true` header in the request.

To generate meaningful dynamic responses, you can use the `x-faker` attribute in schema definitions of the OpenAPI specification. For more information on dynamically generated responses with the `x-faker` attribute, see the [Prism documentation](https://docs.stoplight.io/docs/prism/9528b5a8272c0-dynamic-response-generation-with-faker).


# Expose a TCP Server via a Service

Choreo offers the flexibility to design and deploy applications in the programming language of your choice. One viable choice for specific network communication needs is TCP (Transmission Control Protocol). TCP provides a reliable, stream-oriented communication mechanism that ensures data integrity and orderliness during transmission. It's the go-to option for scenarios where guaranteed data delivery and error recovery are paramount.

In this guide, you will learn to use Choreo to create a service component that exposes a TCP server implemented in [Go](https://go.dev/), enabling efficient and scalable communication with any TCP client application. No prior knowledge of the Go language is necessary to follow this guide.

By following this guide, you will:

- Setup a TCP server
    - Create a simple TCP server using a service component.
    - Link the containerized TCP service to the Choreo component using a Dockerfile. 
    - Deploy the TCP server component in Choreo. 
- Setup a TCP client
    - Create a TCP client using a manual task component. 
    - Link the containerized TCP client to the Choreo component using a Dockerfile. 
    - Deploy the TCP client component in Choreo.
- Invoke the TCP server using a TCP client and observe the response through the Choreo log view.

## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample service](https://github.com/wso2/choreo-samples/tree/main/docker-tcp-service) implementation for this guide.

Let's get started!

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the sample service.

!!! note 
    The following file paths are relative to the path `<sample-repository-dir>/docker-tcp-service`.

|File Path                 |Description                                                                                   |
|--------------------------|----------------------------------------------------------------------------------------------|
| `server/main.go`         | The greeter service code written in the Go language.                                         |
| `client/main.go`         | The greeter client application written in the Go language.                                   |
| `Dockerfile.server`      | The Dockerfile to build the container image of the server application.                       |
| `Dockerfile.client`      | The Dockerfile to build the container image of the client application.                       |
| `.choreo/component.yaml` | The Choreo-specific configuration provides information about how Choreo exposes the service. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints.

Let's run the TCP server service component on port 5050. To securely expose the service through Choreo, you must provide the port and other required information to Choreo. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

Choreo looks for an `component.yaml` file inside the `.choreo` directory to configure the endpoint details of a containerized component. Place the `.choreo` directory at the root of the Docker build context path.

In our TCP server sample, the `component.yaml` file is at `docker-tcp-service/.choreo/component.yaml`, where the build context path is `docker-tcp-service`.

## Step 1: Create a service component with a TCP endpoint

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory** | `docker-tcp-service`                  |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-tcp-service/Dockerfile.server`|

    !!! info
        1.  To successfully build your container with Choreo, it is essential to explicitly define a User ID (UID) under the USER instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-samples/blob/main/docker-tcp-service/Dockerfile.server).
        To ensure that the defined USER instruction is valid, it must conform to the following conditions:
            - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
            - Usernames are considered invalid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

        2. The Dockerfile utilized in this guide is a multi-stage Dockerfile, which is designed to keep the final image size small and provides the ability to build the application with a specific version of tools and libraries.

8. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go TCP Server`         |
    | **Component Name**        | `go-tcp-server`         |
    | **Description**           | Send greetings          |
    
9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you have connected the source repository, and configured the endpoint details, it's time to build the service and create an image. Then you can deploy the image and test the service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

    You can access the following scans under **Build**. 

      - **The Dockerfile scan**: Choreo performs a scan to check if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
      - **Container (Trivy) vulnerability scan**: This detects vulnerabilities in the final docker image. 
      - **Container (Trivy) vulnerability scan**: The details of the vulnerabilities open in a separate pane. If this scan detects critical vulnerabilities, the build will fail.
     
        !!! info
            If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Environment Configurations** pane that opens, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

6. Once you have successfully deployed your service, navigate to the component overview page and copy the TCP service address. You need to provide that address when setting up the client application later in this guide.

You have successfully deployed the TCP server. Currently, the TCP service is only accessible by the components deployed within the same project.

## Step 3: Invoke the TCP service

Now let's use a TCP client to invoke the TCP service that you created above. To do this, you can create a manual trigger component as the TCP client. This is the recommended approach because, in this example, it's more efficient to have a client that connects to the server, sends a request, and then stops. Here, a continuously executing task isn't required. Furthermore, if you use a manual trigger component, you won't need to expose an endpoint in the client for invocation, unlike with an API.

### Step 3.1: Create a manual trigger for the TCP client

To create a manual task component, follow these steps:

1. On the Choreo Console header, click the **Project** list and select the project where you created the TCP service component. This opens the project home page.
2. Go to the **Component Listing** section and click **+ Create**.
3. Click the **Manual Task** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Docker Context**      |`docker-tcp-service`     |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-tcp-service/Dockerfile.client`|

8. Enter a display name, a unique name, and a description for the component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**              |
    |---------------------------|------------------------|
    | **Component Display Name**| `Go TCP Client`        |
    | **Component Name**        | `go-tcp-client`        |
    | **Description**           | `Receive greetings`    |


9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

### Step 3.2: Build the TCP client component

To build the component, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 3.3: Setup environment variables and deploy the TCP client

The client application, in this case, the TCP client, requires the server URL of the TCP server service. This is read from the client application as an environment variable. Follow the steps below to configure the environment variable for the client application:

1. On the Choreo Console left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane that opens, click **+ Add**.
4. Specify the following name and value to configure the environment variable for the client application:

    | **Field**       | **Value**               |
    |-----------------|-------------------------|
    | **Name**        | `SERVER_ADDRESS`       |
    | **Value**       | Paste the URL value copied after deploying the TCP service via [step 2.2](#step-22-deploy) above.  Make sure to **drop the `tcp://` part and the trailing `/` from the URL when copying**. For example, add only `go-tcp-server-1097922445:8080`.|

5.  Click **Add** and then click **Next**.
6.  Click **Deploy**.

### Step 3.4: Execute the TCP client component

To execute the TCP client, follow these steps:

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the TCP client and generates logs.
   You can trigger multiple runs to generate multiple logs.

For details on what you can monitor via the execute page, see [Monitor executions](../develop-integrations/develop-a-manual-task.md#step-7-monitor-executions).


# Expose a UDP Server via a Service

Choreo offers the flexibility to design and deploy applications in the programming language of your choice. One compelling choice for certain network communication needs is UDP (User Datagram Protocol). UDP is a high-speed, connectionless protocol ideal for scenarios where lightweight, real-time data transmission is essential.

In this guide, you will learn to use Choreo to create a Service component that exposes a UDP server implemented in [Go](https://go.dev/), enabling efficient and scalable communication with any UDP client application. No prior knowledge of the Go language is necessary to follow this guide.

By following this guide, you will:

- Setup a UDP server
    - Create a simple UDP server using a Service component.
    - Link the containerized UDP service to the Choreo component using the Dockerfile. 
    - Deploy the UDP server component in Choreo. 
- Setup a UDP client
    - Create a UDP client using a manual task component. 
    - Link the containerized UDP client to the Choreo component using the Dockerfile. 
    - Deploy the UDP client component in Choreo.
- Invoke the UDP server using a UDP client and check the response through the Choreo log view.

## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample service](https://github.com/wso2/choreo-samples/tree/main/docker-udp-service) implementation for this guide.

Let's get started!

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the sample service.

!!! note 
    The following file paths are relative to the path `<sample-repository-dir>/docker-udp-service`.

|File Path                |Description                                                                                   |
|-------------------------|----------------------------------------------------------------------------------------------|
| `server/main.go`        | The greeter service code written in the Go language.                                         |
| `client/main.go`        | The greeter client application written in the Go language.                                   |
| `Dockerfile.server`     | The Dockerfile to build the container image of the server application.                       |
| `Dockerfile.client`     | The Dockerfile to build the container image of the client application.                       |
| `.choreo/component.yaml`| The Choreo-specific configuration provides information about how Choreo exposes the service. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints.

Let's run the UDP server service component on port 5050. To securely expose the service through Choreo, you must provide the port and other required information to Choreo. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

Choreo looks for an `component.yaml` file inside the `.choreo` directory to configure the endpoint details of a containerized component. Place the `.choreo` directory at the root of the Docker build context path.

In our gRPC server sample, the `component.yaml` file is at `docker-udp-service/.choreo/component.yaml`, where the build context path is `docker-udp-service`.

## Step 1: Create a service component with a UDP endpoint

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
6. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

7. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**   | `docker-udp-service`    |    

8. Select **Docker** as the buildpack.
9. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-udp-service/Dockerfile.server`|

    !!! info
        1.  To successfully build your container with Choreo, it is essential to explicitly define a User ID (UID) under the USER instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-samples/blob/main/docker-udp-service/Dockerfile.server).
        To ensure that the defined USER instruction is valid, it must conform to the following conditions:
            - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
            - Usernames are considered invalid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

        2. The Dockerfile utilized in this guide is a multi-stage Dockerfile, which is designed to keep the final image size small and provides the ability to build the application with a specific version of tools and libraries.

4. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go UDP Server`         |
    | **Component Name**        | `go-udp-server`         |
    | **Description**           | Send greetings          |

10. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you have connected the source repository, and configured the endpoint details, it's time to build the service and create an image. Then you can deploy the image and test the service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

    You can access the following scans under **Build**. 

      - **The Dockerfile scan**: Choreo performs a scan to check if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
      - **Container (Trivy) vulnerability scan**: This detects vulnerabilities in the final docker image. 
      - **Container (Trivy) vulnerability scan**: The details of the vulnerabilities open in a separate pane. If this scan detects critical vulnerabilities, the build will fail.
     
        !!! info
            If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Environment Configurations** pane that opens, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

6. Once you have successfully deployed your service, navigate to the component overview page and copy the UDP service address. You must provide that address when setting up the client application later in this guide.

You have successfully deployed the UDP server. Currently, the UDP service is only accessible by the components deployed within the same project.

## Step 3: Invoke the UDP service

Now let's use a UDP client to invoke the UDP service that you created above. To do this, you can create a manual trigger component as the UDP client. This is the recommended approach because, in this example, it's more efficient to have a client that connects to the server, sends a request, and then stops. Here, a continuously executing task isn't required. Furthermore, if you use a manual trigger component, you won't need to expose an endpoint in the client for invocation, unlike with an API.

### Step 3.1: Create a manual trigger for the UDP client

To create a manual task component, follow these steps:

1. On the Choreo Console header, click the **Project** list and select the project where you created the UDP service component. This opens the project home page.
2. Go to the **Component Listing** section and click **+ Create**.
3. Click the **Manual Task** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory** | `docker-udp-service`    |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-udp-service/Dockerfile.client`|

8. Enter a display name, a unique name, and a description for the component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**              |
    |---------------------------|------------------------|
    | **Component Display Name**| `Go UDP Client`        |
    | **Component Name**        | `go-udp-client`        |
    | **Description**           | `Receive greetings`    |


9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

### Step 3.2: Build the UDP client component

To build the component, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 3.3: Setup environment variables and deploy the UDP client

The client application, in this case, the UDP client, requires the server URL of the UDP server service. This is read from the client application as an environment variable. Follow the steps below to configure the environment variable for the client application:

1. On the Choreo Console left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane that opens, click **+ Add**.
4. Specify the following name and value to configure the environment variable for the client application:

    | **Field**       | **Value**               |
    |-----------------|-------------------------|
    | **Name**        | `SERVER_ADDRESS`       |
    | **Value**       | Paste the URL value copied after deploying the UDP service via [step 2.2](#step-22-deploy) above.  Make sure to **drop the `udp://` part and the trailing `/` from the URL when copying**. For example, add only `go-udp-server-1097922445:8080`.|

5.  Click **Add** and then click **Next**.
6.  Click **Deploy**.

### Step 3.4: Execute the UDP client component

To execute the UDP client, follow these steps:

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the UDP client and generates logs.
   You can trigger multiple runs to generate multiple logs.

For details on what you can monitor via the execute page, see [Monitor executions](../develop-integrations/develop-a-manual-task.md#step-7-monitor-executions).


# Expose a WebSocket Endpoint via a Service

Choreo allows you to create and deploy applications in your preferred programming language, offering a seamless platform for building dynamic and scalable solutions. This guide walks you through the steps to deploy a WebSocket service using the NodeJS buildpack.

WebSockets provide real-time, two-way communication between a client and server over a persistent TCP connection. This makes WebSocket APIs ideal for applications that require real-time updates.

In this guide, you will:

- Build a simple WebSocket service using a sample implementation in NodeJS.
- Deploy the service in Choreo, allowing any WebSocket client application to establish a connection and exchange real-time messages with your service.

## Prerequisites

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample WebSocket service](https://github.com/wso2/choreo-samples/tree/main/websocket-chat-app) implementation for this guide.

Let's get started!

## Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the NodeJS chat Application.

!!! note
    The following file paths are relative to the path `<sample-repository-dir>/websocket-chat-app/websocket-chat-service-nodejs`.

|Filepath                        | Description                                                     |
|--------------------------------|-----------------------------------------------------------------|
| `server.js`                    | The NodeJS chat service.                                        |
| `.choreo/component.yaml`       | The configuration file with endpoint details.                   |

!!! note
    Choreo currently supports defining WebSocket APIs using the AsyncAPI 2.0 specification.

## Step 1: Create a service component 

To create a NodeJS service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**   | `websocket-chat-app/websocket-chat-service-nodejs`  |

6. Select **NodeJS** as the buildpack and **18.x.x** as the Language Version

8. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:

    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `NodeJS Chat Service`   |
    | **Component Name**        | `nodejs-chat-service`   |
    | **Description**           | Manage a chat service   |

9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service component that provides a WebSocket API built with NodeJS. The next step is to proceed with building and deploying the service.

## Step 2: Build and deploy

Now that you have connected the source repository, it's time to build and deploy the chat service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane that opens, click **Next** to skip the configuration.
4. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

Once you have successfully deployed your service, you can [test](../../testing/test-websocket-endpoints-via-the-websocket-console.md), [manage](../../api-management/lifecycle-management.md), and observe it like any other component type in Choreo.

During testing, once the WebSocket connection is established, you can send {"type": "Connect", "username": "user1"} to the WebSocket endpoint to connect to the chat service. You can then send chat messages by using {"type": "Data", "message": "Hello, World!"}.

!!! note
     Some clients, such as certain browsers, may not support adding headers to the WebSocket handshake. In these cases, you can include the access token or test key required for WebSocket API invocation within the `sec-websocket-protocol` header, along with any specified subprotocols.

     For example: `sec-websocket-protocol: choreo-oauth2-token, {access token}, subprotocols`

     If you are using a test key, replace `choreo-oauth2-token` with `choreo-test-key`.


# Service Component Overview

Explore how to create, deploy, manage, and observe service components in Choreo.

## What is a service component?

A service component in Choreo lets you deploy and expose REST, GraphQL, gRPC, UDP, WS or TCP services. It is a fundamental building block for creating cloud-native applications in Choreo. They provide a simple and effective way to expose functionality as a service to other components within Choreo or to the outside world.

Service components encapsulate business logic and provide standardized interfaces, called endpoints, for communicating with other components or systems. You can deploy and scale services independently, which makes them highly flexible and adaptable to changing workloads.

With the help of the service component, developers can quickly create APIs and microservices, making it easier to implement and manage complex software systems. Service components can also be integrated with other Choreo components, that acts as message processors, connectors, and data sources, etc to create powerful end-to-end solutions.

You can expose a service to other components through endpoints. For details on configuring endpoints, see [Configure Endpoints](../configure-endpoints.md).


# Build and Deploy a Single-Page Web Application

A web application is an application program hosted on a server and serves ingress traffic through a browser. In Choreo, you can deploy a web application by creating a Web Application component and connecting it to a Git repository that contains the implementation of the web application. Web applications can fall into one of the following categories:

- **Single page applications (SPAs)**: Examples include React, Angular, Vue, Svelte, etc.
- **Web servers**: These serve static content or provide server-side rendering/static site generation (SSR/SSG).
- **Static content**: Examples include websites and other static resources that do not require a backend, usually comprising static HTML/JS/CSS files.

## Prerequisites

- To deploy a web application component, you must have a GitHub account with a repository containing the web application's implementation. For this guide, fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample web application implementation.

## Create a web application

You can create a web application in Choreo as follows:

### Build and deploy a SPA from source code

1. To create a web application component, connect a repository that includes the web application source code.
2. Select the relevant buildpack: Default buildpacks include **React**, **Angular**, and **Vue.js**. If you are using a different SPA framework, you can try one of these buildpacks because the configurations can be overridden to support most JavaScript-based SPAs.
3. Enter the build command: Based on your package manager (NPM, yarn, or pnpm). The relevant package manager is run based on the dependency lock file in your repository (defaults to NPM if no lock file is present).
4. Specify the build output directory.
5. Specify the NodeJS version: Choreo does not pick the Node.js version from the `package.json` engine property. The required Node version must be explicitly set in the build configuration.

Once you create the Web Application component, Choreo automatically generates a build pipeline for your single-page application and deploys it.

### Bring your Dockerfile

1. To create a web application component, connect a repository that contains the Dockerfile for your containerized web application.
2. Commit a Dockerfile to your connected Git repository to have full control over your build process.

This approach is recommended if you are deploying a web server and not just a single-page application (or a single-page application with a complex build process).

### Host static websites

1. Create a web application component and connect it to the GitHub repository that contains the required static assets.
2. Select the **Static Websites** buildpack: This buildpack does not trigger a build process. It only fetches the files from the path specified in the repository and serves them as-is.

## Build and deploy a SPA from source code

Follow the steps below to create a sample Web Application component and deploy it in Choreo:

1. Sign in to the Choreo Console at [https://console.choreo.dev/login/](https://console.choreo.dev/login/). This opens the **Project Home** page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Web Application** card.
6. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

7. Enter the following information:

    | **Field**                 | **Description**        |
    |---------------------------|------------------------|
    | **GitHub Account**        | Your account           |
    | **GitHub Repository**     | choreo-samples         |
    | **Branch**                | main                   |
    | **Component Directory**     | /react-single-page-app |

8. Select **React** as the **Buildpack**.
9. Enter the following information:

    | **Field**                 | **Description**        |
    |---------------------------|------------------------|
    | **Build Command**         | `npm run build`        |
    | **Build Path**            | `build`                |
    | **Node Version**          | `18`                   |

    !!! tip
        Managed authentication is enabled by default when you create a web application using **React**, **Angular**, or **Vue.js** buildpacks. To learn how to set up authentication for your web application with Choreo's managed authentication, see [Secure Web Applications with Managed Authentication](../../authentication-and-authorization/secure-web-applications-with-managed-authentication.md).

4. Specify a display name, a unique name and description for the component.
10. Click **Create**. Choreo initializes the component with the sample implementation and opens the **Overview** page of the component.

You have successfully created a Web Application component from the source code. Now let's build and deploy the web application.

## Build your web application

1. In the left navigation menu, click **Build**.
2. In the **Builds** pane, click **Build**. This opens the **Commits** pane, where you can see all the commits related to the component.
3. Select the latest commit and click **Build**. This triggers the build process and displays the progress in the **Build Logs** pane.

    You can access the following scans in the **Build Logs** pane:

    - **Dockerfile Scan**: Choreo checks if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
    - **Container (Trivy) Vulnerability Scan**: Detects vulnerabilities in the final Docker image. If critical vulnerabilities are detected, the build will fail.

    !!! info
        If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

    !!! note
        The build process may take some time. Once complete, the build status will be listed in the **Builds** pane. Here, you will see the build status as **Success**.

## Deploy and access your web application

1. In the left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure and Deploy**. This opens the **Configure & Deploy** pane. In this guide, you do not need to add a file mount.
3. Click **Next** to proceed to the **Authentication Settings** pane.
4. Keep the default settings and click **Deploy**.

    !!! note
        The deployment process may take a few minutes. Once complete, the **Deployment Status** will show as **Active** in the **Development** card.

5. To verify that the web application is hosted successfully, click the **Web App URL** in the **Development** card. This takes you to the web application.

## Create a short URL for your web application in production

!!! info
    This feature is only available on the Choreo cloud data plane.

When you promote your component to the Production environment, you can create a personalized short URL for your web application. The URL follows the `https://{your-short-prefix}.choreoapps.dev` structure, where you can select a name of your preference for `{your-short-prefix}`.

1. Click **Promote** in the **Development** card and promote your web application to production.
2. In the **Production** card, click **Create a short URL**.
3. Specify a **Short URL prefix** of your choice and click **Save**.

    !!! note
        Short URL names/prefixes are subject to availability, provided on a first-come-first-serve basis.

## Manage runtime configurations for web applications

For web applications with a backend server, Choreo allows you to mount runtime configurations and secrets as environment variables and/or file mounts for a specific environment. Alternatively, you can also inject them into the client application during server-side rendering or when serving static content.

For SPAs that run completely on the browser, Choreo does not support *baking-in* environment variables or other configurations. Instead, Choreo recommends the following approach (applicable to most SPA frameworks, including React):

!!! note
    - With SPAs, anything you mount as a runtime config will be available to your users in the browser.
    - **Do not include sensitive secrets that are not browser-safe**.

1. Go to your forked [Choreo samples repository](https://github.com/wso2/choreo-samples).
2. Open the `public` directory.
3. Create and commit a new file named `config.js` in the `public` directory of your React application. This file should contain the runtime configuration variables you want to expose to your application, such as API endpoints or feature flags. For example:

    ```javascript
    window.config = {
        apiUrl: 'https://api.example.com',
        featureFlags: {
            enableNewFeature: true,
            enableExperimentalFeature: false,
        },
    };
    ```

4. In your `index.html` file inside the `public` directory, add a script tag to include the `config.js` file inside the `<body>` tag:

    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>My React App</title>
    </head>
    <body>
        <div id="root"></div>
        <script src="%PUBLIC_URL%/config.js"></script>
    </body>
    </html>
    ```

5. In your React component, access the configuration variables by referencing the `window.config` object:

    ```javascript
    import React from 'react';

    function MyComponent() {
        const apiUrl = window.config.apiUrl;
        const enableNewFeature = window.config.featureFlags.enableNewFeature;
        const enableExperimentalFeature = window.config.featureFlags.enableExperimentalFeature;

        // ...
    }
    ```

6. When you deploy your component to Choreo, create a config file mount in the specified path for each environment (where your `index.html` expects the `config.js` file). For more details, see [Manage Configurations and Secrets](https://wso2.com/choreo/docs/devops-and-ci-cd/manage-configurations-and-secrets/#apply-a-file-mount-to-your-container).

## Limitations

The following limitations are specific to the Choreo cloud data plane:

- **Request size limit**: 256KB (including headers, cookies, and payloads).
- **Response body size limit**: 20MB.
- **Open ports**: Only one open port is permitted per web application. While you can have multiple ports open for project-level communication within a data plane, incoming traffic from the internet can only be directed to one port. This differs from Service-type components, which support multiple endpoints.

## Troubleshoot a web application

- **Blank page or 502 error after deployment**:
    If you encounter a blank page or a 502 error after deploying your web application, it typically indicates that the wrong directory is being served. To resolve this issue:
    1. Double-check the build output directory, especially if you are using a Dockerfile-less buildpack.
    2. Ensure that the specified output directory matches the actual output directory generated during the build process. For example, if you have erroneously entered `public/` as the output directory when it should have been `build/`.

By verifying and correcting the output directory alignment, you should be able to address the issue of encountering a blank page or experiencing a 502 error on deploying your web application.


# Develop Web Applications Locally with Choreo’s Managed Authentication

Choreo’s managed authentication capability provides a set of backend for frontend (BFF) endpoints to facilitate authentication and authorization for web applications. These endpoints are readily available for single-page web applications deployed on Choreo.

As a web application developer, you may need to run the application on your local workstation. Choreo’s local development capability ensures that authentication and authorization during local development work the same way as they do when the application is deployed to Choreo, eliminating the need for code changes.

This guide explains how to configure and use Choreo’s local development capability to streamline your workflow.

## How local development works in Choreo

Local development uses a proxy that sits in front of the locally running web application. This proxy intercepts all incoming requests:
- Requests to `/choreo-apis/*` and `/auth/*` are forwarded to Choreo.
- All other requests are forwarded to the locally running web application.

The proxy runs on HTTPS using a self-signed certificate, which is essential for secure, HTTP-only cookie-based managed authentication. Once the proxy is running, you can access the web application using the proxy's URL and start developing locally. The behavior of the web application, in terms of managed authentication, will mirror its behavior when deployed to Choreo.

## Configure local development

### Prerequisites

- Create a single-page application (SPA) with managed authentication enabled. For details, see [Secure Web Applications with Managed Authentication](../../authentication-and-authorization/secure-web-applications-with-managed-authentication.md#step-1-set-up-managed-authentication-for-your-web-application).
- Promote and deploy the application to the environment where you want to enable local development.

    !!! note
        - The locally running web application will use the same managed authentication configuration as the environment where local development is configured.
        - Local development is only allowed in non-critical environments.

### Apply configurations

1. Sign in to the Choreo Console.
2. In the **Component Listing** pane, click on the component you created and deployed.
3. In the left navigation menu, click **Deploy**.
4. Go to the respective environment card and click **Local Development**.
5. In the **Local Development** pane, toggle **Local Development** to enable it.
6. (Optional) To update the port on which the local development proxy server runs, expand **Advanced Configurations** and specify a value for **Proxy Port**.
7. Click **Apply**.

You have now configured local development. The next section explains how to access your web application for local development.

## Access your web application locally

### Prerequisites

- Ensure local development is enabled in the desired environment.
- Ensure your web application is running locally on `http://localhost` on a specific port.

### Access your web application locally

You can use either the Choreo built-in identity provider or an external identity provider to access your web application locally.

=== "Use the Choreo built-in identity provider"

    1. Sign in to the Choreo Console.
    2. In the **Component Listing** pane, click on the component you created and deployed.
    3. In the left navigation menu, click **Deploy**.
    4. Go to the respective environment card and click **Local Development**.
    5. In the **Local Development** pane, copy the command under **Step 1**.
    6. Paste the command in a terminal, replace `[APP_PORT]` with the port on which your application is running locally, and run the command.
    7. To access the application, go to the URL provided under **Step 2** in the **Local Development** pane.

        !!! note
            The local development proxy runs on HTTPS using a self-signed certificate. Your browser may warn that the certificate is not valid. Accept the risk and proceed.

=== "Use an external identity provider"

    1. Sign in to the Choreo Console.
    2. In the **Component Listing** pane, click on the component you created and deployed.
    3. In the left navigation menu, click **Deploy**.
    4. Go to the respective environment card and click **Local Development**.
    5. In the **Local Development** pane, copy the redirect URLs under **Step 1**.
    6. Go to the settings in the OAuth application in your identity provider and specify the copied URLs as allowed redirect URLs.
    7. In the **Local Development** pane, copy the command under **Step 2**.
    8. Paste the command in a terminal, replace `[APP_PORT]` with the port on which your application is running locally, and run the command.
    9. To access the application, go to the URL provided under **Step 3** in the **Local Development** pane.

        !!! note
            The local development proxy runs on HTTPS using a self-signed certificate. Your browser may warn that the certificate is not valid. Accept the risk and proceed.


# Create a Connection

Connections in Choreo provide a simple and uniform approach to seamlessly integrate components with services or resources.

Choreo allows you to create connections to services deployed in Choreo or registered as external services. It also allows you to create connections to any Choreo-managed database.

To create a connection to a service or a database, follow the step-by-step instructions in the respective tab:

=== "Create a connection to a service"

    <h2>Create a connection to a Choreo service</h2>

    Follow these steps to create a connection to a service deployed in Choreo:

    1. In the Choreo Console, go to the top navigation menu and set the visibility level as [project](../../choreo-concepts/connections.md#project-connections) or [component](../../choreo-concepts/connections.md#component-connections) as follows: 

        - **Project Connection**: Select an organization and a project in that organization. 
        - **Component Connection**: Select an organization, a project in that organization, and a component in the selected project. 

    2. In the left navigation menu, click **Dependencies**  and then **Connections**. This page lists all the existing connections.
    3. Click **+Create**. This opens the Marketplace view where you can browse and search for services or databases.
    4. Click the **Services** tab. You can search and apply filters to efficiently find a service.
    5. Click on the service you want to connect to. 
    6. Enter a name and a description for the connection.
    7. Select an **Access Mode** and **Authentication Scheme** for the connection.
    8. Click **Create**.
   
    This creates the connection and displays its details for each environment, along with an inline guide on how to use the connection in your component. 

    !!! note
        During connection creation, secret values for the lowest environment are visible, allowing you to copy them for local use if necessary. Secret values for higher environments remain hidden to ensure security
     
    <h2>Create a connection to an external service</h2>

    Follow these steps to create a connection to an external service:

    1. Follow steps 1–5 from the previous section.
    2. Expand the **Environment to Endpoint** section and verify the service endpoints assigned to the Choreo environments.
    3. Click **Create**.

      For step-by-step instructions on using a connection in your service, see [Use a Connection in Your Service](./use-a-connection-in-your-service.md).

      For step-by-step instructions on using a connection in your web application, see [Use a Connection in Your Web Application](./use-a-connection-in-your-web-application.md).


=== "Create a connection to a database"

    Prerequisites:

     - Create a Choreo-managed database. For details, see [Choreo-Managed Databases and Caches](../../manage-databases-and-caches/choreo-managed-databases-and-caches.md).
     - Add the database to the Marketplace. For details, see [Add Choreo-Managed Databases and Caches to the Marketplace](../../manage-databases-and-caches/add-choreo-managed-databases-and-caches-to-the-marketplace.md).

    Follow these steps to create a connection to a Choreo-managed database:

    1. In the Choreo Console, go to the top navigation menu and set the visibility level as [project](../../choreo-concepts/connections.md#project-connections) or [component](../../choreo-concepts/connections.md#component-connections) as follows: 

        - **Project Connection**: Select an organization and a project in that organization. 
        - **Component Connection**: Select an organization, a project in that organization, and a component in the selected project. 

    2. In the left navigation menu, click **Dependencies**  and then **Connections**. This page lists all the existing connections.
    3. Click **+Create**. This opens the Marketplace view where you can browse and search for services or databases.
    4. Click the **Databases** tab. You can search and apply filters to efficiently find a database.
    5. Click on the database you want to connect to. 
    6. To create the connection, follow these steps:

        1. Enter a name and description.
        2. Under **Environment Configuration**, select credentials for each environment.

            !!! note
                 By default, the selected database is applied to all environments. To use different databases for specific environments, select the appropriate database and provide the corresponding credentials for each environment.

        3. Click **Create**.  
    
    This creates the connection and displays the database connection details for each environment, along with an inline guide on how to use the connection in your component. 

    !!! note
        During connection creation, secret values for the lowest environment are visible, allowing you to copy them for local use if necessary. Secret values for higher environments remain hidden to ensure security
    
    For step-by-step instructions on using a database in your component, see [Use a Database Connection in Your Component](./use-a-database-connection-in-your-component.md).


# Use a Connection in Your Service

Choreo allows you to share and reuse your services, accelerating development and enhancing efficiency in building integrated applications through connections.

For step-by-step on instruction on creating a connection, see [Create a Connection](create-a-connection.md).

To learn more about Choreo Connections, see the documentation on [Connections](../../choreo-concepts/connections.md).

## Consume a service through a connection

You can consume a Choreo-deployed service within another service. Consuming connections from within Choreo services is seamless and straightforward. Follow the steps below to consume a Choreo service:

### Step 1: Add connection configurations

To integrate another service into your application, click the appropriate tab below based on your current configuration file and follow the step-by-step instructions:

=== "Component.yaml file (v1.1)"

    1. Copy and paste the snippet from the in-line developer guide into the `component.yaml` file.

        The following is a sample snippet: 

        ``` yaml

        dependencies:
            connectionReferences:
            - name: <CONNECTION_NAME>
              resourceRef: <RESOURCE_IDENTIFIER>

        ```

          | Field            | Description                                                         |
          |------------------|---------------------------------------------------------------------|
          | name             | The name given to the connection.                                   |
          | resourceRef      | A unique, readable identifier of the service being connected to.    |


    2. If you've previously added a `connectionReferences` section under `dependencies`, append this as another item under `connectionReferences`. Upon deploying the component, Choreo automatically creates a subscription if applicable and the necessary configurations to establish the connection will be injected into the Choreo-defined environment variables.
      
          The following table details the Choreo-defined environment variables:

          | Configuration Key       | Choreo-Defined Environment Variable Name                       |
          |-------------------------|----------------------------------------------------------------|
          | ServiceURL              | CHOREO_<CONNECTION_NAME\>_SERVICEURL                           |
          | ConsumerKey             | CHOREO_<CONNECTION_NAME\>_CONSUMERKEY                          |
          | ConsumerSecret          | CHOREO_<CONNECTION_NAME\>_CONSUMERSECRET                       |
          | TokenURL                | CHOREO_<CONNECTION_NAME\>_TOKENURL                             |
          | ChoreoAPIKey            | CHOREO_<CONNECTION_NAME\>CHOREOAPIKEY                          |


          If you want to use custom environment variable names instead of the Choreo-defined ones, you must define the environment configurations under the `configuration` section in the same file.
          The following is a sample snippet: 

          ``` yaml
          configuration:
            env:
              - name: HR_SERVICE_URL
                valueFrom:
                  connectionRef:
                    name: hr-connection
                    key: ServiceURL
          ```

          The following table provides details on the configuration keys associated with the connection. These keys can be referenced as `env[i].valueFrom.connectionRef.key`.

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | ServiceURL     | string     | Service URL of the Choreo service     | false         | false        |
          | ConsumerKey    | string     | Consumer key of the Choreo service    | false         | false        |
          | ConsumerSecret | string     | Consumer secret of the Choreo service | false         | true         |
          | TokenURL       | string     | Token URL of the STS                  | false         | false        |
          | ChoreoAPIKey   | string     | API key of the Choreo service         | false         | true         |

          For more details, see the instructions under the **component.yaml file (v1.1)** tab.

    ### Step 2: Read configurations within the application

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const serviceURL = process.env.CHOREO_<CONNECTION_NAME>_SERVICEURL;
    ```

=== "Component.yaml file (v1.0)"

    !!! note
        This `component.yaml v1.0` is a legacy configuration format. For new projects, we recommend using the latest version (v1.1) of `component.yaml` for improved usability and features.
  
    1. Copy and paste the snippet from the in-line developer guide into the `component.yaml` file.
      
        The following is a sample snippet:

        ``` yaml

        dependencies:
            serviceReferences:
            - name: <SERVICE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: ServiceURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerSecret
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: TokenURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ChoreoAPIKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>

        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the service you are connecting to.              |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added a service reference section under `dependencies`, append this as another item under `serviceReferences`. 

          Upon deploying the component, Choreo automatically creates a subscription if applicable and populates the specified environment variables with actual values.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | ServiceURL     | string     | Service URL of the Choreo service     | false         | false        |
          | ConsumerKey    | string     | Consumer key of the Choreo service    | false         | false        |
          | ConsumerSecret | string     | Consumer secret of the Choreo service | false         | true         |
          | TokenURL       | string     | Token URL of the STS                  | false         | false        |
          | ChoreoAPIKey   | string     | API key of the Choreo service         | false         | true         |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const serviceURL = process.env.SVC_URL;
    ```

=== "Component-config.yaml file"

    !!! note
        This `component-config.yaml` is a legacy configuration format. For new projects, we recommend using the latest version (v1.1) of `component.yaml` for improved usability and features.

    1. Copy and paste the snippet from the in-line developer guide into the `component-config` file under the `spec` section.

        The following is a sample snippet:

        ``` yaml

        outbound:
            serviceReferences:
            - name: <SERVICE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: ServiceURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerSecret
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: TokenURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ChoreoAPIKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>

        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the service you are connecting to.              |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added an outbound service reference, append this as another item under `serviceReferences`. 

          Upon deploying the component, Choreo automatically creates a subscription if applicable and populates the specified environment variables with actual values.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | ServiceURL     | string     | Service URL of the Choreo service     | false         | false        |
          | ConsumerKey    | string     | Consumer key of the Choreo service    | false         | false        |
          | ConsumerSecret | string     | Consumer secret of the Choreo service | false         | true         |
          | TokenURL       | string     | Token URL of the STS                  | false         | false        |
          | ChoreoAPIKey   | string     | API key of the Choreo service         | false         | true         |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const serviceURL = process.env.SVC_URL;
    ```

If you're using the API key security scheme for the connection, skip Step 3 and follow the instructions in [Step 4: API key security scheme](#step-4-invoke-the-service) tab.

### Step 3: Acquire an OAuth 2.0 access token

To consume a Choreo service with the visibility level set to organization or public and secured by the OAuth 2.0 security scheme, you must obtain an OAuth 2.0 token from the token endpoint. Subsequently, you can use the token to invoke the service.

- For languages with OAuth 2.0-aware HTTP clients, you must pass the OAuth 2.0-related configurations such as client id, client secret and so on, obtained when creating the connection to your HTTP client configuration. The HTTP client autonomously manages token retrieval and refreshing.

- For languages without OAuth 2.0-aware HTTP clients, you must manually initiate a call to the token endpoint. This includes fetching the token and managing token expiration and refresh directly within your application code. The following is a sample curl command to obtain a token:


    ```bash
    CONSUMER_KEY="your_consumer_key"
    CONSUMER_SECRET="your_consumer_secret"
    TOKEN_URL="your_token_url"

    # Encode client credentials as Base64
    CLIENT_CREDENTIALS=$(echo -n "$CLIENT_ID:$CLIENT_SECRET" | base64)

    curl -X POST $TOKEN_URL \
      -H "Content-Type: application/x-www-form-urlencoded" \
      -H "Authorization: Basic $CLIENT_CREDENTIALS" \
      --data-urlencode "grant_type=client_credentials"

    ```

### Step 4: Invoke the service

Click the tab that matches the security scheme of your service and follow the instructions below:

=== "API key security scheme"

     To invoke the API, use the `choreo-api-key` header with the API key value retrieved from the corresponding environment variable as described in [step 2](#step-2-read-configurations-within-the-application).

     The following is a sample code snippet in NodeJS:

     ``` java
       const response = await axios.get(serviceURL/{RESOURCE_PATH}, {
           headers: {
             'Choreo-API-Key': `${choreoApiKey}`
           }
       });
     ```

=== "OAuth 2.0 security scheme"

     To invoke the service, use the following instructions based on your programming language:

      - For languages with OAuth 2.0-aware HTTP clients, use the service URL resolved in [Step 2](#step-2-read-configurations-within-the-application). The OAuth-aware client manages authentication automatically. For sample requests and responses, see the API definition provided via the Choreo marketplace for the service.

      - For languages without OAuth 2.0-aware HTTP clients, use the token obtained in [step 3](#step-3-acquire-an-oauth-20-access-token) to make calls to the dependent service. Subsequently, add the obtained token to the HTTP authorization header with the bearer prefix. As the service URL, use the URL resolved in [step 2](#step-2-read-configurations-within-the-application). For sample requests and responses, see the API definition of the service provided via the Choreo marketplace.

       The following is a sample code snippet in NodeJS:

       ``` java
       const response = await axios.get(serviceURL/{RESOURCE_PATH}, {
           headers: {
             'Authorization': `Bearer ${accessToken}`
             'Choreo-API-Key': `${choreoApiKey}`
           }
       });
       ```

    !!! note
        If you want to consume a Choreo service at the project visibility level, you don't need to obtain a token. You can directly invoke the service using the resolved URL.


# Use a Connection in Your Web Application

Choreo simplifies the process of integrating services into your web application. The approach to connect to a service can vary based on your web application. 

To connect to a selected service, follow the step-by-step instructions given below depending on the authentication mechanism used in your web application.

=== "Managed authentication"
    
    Choreo-managed authentication allows you to seamlessly handle authentication for your web application. You can configure your web application to work with the built-in identity provider of Choreo or any external identity provider that supports OIDC/OAuth2.0

    !!! note 
         Choreo's managed authentication is currently available only for web applications created with **React**, **Angular**, or **Vue.js** buildpacks.

    Follow the steps below to use an existing connection within your web application: 

    <h2> Step 1: Add the connection configuration</h2>

    To integrate a service into your application, you must first add the connection configuration as follows: 

    1. For single page applications (SPAs), you must add the connection configuration as a file mount. You can mount a file via the **Configurations** pane on the **Deploy** page. You must mount a file (for example, `config.js`) and add the configuration provided in the inline developer documentation into it. 

        The following is a sample configuration:

        ``` yaml
             window.configs = {
                 apiUrl: '<SERVICE_URL>',        
             };

        ```

    2.  To ensure accessibility of the `config.js` file via JavaScript at runtime, add a script tag as follows in the `index.html` file to reference the `config.js` file:

        ``` html
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="utf-8" />
            <title>My React App</title>
        </head>
        <body>
            <div id="root"></div>
            <script src="/public/config.js"></script>
        </body>
        </html>
        ``` 

        !!! note
             If you use an external IdP, you must add the IdP's configuration to the same file.
    
             For more information on working with IdPs, see [Configure Asgardeo as an External Identity Provider](https://wso2.com/choreo/docs/administer/configure-an-external-idp/configure-asgardeo-as-an-external-idp/).


    <h2> Step 2: Read the configuration</h2>

    Once you add the connection configuration, you can proceed to read the configuration from your application. The steps to read depend on the programming language you use.

    The following is a sample code snippet in NodeJS:

    ``` java
         const serviceURL = window?.configs?.apiUrl ? window.configs.apiUrl : "/";
    ```

    <h2> Step 3: Invoke the service</h2>

    If you use Choreo-managed authentication, Choreo handles the security handshaking for the application during deployment. The connected service will be accessible under the same domain as your application. Therefore, you can call the configured path directly using your preferred HTTP client.

    The following is a sample code snippet in NodeJS:

    ``` java
         const response = await axios.get(serviceURL/{RESOURCE_PATH});
    ```

    !!! note
         If you are using an external IdP provider instead of Choreo-managed authentication, you must obtain an access token from your IdP and add it to the HTTP authorization header with the bearer prefix.


=== "Custom authentication or no authentication"

    If you are not using Choreo-managed authentication or your web application lacks authentication, follow the steps below to connect to a service from your web application:

    <h2> Step 1: Add the connection configuration</h2>

    1. For single-page applications (SPAs), you must add the connection configuration as a file mount. You can mount a file via the **Configurations** pane on the **Deploy** page. You must mount a file (for example, `config.js`) and add the configuration provided in the inline developer documentation into it.
 
        The following is a sample configuration:

        ``` yaml
             window.configs = {
                 apiUrl: '<SERVICE_URL>',
                 consumerKey: '<CONSUMER_KEY>',
                 consumerSecret: '<CONSUMER_SECRET>',
                 tokenUrl: '<TOKEN_URL>',
             };
        ```

    2.  To ensure accessibility of the `config.js` file via JavaScript at runtime, add a script tag as follows in the `index.html` file to reference the `config.js` file:

        ``` html
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="utf-8" />
            <title>My React App</title>
        </head>
        <body>
            <div id="root"></div>
            <script src="/public/config.js"></script>
        </body>
        </html>
        ``` 

    For other types of web applications, you must add the respective configuration into your application.

    <h2> Step 2: Read the configuration</h2>

    Once you have added the connection configuration, you can proceed to read the configuration from your application. The steps to read depend on the programming language you use.

    The following is a sample code snippet in NodeJS:

    ``` java
         const serviceURL = window?.configs?.apiUrl ? window.configs.apiUrl : "/";
    ```

    <h2> Step 3: Acquire an OAuth 2.0 access token</h2>

    - For languages with OAuth 2.0-aware HTTP clients, you must pass the OAuth 2.0-related configurations such as client id, client secret and so on, obtained when creating the connection to your HTTP client configuration. The HTTP client autonomously manages token retrieval and refreshing.
  
    - For languages without OAuth 2.0-aware HTTP clients, you must manually initiate a call to the token endpoint. This includes fetching the token and managing token expiration and refresh directly within your application code. The following is a sample curl command to obtain a token:


        ```bash
        CONSUMER_KEY="your_consumer_key"
        CONSUMER_SECRET="your_consumer_secret"
        TOKEN_URL="your_token_url"

        # Encode client credentials as Base64
        CLIENT_CREDENTIALS=$(echo -n "$CLIENT_ID:$CLIENT_SECRET" | base64)

        curl -X POST $TOKEN_URL \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -H "Authorization: Basic $CLIENT_CREDENTIALS" \
        --data-urlencode "grant_type=client_credentials"

        ```

    <h2> Step 4: Invoke the service</h2>

    You can invoke the service as follows:

    - For languages with OAuth 2.0-aware HTTP clients, you can invoke the service in a straightforward manner. The HTTP client seamlessly manages OAuth 2.0 authentication without requiring additional intervention.

        As the service URL you can use the URL that you resolved in step 2 above. For sample requests and responses, see the API definition provided via the Choreo marketplace for the service.

    - For languages without OAuth 2.0-aware HTTP clients, you can use the token obtained in step 3 above to make calls to the dependent service. Subsequently, add the obtained token to the HTTP authorization header with the bearer prefix.

        As the service URL you can use the URL that you resolved in step 2 above. For sample requests and responses, see the API definition of the service provided via the Choreo marketplace.

        The following is a sample code snippet in NodeJS:

        ```java 
            const response = await axios.get(serviceURL/{RESOURCE_PATH}, {
                headers: {
                'Authorization': `Bearer ${accessToken}`
                }
            })
        ```


# Use a Database Connection in Your Component

Choreo allows you to share and reuse Choreo-managed databases, accelerating development and enhancing efficiency in building integrated applications through connections.

For step-by-step instructions on creating a database connection, see [Create a Connection](create-a-connection.md).

To learn more about Choreo Connections, see the documentation on [Connections](../../choreo-concepts/connections.md).

## Consume a database through a connection

To consume a Choreo-managed database via a connection, follow these steps:

### Step 1: Add connection configurations

To integrate a database into your application, click the appropriate tab below based on your current configuration file and follow the step-by-step instructions:

=== "Component.yaml file (v1.1)"

    1. Copy and paste the snippet from the  developer guide into the `component.yaml` file.

        The following is a sample snippet:

        ``` yaml

        dependencies:
            connectionReferences:
            - name: <CONNECTION_NAME>
              resourceRef: <RESOURCE_IDENTIFIER>

        ```

          | Field            | Description                                                         |
          |------------------|---------------------------------------------------------------------|
          | name             | The name given to the connection.                                   |
          | resourceRef      | A unique, readable identifier of the database being connected to.    |


    2. If you've previously added a `connectionReferences` section under `dependencies`, append this as another item under `connectionReferences`. Upon deploying the component, the necessary configurations to establish the connection will be injected into Choreo-defined environment variables.

          The following table details the Choreo-defined environment variables:

          | Configuration Key       | Choreo-Defined Environment Variable Name                       |
          |-------------------------|----------------------------------------------------------------|
          | HostName                | CHOREO_<CONNECTION_NAME\>_HOSTNAME                             |
          | Port                    | CHOREO_<CONNECTION_NAME\>_PORT                                 |
          | Username                | CHOREO_<CONNECTION_NAME\>_USERNAME                             |
          | Password                | CHOREO_<CONNECTION_NAME\>_PASSWORD                             |
          | DatabaseName            | CHOREO_<CONNECTION_NAME\>DATABASENAME                          |


          If you'd like to use custom environment variable names instead of the Choreo-defined ones, add the dependency as a service reference under `dependencies` in the same file. For more details, refer to the instructions under the `component.yaml file (v1.0)` tab.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | HostName       | string     | Hostname of the database server       | false         | false        |
          | Port           | string     | Port of the database server           | false         | false        |
          | Username | string           | Username of the database server       | false         | false        |
          | Password       | string     | Password of the database server       | false         | true         |
          | DatabaseName   | string     | Name of the database                  | false         | false        |
    ### Step 2: Read configurations within the application

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const hostName = process.env.CHOREO_<CONNECTION_NAME>_HOSTNAME;
    ```

=== "Component.yaml file (v1.0)"

    !!! note
        The `component.yaml v1.0` file is considered legacy. For new components, we recommend using the latest version, `component.yaml v1.1`, which offers enhanced usability and features.

    1. Copy and paste the snippet from the  developer guide into the `component.yaml` file.

        The following is a sample snippet:

        ``` yaml

        dependencies:
            serviceReferences:
            - name: database:<DATABASE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: HostName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Port
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Username
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Password
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: DatabaseName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>


        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the database you are connecting to.             |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added a service reference section under `dependencies`, append this as another item under `serviceReferences`.

          Upon deploying the component, Choreo automatically populates the specified environment variables with actual values.

          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | HostName       | string     | Hostname of the database server       | false         | false        |
          | Port           | string     | Port of the database server           | false         | false        |
          | Username | string           | Username of the database server       | false         | false        |
          | Password       | string     | Password of the database server       | false         | true         |
          | DatabaseName   | string     | Name of the database                  | false         | false        |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const hostName = process.env.HOSTNAME;
    ```

=== "Component-config.yaml file"

    !!! note
        The `component-config.yaml` file is considered legacy. For new components, we recommend using the latest version, `component.yaml v1.1`, which offers enhanced usability and features.

    1. Copy and paste the snippet from the  developer guide into the `component-config` file under the `spec` section.

        The following is a sample snippet:

        ``` yaml

        outbound:
            serviceReferences:
            - name: database:<DATABASE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: HostName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Port
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Username
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Password
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: DatabaseName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>

        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the database you are connecting to.              |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added an outbound service reference, append this as another item under `serviceReferences`.

          Upon deploying the component, Choreo automatically populates the specified environment variables with actual values.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | HostName       | string     | Hostname of the database server       | false         | false        |
          | Port           | string     | Port of the database server           | false         | false        |
          | Username | string           | Username of the database server       | false         | false        |
          | Password       | string     | Password of the database server       | false         | true         |
          | DatabaseName   | string     | Name of the database                  | false         | false        |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const hostName = process.env.HOSTNAME;
    ```

### Step 3: Initiate a database connection

To initiate a connection to the database, follow these steps:

In this example, you will connect to a MySQL database.

#### Step 3.1: Install the required packages

For the MySQL database, install the `mysql2` package using npm:

```bash
// Install the mysql2 package
npm install mysql2

```

#### Step 3.2: Import required packages

```java

const client = require('mysql2')

```

#### Step 3.3: Establish a connection

To establish the connection, use the environment variables for `hostName`, `username`, `password`, `databaseName`, and `port` as follows:

```java

var connection = client.createConnection({
      host: hostName,
      user: username,
      password: password,
      database: databaseName,
      port: port
});

connection.connect((err) => {
      if (err) {
          return;
      }
      // Connection is successful
});

```

By following these steps, your component can interact with the Choreo-managed database seamlessly.




# Integrate Unit Tests into the Build Pipeline

Choreo allows you to integrate unit tests into the build pipeline, enabling code validation before deployment. This ensures early testing of code changes, reducing the risk of defects in production.

!!! note
        Currently, Choreo supports unit tests only for the `WSO2 MI` buildpack.

## How it works

### Step 1: Write tests

You can create unit tests in your source code using standard testing libraries. For step-by-step instructions on creating unit tests for WSO2 Micro Integrator projects, see [Creating a Unit Test Suite](https://mi.docs.wso2.com/en/latest/develop/creating-unit-test-suite/).

### Step 2: Enable unit tests

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click the component for which you want to enable unit tests.
3. In the left navigation menu, click **Build**.
4. On the **Build** page, click to edit **Build Configurations**.
5. Turn on the **Unit Test** toggle.
6. Click **Save**.

### Step 3: Trigger a new build

- On the **Build** page, click **Build Latest**.

This starts a new build with unit tests enabled. You can monitor its progress in the **Build Details** pane.

## View failed unit tests

If a unit test fails during the build, you can view its detailed logs for troubleshooting. Click **View Details** corresponding to the failed build, then expand the failed unit test step to view the logs.

## Explore a sample

To see unit tests in action within the build pipeline, try out the [WSO2 MI helloworld](https://github.com/wso2/choreo-samples/tree/main/hello-world-mi) sample. 


# Manage Component Source Configurations

In Choreo, you can configure service endpoints and connections via the `component.yaml` source configuration file. This file ensures that the configurations required to initialize endpoints and connections are defined, as they cannot be inferred from the source code. This guide provides an overview of how to configure and manage these settings effectively.

The source configuration file must be committed to your repository within the `.choreo` directory at the root of the project directory. This ensures the ability to version the configuration files alongside repository commits, enabling better tracking and management of configurations.

!!! note
    -  The `component-config.yaml` and `endpoints.yaml` files will eventually be deprecated and replaced by the `component.yaml` file. 
        - For details on how to seamlessly update to the latest `component.yaml` file`, see [Update to the latest source configuration file](#update-to-the-latest-source-configuration-file).
    - Choreo prioritizes configuration files in the following order: `component.yaml` takes the highest precedence, followed by `component-config.yaml`, and then `endpoints.yaml`.

## Overview of the `component.yaml` file 

**File location**:

```bash
<build-context-path>/.choreo/component.yaml
```

!!! note
    - For components built using **Buildpacks**, replace `build-context-path` with the `<project-directory>`. 
    For example, `<project-directory>/.choreo/component.yaml`.
    - For components built using **Docker**, replace `build-context-path` with the `<docker-context-path>`. 
    For example, `<docker-context-path>/.choreo/component.yaml`.

**Sample `component.yaml` file content**:

Click the respective tab to view the structure for your current configuration file version:

=== "Version 1.1"

    ``` yaml
    # +required The configuration file schema version
    schemaVersion: 1.1

    # +optional Incoming connection details for the component
    endpoints:
      # +required Unique name for the endpoint.
      # This name will be used when generating the managed API
      - name: greeter-sample
        # +optional Display name for the endpoint.
        displayName: Go Greeter Sample
        # +required Service section has the user service endpoint details
        service:
          # +optional Context (base path) of the API that gets exposed via the endpoint.
          basePath: /greeting-service
          # +required Numeric port value that gets exposed via the endpoint
          port: 9090
        # +required Type of traffic that the endpoint is accepting.
        # Allowed values: REST, GraphQL, WS, GRPC, TCP, UDP.
        type: REST
        # +optional Network level visibilities of the endpoint.
        # Accepted values: Project|Organization|Public(Default).
        networkVisibilities: 
          - Public
          - Organization
        # +optional Path to the schema definition file. Defaults to wild card route if not provided
        # This is only applicable to REST or WS endpoint types.
        # The path should be relative to the docker context.
        schemaFilePath: openapi.yaml
      
      # +optional Outgoing connection details for the component.
      dependencies:
        # +optional Defines the connection references from the Internal Marketplace.
        connectionReferences:
          # +required Name of the connection.
          - name: hr-connection
            # +required service identifer of the dependent component.
            resourceRef: service:/HRProject/UserComponent/v1/ad088/PUBLIC
      # +optional Defines runtime configurations
      configurations:
        # +optional List of environment variables to be injected into the component.
        env:
          # +required Name of the environment variable
          - name: HR_SERVICE_URL
            # +required value source
            # Allowed value sources: connectionRef
            valueFrom:
              # +required Choreo connection value source
              connectionRef:
                # +required Choreo connection name to refer the value from
                name: hr-connection
                # +required Choreo connection configuration key to refer the value from
                key: ServiceURL
    ```

    The descriptor-based approach of the `component.yaml` file simplifies and streamlines endpoint and connection configuration management. The use of versioned schemas ensures backward compatibility, providing a seamless transition with future updates.

    You can define the following root-level configurations via the `component.yaml` file:

    | Configuration        | Required     | Description                                                              |
    |----------------------|--------------|--------------------------------------------------------------------------|
    | **schemaVersion**    | Required     | The version of the `component.yaml` file. Defaults to the latest version.|
    | **endpoints**        | Optional     | The list of endpoint configurations.                                     |
    | **dependencies**     | Optional     | The list of dependency configurations.                                   |
    | **configurations**    | Optional     | The runtime configuration definitions.                                   |

    ### Endpoint configurations
    In the `endpoints` section of the `component.yaml` file, you can define multiple service endpoint configurations. Each endpoint must have a unique name and the required fields specified in the schema overview.

    !!! tip "Why have a unique name?"
          When you define multiple endpoints, the `endpoint.name` is appended to the Choreo-generated URL. A unique name ensures the endpoint is easily recognizable and readable within the URL.
          
    | Configuration        | Required     | Description                                                                                             |
    |----------------------|--------------|---------------------------------------------------------------------------------------------------------|
    | **name**             | Required     | A unique identifier for the endpoint within the service component. Avoid using excessively long names.  |
    | **displayName**      | Optional     | A display name for the endpoint.                                                                        |
    | **service**          | Required     | Service details for the endpoint.                                                                       |
    | **.basePath**        | Required     | The base path of the API exposed via this endpoint.                                                     |
    | **.port**            | Required     | The numeric port value exposed via this endpoint.                                                       |
    | **type**             | Required     | The type of traffic the endpoint accepts. For example, `REST`, `GraphQL`, `WS`, `gRPC`, `UDP`, or `TCP`.|
    | **networkVisibilities** | Required | The network-level visibility of the endpoint. For example, project, organization, or public.             |
    | **schemaFilePath** | Required | The file path to the swagger definition  or AsyncAPI 2.0 specification file. Defaults to the wildcard route if not specified. This field should be a relative path to the project path when using **Java**, **Python**, **NodeJS**, **Go**, **PHP**, **Ruby**, or **WSO2 MI** buildpacks. For REST or WebSocket endpoint types, when using the **Ballerina** or **Dockerfile** buildpack, the path should be relative to the component root or Docker context. |

    ### Dependency configurations

    In the `dependencies` section of the `component.yaml` file, you can define multiple connection configurations under `dependencies.connectionReferences`. You can use the connection reference generated in the inline developer guide when creating a connection. For instructions on copying [connection configurations](https://wso2.com/choreo/docs/develop-components/sharing-and-reusing/use-a-connection-in-your-service/), see the inline developer guide displayed during connection creation.

    You must include the following configurations in the `dependencies.connectionReferences` schema:

    | Configuration        | Required     | Description                                                                      |
    |----------------------|--------------|----------------------------------------------------------------------------------|
    | **name**             | Required     | The name given to the connection.                                                |
    | **resourceRef**      | Required     | A unique, human-readable identifier for the service you are connecting.          |


    !!! note
        Choreo automatically generates connection configurations when you create a connection. The properties such as **name** and **resourceRef** are automatically generated. The configurations required to establish the connection will be injected into Choreo-defined environment variables.

        To use custom environment variable names instead of Choreo's default ones, add the dependency as a `serviceReference` in your `component.yaml v1.1` file. You can copy the `serviceReference` section from the `component.yaml v1.0` tab and paste it under `dependencies` in your `component.yaml v1.1` file, which maintains backward compatibility with the v1.0 format.

    ### Runtime configurations
    In the `configurations` section of the `component.yaml` file, you can define runtime configurations for the component. These configurations currently support environment variable injection related to dependencies.
    
    | Configuration                 | Required     | Description                                                                       |
    |-------------------------------|--------------|-----------------------------------------------------------------------------------|
    | **env**                       | Optional     | An array of env variable configurations.                                          |
    | **name**                      | Required     | A unique name for the environment variable, starting with a letter or an underscore, and containing only letters, numbers, or underscores. |
    | **valueFrom**                 | Required     | The source of the environment variable value.                                     |
    | **connectionRef**             | Required     | Connection reference value source definition.                                     |
    | **name**                      | Required     | The name of the Choreo connection to reference the value from.                    |
    | **key**                       | Required     | The Choreo connection configuration key to reference the value from. For details on available keys, see [connection configurations](https://wso2.com/choreo/docs/develop-components/sharing-and-reusing/use-a-connection-in-your-service/) or the inline developer guide. |

    !!! note
        Runtime configurations are supported starting from `component.yaml v1.1`.

        When an environment variable value is specified using `connectionRef`, the connection's environment variable is renamed to the environment variable name defined in the `configurations` section. For example, in the sample `component.yaml` file given above, the `CHOREO_HR_CONNECTION_SERVICEURL` variable in the `hr-connection` is renamed to `HR_SERVICE_URL`.

=== "Version 1.0"

    ``` yaml
    # +required The configuration file schema version
    schemaVersion: 1.0

    # +optional Incoming connection details for the component
    endpoints:
      # +required Unique name for the endpoint.
      # This name will be used when generating the managed API
      - name: greeter-sample
        # +optional Display name for the endpoint.
        displayName: Go Greeter Sample
        # +required Service section has the user service endpoint details
        service:
          # +optional Context (base path) of the API that gets exposed via the endpoint.
          basePath: /greeting-service
          # +required Numeric port value that gets exposed via the endpoint
          port: 9090
        # +required Type of traffic that the endpoint is accepting.
        # Allowed values: REST, GraphQL, WS, GRPC, TCP, UDP.
        type: REST
        # +optional Network level visibilities of the endpoint.
        # Accepted values: Project|Organization|Public(Default).
        networkVisibilities: 
          - Public
          - Organization
        # +optional Path to the schema definition file. Defaults to wild card route if not provided
        # This is only applicable to REST or WS endpoint types.
        # The path should be relative to the docker context.
        schemaFilePath: openapi.yaml
      
    # +optional Outgoing connection details for the component.
    dependencies:
      # +optional Defines the service references from the Internal Marketplace.
      serviceReferences:
        # +required Name of the service reference.
        - name: choreo:///apifirst/HRProject/UserComponent/ad088/v1/PUBLIC
          # +required Name of the connection instance.
          connectionConfig: 19d2648b-d29c-4452-afdd-1b9311e81412
          # +required Environment variables injected into the component for connection configuration.
          env:
            # +required Key name of the connection configuration.
            - from: ServiceURL
              # +required Environment variable injected into the container.
              to: SERVICE_URL
    ```

    The descriptor-based approach of the `component.yaml` file simplifies and streamlines endpoint and connection configuration management. The use of versioned schemas ensures backward compatibility, providing a seamless transition with future updates.

    You can define the following root-level configurations via the `component.yaml` file:

    | Configuration        | Required     | Description                                                              |
    |----------------------|--------------|--------------------------------------------------------------------------|
    | **schemaVersion**    | Required     | The version of the `component.yaml` file. Defaults to the latest version.|
    | **endpoints**        | Optional     | The list of endpoint configurations.                                     |
    | **dependencies**     | Optional     | The list of dependency configurations.                                   |

    <h3> Endpoint configurations </h3>
    In the `endpoints` section of the `component.yaml` file, you can define multiple service endpoint configurations. Each endpoint must have a unique name and the required fields specified in the schema overview.

    !!! tip "Why have a unique name?"
          When you define multiple endpoints, the `endpoint.name` is appended to the Choreo-generated URL. A unique name ensures the endpoint is easily recognizable and readable within the URL.
          
    | Configuration           | Required     | Description                                                                                             |
    |-------------------------|--------------|---------------------------------------------------------------------------------------------------------|
    | **name**                | Required     | A unique identifier for the endpoint within the service component. Avoid using excessively long names.  |
    | **displayName**         | Optional     | A display name for the endpoint.                                                                        |
    | **service**             | Required     | Service details for the endpoint.                                                                       |
    | **.basePath**           | Required     | The base path of the API exposed via this endpoint.                                                     |
    | **.port**               | Required     | The numeric port value exposed via this endpoint.                                                       |
    | **type**                | Required     | The type of traffic the endpoint accepts. For example, `REST`, `GraphQL`, `gRPC`, `WS`, `UDP`, or `TCP`.|
    | **networkVisibilities** | Required     | The network-level visibility of the endpoint. For example, project, organization, or public.            |
    | **schemaFilePath**      | Required     | The file path to the swagger definition or AsyncAPI 2.0 specification file. Defaults to the wildcard route if not specified. This field should be a relative path to the project path when using **Java**, **Python**, **NodeJS**, **Go**, **PHP**, **Ruby**, or **WSO2 MI** buildpacks. For REST or WebSocket endpoint types, when using the **Ballerina** or **Dockerfile** buildpack, the path should be relative to the component root or Docker context. |

    <h3> Dependency configurations </h3>

    In the `dependencies` section of the `component.yaml` file, you can define multiple service connection configurations under `dependencies.serviceReferences`. You can use the service references generated in the inline developer guide when creating a service connection. For instructions on copying [connection configurations](https://wso2.com/choreo/docs/develop-components/sharing-and-reusing/use-a-connection-in-your-service/), see the inline developer guide displayed during connection creation.

    You must include the following configurations in the `dependencies.serviceReferences` schema:

    | Configuration        | Required     | Description                                                                      |
    |----------------------|--------------|----------------------------------------------------------------------------------|
    | **name**             | Required     | A unique name for the service reference.                                         |
    | **connectionConfig** | Required     | A unique name for the connection instance.                                       |
    | **env**              | Required     | The list of environment variable mappings to inject into the container.          |
    | **.from**            | Required     | The key name of the connection configuration.                                    |
    | **.to**              | Required     | The environment variable to inject into the container.                           |

    !!! note
        Choreo automatically generates connection configurations when you create a connection. The properties such as **name**, **connectionConfig**, and **env.from** are automatically generated. However, you must manually set the **env.to** value.

## Overview of the `component-config.yaml` file 

**File location**:

```bash
<build-context-path>/.choreo/component-config.yaml
```

**Sample `component-config.yaml` file content**:

```yaml
apiVersion: core.choreo.dev/v1beta1
kind: ComponentConfig
spec:
  # +optional Incoming connection details for the component (AKA endpoints).
  inbound:
    # +required Unique name for the endpoint.
    # This name will be used when generating the managed API
    - name: Greeting Service
      # +required Numeric port value that gets exposed via the endpoint
      port: 9090
      # +required Type of traffic that the endpoint is accepting.
      # Allowed values: REST, GraphQL, GRPC, TCP, UDP, WS.
      type: REST
      # +optional Network level visibility of the endpoint. Defaults to Public
      # Accepted values: Project|Organization|Public.
      networkVisibility: Public
      # +optional Context (base path) of the API that gets exposed via the endpoint.
      # This is mandatory if the endpoint type is set to REST, GraphQL or WS.
      context: /greeting
      # +optional The path to the schema definition file. Defaults to wildcard route if not specified.
      # This is only applicable to REST and WS endpoint types.
      # The path should be relative to the Docker context.
      schemaFilePath: greeting_openapi.yaml
  # +optional Outgoing connection details for the component.
  outbound:
    # +optional Defines the service references from the Internal Marketplace.
    serviceReferences:
      # +required Name of the service reference.
      - name: choreo:///apifirst/mttm/mmvhxd/ad088/v1.0/PUBLIC
        # +required Name of the connection instance.
        connectionConfig: 19d2648b-d29c-4452-afdd-1b9311e81412
        # +required Environment variables injected to the component for connection configuration.
        env:
          # +required Key name of the connection configuration.
          - from: ServiceURL
            # +required Environment variable injected to the container.
            to: SERVICE_URL
```

The `component-config.yaml` file complements and enhances the existing endpoint configuration process. It allows you to define how the endpoints (inbound connections) in your service are exposed and how your service connects to external services or components (outbound connections).

You can define the following root-level configurations via the `component-config.yaml` file:

| Configuration        | Required     | Description                                                                           |
|----------------------|--------------|---------------------------------------------------------------------------------------|
| **apiVersion**       | Required     | The version of the `component-config.yaml` file defaults to `core.choreo.dev/v1beta1`.|
| **kind**             | Required     | The resource type of the file defaults to `ComponentConfig`.                          |
| **spec.inbound**     | Optional     | The list of inbound connection configurations.                                        |
| **spec.outbound**    | Optional     | The list of outbound connection configurations.                                       |

#### Inbound connection configurations (`spec.inbound`)

In the `spec.inbound` configuration section, you can specify endpoints to set up inbound connections. To specify endpoints, you can follow the existing endpoints schema structure. For details on the endpoints schema structure, see the [endpoints schema documentation](#overview-of-the-endpointsyaml-file).

#### Outbound connection configurations (`spec.outbound`)

In the `spec.outbound` section, you can define `serviceReferences`. To define `serviceReferences`, you can use the service references generated in the Internal Marketplace when creating a service connection. To copy the [outbound connection configurations](../sharing-and-reusing/use-a-connection-in-your-service/#use-a-connection-in-your-service), see the inline developer guide displayed when you create a connection.

You must include the following configurations in the `serviceReferences` schema:

| Configuration        | Required     | Description                                                                      |
|----------------------|--------------|----------------------------------------------------------------------------------|
| **name**             | Required     | A unique name for the service reference.                                         |
| **connectionConfig** | Required     | A unique name for the connection instance.                                       |
| **env**              | Optional     | The list of environment variable mappings to inject into the container.          |
| **env.from**         | Required     | The key name of the connection configuration.                                    |
| **env.to**           | Required     | The environment variable to inject into the container.                           |

## Overview of the `endpoints.yaml` file

**File location**:

```bash
<build-context-path>/.choreo/endpoints.yaml
```

**Sample `endpoints.yaml` file content**:

```yaml
# +required Version of the endpoint configuration YAML
version: 0.1

# +required List of endpoints to create
endpoints:
  # +required Unique name for the endpoint.
  # This name will be used when generating the managed API
- name: Greeting Service
  # +required Numeric port value that gets exposed via this endpoint
  port: 9090
  # +required Type of the traffic this endpoint is accepting.
  # Allowed values: REST, GraphQL, GRPC, UDP, TCP, WS.
  type: REST
  # +optional Network level visibility of this endpoint. Defaults to Public
  # Accepted values: Project|Organization|Public.
  networkVisibility: Project
  # +optional Context (base path) of the API that is exposed via this endpoint.
  # This is mandatory if the endpoint type is set to REST, GraphQL or WS.
  context: /greeting
  # +optional Path to the schema definition file. Defaults to wild card route if not provided
  # This is only applicable to REST and WS endpoint types.
  # The path should be relative to the docker context.
  schemaFilePath: greeting_openapi.yaml
```

The `endpoints.yaml` configuration file allows you to define configurations for multiple endpoints necessary for Choreo service components. This schema is essential to identify the context, port binding, network exposure level, and other attributes required to generate a Choreo endpoint.

You can define the following root-level configurations via the `endpoints.yaml` file:

| Configuration        | Required     | Description                                                                       |
|----------------------|--------------|-----------------------------------------------------------------------------------|
| **version**          | Required     | The version of the `endpoints.yaml` file.                                         |
| **name**             | Required     | A unique name for the endpoint, which Choreo will use to generate the managed API.|
| **port**             | Required     | The numeric port value that gets exposed via this endpoint.                       |
| **type**             | Required     | The type of traffic this endpoint accepts, such as `REST`, `GraphQL`, `gRPC`, `WS`, `UDP`, or `TCP`. Currently, the MI preset supports only the `REST` type.                                         |
| **networkVisibility**| Required     | The network level visibility of this endpoint, which defaults to `Public` if not specified. Accepted values are `Project`, `Organization`, or `Public`.|
| **context**          | Required     | The context (base path) of the API that Choreo exposes via this endpoint.         |
| **schemaFilePath**   | Required     | The swagger definition file path. Defaults to the wildcard route if not provided. This field should be a relative path to the project path when using the **Java**, **Python**, **NodeJS**, **Go**, **PHP**, **Ruby**, and **WSO2 MI** buildpacks. For REST endpoint types, when using the **Ballerina** or **Dockerfile** buildpack, this field should be a relative path to the component root or Docker context.|

## Update to the latest source configuration file

With the upcoming deprecation of the `component-config.yaml` file and the `endpoints.yaml` file, Choreo provides a seamless process to move to the latest `component.yaml`  version of the `component.yaml` file. Follow these steps to transition seamlessly:

### Step 1: Identify whether your current source configuration file is outdated

You can determine whether you’re using an outdated configuration file in the following ways:

- **During a build:**
     - On the **Build** page, after triggering a build, a warning will appear if your source configuration file is outdated. Click **View Details** in the **Initialization** -> **Source Config Validation** step. You will see an information banner with an option to update the file.

- **In existing deployments:**
     - If an existing deployment uses a build with an outdated source configuration file, you will see a warning icon on the build card of the relevant environment card.


### Step 2: Generate the latest `component.yaml` file

- In either of the scenarios above, click **Update** to initiate the process of generating the latest `component.yaml` file. The updated file will retain your existing configurations to ensure a smooth update process.


### Step 3: Add the generated configuration file to your repository

1. Download the generated `component.yaml` file.
2. Replace the existing source configuration file in the `.choreo` folder within your source repository.
    - Ensure the file name is `component.yaml`.


### Step 4: Trigger a new build

1. Commit the new `component.yaml` file to your repository. Push changes to the remote Git repository.
2. Trigger a build using the latest commit.


### Step 5: Verify the update

Once the build is complete:

  - Deploy the build.
  - Confirm that the warning messages no longer appear.

You can benefit from the latest features and enhancements provided by the updated source configuration file.


# Manage Deployment Tracks for Choreo Components

Choreo allows you to create and manage dedicated [deployment tracks](../choreo-concepts/deployment-tracks.md) for components, facilitating independent version control and deployment. This capability also allows you to unlink deployment tracks from associated branches or relink them to different branches so that you can align with your preferred Git workflows, such as the feature branch workflow or GitFlow workflow.

!!! info
     Deployment track creation and management does not apply to API Proxy and [BYOI components](../develop-components/bring-your-own-image.md).

## Create a deployment track

**Prerequisites**:

 - Create a component in Choreo.

Follow the steps below to create a deployment track for a component:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to create a deployment track for.
3. On the header of the component overview page, click the **Deployment Track** drop-down list.
4. Click **+ Create New** to open the **Create Deployment Track** dialog.
5. In the **Create Deployment Track** dialog, do the following:
    1. Select a branch to associate with the deployment track.
    2. Optionally, specify a description for the deployment track. 
    3. To create a deployment track for a service component, specify a unique API version indicating the major and minor version numbers.
6. Click **Create**.

## Unlink a deployment track

If you want to detach a branch reference from a deployment track, you must unlink the branch.

!!! info
     When you unlink the branch of a deployment track, the active deployments are unaffected. However, while you can redeploy the existing deployment, you cannot perform a new deployment.

Follow the steps below to unlink a deployment track of a component:
  
1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to unlink a deployment track.
3. On the header of the component overview page, click the **Deployment Track** drop-down list and then click **View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
4. Click the edit icon corresponding to the deployment track you want to unlink.
5. In the **Edit Branch** dialog that opens, click the **Branch Name** list and select **None**.
6. Click **Save**.

## Link a deployment track

To associate a branch reference to an unlinked deployment track, you must link a branch.

!!! info
    To build and deploy the contents of the linked branch,  you must perform a manual build and deploy.

**Prerequisites**:

 - A minimum of two branches in your GitHub repository.

Follow the steps below to link a branch to an unlinked deployment track:
  
1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to associate a branch reference for.
3. On the header of the component overview page, click the **Deployment Track** drop-down list and then click **View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
4. Click **+ Link Branch** corresponding to the unlinked deployment track for which you want to associate a branch.
5. In the **Link Branch** dialog that opens, click the **Branch Name** list and select the branch you want to relink.
6. Click **Save**.

## Relink a deployment track

To switch the branch reference of a linked deployment track, you must relink to an appropriate branch.

!!! info
      If you unlink the existing branch of a deployment track and link a different branch, you must perform a manual build and deploy to build and deploy the contents of the recently linked branch.

**Prerequisites**:

 - A minimum of two branches in your GitHub repository.

Follow the steps below to switch the branch reference of a linked deployment track:
  
1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to relink a deployment track for.
3. On the header of the component overview page,  click the **Deployment Track** drop-down list and then click **View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
4. Click the **Edit Branch** icon corresponding to the deployment track you want to relink.
5. In the **Edit Branch** dialog that opens, click the **Branch Name** list and select the branch you want to relink.
6. Click **Save**.

Now that you understand how to create and manage deployment tracks for components, let’s explore a sample scenario to see how a developer can use deployment tracks to manage version releases in Choreo.

## Sample Scenario: Manage version releases with deployment tracks

Let’s consider the following version release scenario: 

- To initiate work on a new feature, a developer creates a new branch, named `feature-x` from either the `main` or `dev` branch.
- Once development is complete, the developer proceeds to merge the `feature-x` branch into the `dev` branch for testing.
- Upon successful testing in the `dev` branch, the developer proceeds to merge all the changes into the `main` branch for production deployment.

Following are the actions you need to take from a deployment track perspective to manage the version release:

1. To prepare for the new version release, unlink the `main` branch from the associated deployment track (let’s consider this as the deployment track 1).
2. Proceed to merge the `dev` branch containing the tested changes into the `main` branch.
3. Unlink the `dev` branch from the associated deployment track (let’s consider this as deployment track 2).
4. Link deployment track 2 containing the latest version of the service to the `main` branch for deployment.
5. To facilitate ongoing development and testing, create another deployment track (let’s consider this as deployment track 3) and link it to the `dev` branch.

!!! tip
     - As a developer, you can strategically unlink and relink deployment tracks to effectively manage different versions of your services within Choreo.
     - You can create new deployment tracks for ongoing development branches like `dev` to ensure a continuous development and release cycle.

## Delete a deployment track

If you no longer need a deployment track, you can delete it.

!!! note
    If the component exposes an endpoint or proxy and you want to delete the last version in the major version range, the recommended approach is to retire that version first. This allows consumers to transition to the next major version and prevents a sudden break in their experience.
    For example, if you have deployment tracks for v1.0 and v2.0, notify consumers to switch to v2.0 before deleting v1.0. Then, retire the APIs in v1.0 and proceed to delete the associated deployment track.




**Prerequisites**:

- At least 2 deployment tracks in a component.

Follow the steps below to delete a deployment track:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to delete a deployment track.
3. On the header of the component overview page, click the **Deployment Track** drop-down list.
4. Click **+ View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
5. Click the **Delete** icon corresponding to the deployment track you want to delete.
6. Click **Delete** to confirm the deletion.

# Manage the Micro Integrator Runtime Version in Your Integration Project

Choreo allows you to use a preferred WSO2 Micro Integrator (MI) runtime version in your integration project. Currently, Choreo supports MI product versions 4.1.0 and 4.2.0. You have the flexibility to deploy WSO2 updates within these specified versions. 

When you create an integration project, you can specify a required runtime version to gain control over the environment in which your integration runs. This version management capability empowers you to tailor your projects depending on your runtime requirements, enhancing the customization and adaptability of your integration workflows.

## Understand the version string

WSO2 Micro Integrator (MI) utilizes a versioning system consisting of three-digit numbers, such as `4.1.0` and `4.2.0`, following semantic versioning principles. The product remains committed to receiving updates from WSO2, including security fixes, bug resolutions, and enhancements. Within the Choreo platform, the MI runtime version is constructed by combining the product release version with its corresponding update level.

In Choreo, the MI runtime version is structured as a four-digit number, for example, `4.1.0.14` or `4.2.0.17`. The first three digits represent the product release version, while the last digit signifies the update level of the product. The fourth digit is optional and can be omitted.

![Version string](../assets/img/develop-components/micro-integrator/version-string.png)

## Version management in WSO2 Integration Studio

If you are using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/) to build and deploy integration artifacts in WSO2 Micro Integrator, you can create multiple runtime environments and execute projects on any selected environment. WSO2 Integration Studio also allows you to configure multiple Micro Integrator runtime environments, offering flexibility and customization in the execution of integration processes.

You can specify the Runtime version when you create an integration project in WSO2 Integration Studio. In the project creation wizard, specify the runtime version in the **Runtime version** field, as shown below.
![Specify Runtime version](../assets/img/develop-components/micro-integrator/specify_runtime_version.png)


An integration project is structured as a Maven project with multiple sub-modules. The root `pom.xml` file holds crucial information about the target runtime. The runtime version you configure when you create a new project is saved within the root `pom.xml` file. The version information is stored in the <project.runtime.version> element under the <properties> in the `pom.xml` file. If there is a need to update the runtime version, you have the flexibility to modify the value to a valid runtime version and ensure that the project runs in the required runtime environment.

![project runtime version](../assets/img/develop-components/micro-integrator/project-runtime-version.png)

You can establish multiple runtime environments by utilizing updated MI instances. With a valid WSO2 subscription, you can also access and download updates to set up an updated MI server locally. This update process allows you to select a preferred update level as the runtime version. Consequently, you can run your integration on a runtime with the latest updates, ensuring optimal performance and access to new features.

### Configure a Micro Integrator runtime environment in Integration Studio

If you are using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), follow these steps to set up a remote server instance with a Micro Integrator runtime environment to execute your integration project:

!!! info "Note"
    If you have not downloaded and installed WSO2 Integration Studio, you can follow the [installation instructions](https://apim.docs.wso2.com/en/latest/integrate/develop/installing-wso2-integration-studio/) in the WSO2 API Manager documentation.

1. Launch WSO2 Integration Studio and click **Add Server** in the **Getting Started** view.
   ![Add server](../assets/img/develop-components/micro-integrator/add-server.png)
2. In the **Define a New Server** dialog, click to expand the `WSO2` directory and select **WSO2 Remote Server**.
   ![Define a remote server instance](../assets/img/develop-components/micro-integrator/define-a-remote-server-instance.png)
3. Enter the WSO2 Micro Integrator Management API URL in the **Server URL** field and click **Test Connection**.

    !!! info "Note"
        The Management API of WSO2 Micro Integrator is an internal REST API introduced to substitute MI admin services. The default HTTPS port of the Management API of WSO2 Micro Integrator is `9164`. If you have not manually changed the default port, you must set the Management API URL as `https://localhost:9164/management`.  If you have changed the default HTTPS port, you must set the port number appropriately when specifying the **Server URL**. For more information on the default ports of WSO2 Micro Integrator, see [WSO2 Micro Integrator default ports](https://apim.docs.wso2.com/en/latest/install-and-setup/setup/reference/default-product-ports/#micro-integrator-ports) in the WSO2 API Manager documentation.

    ![Set server URL](../assets/img/develop-components/micro-integrator/set-server-url.png)
    
4. Click **Finish**.
5. In the **Add and Remove** dialog, select the integration components to move from the left side to the right side.
6. Click **Add >**.
7. Click **Finish**. 

Your integration project is now running in a remote server instance with the Micro Integrator runtime environment you require.
If you need to make changes to the integration project, expand the remote server instance, right-click on the deployed exporter project, and select **Redeploy** to apply the changes.

![Redeploy project](../assets/img/develop-components/micro-integrator/redeploy-project.png)

## Convention for version interpretation in Choreo deployments

You can use the following convention to indicate the required MI runtime version in your integration project:


| **Version format**           | **Example**       | **Description**   |
|------------------------------|-------------------|-------------------|
| Product version              | `4.1.0`, `4.2.0`  | Deploy on the latest update level of the mentioned product version.                 |
| Product version with update level  | `4.1.0.15`, `4.2.0.17` |  Deploy on the exact update level of the mentioned product version.    |
| GA version                   | `4.1.0.0`, `4.2.0.0` | Deploy on the exact GA version without any update.                  |
| Default version            | Empty value         | Deploy on the latest update level of the default product version.                  |


Choreo utilizes Alpine images for configuring and deploying the Micro Integrator runtime. This includes automated configuration of the JRE/JDK, customized to the compatibility of the chosen runtime version, simplifying the setup procedure.

## Migrate between runtime versions

Changing the runtime version in an integration project may become necessary during product version upgrades or when you want to apply updates. 

To change the runtime version of a MI Integration, follow the below steps.

### Update the runtime version in the integration project
    
To change the runtime version in the integration project, follow the steps below:
1. Open the project in Integration Studio.
2. Right-click on the project and select **Change Runtime MI Version**.
    ![Update Runtime version](../assets/img/develop-components/micro-integrator/click_change_runtime.png)
3.  Specify the new runtime version as shown below:
    ![Update Runtime version](../assets/img/develop-components/micro-integrator/update_runtime_version.png)
4. Alternatively, you can manually update the version by opening the root `pom.xml` file.  Open pom.xml and change the required runtime version in `<project.runtime.version>` element under `<properties>` section.

To test the changes locally, you must download and set up the runtime environment locally. Then, you must [configure the Integration Studio runtime environment](#configure-a-micro-integrator-runtime-environment-in-integration-studio) by directing it to the locally installed MI runtime. Once the setup is complete, you can deploy your integrations on the MI runtime environment and proceed to the testing phase.

After completing the tests to ensure everything works as expected, you can follow below steps to deploy the project in Choreo:

1. Commit and push the changes to your repository.
2. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
3. Select your project from the **Project** list in the header.
4. Select your MI integration component from the **Component** list in the header.
5. In the left navigation menu, click **Build**.
6. Select the latest commit and click **Build**.
7. In the left navigation menu, click **Deploy**.
8. Click on the **Configure and Deploy** and deploy the component.
9. Verify the Runtime version by checking the logs by selecting the **Runtime Logs** under the **Observability** section.

  You will see the runtime version in the logs as shown below:
  ![Runtime version in logs](../assets/img/develop-components/micro-integrator/runtime_version_in_logs.png)

Next, you must conduct additional testing in the development environment on Choreo before you promote the integration to production environments.

## Troubleshoot errors

The following error codes can help you troubleshoot errors that occur during the integration component build:

| **Error code** | **Description**            |
|----------------|----------------------------|
| 110 - 119      | Internal server error.     |
| 121            | Malformed runtime version. |
| 122            | The specified runtime version is not available. Either the product or update level is not available.    |
| 123            | Trivy security vulnerabilities found in the `libs` directory. |
| 124            | Trivy security vulnerabilities found in the `dropins` directory. |
| 125            | Trivy security vulnerabilities found in the `libs` or `dropins` directory. |
| 126            | Error building integration project. |


# Submit and Manage Workflow Approval Requests

In Choreo, if an administrator [configures a workflow to require approval](../administer/configure-approvals-for-choreo-workflows.md), you must submit a request to obtain approval to perform the task.

Upon submitting a workflow approval request, Choreo notifies all authorized assignees via email about the [review request](../administer/review-workflow-approval-requests.md). When an authorized assignee approves or rejects the request, you will receive an email with details of the decision.

The approach to request approval can vary depending on the workflow. 

## Request approval for environment promotion

**Prerequisites**:

- Ensure you have a component created, built, and deployed to the development environment.
- Ensure that an approval workflow is configured for environment promotion.
- Ensure you are promoting the component to a critical environment, such as production.

To request approval to promote a component from the development environment to production, follow these steps:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to deploy. This takes you to the **Overview** page of the component.
3. In the left navigation menu, click **Deploy**.
4. Go to the **Development** card and click **Request to Promote**.
5. In the **Request Approval** pane that opens, enter your request details and click **Submit**. This creates a request and notifies all authorized assignees via email about the request.

    !!! note
         When an environment promotion request for a specific component is pending review, Choreo restricts other developers from making the same request until the pending request is either approved or rejected.

When an authorized assignee approves the request, you will receive a confirmation email and can proceed to promote the component to production.

## Cancel a workflow approval request

If you want to cancel a workflow approval request that is already submitted, you can do so before the request is approved or rejected. 

When you submit a workflow approval request, the **Request to Promote** button changes to **Cancel Request**. To cancel an approval request, click **Cancel Request**. Upon confirming the cancellation, all configured approvers are notified immediately, and the request will no longer be pending.


# Work with the Micro Integrator Runtime in Choreo

WSO2 Micro Integrator (WSO2 MI) is a lightweight, high-performance integration runtime. It allows you to run integrations developed using WSO2 Integration Studio within Choreo. 

The topics on this page walk you through the key aspects you need to understand to use the WSO2 MI runtime effectively in Choreo.

## Integration types

Choreo supports the following WSO2 MI integrations that cater to different use cases and requirements. Each integration type serves a specific purpose. Therefore, it is essential to understand their differences to easily choose the most appropriate integration for your use case.

- **Service**: Exposes an integration as an API via HTTP, making it possible to create a RESTful interface for your integration services. This type is ideal for scenarios where you need to provide an API for external systems or clients to interact with your integration.
- **Event Handler**: Triggers an integration based on external events such as messages arriving on a queue or updates in a database. This type is well-suited for implementing event-driven architectures or responding to changes in your system's environment.
- **Scheduled Task**: Runs an integration automatically at predefined time intervals, ensuring that specific integration tasks occur at regular intervals. This type is ideal for batch processing, data synchronization, or periodic maintenance tasks.
- **Manual Task**: Initiates an integration via user action, giving you full control over when the integration executes. This type is useful for on-demand tasks, testing, or debugging purposes.

## Develop integrations with WSO2 Integration Studio

[WSO2 Integration Studio](https://wso2.com/integration/integration-studio/) is a powerful, Eclipse-based graphical development environment that enables you to build and deploy integration artifacts in WSO2 Micro Integrator. This comprehensive IDE offers a robust set of tools for designing and testing integration flows and crafting integration artifacts. By utilizing the visual, drag-and-drop capabilities of WSO2 Integration Studio, developers can significantly reduce the time and effort needed to construct and deploy integration flows.

In addition to streamlining the development process, Integration Studio offers features such as debugging, testing, and version control to ensure the quality and reliability of integration flows. By creating an Integration project and Composite Exporter project in WSO2 Integration Studio, developers can export their integration projects as a single deployment artifact, known as a composite application. This composite application encompasses all the components and configurations necessary for deploying the integration project to WSO2 Micro Integrator.

The Composite Exporter project simplifies the deployment process by allowing developers to package their integration projects as a single, self-contained artifact that can be easily deployed and managed. This approach enhances the consistency and reliability of integration projects while streamlining the overall deployment process.

To start developing integrations with WSO2 Micro Integrator, see [WSO2 Micro Integrator documentation - Developing Integration Solutions](https://mi.docs.wso2.com/en/latest/develop/intro-integration-development/).

## Integration project directory structure

An Integration Project in WSO2 Integration Studio is a multi-module Maven project that can contain multiple modules with WSO2 Synapse configurations and a composite application module to export all the configurations as a single deployable artifact.

An integration project directory structure includes the following key components:

 - WSO2 Synapse configurations: These modules contain the essential configurations for the integration project.
 - Composite Application module: This module is responsible for exporting all the Synapse configurations as a single deployable artifact.

Optionally, you can include the following components in your integration project:

 - OpenAPI definition file: You can add the OpenAPI definition file to any location within the project. When creating a component, you'll need to define the path to this file. Choreo will automatically generate an OpenAPI definition for you based on your integration project, if you don't provide one.
 - Java libraries: If your integration project requires additional Java libraries, you can add them to the libs directory located in the project root.
 - deployment.toml file: This optional configuration file allows you to customize the preconfigured settings of WSO2 MI instances running on Choreo. By including this file, you can tailor the behavior of your WSO2 MI instances to better suit your project's specific requirements.

Understanding the Integration Project directory structure is crucial for organizing your project and ensuring that all necessary components are included in the final deployable artifact.

## OpenAPI support

OpenAPI Support plays a crucial role in enhancing the functionality of integrations exposed as APIs. By providing an OpenAPI definition for your exposed integration, you can streamline testing and management processes, ensuring a more efficient and user-friendly experience. Choreo will automatically generate an OpenAPI definition for you based on your integration project, if you don't provide one, saving you time and effort.

To incorporate OpenAPI support, store the OpenAPI definition file within the repository hosting your Integration Studio project. When creating the project, simply point to the file's location in the repository. If needed, you can change the location of the OpenAPI definition file later via the deploy page.

![Open API file](../assets/img/develop-components/micro-integrator/openapi_file.png)

By leveraging OpenAPI Support, you can optimize the way you test and manage your integrations, resulting in a more efficient development process and a smoother user experience.

## Work with third-party libraries

The use of third-party libraries in your Micro Integrator project can offer several advantages, such as enhanced functionality, improved integration capabilities, optimized performance, and reduced development time.

Here are some of the benefits of adding third-party JARs to the Micro Integrator:

 - Increased functionality: Third-party libraries can extend the core Micro Integrator distribution, allowing for greater flexibility and customization of integration solutions.
 - Enhanced integration capabilities: Third-party libraries enable the Micro Integrator to interact with existing systems such as databases or other APIs, improving overall integration capabilities.
 - Optimized performance: By offering optimized implementations of common functions, third-party libraries can improve the performance of the Micro Integrator.
 - Efficient development: Developers can avoid re-implementing commonly used functions, reducing development time and increasing efficiency.

To incorporate third-party libraries into your Micro Integrator project, create a new directory called `libs` at the
root of your project. If your project root and GitHub repository root are not the same, place the `libs` directory in
the project root. After adding the required JAR files to the `libs` directory, the Micro Integrator runtime will
automatically include them when deploying the component. This process ensures that any dependencies needed by your
integration flow are available at runtime.

In addition to `jar` libraries, you may also need to incorporate OSGi bundle JARs into your project. To do this,
create another directory called `dropins` at the root of your project. Similarly, if the project root and GitHub
repository root differ, place the `dropins` directory in the project root. Within the `dropins` directory, add the OSGi
bundle JAR files. The OSGI runtime will pick up these bundles during deployment, enabling you to utilize their
functionality within your Micro Integrator project.

![Libs directory](../assets/img/develop-components/micro-integrator/libs_dir.png)

## Importing custom certificates to MI

The feature enables Choreo MI users to import certificates into the MI `client-truststore.jks` file. This functionality
proves valuable when users need to establish connections with servers or services utilizing SSL/TLS encryption and
possessing self-signed certificates or certificates issued by private certificate authorities (CAs) that are not
automatically trusted. Importing the certificate to the MI `client-truststore.jks` file enables MI clients to establish secure connections with
the server or service seamlessly, eliminating SSL/TLS errors or warnings.

Before importing the certificate, it is necessary to obtain the certificate file, which can be in PEM or DER format. You
can get the certificate from the server or service provider or export it from a web browser. Certificates should be
added to the `/wso2mi/certs/` folder. Users need to verify that the mount path for the certificate file aligns with this
specific path.

1. In the Choreo console, select the component you wish to add a certificate to.
2. From the left navigation click **Deploy**.
3. Click on the **Configs and Secrets** tab.
4. Click **Create**.
5. Select **ConfigMap** as the **Config Type** and **File Mount** as the **Mount Type**.
6. Click **Next**.
7. Specify the following values as mount configurations:

    | **Field**       | **Value**                                              |                                    
    |-----------------|--------------------------------------------------------|
    | **Config Name** | An appropriate name for the certificate.             |
    | **Mount path**  | `/wso2mi/certs/<filename>`. For example, `/wso2mi/certs/certificate.crt` |

8. Click **Upload File** and attach the certificate.
9. Click **Create**.

## Working with sensitive data using MI Secure Vault

MI Secure Vault is a feature that allows users to securely store sensitive data, such as passwords and tokens, and
provide access to that data to MI Integrations. This feature provides an added layer of security to your integrations by
reducing the risk of accidental exposure of sensitive data.

To use MI Secure Vault to work with sensitive data, follow these steps:

1. Select the component from the Choreo Console.
2. From the left navigation, click Deploy.
3. Click on the **Configure and Deploy**.
4. Click on the **Add Environment Configurations**
5. Specify the following values as configurations:

    | **Field**       | **Value**                                 |                                    
    |-------------------------------------------|--------------------------------------------------------|
    | **Name** | An appropriate name for the secret/alias. |
    | **Value**       | Value for the secret                      |

6. Select **Mark as a Secret**.
7. Click **Add**.
8. Click **Deploy**.
9. Once the secret has been created, you can access it in your integration code using the following syntax:

```xml
<property name="secret_value_1" expression="wso2:vault-lookup('user_pass')" scope="default" type="STRING"/>
```
This code retrieves the secret named "user_pass" from the MI Secure Vault and stores it in the property named "
secret_value_1". You can then use this property in your integration code to access the secret value.

For more information on these features, see the [Accessing secrets](https://mi.docs.wso2.com/en/latest/install-and-setup/setup/security/encrypting-plain-text/#step-3-accessing-secrets) section of the MI Secure Vault documentation. By using MI
Secure Vault to store and access sensitive data in your integrations, you can ensure that your integrations
remain secure and protect sensitive data from unauthorized access.


## Scan third-party libraries to identify security vulnerabilities

Scanning third-party libraries for security vulnerabilities is essential for identifying potential weaknesses in an application that could be exploited by attackers. Taking a proactive approach to security helps organizations detect and mitigate risks before they can be exploited, preventing data breaches, system compromises, and other security incidents.

Choreo incorporates a security vulnerability scanning process during deployment. It uses Trivy to scan and detect critical vulnerabilities in third-party libraries added to the integration component. If the scan uncovers any critical vulnerabilities, the deployment process is halted. The deployment pane displays the Trivy scan status and any security failures in the Library (Trivy) vulnerable scan step, which can be accessed by clicking on it. Once the vulnerability has been addressed, you can redeploy the component.

## Customize WSO2 Micro Integrator preconfigured settings

Customizing WSO2 Micro Integrator Preconfigured Settings is essential for ensuring that the integration solution works optimally within the specific context of your organization. While WSO2 MI comes with preconfigured settings designed for general use, these settings may not be suitable for every organization's unique requirements. Customizing these settings can help optimize performance and ensure compatibility with your organization's systems and applications.

To customize the preconfigured settings of WSO2 MI instances running on Choreo, define a `deployment.toml` file in the GitHub repository subpath of your Micro Integrator project:

![deployment.toml](../assets/img/develop-components/micro-integrator/config_file.png)

!!! note
    If you change critical configuration parameters such as port offset and hostname, it can break internal communication.
    Therefore, the recommended approach is to update only the necessary configuration parameters.

Given below is a sample `deployment.toml` file that can be used to configure the JMS transport. For more information on WSO2 MI
configuration parameters, see the [MI Configuration Catalog](https://mi.docs.wso2.com/en/latest/reference/config-catalog-mi/).

```
[[transport.jms.sender]]
name = "myQueueSender"
parameter.initial_naming_factory = "org.apache.activemq.jndi.ActiveMQInitialContextFactory"
parameter.provider_url = "$env{JMS_PROVIDER_URL}"
parameter.connection_factory_name = "QueueConnectionFactory"
parameter.connection_factory_type = "queue"
parameter.cache_level = "producer"

[[transport.jms.listener]]
name = "myQueueListener"
parameter.initial_naming_factory = "org.apache.activemq.jndi.ActiveMQInitialContextFactory"
parameter.provider_url = "$env{JMS_PROVIDER_URL}"
parameter.connection_factory_name = "QueueConnectionFactory"
parameter.connection_factory_type = "queue"
parameter.cache_level = "consumer"
```

## Environment variables

Using environment variables is a recommended practice when developing integration artifacts with WSO2 Integration Studio, as it improves configuration management, security, portability, and manageability. By leveraging environment variables, organizations can streamline the management and maintenance of their integrations, ensuring that updates can be implemented quickly and efficiently.

The component's Deploy page provides a user-friendly interface to manage environment variables across different environments. For information on managing environment variables for complex use cases, see [Configurations and secrets](../devops-and-ci-cd/manage-configurations-and-secrets.md).

![Environment variables](../assets/img/develop-components/micro-integrator/env_variables.png)

Environment variables offer several benefits:

 - Configuration management: They simplify the process of managing and updating configuration settings, making it easier to maintain consistency across different environments.
 - Security: Environment variables help protect sensitive information by storing it securely and separating it from the main codebase.
 - Portability: By using environment variables, you can ensure that your integration artifacts can be easily migrated and deployed across various environments with minimal changes.
 - Manageability: Environment variables offer a centralized way to manage configuration settings, making it easier to update and maintain your integrations over time.

For a comprehensive list of parameters that can be configured as environment variables, see [WSO2 Micro Integrator documentation - Injecting Parameters - Supported parameters](https://mi.docs.wso2.com/en/latest/develop/injecting-parameters/#supported-parameters).

## Configure logging

Configuring logging is crucial when developing and maintaining a software system, as it can significantly improve efficiency during the development, testing, and maintenance phases of the software development process. Logging captures events and messages that occur during an application's execution, providing valuable insights for troubleshooting and debugging issues.

With Micro Integrator instances, you can configure and customize logging according to your requirements. Logging configurations can be added to each MI instance's environment, allowing you to fine-tune logging depending on the specific environment or deployment scenario.

To configure logging in MI instances, follow the steps given below: 

!!! tip
     You can use environment variables with specific naming conventions.

1. Start the variable name with `logging_level_` followed by the package or class name.
2. Replace the dot character in the package name with an underscore.
3. Set the variable value to the required logging level for the corresponding package or class.

    For example, to enable wire logs, change the logging level of the `org.apache.synapse.transport.http.wire` package to `debug`. 

To configure logging, set the environment variable as follows:

1. In the left navigation menu, click **Deploy** and then click **Configs & Secrets**. 
2. Click **+ Create**. 
3. Select **ConfigMap** as the **Config Type** and **Environment Variables** as the **Mount Type**. 
4. Click **Next**. 
5. Specify the following values as mount configurations:

    | **Field**       | **Value**                                              |                                    
    |-----------------|--------------------------------------------------------|
    | **Config Name** | An appropriate name for the configuration.             |
    | **Name**        | `logging_level_org_apache_synapse_transport_http_wire` |
    | **Value**       | `debug`                                                |

6. Click **Create**.

## Connectors

WSO2 Micro Integrator (MI) Connectors are prebuilt connectors designed to simplify integration between WSO2 MI and various other systems. They enable seamless connections to databases, message brokers, REST APIs, and more, allowing you to perform actions such as sending messages, executing queries, or retrieving data. These connectors are easy to use, making it straightforward to incorporate them into your WSO2 MI integration flows. Micro Integrator connectors are versatile and can be utilized in various integration scenarios, including data integration, service-oriented architecture (SOA) integration, and event-driven architecture (EDA) integration.

WSO2 Integration Studio is a comprehensive development environment that facilitates the creation of integration flows using WSO2 Micro Integrator Connectors. With Integration Studio, you can design and implement integration flows that connect diverse systems and execute various actions, such as sending messages, executing queries, or retrieving data. You can build integration flows using either prebuilt connectors provided by WSO2 MI or custom connectors developed using the Connector Development Toolkit. Integration Studio offers a graphical user interface that simplifies the process of building and testing integration flows while also providing a set of tools for managing and deploying these flows in a WSO2 MI runtime environment.

For more information, see the following topics in the WSO2 Micro Integrator documentation.

- [Connectors Overview](https://mi.docs.wso2.com/en/latest/reference/connectors/connectors-overview/)
- [Adding Connectors](https://mi.docs.wso2.com/en/latest/develop/creating-artifacts/adding-connectors/)

## Deploying integrations in Choreo 

WSO2 MI buildpack is where you can deploy integrations developed with WSO2 Micro Integrator as an API. In this preset, you have three different ways to define endpoints. Choreo gives priory to the definition of endpoints in the below-mentioned order. 

1. **Using component.yaml file**
This is the most flexible method to define endpoints. You can configure the endpoint details with the `component.yaml` configuration file. Place this file in the `.choreo` directory in the project path of the component. 
If the Micro Integrator project has inbound endpoints, you can expose them via different endpoints using the `component.yaml`file.

    To learn about the `component.yaml` file, see [Overview of the component.yaml file](../develop-components/manage-component-source-configurations.md#overview-of-the-componentyaml-file).

3. **Auto generating endpoints**
If `component.yaml` is not provided and if the source Micro Integrator project has APIs, Choreo scans the project and generates the API endpoints. If the project has few APIs, an endpoint will be generated for each API. The visibility of this auto-generated endpoint is set to `Public` by default. You can change the visibility in the deployment flow.

4. **Provide default endpoints**
If `component.yaml` is not provided and if the source Micro Integrator project doesn't have APIs, Choreo generates a default endpoint which will expose the default micro integrator port (8290) with `Public` visibility and wildcard context.

!!! note
    If you are currently using `component-config.yaml` or `endpoints.yaml` configuration files, see the respective [migration guide](../develop-components/manage-component-source-configurations.md#migration-guide) for instructions on migrating to the recommended `component.yaml` configuration file.

## Explore Choreo examples on GitHub

For a hands-on experience with MI-based integrations in Choreo, we recommend exploring our samples in Choreo Console. You can filter out the samples based on the buildpack `WSO2 MI`. This will point you to the samples in the [Choreo samples GitHub repository](https://github.com/wso2/choreo-samples)

### [Choreo samples - GitHub Repository](https://github.com/wso2/choreo-samples)

- **Fork the Repository**: Start by forking the repository to your account.

- **Explore & run**: Navigate through the different integration scenarios. Each example has a README.md with setup and execution instructions.



# Develop a Manual Task

This guide walks you through the steps to develop, deploy, test, and observe a manual task using Choreo.

In this guide, you will:

- Develop a manual task to fetch the weather forecast for a specified location for the next 24 hours from the [OpenWeatherMap](https://openweathermap.org) API.
- Process the weather data into a specific format.
- Send the formatted data to a specified email address.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

    !!! info "Repository File Structure"
        The sample code for this guide is in the `<sample-repository-dir>/weather-to-email-integration` directory. The following table describes the key files in the repository:

        | **File Path**         | **File Content**                                                     |
        | --------------------- | -------------------------------------------------------------------- |
        | **Ballerina.toml**    | Contains metadata about the project                                  |
        | **Dependencies.toml** | Lists the dependencies required for the project                      |
        | **main.bal**          | Contains the entry point of the project, including the main function |
        | **types.bal**         | Contains custom data types used in the project                       |
        | **utils.bal**         | Contains utility functions and helper functions used in the project  |

3. Go to [OpenWeatherMap](https://openweathermap.org/) and sign up to obtain an API key. For details, see the [OpenWeatherMap documentation](https://openweathermap.org/appid#signup).

## Step 1: Create a manual task component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Manual Task** card.
6. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:

        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

7. Enter the following information:

    | **Field**             | **Description**                                      |
    | ----------------------| -----------------------------------------------------|
    | **Organization**      | Your GitHub account                                  |
    | **Repository**        | `choreo-samples`                                     |
    | **Branch**            | `main`                                               |
    | **Component Directory** | `weather-to-email-integration`                       |

8. Select **Ballerina** as the **Build Pack**.

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Component Directory** specifies the location of the project to build the component.

4. Enter a unique name and description for the component. You can use the following values:

    | **Field**          | **Value**                        |
    | ------------------ | -------------------------------- |
    | **Component Name** | `WeatherToEmail`                 |
    | **Description**    | `My first manual task`           |


8. Click **Create**. Choreo initializes the component with the sample implementation and opens the **Overview** page of the component.

## Step 2: Build the manual task

1. In the left navigation menu, click **Build**.
2. In the **Builds** pane, click **Build**. This opens the **Commits** pane, where you can see all the commits related to the component.
3. Select the latest commit and click **Build**. This triggers the build process and displays the build progress in the **Build Logs** pane.

    !!! info
        The build process may take some time. Once complete, the build status will be listed in the **Builds** pane. Here, you will see the build status as **Success**.

## Step 3: Deploy the manual task

1. In the left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane, specify values for the configurable variables:

    !!! tip
        The configurable variables populated here are defined in the sample Ballerina project used in this guide. To learn how to declare configurable variables in Ballerina, see the [Ballerina documentation on declaring configurable variables](https://ballerina.io/learn/by-example/configurable-variables/).

    | **Field**     | **Value**                                                               |
    | ------------- | ----------------------------------------------------------------------- |
    | **apiKey**    | The API key you obtained in the prerequisites section                   |
    | **latitude**  | Latitude of the location to get the weather forecast                    |
    | **longitude** | Longitude of the location to get the weather forecast                   |
    | **email**     | The email address to receive the formatted weather forecast information |

    !!! note
        If you use **Ballerina** as the buildpack and want to set a configurable variable as a secret, click the lock icon corresponding to the configurable variable. This marks it as a secret and conceals the input value.

        For example, if you set the **apiKey** as a secret, its input value will be concealed. To update the input value later, click **Update Secret Content** and specify a new value.

4. Click **Deploy**.

## Step 4: Execute the manual task

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the task.

    !!! info "Inject Dynamic Values into Your Application as Command-Line Arguments"
        If you want to inject dynamic values into your application as command-line arguments when you run a manual task, follow these steps:
        1. Click the drop-down icon next to **Run Now** and then click **Run with Arguments**.
        2. In the **Runtime Arguments** pane, enter the arguments you want to pass to your application.
        3. Click **Execute**. This triggers the task with the specified arguments.

        The capability to run a manual task with arguments is supported for the following buildpacks:

        === "Dockerfile"
            To explore a Dockerfile-based manual task with arguments, try out the [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/docker-hello-world-manual-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on Docker projects, the **Run with Arguments** capability is not supported if the Dockerfile contains `CMD`. In such scenarios, use `ENTRYPOINT` to define your default commands.

        === "Go"
            To explore a Go-based manual task with arguments, try out the [Hello World Go Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-go-task) sample. For instructions, see the `readme.md` file in the sample repository.

        === "Java"
            To explore a Java-based manual task with arguments, try out the [Hello World Java Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-java-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on Java projects:
                - The **Run with Arguments** capability is not supported if `Procfile` is available in the project.
                - The `Main` class should be defined in the `manifest` file.
                - If Maven files such as `mvn.cmd` exist in the project without the `.mvn` directory, the build will fail. To ensure a successful build, either commit the `.mvn` directory along with any Maven files or exclude Maven files if you choose not to commit the `.mvn` directory.

        === "NodeJS"
            To explore a NodeJS-based manual task with arguments, try out the [Hello World NodeJS Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-nodejs-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on NodeJS projects:
                - The **Run with Arguments** capability is not supported if `Procfile` is available in the project.
                - The project root must contain the `package.json` file with the `main` attribute defined.

        === "WSO2 MI"
            To explore a WSO2 MI-based manual task with arguments, try out the [Weather to Logs Task](https://github.com/wso2/choreo-samples/tree/main/weather-to-logs-mi-manual-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on WSO2 MI projects and deploying a WSO2 MI integration as a manual task in Choreo, use the WSO2 MI automation mode. For details, see [Running the Micro Integrator in Automation Mode](https://apim.docs.wso2.com/en/latest/install-and-setup/install/running-the-mi-in-automation-mode/).

        === "Ballerina"
            To explore a Ballerina manual task with arguments, try out the [Weather to Email Task](https://github.com/wso2/choreo-samples/tree/main/weather-to-email-integration) sample. For instructions, see the README.md file in the sample repository.

            !!! info
                If you want to pass arguments to Ballerina main functions, use the **Run with Arguments** capability. For details on the arguments you can pass, see the [Ballerina documentation](https://ballerina.io/learn/by-example/main-function/). You can also override configurable values in the same manner. For more information, see [Provide values to configurable variables](https://ballerina.io/learn/provide-values-to-configurable-variables/#provide-via-command-line-arguments).

## Step 5: Test the manual task

Once the task is triggered, an email with the subject `[WSO2 Choreo Demo] Next 24H Weather Forecast` is sent from `choreo.demo@gmail.com` to the email address specified as the **email** configurable variable value in [Step 3](#step-3-deploy-the-manual-task).

If the manual task ran successfully, you should receive an email similar to the following:

![Received email](../../assets/img/develop-components/develop-a-scheduled-integration/Received-email.png)

## Step 6: Observe the manual task

The observability view in Choreo displays graphs that depict details such as throughput, latency, diagnostic data, and logs to identify and troubleshoot anomalies in components you deploy.

1. In the left navigation menu, click **Observability**.
2. Observe the following:
    - The throughput and latencies of requests served over a given period.
    - The logs generated over a given period.
    - The flame graph (Diagnostics View) generated over a given period.
    - The low-code diagram.

To learn more about the observability details you can view via Choreo observability, see [Observability Overview](../../monitoring-and-insights/observability-overview.md).

## Step 7: Monitor executions

To track and monitor executions associated with the deployed manual task, go to the left navigation menu and click **Execute**.

!!! tip
    The **Execute** view is applicable to both scheduled and manual tasks.

You can view the following information:

- **Total executions**: The total number of executions within the past 30 days.

    ![Total Execution](../../assets/img/develop-components/develop-a-scheduled-integration/total_executions.png)

- **Execution history**: The currently active executions and those that are already complete. You can view information such as the execution ID, the revision of the execution, and the time it was triggered.

    ![Execution History](../../assets/img/develop-components/develop-a-scheduled-integration/execution_history.png)

- **Detailed execution logs**: Click on an execution to view detailed logs related to it.

    !!! info
        It may take a few minutes for the logs to appear. You may need to manually refresh to view the latest logs.

    ![Execution Logs](../../assets/img/develop-components/develop-a-scheduled-integration/execution_logs.png)


# Develop a Scheduled Task

Choreo is a versatile integration platform that allows you to create various types of integrations depending on your requirements. If you need to automatically run a specific integration at regular intervals, you can use Choreo to develop a scheduled task. This type of integration can automate the synchronization of data between different systems at specified intervals, reducing errors and improving productivity by eliminating the need for manual intervention.

This guide walks you through the steps to develop, deploy, test, and observe a scheduled task using Choreo.

In this guide, you will:

- Develop a scheduled task to fetch the weather forecast for a specified location for the next 24 hours from the [OpenWeatherMap](https://openweathermap.org) API.
- Process the weather data into a specific format.
- Send the formatted data to a specified email address at a specific time every day.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

    !!! info "Repository File Structure"
        The sample code for this guide is in the `<sample-repository-dir>/weather-to-email-scheduled-task` directory. The following table describes the key files in the repository:

        | **File Path**         | **File Content**                                                     |
        | --------------------- | -------------------------------------------------------------------- |
        | **Ballerina.toml**    | Contains metadata about the project                                  |
        | **Dependencies.toml** | Lists the dependencies required for the project                      |
        | **main.bal**          | Contains the entry point of the project, including the main function |
        | **types.bal**         | Contains custom data types used in the project                       |
        | **utils.bal**         | Contains utility functions and helper functions used in the project  |

3. Go to [OpenWeatherMap](https://openweathermap.org/) and sign up to obtain an API key. For details, see the [OpenWeatherMap documentation](https://openweathermap.org/appid#signup).

## Step 1: Create a scheduled task component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Scheduled Task** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following information:

    | **Field**             | **Description**                                |
    | --------------------- | ---------------------------------------------- |
    | **Organization**      | Your GitHub account                            |
    | **Repository**        | `choreo-samples`                               |
    | **Branch**            | `main`                                         |
    | **Component Directory** | `weather-to-email-scheduled-task`              |

6. Select **Ballerina** as the build pack.

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Component Directory** specifies the location of the project to build the component.

7. Enter a unique name and description for the component. You can use the following values:

    | **Field**          | **Value**                        |
    | ------------------ | -------------------------------- |
    | **Component Name** | `WeatherToEmail`                 |
    | **Description**    | `My first scheduled task`        |

8. Click **Create**. Choreo initializes the component with the sample implementation and opens the **Overview** page of the component.

Now you can proceed to build and deploy the scheduled task.

## Step 2: Build the scheduled task

1. In the left navigation menu, click **Build**.
2. In the **Builds** pane, click **Build**. This opens the **Commits** pane, where you can see all the commits related to the component.
3. Select the latest commit and click **Build**. This triggers the build process and displays the build progress in the **Build Logs** pane.

    !!! info
        The build process may take some time. Once complete, the build status will be listed in the **Builds** pane. Here, you will see the build status as **Success**.

## Step 3: Deploy the scheduled task

1. In the left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane, specify values for the configurable variables:

    !!! tip
        The configurable variables populated here are defined in the sample Ballerina project used in this guide. To learn how to declare configurable variables in Ballerina, see the [Ballerina documentation on declaring configurable variables](https://ballerina.io/learn/by-example/configurable-variables/).

    | **Field**     | **Value**                                                               |
    | ------------- | ----------------------------------------------------------------------- |
    | **apiKey**    | The API key you obtained in the prerequisites section                   |
    | **latitude**  | Latitude of the location to get the weather forecast                    |
    | **longitude** | Longitude of the location to get the weather forecast                   |
    | **email**     | The email address to receive the formatted weather forecast information |

    !!! note
        If you use **Ballerina** as the buildpack and want to set a configurable variable as a secret, click the lock icon corresponding to the configurable variable. This marks it as a secret and conceals the input value.

        For example, if you set the **apiKey** as a secret, its input value will be concealed. To update the input value later, click **Update Secret Content** and specify a new value.

4. Click **Next**.
5. Define a schedule to run the task. In this guide, set the schedule to receive the weather information daily at 8:00 AM UTC. Enter the following values:

    | **Field**            | **Value**                                             |
    | -------------------- | ----------------------------------------------------- |
    | **Select Time Zone** | Select a time zone to schedule the task               |
    | **Select Range**     | **Day**                                               |
    | **Every**            | `1`                                                   |
    | **At**               | `08:00`                                               |

    !!! tip
        To test and verify the task immediately, you can schedule the deployment to run in just a few minutes after you create it. However, to avoid unnecessary expenses, reschedule or stop the deployment once you test and verify.

6. Click **Deploy**. This deploys the scheduled task to the development environment and indicates the **Scheduled Status** as **Active** in the **Development** card.

You can test the scheduled task when it runs at the configured time.

## Step 4: Test the scheduled task

When the scheduled task runs at the configured time, an email with the subject `[WSO2 Choreo Demo] Next 24H Weather Forecast` is sent from `choreo.demo@gmail.com` to the email address specified as the **email** configurable variable value in [Step 3](#step-3-deploy-the-scheduled-task).

If the scheduled task ran successfully, you should receive an email similar to the following:

![Received email](../../assets/img/develop-components/develop-a-scheduled-integration/Received-email.png)

## Step 5: Observe the scheduled task

The observability view in Choreo displays graphs that depict details such as throughput, latency, diagnostic data, and logs to identify and troubleshoot anomalies in components you deploy.

1. In the left navigation menu, click **Observability**.
2. Observe the following:
    - The throughput and latencies of requests served over a given period.
    - The logs generated over a given period.
    - The flame graph (Diagnostics View) generated over a given period.
    - The low-code diagram.

To learn more about the observability details you can view via Choreo observability, see [Observability Overview](../../monitoring-and-insights/observability-overview.md).

## Step 6: Monitor executions

To track and monitor executions associated with the deployed scheduled task, go to the left navigation menu and click **Execute**.

!!! tip
    The **Execute** view is applicable to both scheduled and manual tasks.

You can view the following information:

- **Total executions**: The total number of executions within the past 30 days.

    ![Total Execution](../../assets/img/develop-components/develop-a-scheduled-integration/total_executions.png)

- **Execution history**: The currently active executions and those that are already complete. You can view information such as the execution ID, the revision of the execution, and the time it was triggered.

    ![Execution History](../../assets/img/develop-components/develop-a-scheduled-integration/execution_history.png)

- **Detailed execution logs**: Click on an execution to view detailed logs related to it.

    !!! info
        It may take a few minutes for the logs to appear. You may need to manually refresh to view the latest logs.

    ![Execution Logs](../../assets/img/develop-components/develop-a-scheduled-integration/execution_logs.png)


# Develop an Event Handler

An event handler executes predefined actions in response to specific events. Choreo simplifies the process of creating and deploying such integrations.

This guide walks you through the steps to create and deploy an Event Handler using WSO2 MI and Choreo.

In this guide, you will build a simple event handler that monitors RabbitMQ for new messages and displays them once they become available.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Set up RabbitMQ:
    - Use an existing RabbitMQ instance or start a new [RabbitMQ](https://www.rabbitmq.com/download.html) instance on a server that can be accessed via the internet.
    - Obtain the `username`, `hostname`, `password`, and `vhost` from the RabbitMQ instance to use later as environment variables.

3. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

## Step 1: Create an event handler component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Event Handler** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following information:

    | **Field**             | **Description**              |
    |-----------------------|----------------------------- |
    | **Organization**      | Your GitHub account          |
    | **Repository**        | `choreo-samples`             |
    | **Branch**            | `main`                       |
    | **Component Directory** | `mi-rabbitmq-listener`       |

6. Select **WSO2 MI** as the build pack. (since you are creating the REST API from a [WSO2 Integration Studio](https://wso2.com/micro-integrator/) project)

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Component Directory** specifies the location of the project to build the component.

7. Enter a unique name and description for the component. You can use the following values:

    | **Field**          | **Value**              |
    |--------------------|------------------------|
    | **Component Name** | `SalesOrderListener`   |
    | **Description**    | `RabbitMQ integration` |

8. Click **Create**.

## Step 2: Deploy the integration

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**.
3. In the **Configurations** pane, click **+ Add** corresponding to **Environment Variables** and add the following environment variables:

    !!! tip
        Use the values from your RabbitMQ instance as per the [Prerequisites](#prerequisites) section for the environment variables.

    | **Name**     | **Value**                                         |
    | ------------- |--------------------------------------------------|
    | **HOSTNAME**  | Hostname of your RabbitMQ server                 |
    | **VHOST**     | Virtual hostname of your RabbitMQ server         |
    | **USERNAME**  | Username for connecting to RabbitMQ              |
    | **PASSWORD**  | Password associated with the RabbitMQ username   |

4. Click **Deploy**. This deploys the event handler to the development environment and indicates the **Deployment Status** as **Active** in the **Development** card.

## Step 3: Test the integration

1. Send a sales order message to the **SalesOrderQueue** on the RabbitMQ server. You can send a sample sales order message similar to the following:

    ```json
    {
        "order_id": "12345",
        "customer_name": "John Doe",
        "product": "Widget",
        "quantity": 10,
        "total_amount": 100.00
    }
    ```

2. Observe the logs:
    - In the left navigation menu, click **Logs** and then click **Runtime Logs**. You will see the order message in the logs.

Now you have gained hands-on experience in creating, configuring, and deploying an event handler.


# Develop an Integration with Integration Studio

Choreo simplifies the process of building, deploying, and managing integration components, making it easy to expose integrations as APIs. This guide walks you through the steps to expose an integration created in WSO2 Integration Studio as an API in Choreo.

In this guide, you will:
- Create a component to expose a sample integration from the [Choreo samples repository](https://github.com/wso2/choreo-samples) as an API.
- Deploy, test, and observe the integration component.
- Publish the integration component as an API to the Choreo Developer Portal.

!!! note
    - To develop integrations for **Manual Task** and **Schedule Task** components in Choreo, use the **automation mode** in the WSO2 Micro Integrator. See [Running MI in Automation Mode](https://apim.docs.wso2.com/en/4.2.0/install-and-setup/install/running-the-mi-in-automation-mode/).
    - For other component types (Service, webhook, event-handler, etc.), use the **server mode**.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    - Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    - Enter a unique organization name. For example, `Stark Industries`.
    - Read and accept the privacy policy and terms of use.
    - Click **Create**. This creates the organization and opens the **Project Home** page.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

## Step 1: Create the integration component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the **Project Home** page.

2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following repository details:

    | **Field**             | **Description**              |
    |-----------------------|----------------------------- |
    | **Organization**      | Your GitHub account          |
    | **Repository**        | `choreo-samples`            |
    | **Branch**            | **`main`**                   |
    | **Component Directory** | `hello-world-mi`             |

6. Select WSO2 MI as the build pack (since you're creating the REST API from a [WSO2 Integration Studio](https://wso2.com/micro-integrator/) project).

7. Provide a unique name and description for the component:

    | **Field**          | **Value**              |
    |--------------------|------------------------|
    | **Component Name** | `Hello World`          |
    | **Description**    | `Hello World REST API` |

8. Click **Create**. Choreo initializes the component with the sample integration.

## Step 2: Deploy the integration component

1. In the Choreo Console left navigation menu, click **Deploy**.

2. Configure and deploy:
   - In the **Build Area** card, click **Configure & Deploy**.
   - In the **Configurations** pane, click **Next**. This displays the endpoint details ready for deployment.
   - Click **Deploy**. This deploys the integration component to the development environment.

    !!! tip
        - Choreo uses [endpoints](../../choreo-concepts/endpoint.md) to expose **Service** components to the network. Learn more about configuring endpoints in [Configure Endpoints](../configure-endpoints.md).
        - Automatic deployment is enabled by default, so only the first deployment needs to be done manually.

   The **Development** card shows the **Deployment Status** as **Active** when the integration is successfully deployed.

## Step 3: Test the integration

1. In the Choreo Console left navigation menu, click **Test** and then click **Console**.
2. In the OpenAPI Console, select **Development** from the environment drop-down list.
3. Expand the **GET /integration** operation.
4. Click **Try it out**, then click **Execute**. This sends a request to your deployed integration.
5. Check the response:
    - In the **Response body** section, observe the response. If the integration works as expected, you should see:
     
     ```json
     {"Hello" : "Integration"}
     ```

## Step 4: Observe the integration

1. Click **Observability** in the left navigation menu to monitor the performance of the integration component.

2. View metrics:
   - Observe throughput and latencies of requests over time.
   - View logs generated during a specific period.
   - Analyze the flame graph (Diagnostics View) for performance insights.

   For more details, see [Observability Overview](../../monitoring-and-insights/observability-overview.md).

## Step 5: Publish the integration component

1. In the Choreo Console left navigation menu, click **Manage** and then click **Lifecycle**.
2. The **Lifecycle Management** pane shows the current lifecycle stage as **Created**.
3. Click **Publish**. This changes the lifecycle stage to **Published** and exposes the integration as an API in the Choreo Developer Portal.
   - To view the published API, click **Go to Devportal**. In the Developer Portal, you can manage subscriptions and generate access tokens for testing.

Now you have successfully exposed an integration designed in WSO2 Integration Studio as a REST API in Choreo!


# Develop an API Proxy from a GitHub Repository Source

An API proxy acts as an intermediary between an existing API and Choreo, intercepting all requests made to the API. It also functions as a managed API, allowing you to apply essential API management features such as security policies and rate limiting.

In this guide, you will:

- Create an API proxy component to expose an existing API.
- Deploy the API proxy.
- Test the API proxy to verify its functionality.
- Manage the API.
- Consume the API.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample proxy source](https://github.com/wso2/choreo-samples/tree/main/department-api-proxy-from-github).  

## Step 1: Create an API proxy

You can create an API proxy either by selecting the source from a GitHub repository, uploading an OpenAPI specification file, or providing an OpenAPI specification URL. This guide demonstrates how to create an API proxy using a GitHub repository as the source.

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **API Proxy** card. This opens the **Create an API Proxy** pane.

4. Click on **Authorize With GitHub** card under **Connect a Git Repository** section to connect your GitHub account.
    - If you haven’t connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
         - Read and write access to code and pull requests.
         - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.    

5. Enter the following repository details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **Repository**         | choreo-samples     |
    | **Branch**             | **`main`**         |
    | **API Directory**      | /department-api-proxy-from-github |

    !!! note
        To select the relevant directory, click on the **Edit** action next to the **API Directory** input field. Then, enter `department-api-proxy-from-github` as the directory name to quickly search and locate the correct directory.

6. Specify the following values as Proxy Metadata:

    !!! info
        The **Context** field must be unique and cannot be changed after creation.**Version** and **Target** are mandatory fields. **Target** can be changed at any time after the creation.

    | **Field**       | **Value**                                  |
    |-----------------|--------------------------------------------|
    | **Context**     | `department-service`                                   |
    | **Version**     | `v1.0`                                      |
    | **Target**      | `https://samples.choreoapps.dev/company/hr`|

7. Specify the following values as Component Details:

    !!! info
        The **Component Name** field must be unique and cannot be changed after creation. This value is automatically generated, but you can edit it if necessary.
        **Component Display Name** is a required field.

    | **Field**       | **Value**                                  |
    |-----------------|--------------------------------------------|
    | **Component Display Name**| `Department Service`                    |
    | **Component Name**        | `department-service`                    |
    | **Description**           | `This is a sample proxy for department service`     |    

8. Click **Create**. This creates the API proxy component and takes you to the **Build** page.

!!! note
    When you create an API proxy from a GitHub repository source, the GitHub source serves as the single source of truth. Therefore, any modifications, such as adding or deleting resources, must be made through the GitHub repository.

## Step 2: Build

!!! info
    The initial build starts automatically when you create the API proxy, and you will be redirected to the **Build** page. In this case, you can skip the steps below. If you need to manually trigger a build later, follow these steps.

1. On the project home page, click on the `Department Service` component you created. This takes you to the component overview page.
2. In the left navigation menu, click **Build**.
3. On the **Build** page, click **Build Latest**.

!!! note
    The build process may take some time. You can track progress in the **Build Details** pane. Once complete, the build status changes to **Success**.

## Step 3: Deploy the API proxy

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**. This opens the **Configure & Deploy** pane.
3. Select **External** as the **API Access Mode** and click **Deploy**. The **Development** card indicates the **Deployment Status** as **Active** when the API proxy is successfully deployed.

Now you are ready to test the API proxy.

## Step 4: Test the API proxy

Choreo allows you to test your API proxy using either the [integrated OpenAPI Console](../../testing/test-rest-endpoints-via-the-openapi-console.md) or [cURL](../../testing/test-apis-with-curl.md). In this guide, you will use the OpenAPI Console.

!!! tip
    Choreo enables OAuth 2.0 to secure APIs by default. Therefore, you need an access token to invoke an API.

    - Choreo automatically generates a key to test the API via the OpenAPI Console. To view the key, click the show key icon in the **Security Header** field.
    - To disable security for the entire API or a specific resource:
        1. In the left navigation menu, click **Deploy**.
        2. Go to the **Build Area** card and click **Security Settings**.
        3. In the **Security Settings** pane:
            - To disable security for the entire API, clear the **OAuth2** checkbox.
            - To disable security for a specific resource, expand the relevant resource and turn off the **Security** toggle.
        4. Click **Apply**.

1. In the left navigation menu, click **Test** and then click **OpenAPI Console**.
2. Select **Development** from the environment drop-down list.
3. Expand the `GET /department/{departmentId}` resource and click **Try it Out**.
4. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

    ![API proxy response](../../assets/img/develop-components/develop-a-rest-api-proxy/rest-api-proxy-response.png){.cInlineImage-full}

    This indicates that your API proxy is working as expected.

## Step 5: Manage the API proxy

Now that you have a tested API proxy, you can publish it and make it available for application developers to consume. In this guide, you will apply rate limiting to the API and publish it.

### Step 5.1: Apply rate limiting to the API proxy

1. In the left navigation menu, click **Deploy**.
2. Go to the required environment card and click the settings icon corresponding to **API Configuration**.
3. In the **CORS, Rate Limiting and Resiliency** pane, click **Rate Limiting** to expand the section.
4. Select **API Level** as the **Rate Limiting Level**.
5. Specify appropriate values for the **Request Limit** and **Time Unit** fields. You can proceed with the default values.
6. Click **Apply**. This applies the rate limiting level to the API proxy and redeploys it.

### Step 5.2: Publish the API proxy

1. In the left navigation menu, click **Lifecycle** under **Manage**. This takes you to the **Lifecycle** page.
2. Click **Publish**.
3. In the **Publish API** dialog, click **Confirm** to proceed with publishing the API. If you want to change the display name, make the necessary changes and then click **Confirm**. This changes the API lifecycle state to **Published**.

## Step 6: Invoke the API

To generate credentials for the published API and invoke it via the Choreo Developer Portal, follow these steps:

1. In the **Lifecycle** page, click **Go to Devportal**. This takes you to the `Department Service` in the Choreo Developer Portal.

2. **Invoke the API**:
    1. In the Developer Portal left navigation menu, click **Try Out**.
    2. In the **Endpoint** list, select **Development** as the environment to try out the API.
    3. Click **Get Test Key** to generate an access token.
    4. Expand the `GET /department/{departmentId}` resource and click **Try it out**.
    5. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

        ![Try out response](../../assets/img/develop-components/develop-a-rest-api-proxy/try-out-response.png){.cInlineImage-full}

Now, you have gained hands-on experience creating, deploying, testing, and publishing an API proxy using Choreo.


# Develop an API Proxy from Scratch

An API proxy acts as an intermediary between an existing API and Choreo, intercepting all requests made to the API. It also functions as a managed API, allowing you to apply essential API management features such as security policies and rate limiting.

In this guide, you will:

- Create an API proxy component to expose an existing API.
- Deploy the API proxy.
- Test the API proxy to verify its functionality.
- Manage the API.
- Consume the API.

## Prerequisites

- If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

## Step 1: Create an API proxy

To create an API proxy, you can either upload an OpenAPI specification or provide an OpenAPI specification URL. In this guide, you will specify a URL to an OpenAPI definition of a sample API.

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **API Proxy** card. This opens the **Create an API Proxy** pane.
4. Select **Creare from Scratch** option. 
5. Specify the following values as Proxy Metadata:

    | **Field**       | **Value**                                  |
    |-----------------|--------------------------------------------|
    | **Context**     | `department-service`                                   |
    | **Version**     | `v1.0`                                      |
    | **Target**      | `https://samples.choreoapps.dev/company/hr` |

6. Enter following details for the Component Details:

    !!! info
        The **Component Name** field must be unique and cannot be changed after creation.

    | **Field**                 | **Value**          |
    |---------------------------|--------------------|
    | **Component Display Name**| `Department Service`          |
    | **Component Name**        | `department-service`          |
    | **Description**           | `Sample proxy for department service`     |

7. Click **Create**. This creates the API proxy component and takes you to the **Deploy** page.

## Step 2: Define resources for the API proxy

To add a new resource that retrieves a department by the department ID, follow these steps:

1. In the left navigation menu, click **Develop** and then click **Resources**.
2. Select **GET** as the **HTTP Verb** and enter `/department/{departmentId}` as the **URI Pattern**.
3. Click **+** to add the resource.
4. Expand the added resource and specify the following values:

    | **Field**        | **Value**                            |
    |------------------|--------------------------------------|
    | **Operation ID** | `findDepartment`                     |
    | **Description**  | `Find a department by department ID` |

5. Remove the five default resources that start with `/*` by clicking the delete icon corresponding to each resource.
6. Click **Save**.

## Step 3: Deploy the API proxy

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**. This opens the **Configure & Deploy** pane.
3. Select **External** as the API access mode and click **Deploy**. The **Development** card indicates the **Deployment Status** as **Active** when the API proxy is successfully deployed.

Now you are ready to test the API proxy.

## Step 4: Test the API proxy

Choreo allows you to test your API proxy using either the [integrated OpenAPI Console](../../testing/test-rest-endpoints-via-the-openapi-console.md) or [cURL](../testing/test-apis-with-curl.md). In this guide, you will use the OpenAPI Console.

!!! tip
    Choreo enables OAuth 2.0 to secure APIs by default. Therefore, you need an access token to invoke an API.

    - Choreo automatically generates a key to test the API via the OpenAPI Console. To view the key, click the show key icon in the **Security Header** field.
    - To disable security for the entire API or a specific resource:
        1. In the left navigation menu, click **Deploy**.
        2. Go to the **Build Area** card and click **Security Settings**.
        3. In the **Security Settings** pane:
            - To disable security for the entire API, clear the **OAuth2** checkbox.
            - To disable security for a specific resource, expand the relevant resource and turn off the **Security** toggle.
        4. Click **Apply**.

1. In the left navigation menu, click **Test** and then click **OpenAPI Console**.
2. Select **Development** from the environment drop-down list.
3. Expand the `GET /department/{departmentId}` resource and click **Try it Out**.
4. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

    ![API proxy response](../../assets/img/develop-components/develop-a-rest-api-proxy/rest-api-proxy-response.png){.cInlineImage-full}

    This indicates that your API proxy is working as expected.

## Step 5: Manage the API proxy

Now that you have a tested API proxy, you can publish it and make it available for application developers to consume. In this guide, you will apply rate limiting to the API and publish it.

### Step 5.1: Apply rate limiting to the API proxy

1. In the left navigation menu, click **Deploy**.
2. Go to the required environment card and click the settings icon corresponding to **CORS, Rate Limiting and Resiliency**.
3. In the **CORS, Rate Limiting and Resiliency** pane, click **Rate Limiting** to expand the section.
4. Select **API Level** as the **Rate Limiting Level**.
5. Specify appropriate values for the **Request Limit** and **Time Unit** fields. You can proceed with the default values.
6. Click **Apply**. This applies the rate limiting level to the API proxy and redeploys it.

### Step 5.2: Publish the API proxy

1. In the left navigation menu, click **Lifecycle** under **Manage**. This takes you to the **Lifecycle** page.
2. Click **Publish**.
3. In the **Publish API** dialog, click **Confirm** to proceed with publishing the API. If you want to change the display name, make the necessary changes and then click **Confirm**. This changes the API lifecycle state to **Published**.

## Step 6: Invoke the API

To generate credentials for the published API and invoke it via the Choreo Developer Portal, follow these steps:

1. In the **Lifecycle** page, click **Go to Devportal**. This takes you to the `Department Service` in the Choreo Developer Portal.

2. **Invoke the API**:
    1. In the Developer Portal left navigation menu, click **Try Out**.
    2. In the **Endpoint** list, select **Development** as the environment to try out the API.
    3. Click **Get Test Key** to generate an access token.
    4. Expand the `GET /department/{departmentId}` resource and click **Try it out**.
    5. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

        ![Try out response](../../assets/img/develop-components/develop-a-rest-api-proxy/try-out-response.png){.cInlineImage-full}

Now, you have gained hands-on experience creating, deploying, testing, and publishing an API proxy using Choreo.

# Develop a Ballerina Service

Choreo allows you to develop and deploy applications using your preferred programming language. This guide demonstrates how to deploy a service component that exposes a REST API using the [Ballerina language](https://ballerina.io/). No prior knowledge of Ballerina is required to follow this guide.

A REST API is a web service that adheres to Representational State Transfer (REST) principles, using HTTP methods to access and manage resources. This guide walks you through building a Ballerina service component, deploying it on Choreo, and testing it with an HTTP client application.

In this guide, you will:

 - Build a simple greeting service using a sample implementation. The service has a single resource named `greet` that accepts a query parameter as input.
 - Deploy the service in Choreo.
 - Test the service.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    - Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    - Enter a unique organization name. For example, `Stark Industries`.
    - Read and accept the privacy policy and terms of use.
    - Click **Create**. This creates the organization and opens the **Project Home** page.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample greetings service](https://github.com/wso2/choreo-samples/tree/main/greeting-service) implementation in Ballerina.

### Learn the repository file structure

It’s important to understand the purpose of key files in the sample service. The table below provides an overview of each file in the greeter service:

!!! note
    The file paths are relative to `<sample-repository-dir>/greeting-service`.

| **Filepath**              | **Description**                                                |
|---------------------------|---------------------------------------------------------------|
| `service.bal`             | The greetings service code written in Ballerina.               |
| `tests/service_test.bal`  | Test files related to the `service.bal` file.                  |
| `Ballerina.toml`          | The Ballerina configuration file.                              |

Let’s get started!

## Step 1: Create a service component

To create a Ballerina service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the **Project Home** page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect your GitHub account. If you haven’t connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Provide the following repository details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **Repository**         | choreo-samples     |
    | **Branch**             | **`main`**         |
    |**Component Directory** | `/greeting-service` |

6. Select **Ballerina** as the buildpack.

7. Provide a display name, a unique name, and a description for the service component:

    !!! info
        The **Component Name** field specifies a unique identifier for the component. This name cannot be changed after creation.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Ballerina Greetings`   |
    | **Component Name**        | `ballerina-greetings`   |
    | **Description**           | Send greetings          |

8. Click **Create**. This creates the component and takes you to the **Overview** page.

You have successfully created a service that exposes a REST API written in Ballerina. Next, let’s build and deploy the service.

## Step 2: Build and deploy

Now that you’ve connected the source repository and configured the endpoint details, it’s time to build and deploy the service.

!!! note
    If you’re rebuilding the Ballerina service component after changing the Ballerina version, ensure that the version in the `Ballerina.toml` file matches the version in the `Dependencies.toml` file.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service may take a while. Track the progress via the logs in the **Build Details** pane. Once complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps:

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane, click **Next** to skip the configuration.
4. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service may take a while. Once deployed, the **Development** environment card shows the **Deployment Status** as **Active**.

Once deployed, you can test, manage, and observe the service like any other component in Choreo.

For detailed instructions, see the following sections:
- [Step 3: Test](../../testing/test-rest-endpoints-via-the-openapi-console.md)
- [Step 4: Manage](../../api-management/lifecycle-management.md)

## Manage the deployment

To view Kubernetes-level insights for detailed diagnosis of this Ballerina REST API, see Choreo’s [DevOps capabilities](../../devops-and-ci-cd/view-runtime-details.md).


# Develop a Service with Docker

Choreo allows you to create and deploy applications in any language. This guide demonstrates how to develop and deploy a containerized service component using a Dockerfile.

In this guide, you will:

 - Create a containerized service component using a sample service implementation. The sample service has a single resource named `greet` that accepts a query parameter as input.
 - Deploy the service in Choreo using a Dockerfile. The service will run on port 9090.
 - Test the service.

If you want to create a service component that exposes a Ballerina service, see [Develop a Ballerina Service](develop-a-ballerina-service.md).

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    - Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    - Enter a unique organization name. For example, `Stark Industries`.
    - Read and accept the privacy policy and terms of use.
    - Click **Create**. This creates the organization and opens the **Project Home** page.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample greetings service](https://github.com/wso2/choreo-samples/tree/main/greeting-service-go) implementation with the Dockerfile.

### Learn the repository file structure

It’s important to understand the purpose of key files in the sample service. The table below provides an overview of each file in the greeter service:

!!! note
    The file paths are relative to `<sample-repository-dir>/greeting-service-go`.

| **Filepath**               | **Description**                                                              |
|----------------------------|------------------------------------------------------------------------------|
| `main.go`                  | The Go-based greeter service code.                                           |
| `Dockerfile`               | The Dockerfile to build the container image of the application.              |
| `.choreo/component.yaml`   | Choreo-specific configuration that provides information about how Choreo exposes the service. |
| `openapi.yaml`             | The OpenAPI contract of the greeter service. This is required to publish the service as a managed API. This file is referenced by the `.choreo/component.yaml` file. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints. The greeter service runs on port 9090. To securely expose the service through Choreo, you must provide the port and other required information in the `component.yaml` file. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

In the greeter sample, the `component.yaml` file is located in the `greeting-service-go/.choreo/` directory.

## Step 1: Create a service component from a Dockerfile

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/cloud-native-app-developer) and sign in. This opens the **Project Home** page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect your GitHub account. If you haven’t connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
         - Read and write access to code and pull requests.
         - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following repository details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **Repository**         | choreo-samples     |
    | **Branch**             | `main`         |
    | **Component Directory** | `/greeting-service-go`         |

6. Select **Docker** as the buildpack.
7. Enter the following details:

    | **Field**                | **Value**                        |
    |--------------------------|----------------------------------|
    | **Dockerfile**           | `/greeting-service-go/Dockerfile`|

    !!! info
        1. To successfully build your container with Choreo, explicitly define a user ID (UID) under the `USER` instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-sample-apps/blob/main/go/greeter/Dockerfile).
           - A valid User ID is a numeric value between 10000-20000 (e.g., `10001` or `10500`).
           - Usernames are invalid and should not be used (e.g., `my-custom-user-12221` or `my-custom-user`).

        2. The Dockerfile used in this guide is a multi-stage Dockerfile, which keeps the final image size small and allows building the application with specific versions of tools and libraries.

8. Provide a display name, a unique name, and a description for the service component:

    !!! info
        The **Component Name** field specifies a unique identifier for the component. This name cannot be changed after creation.

    | **Field**                 | **Value**          |
    |---------------------------|--------------------|
    | **Component Display Name**| `Greetings`        |
    | **Component Name**        | `greetings`        |
    | **Description**           | Send greetings     |

9. Click **Create**. This creates the component and takes you to the **Overview** page.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you’ve connected the source repository and configured the endpoint details, it’s time to build the service and create an image. Then, you can deploy the image and test the greeter service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service may take a while. Track the progress via the logs in the **Build Details** pane. Once complete, the build status changes to **Success**.

    You can access the following scans under **Build**:
    - **Dockerfile Scan**: Choreo checks if a non-root user ID is assigned to the Docker container for security. If no non-root user is specified, the build will fail.
    - **Container (Trivy) Vulnerability Scan**: This detects vulnerabilities in the final Docker image. If critical vulnerabilities are found, the build will fail.

    !!! info
        If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps:

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service may take a while. Once deployed, the **Development** environment card shows the **Deployment Status** as **Active**.

Once deployed, you can [test](../../testing/test-rest-endpoints-via-the-openapi-console.md), [manage](../../api-management/lifecycle-management.md), and [observe](../../monitoring-and-insights/observability-overview.md) the service like any other component in Choreo.

To view Kubernetes-level insights for detailed diagnosis of this Dockerfile-based REST API, see [Choreo's DevOps capabilities](../../devops-and-ci-cd/view-runtime-details.md).


# Develop a Service

Choreo allows you to create and deploy applications in your preferred programming language. 

In this guide, you will:

- Build a simple greeting service using a sample service implementation. The sample implementation will have a single resource named `greet` that accepts a single query parameter as input.
- Deploy the service in Choreo using a `Go` buildpack. The service will run on port 9090.
- Test the service.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample greetings service](https://github.com/wso2/choreo-samples/tree/main/greeting-service-go) implementation in `Go`.

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the greeter service:

!!! note 
    The specified file paths are relative to `<sample-repository-dir>/greeting-service-go`.

| **Filepath**             | **Description**                                                               |
|--------------------------|-------------------------------------------------------------------------------|
| `main.go`                | The Go-based greeter service code.                                            |
| `.choreo/component.yaml` | Choreo-specific configuration that provides information about how Choreo exposes the service. |
| `openapi.yaml`           | The OpenAPI contract of the greeter service. This is required to publish the service as a managed API. This `openapi.yaml` file is referenced by the `.choreo/component.yaml` file. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints. To run the greeter service on port 9090 and securely expose it through Choreo, you must provide the port and other required information in the `component.yaml` file. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

In the greeter sample, the `component.yaml` file is located in the `greeting-service-go/.choreo/` directory.

## Step 1: Create a service component

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Public Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Under **Connect a Git Repository**, enter the following details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **GitHub Repository**  | choreo-samples     |
    | **Branch**             | main               |
    | **Component Directory** | `/greeting-service-go` |

6. Select **Go** as the buildpack.
7. Enter the following details:

    | **Field**                | **Value**              |
    |--------------------------|------------------------|
    | **Language Version**     | 1.x                    |

8. Provide component display name, name and description:

    !!! info
        The **Component Name** field must be unique and cannot be changed after creation.

    | **Field**                 | **Value**          |
    |---------------------------|--------------------|
    | **Component Display Name**| Greetings          |
    | **Component Name**        | greetings          |
    | **Description**           | Send greetings     |

9. Click **Create**. This creates the component and lists it under **Component Listing** on the project home page.

You have successfully created the service. The next step is to build and deploy it.

## Step 2: Build and deploy

Now that you have connected the source repository and configured the endpoint details, it's time to build and deploy the greeter service.

### Step 2.1: Build

1. On the project home page, click on the `Greetings` component you created. This takes you to the component overview page.
2. In the left navigation menu, click **Build**.
3. On the **Build** page, click **Build Latest**.

    !!! note
        The build process may take some time. You can track progress in the **Build Details** pane. Once complete, the build status changes to **Success**.

### Step 2.2: Deploy

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take some time. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

Once you have successfully deployed the service, you can [test](../../testing/test-rest-endpoints-via-the-openapi-console.md), [manage](../../api-management/lifecycle-management.md), and [observe](../../monitoring-and-insights/observability-overview.md) it like any other component type in Choreo.


# Expose a Ballerina GraphQL Endpoint via a Service

Choreo offers the flexibility to develop and deploy applications in a language of your preference. This guide shows you how to deploy a service component that exposes a GraphQL API using the Ballerina language in Choreo. No prior knowledge of the Ballerina language is required to follow this guide. 

GraphQL API is a query language and runtime that provides a single endpoint for retrieving flexible and efficient data in a strongly-typed and self-documenting way. By following this guide, you will build a service component in Ballerina and deploy it on Choreo for any GraphQL client application to utilize it.

This guide shows how to build a simple reading list service and deploy it in Choreo using Ballerina. The GraphQL endpoint you create in this guide has two operations: **Query** and **Mutation**. The Query type operations read the data in the data source, and the Mutation operations update the data in the data source. The reading list service has two queries and three mutations as follows:

### Queries

**Retrieve the reading list**

This resource accepts an optional filter, `status`, which filters the reading list by reading status. Accepted values for status are `reading`, `read`, and `to_read`.

**Sample request**:
```
$ curl -X POST -H "Content-Type: application/json" -d '{"query": "query {allBooks (status: \"reading\") { id title author status }}"}' http://localhost:8090
```

**Sample response**
```
$ {
  "data": {
    "allBooks": [
      {
        "id": 1,
        "title": "Sample Book",
        "author": "Test Author",
        "status": "to_read"
      }
    ]
  }
}
```

**Retrieve a book item from the reading list**

This resource accepts a filter, `id`, which will select the book item from the reading list by book id.  The id is an Integer value. 

**Sample request**
```
$ curl -X POST -H "Content-Type: application/json" -d '{"query": "query {book (id: 1) { id title author status }}"}' http://localhost:8090
```

**Sample response**
```
$ {
  "data": {
    "book": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "to_read"
    }
  }
}
```

### Mutations

**Add a book item to the reading list**

This remote function accepts a book record as the input and consists of the title and the author. When you add a new book to the reading list, the method updates the reading status of the newly added book to `to_read`. This method returns the added book item upon successful execution.


**Sample request**

```
$ curl -X POST -H "Content-type: application/json" -d '{ "query": "mutation { addBook(book: {title: \"Sample Book\", author: \"Test Author\"}) { id title author status } }" }' 'http://localhost:8090'
```

**Sample response**

```
$ {
  "data": {
    "addBook": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "to_read"
    }
  }
}
```

**Update the reading status of a book**

This remote function requires `id` and `status` as inputs to update the reading status of the selected book. The `id` refers to the id of the book. It is an integer.  The `status` refers to the reading status that needs to be updated. This method returns the updated book item upon successful execution.

**Sample request**

```
$ curl -X POST -H "Content-type: application/json" -d '{ "query": "mutation { setStatus(id: 1, status: \"reading\") { id title author status } }" }' 'http://localhost:8090'
```

**Sample response**

```
$ {
  "data": {
    "setStatus": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "reading"
    }
  }
}
```

**Delete a book item from the reading list**

This remote function requires the `id` as the input to delete the book item from the reading list. This method returns the removed book item upon successful execution.

**Sample request**

```
$ curl -X POST -H "Content-type: application/json" -d '{ "query": "mutation { deleteBook(id: 1) { id title author status } }" }' 'http://localhost:8090'
```

**Sample response**
```
$ {
  "data": {
    "deleteBook": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "reading"
    }
  }
}
```

Our next step is to set up the resources that you will require to follow the guide, including the sample reading list application and the Choreo GitHub app.

## Prerequisites

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample GraphQL service](https://github.com/wso2/choreo-samples/tree/main/reading-list-graphql) implementation for this guide.

Let's get started!

## Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the reading list service.

!!! note
    The following file paths are relative to the path `<sample-repository-dir>/reading-list-graphql`.

|Filepath                 | Description                                                     |
|-------------------------|-----------------------------------------------------------------|
| `service.bal`           | The reading list service code written in the Ballerina language.|
| `Ballerina.toml`        | The Ballerina configuration file.                               |
| `.choreo/component.yaml`| The configuration file with endpoint details.                   |

## Step 1: Create a service component 

To create a Ballerina service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**| `reading-list-graphql`    |.

6. Select **Ballerina** as the buildpack.

7. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Ballerina Reading List`|
    | **Component Name**        | `ballerina-reading-list`|
    | **Description**           | Manage a reading list   |

8. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service component that exposes a GraphQL API written in the Ballerina language. Next, let's build and deploy the service.

## Step 2: Build and deploy

Now that we have connected the source repository, it's time to build and deploy the reading list service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Configurations** pane that opens, click **Next** to skip the configuration.
4. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.
To build and deploy the service, follow the steps below:

Once you have successfully deployed your service, you can test, manage, and observe it like any other component type in Choreo.

For detailed instructions, see the following sections:

- [Step 3: Test](https://wso2.com/choreo/docs/testing/test-graphql-endpoints-via-the-graphql-console/)
- [Step 4: Manage](https://wso2.com/choreo/docs/manage/api-management/)


# Expose a gRPC Endpoint via a Service

Choreo allows you to create and deploy applications in your preferred programming language. One powerful option is gRPC, a high-performance and language-agnostic remote procedure call (RPC) framework. It utilizes [Protocol Buffers](https://github.com/protocolbuffers/protobuf) to define services and generate client/server code.

In this guide, you will learn to use Choreo to create a service component that exposes a gRPC server implemented in [Go](https://go.dev/), enabling efficient and scalable communication with any gRPC client application. No prior knowledge of the Go language is necessary to follow this guide.

By following this guide, you will:

- Create a simple gRPC server using a Service component.
- Link the containerized gRPC service to the Choreo component using the Dockerfile. 
    The greeter service has a single RPC method named `sayHello`. Following is the proto file the server and the client application are using:

    ```proto
    syntax = "proto3";
    option go_package = "github.com/wso2/choreo-samples/go-grpc/pkg";

    service greeter {
      rpc SayHello (HelloRequest) returns (HelloReply) {}
    }

    message HelloRequest {
      string name = 1;
    }

    message HelloReply {
      string message = 1;
    }
    ```

- Deploy the gRPC server component in Choreo. 
- Create a gRPC client using a Manual Trigger component. 
- Deploy the gRPC client.
- Invoke the gRPC server using a gRPC client and check the response through the Choreo log view.


## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample service](https://github.com/wso2/choreo-samples/tree/main/go-grpc) implementation for this guide.

Let's get started!

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the greeter service.

!!! note 
    The following file paths are relative to the path `<sample-repository-dir>/go-grpc`.

|File Path                |Description                                                                                   |
|-------------------------|----------------------------------------------------------------------------------------------|
| `main.go`               | The greeter service code written in the Go language.                                         |
| `greeter_client/main.go`| The greeter client application written in the Go language.                                   |
| `Dockerfile.server`     | The Dockerfile to build the container image of the server application.                       |
| `Dockerfile.client`     | The Dockerfile to build the container image of the client application.                       |
| `.choreo/component.yaml`| The Choreo-specific configuration that provides information about how Choreo exposes the service.|
| `pkg/greeter.proto`     | The interface definition of the gRPC service. This is used to generate the server and client stubs for the Go application.|

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints.

Let's run the gRPC server service component on port 8080. To securely expose the service through Choreo, you must provide the port and other required information to Choreo. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

Choreo looks for an `component.yaml` file inside the `.choreo` directory to configure the endpoint details of the containerized component. Ensure the `.choreo` directory is at the root of the Docker build context path.

In the gRPC server sample, the `component.yaml` file is at `go-grpc/.choreo/component.yaml`, where the build context path is `go-grpc`.

## Step 1: Create a service component with a gRPC endpoint

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
6. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

7. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory** | `go-grpc`                  |

8. Select **Docker** as the buildpack.
9. Enter the following information:
    
    | **Field**                | **Value**                  |
    |--------------------------|----------------------------|
    | **Dockerfile**           | `go-grpc/Dockerfile.server`|

    !!! info
        1.  To successfully build your container with Choreo, it is essential to explicitly define a User ID (UID) under the USER instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-samples/blob/main/go-grpc/Dockerfile.server).
        To ensure that the defined USER instruction is valid, it must conform to the following conditions:
            - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
            - Usernames are considered invalid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

        2. The Dockerfile utilized in this guide is a multi-stage Dockerfile, which is designed to keep the final image size small and provides the ability to build the application with a specific version of tools and libraries.

4. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go gRPC Server`        |
    | **Component Name**        | `go-grpc-server`        |
    | **Description**           | Send greetings          |
    
10. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you have connected the source repository, and configured the endpoint details, it's time to build the service and create an image. Then you can deploy the image and test the greeter service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

    You can access the following scans under **Build**. 

      - **The Dockerfile scan**: Choreo performs a scan to check if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
      - **Container (Trivy) vulnerability scan**: This detects vulnerabilities in the final docker image. 
      - **Container (Trivy) vulnerability scan**: The details of the vulnerabilities open in a separate pane. If this scan detects critical vulnerabilities, the build will fail.
     
        !!! info
            If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Environment Configurations** pane that opens, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

6. Once you have successfully deployed your service, navigate to the component overview page and copy the gRPC service URL. You need to provide that URL when setting up the client application later in this guide.

You have successfully deployed the gRPC server. Currently, the gRPC service is only accessible by the components deployed within the same project.

## Step 3: Invoke the gRPC service

Let's invoke the gRPC service that you created above, using a gRPC client. 

### Step 3.1: Create a manual task for the gRPC client

To create a manual task component, follow these steps:

1. On the Choreo Console header, click the **Project** list and select the project where you created the gRPC service component. This opens the project home page.
2. Go to the **Component Listing** section and click **+ Create**.
3. Click the **Manual Task** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**       | `go/grpc`                  |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                  |
    |--------------------------|----------------------------|
    | **Dockerfile**           | `go/grpc/Dockerfile.client`|

8. Enter a display name, a unique name, and a description for the component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go gRPC Client`        |
    | **Component Name**        | `go-grpc-client`        |
    | **Description**           | `Receive greetings`     |


9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

### Step 3.2: Build the gRPC client component

To build the component, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 3.3: Setup environment variables and deploy the gRPC client

The client application, in this case, the gRPC client, requires the server URL of the gRPC server service. This is read from the client application as an environment variable. Follow the steps below to configure the environment variable for the client application:

1. On the Choreo Console left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane that opens, click **+ Add**.
4. Specify the following name and value to configure the environment variable for the client application:

    | **Field**       | **Value**               |
    |-----------------|-------------------------|
    | **Name**        | `GREETER_SERVICE`       |
    | **Value**       | Paste the URL value copied after deploying the gRPC service via [step 2.2](#step-22-deploy) above.  Make sure to **drop the `http://` or `grpc://` part and the trailing `/` from the URL when copying**. For example, if the URL is `http://go-grpc-server-3192360657:8080/`, add only `go-grpc-server-3192360657:8080`.|

5.  Click **Add** and then click **Next**.
6.  Click **Deploy**.

### Step 3.4: Execute the gRPC client component

To execute the gRPC client, follow these steps:

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the gRPC client and generates logs.
   You can trigger multiple runs to generate multiple logs.

For details on what you can monitor via the execute page, see [Monitor executions](../develop-integrations/develop-a-manual-task.md#step-7-monitor-executions). 


# Expose a Prism-Based Mock Server Using an OpenAPI Specification

Choreo supports deploying [Prism-based](https://docs.stoplight.io/docs/prism/674b27b261c3c-prism-overview) mock servers using OpenAPI specifications. With the Choreo Prism mock service component, you can serve multiple mock servers, each based on a different OpenAPI specification, as separate endpoints.

By default, these mock servers serve static content generated from the examples in the configured OpenAPI Specification (OAS). 

## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [Prism mock service](https://github.com/wso2/choreo-samples/tree/main/prism-mock-service) artifacts for this guide.

## Step 1: Create a Prism mock service component

To create a Prism mock service component, follow these steps:
    
1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, you can paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    |**Component Directory**  | `prism-mock-service`    |

6. Select **Prism Mock** as the buildpack.
7. Enter a display name, a unique name, and a description for the service component.
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

8. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

## Step 2: Build and deploy the component

Now that you have successfully created the Prism mock service, it's time to build and deploy it.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**. This builds the service from the latest commit.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

Once you have successfully deployed the service, you can [test](../../testing/test-rest-endpoints-via-the-openapi-console.md), [manage](../../api-management/lifecycle-management.md), and [observe](../../monitoring-and-insights/observability-overview.md) it like any other component type in Choreo.

## Serve dynamic content

The Prism mock service can serve dynamic content according to the schema definitions in the OpenAPI specification. To use the Prism mock service with dynamic content, clients must add the `prefer:dynamic=true` header in the request.

To generate meaningful dynamic responses, you can use the `x-faker` attribute in schema definitions of the OpenAPI specification. For more information on dynamically generated responses with the `x-faker` attribute, see the [Prism documentation](https://docs.stoplight.io/docs/prism/9528b5a8272c0-dynamic-response-generation-with-faker).


# Expose a TCP Server via a Service

Choreo offers the flexibility to design and deploy applications in the programming language of your choice. One viable choice for specific network communication needs is TCP (Transmission Control Protocol). TCP provides a reliable, stream-oriented communication mechanism that ensures data integrity and orderliness during transmission. It's the go-to option for scenarios where guaranteed data delivery and error recovery are paramount.

In this guide, you will learn to use Choreo to create a service component that exposes a TCP server implemented in [Go](https://go.dev/), enabling efficient and scalable communication with any TCP client application. No prior knowledge of the Go language is necessary to follow this guide.

By following this guide, you will:

- Setup a TCP server
    - Create a simple TCP server using a service component.
    - Link the containerized TCP service to the Choreo component using a Dockerfile. 
    - Deploy the TCP server component in Choreo. 
- Setup a TCP client
    - Create a TCP client using a manual task component. 
    - Link the containerized TCP client to the Choreo component using a Dockerfile. 
    - Deploy the TCP client component in Choreo.
- Invoke the TCP server using a TCP client and observe the response through the Choreo log view.

## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample service](https://github.com/wso2/choreo-samples/tree/main/docker-tcp-service) implementation for this guide.

Let's get started!

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the sample service.

!!! note 
    The following file paths are relative to the path `<sample-repository-dir>/docker-tcp-service`.

|File Path                 |Description                                                                                   |
|--------------------------|----------------------------------------------------------------------------------------------|
| `server/main.go`         | The greeter service code written in the Go language.                                         |
| `client/main.go`         | The greeter client application written in the Go language.                                   |
| `Dockerfile.server`      | The Dockerfile to build the container image of the server application.                       |
| `Dockerfile.client`      | The Dockerfile to build the container image of the client application.                       |
| `.choreo/component.yaml` | The Choreo-specific configuration provides information about how Choreo exposes the service. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints.

Let's run the TCP server service component on port 5050. To securely expose the service through Choreo, you must provide the port and other required information to Choreo. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

Choreo looks for an `component.yaml` file inside the `.choreo` directory to configure the endpoint details of a containerized component. Place the `.choreo` directory at the root of the Docker build context path.

In our TCP server sample, the `component.yaml` file is at `docker-tcp-service/.choreo/component.yaml`, where the build context path is `docker-tcp-service`.

## Step 1: Create a service component with a TCP endpoint

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory** | `docker-tcp-service`                  |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-tcp-service/Dockerfile.server`|

    !!! info
        1.  To successfully build your container with Choreo, it is essential to explicitly define a User ID (UID) under the USER instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-samples/blob/main/docker-tcp-service/Dockerfile.server).
        To ensure that the defined USER instruction is valid, it must conform to the following conditions:
            - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
            - Usernames are considered invalid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

        2. The Dockerfile utilized in this guide is a multi-stage Dockerfile, which is designed to keep the final image size small and provides the ability to build the application with a specific version of tools and libraries.

8. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go TCP Server`         |
    | **Component Name**        | `go-tcp-server`         |
    | **Description**           | Send greetings          |
    
9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you have connected the source repository, and configured the endpoint details, it's time to build the service and create an image. Then you can deploy the image and test the service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

    You can access the following scans under **Build**. 

      - **The Dockerfile scan**: Choreo performs a scan to check if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
      - **Container (Trivy) vulnerability scan**: This detects vulnerabilities in the final docker image. 
      - **Container (Trivy) vulnerability scan**: The details of the vulnerabilities open in a separate pane. If this scan detects critical vulnerabilities, the build will fail.
     
        !!! info
            If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Environment Configurations** pane that opens, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

6. Once you have successfully deployed your service, navigate to the component overview page and copy the TCP service address. You need to provide that address when setting up the client application later in this guide.

You have successfully deployed the TCP server. Currently, the TCP service is only accessible by the components deployed within the same project.

## Step 3: Invoke the TCP service

Now let's use a TCP client to invoke the TCP service that you created above. To do this, you can create a manual trigger component as the TCP client. This is the recommended approach because, in this example, it's more efficient to have a client that connects to the server, sends a request, and then stops. Here, a continuously executing task isn't required. Furthermore, if you use a manual trigger component, you won't need to expose an endpoint in the client for invocation, unlike with an API.

### Step 3.1: Create a manual trigger for the TCP client

To create a manual task component, follow these steps:

1. On the Choreo Console header, click the **Project** list and select the project where you created the TCP service component. This opens the project home page.
2. Go to the **Component Listing** section and click **+ Create**.
3. Click the **Manual Task** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Docker Context**      |`docker-tcp-service`     |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-tcp-service/Dockerfile.client`|

8. Enter a display name, a unique name, and a description for the component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**              |
    |---------------------------|------------------------|
    | **Component Display Name**| `Go TCP Client`        |
    | **Component Name**        | `go-tcp-client`        |
    | **Description**           | `Receive greetings`    |


9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

### Step 3.2: Build the TCP client component

To build the component, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 3.3: Setup environment variables and deploy the TCP client

The client application, in this case, the TCP client, requires the server URL of the TCP server service. This is read from the client application as an environment variable. Follow the steps below to configure the environment variable for the client application:

1. On the Choreo Console left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane that opens, click **+ Add**.
4. Specify the following name and value to configure the environment variable for the client application:

    | **Field**       | **Value**               |
    |-----------------|-------------------------|
    | **Name**        | `SERVER_ADDRESS`       |
    | **Value**       | Paste the URL value copied after deploying the TCP service via [step 2.2](#step-22-deploy) above.  Make sure to **drop the `tcp://` part and the trailing `/` from the URL when copying**. For example, add only `go-tcp-server-1097922445:8080`.|

5.  Click **Add** and then click **Next**.
6.  Click **Deploy**.

### Step 3.4: Execute the TCP client component

To execute the TCP client, follow these steps:

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the TCP client and generates logs.
   You can trigger multiple runs to generate multiple logs.

For details on what you can monitor via the execute page, see [Monitor executions](../develop-integrations/develop-a-manual-task.md#step-7-monitor-executions).


# Expose a UDP Server via a Service

Choreo offers the flexibility to design and deploy applications in the programming language of your choice. One compelling choice for certain network communication needs is UDP (User Datagram Protocol). UDP is a high-speed, connectionless protocol ideal for scenarios where lightweight, real-time data transmission is essential.

In this guide, you will learn to use Choreo to create a Service component that exposes a UDP server implemented in [Go](https://go.dev/), enabling efficient and scalable communication with any UDP client application. No prior knowledge of the Go language is necessary to follow this guide.

By following this guide, you will:

- Setup a UDP server
    - Create a simple UDP server using a Service component.
    - Link the containerized UDP service to the Choreo component using the Dockerfile. 
    - Deploy the UDP server component in Choreo. 
- Setup a UDP client
    - Create a UDP client using a manual task component. 
    - Link the containerized UDP client to the Choreo component using the Dockerfile. 
    - Deploy the UDP client component in Choreo.
- Invoke the UDP server using a UDP client and check the response through the Choreo log view.

## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample service](https://github.com/wso2/choreo-samples/tree/main/docker-udp-service) implementation for this guide.

Let's get started!

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the sample service.

!!! note 
    The following file paths are relative to the path `<sample-repository-dir>/docker-udp-service`.

|File Path                |Description                                                                                   |
|-------------------------|----------------------------------------------------------------------------------------------|
| `server/main.go`        | The greeter service code written in the Go language.                                         |
| `client/main.go`        | The greeter client application written in the Go language.                                   |
| `Dockerfile.server`     | The Dockerfile to build the container image of the server application.                       |
| `Dockerfile.client`     | The Dockerfile to build the container image of the client application.                       |
| `.choreo/component.yaml`| The Choreo-specific configuration provides information about how Choreo exposes the service. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints.

Let's run the UDP server service component on port 5050. To securely expose the service through Choreo, you must provide the port and other required information to Choreo. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

Choreo looks for an `component.yaml` file inside the `.choreo` directory to configure the endpoint details of a containerized component. Place the `.choreo` directory at the root of the Docker build context path.

In our gRPC server sample, the `component.yaml` file is at `docker-udp-service/.choreo/component.yaml`, where the build context path is `docker-udp-service`.

## Step 1: Create a service component with a UDP endpoint

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
6. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

7. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**   | `docker-udp-service`    |    

8. Select **Docker** as the buildpack.
9. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-udp-service/Dockerfile.server`|

    !!! info
        1.  To successfully build your container with Choreo, it is essential to explicitly define a User ID (UID) under the USER instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-samples/blob/main/docker-udp-service/Dockerfile.server).
        To ensure that the defined USER instruction is valid, it must conform to the following conditions:
            - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
            - Usernames are considered invalid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

        2. The Dockerfile utilized in this guide is a multi-stage Dockerfile, which is designed to keep the final image size small and provides the ability to build the application with a specific version of tools and libraries.

4. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go UDP Server`         |
    | **Component Name**        | `go-udp-server`         |
    | **Description**           | Send greetings          |

10. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you have connected the source repository, and configured the endpoint details, it's time to build the service and create an image. Then you can deploy the image and test the service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

    You can access the following scans under **Build**. 

      - **The Dockerfile scan**: Choreo performs a scan to check if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
      - **Container (Trivy) vulnerability scan**: This detects vulnerabilities in the final docker image. 
      - **Container (Trivy) vulnerability scan**: The details of the vulnerabilities open in a separate pane. If this scan detects critical vulnerabilities, the build will fail.
     
        !!! info
            If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Environment Configurations** pane that opens, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

6. Once you have successfully deployed your service, navigate to the component overview page and copy the UDP service address. You must provide that address when setting up the client application later in this guide.

You have successfully deployed the UDP server. Currently, the UDP service is only accessible by the components deployed within the same project.

## Step 3: Invoke the UDP service

Now let's use a UDP client to invoke the UDP service that you created above. To do this, you can create a manual trigger component as the UDP client. This is the recommended approach because, in this example, it's more efficient to have a client that connects to the server, sends a request, and then stops. Here, a continuously executing task isn't required. Furthermore, if you use a manual trigger component, you won't need to expose an endpoint in the client for invocation, unlike with an API.

### Step 3.1: Create a manual trigger for the UDP client

To create a manual task component, follow these steps:

1. On the Choreo Console header, click the **Project** list and select the project where you created the UDP service component. This opens the project home page.
2. Go to the **Component Listing** section and click **+ Create**.
3. Click the **Manual Task** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory** | `docker-udp-service`    |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-udp-service/Dockerfile.client`|

8. Enter a display name, a unique name, and a description for the component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**              |
    |---------------------------|------------------------|
    | **Component Display Name**| `Go UDP Client`        |
    | **Component Name**        | `go-udp-client`        |
    | **Description**           | `Receive greetings`    |


9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

### Step 3.2: Build the UDP client component

To build the component, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 3.3: Setup environment variables and deploy the UDP client

The client application, in this case, the UDP client, requires the server URL of the UDP server service. This is read from the client application as an environment variable. Follow the steps below to configure the environment variable for the client application:

1. On the Choreo Console left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane that opens, click **+ Add**.
4. Specify the following name and value to configure the environment variable for the client application:

    | **Field**       | **Value**               |
    |-----------------|-------------------------|
    | **Name**        | `SERVER_ADDRESS`       |
    | **Value**       | Paste the URL value copied after deploying the UDP service via [step 2.2](#step-22-deploy) above.  Make sure to **drop the `udp://` part and the trailing `/` from the URL when copying**. For example, add only `go-udp-server-1097922445:8080`.|

5.  Click **Add** and then click **Next**.
6.  Click **Deploy**.

### Step 3.4: Execute the UDP client component

To execute the UDP client, follow these steps:

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the UDP client and generates logs.
   You can trigger multiple runs to generate multiple logs.

For details on what you can monitor via the execute page, see [Monitor executions](../develop-integrations/develop-a-manual-task.md#step-7-monitor-executions).


# Expose a WebSocket Endpoint via a Service

Choreo allows you to create and deploy applications in your preferred programming language, offering a seamless platform for building dynamic and scalable solutions. This guide walks you through the steps to deploy a WebSocket service using the NodeJS buildpack.

WebSockets provide real-time, two-way communication between a client and server over a persistent TCP connection. This makes WebSocket APIs ideal for applications that require real-time updates.

In this guide, you will:

- Build a simple WebSocket service using a sample implementation in NodeJS.
- Deploy the service in Choreo, allowing any WebSocket client application to establish a connection and exchange real-time messages with your service.

## Prerequisites

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample WebSocket service](https://github.com/wso2/choreo-samples/tree/main/websocket-chat-app) implementation for this guide.

Let's get started!

## Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the NodeJS chat Application.

!!! note
    The following file paths are relative to the path `<sample-repository-dir>/websocket-chat-app/websocket-chat-service-nodejs`.

|Filepath                        | Description                                                     |
|--------------------------------|-----------------------------------------------------------------|
| `server.js`                    | The NodeJS chat service.                                        |
| `.choreo/component.yaml`       | The configuration file with endpoint details.                   |

!!! note
    Choreo currently supports defining WebSocket APIs using the AsyncAPI 2.0 specification.

## Step 1: Create a service component 

To create a NodeJS service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**   | `websocket-chat-app/websocket-chat-service-nodejs`  |

6. Select **NodeJS** as the buildpack and **18.x.x** as the Language Version

8. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:

    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `NodeJS Chat Service`   |
    | **Component Name**        | `nodejs-chat-service`   |
    | **Description**           | Manage a chat service   |

9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service component that provides a WebSocket API built with NodeJS. The next step is to proceed with building and deploying the service.

## Step 2: Build and deploy

Now that you have connected the source repository, it's time to build and deploy the chat service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane that opens, click **Next** to skip the configuration.
4. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

Once you have successfully deployed your service, you can [test](../../testing/test-websocket-endpoints-via-the-websocket-console.md), [manage](../../api-management/lifecycle-management.md), and observe it like any other component type in Choreo.

During testing, once the WebSocket connection is established, you can send {"type": "Connect", "username": "user1"} to the WebSocket endpoint to connect to the chat service. You can then send chat messages by using {"type": "Data", "message": "Hello, World!"}.

!!! note
     Some clients, such as certain browsers, may not support adding headers to the WebSocket handshake. In these cases, you can include the access token or test key required for WebSocket API invocation within the `sec-websocket-protocol` header, along with any specified subprotocols.

     For example: `sec-websocket-protocol: choreo-oauth2-token, {access token}, subprotocols`

     If you are using a test key, replace `choreo-oauth2-token` with `choreo-test-key`.


# Service Component Overview

Explore how to create, deploy, manage, and observe service components in Choreo.

## What is a service component?

A service component in Choreo lets you deploy and expose REST, GraphQL, gRPC, UDP, WS or TCP services. It is a fundamental building block for creating cloud-native applications in Choreo. They provide a simple and effective way to expose functionality as a service to other components within Choreo or to the outside world.

Service components encapsulate business logic and provide standardized interfaces, called endpoints, for communicating with other components or systems. You can deploy and scale services independently, which makes them highly flexible and adaptable to changing workloads.

With the help of the service component, developers can quickly create APIs and microservices, making it easier to implement and manage complex software systems. Service components can also be integrated with other Choreo components, that acts as message processors, connectors, and data sources, etc to create powerful end-to-end solutions.

You can expose a service to other components through endpoints. For details on configuring endpoints, see [Configure Endpoints](../configure-endpoints.md).


# Build and Deploy a Single-Page Web Application

A web application is an application program hosted on a server and serves ingress traffic through a browser. In Choreo, you can deploy a web application by creating a Web Application component and connecting it to a Git repository that contains the implementation of the web application. Web applications can fall into one of the following categories:

- **Single page applications (SPAs)**: Examples include React, Angular, Vue, Svelte, etc.
- **Web servers**: These serve static content or provide server-side rendering/static site generation (SSR/SSG).
- **Static content**: Examples include websites and other static resources that do not require a backend, usually comprising static HTML/JS/CSS files.

## Prerequisites

- To deploy a web application component, you must have a GitHub account with a repository containing the web application's implementation. For this guide, fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample web application implementation.

## Create a web application

You can create a web application in Choreo as follows:

### Build and deploy a SPA from source code

1. To create a web application component, connect a repository that includes the web application source code.
2. Select the relevant buildpack: Default buildpacks include **React**, **Angular**, and **Vue.js**. If you are using a different SPA framework, you can try one of these buildpacks because the configurations can be overridden to support most JavaScript-based SPAs.
3. Enter the build command: Based on your package manager (NPM, yarn, or pnpm). The relevant package manager is run based on the dependency lock file in your repository (defaults to NPM if no lock file is present).
4. Specify the build output directory.
5. Specify the NodeJS version: Choreo does not pick the Node.js version from the `package.json` engine property. The required Node version must be explicitly set in the build configuration.

Once you create the Web Application component, Choreo automatically generates a build pipeline for your single-page application and deploys it.

### Bring your Dockerfile

1. To create a web application component, connect a repository that contains the Dockerfile for your containerized web application.
2. Commit a Dockerfile to your connected Git repository to have full control over your build process.

This approach is recommended if you are deploying a web server and not just a single-page application (or a single-page application with a complex build process).

### Host static websites

1. Create a web application component and connect it to the GitHub repository that contains the required static assets.
2. Select the **Static Websites** buildpack: This buildpack does not trigger a build process. It only fetches the files from the path specified in the repository and serves them as-is.

## Build and deploy a SPA from source code

Follow the steps below to create a sample Web Application component and deploy it in Choreo:

1. Sign in to the Choreo Console at [https://console.choreo.dev/login/](https://console.choreo.dev/login/). This opens the **Project Home** page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Web Application** card.
6. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

7. Enter the following information:

    | **Field**                 | **Description**        |
    |---------------------------|------------------------|
    | **GitHub Account**        | Your account           |
    | **GitHub Repository**     | choreo-samples         |
    | **Branch**                | main                   |
    | **Component Directory**     | /react-single-page-app |

8. Select **React** as the **Buildpack**.
9. Enter the following information:

    | **Field**                 | **Description**        |
    |---------------------------|------------------------|
    | **Build Command**         | `npm run build`        |
    | **Build Path**            | `build`                |
    | **Node Version**          | `18`                   |

    !!! tip
        Managed authentication is enabled by default when you create a web application using **React**, **Angular**, or **Vue.js** buildpacks. To learn how to set up authentication for your web application with Choreo's managed authentication, see [Secure Web Applications with Managed Authentication](../../authentication-and-authorization/secure-web-applications-with-managed-authentication.md).

4. Specify a display name, a unique name and description for the component.
10. Click **Create**. Choreo initializes the component with the sample implementation and opens the **Overview** page of the component.

You have successfully created a Web Application component from the source code. Now let's build and deploy the web application.

## Build your web application

1. In the left navigation menu, click **Build**.
2. In the **Builds** pane, click **Build**. This opens the **Commits** pane, where you can see all the commits related to the component.
3. Select the latest commit and click **Build**. This triggers the build process and displays the progress in the **Build Logs** pane.

    You can access the following scans in the **Build Logs** pane:

    - **Dockerfile Scan**: Choreo checks if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
    - **Container (Trivy) Vulnerability Scan**: Detects vulnerabilities in the final Docker image. If critical vulnerabilities are detected, the build will fail.

    !!! info
        If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

    !!! note
        The build process may take some time. Once complete, the build status will be listed in the **Builds** pane. Here, you will see the build status as **Success**.

## Deploy and access your web application

1. In the left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure and Deploy**. This opens the **Configure & Deploy** pane. In this guide, you do not need to add a file mount.
3. Click **Next** to proceed to the **Authentication Settings** pane.
4. Keep the default settings and click **Deploy**.

    !!! note
        The deployment process may take a few minutes. Once complete, the **Deployment Status** will show as **Active** in the **Development** card.

5. To verify that the web application is hosted successfully, click the **Web App URL** in the **Development** card. This takes you to the web application.

## Create a short URL for your web application in production

!!! info
    This feature is only available on the Choreo cloud data plane.

When you promote your component to the Production environment, you can create a personalized short URL for your web application. The URL follows the `https://{your-short-prefix}.choreoapps.dev` structure, where you can select a name of your preference for `{your-short-prefix}`.

1. Click **Promote** in the **Development** card and promote your web application to production.
2. In the **Production** card, click **Create a short URL**.
3. Specify a **Short URL prefix** of your choice and click **Save**.

    !!! note
        Short URL names/prefixes are subject to availability, provided on a first-come-first-serve basis.

## Manage runtime configurations for web applications

For web applications with a backend server, Choreo allows you to mount runtime configurations and secrets as environment variables and/or file mounts for a specific environment. Alternatively, you can also inject them into the client application during server-side rendering or when serving static content.

For SPAs that run completely on the browser, Choreo does not support *baking-in* environment variables or other configurations. Instead, Choreo recommends the following approach (applicable to most SPA frameworks, including React):

!!! note
    - With SPAs, anything you mount as a runtime config will be available to your users in the browser.
    - **Do not include sensitive secrets that are not browser-safe**.

1. Go to your forked [Choreo samples repository](https://github.com/wso2/choreo-samples).
2. Open the `public` directory.
3. Create and commit a new file named `config.js` in the `public` directory of your React application. This file should contain the runtime configuration variables you want to expose to your application, such as API endpoints or feature flags. For example:

    ```javascript
    window.config = {
        apiUrl: 'https://api.example.com',
        featureFlags: {
            enableNewFeature: true,
            enableExperimentalFeature: false,
        },
    };
    ```

4. In your `index.html` file inside the `public` directory, add a script tag to include the `config.js` file inside the `<body>` tag:

    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>My React App</title>
    </head>
    <body>
        <div id="root"></div>
        <script src="%PUBLIC_URL%/config.js"></script>
    </body>
    </html>
    ```

5. In your React component, access the configuration variables by referencing the `window.config` object:

    ```javascript
    import React from 'react';

    function MyComponent() {
        const apiUrl = window.config.apiUrl;
        const enableNewFeature = window.config.featureFlags.enableNewFeature;
        const enableExperimentalFeature = window.config.featureFlags.enableExperimentalFeature;

        // ...
    }
    ```

6. When you deploy your component to Choreo, create a config file mount in the specified path for each environment (where your `index.html` expects the `config.js` file). For more details, see [Manage Configurations and Secrets](https://wso2.com/choreo/docs/devops-and-ci-cd/manage-configurations-and-secrets/#apply-a-file-mount-to-your-container).

## Limitations

The following limitations are specific to the Choreo cloud data plane:

- **Request size limit**: 256KB (including headers, cookies, and payloads).
- **Response body size limit**: 20MB.
- **Open ports**: Only one open port is permitted per web application. While you can have multiple ports open for project-level communication within a data plane, incoming traffic from the internet can only be directed to one port. This differs from Service-type components, which support multiple endpoints.

## Troubleshoot a web application

- **Blank page or 502 error after deployment**:
    If you encounter a blank page or a 502 error after deploying your web application, it typically indicates that the wrong directory is being served. To resolve this issue:
    1. Double-check the build output directory, especially if you are using a Dockerfile-less buildpack.
    2. Ensure that the specified output directory matches the actual output directory generated during the build process. For example, if you have erroneously entered `public/` as the output directory when it should have been `build/`.

By verifying and correcting the output directory alignment, you should be able to address the issue of encountering a blank page or experiencing a 502 error on deploying your web application.


# Develop Web Applications Locally with Choreo’s Managed Authentication

Choreo’s managed authentication capability provides a set of backend for frontend (BFF) endpoints to facilitate authentication and authorization for web applications. These endpoints are readily available for single-page web applications deployed on Choreo.

As a web application developer, you may need to run the application on your local workstation. Choreo’s local development capability ensures that authentication and authorization during local development work the same way as they do when the application is deployed to Choreo, eliminating the need for code changes.

This guide explains how to configure and use Choreo’s local development capability to streamline your workflow.

## How local development works in Choreo

Local development uses a proxy that sits in front of the locally running web application. This proxy intercepts all incoming requests:
- Requests to `/choreo-apis/*` and `/auth/*` are forwarded to Choreo.
- All other requests are forwarded to the locally running web application.

The proxy runs on HTTPS using a self-signed certificate, which is essential for secure, HTTP-only cookie-based managed authentication. Once the proxy is running, you can access the web application using the proxy's URL and start developing locally. The behavior of the web application, in terms of managed authentication, will mirror its behavior when deployed to Choreo.

## Configure local development

### Prerequisites

- Create a single-page application (SPA) with managed authentication enabled. For details, see [Secure Web Applications with Managed Authentication](../../authentication-and-authorization/secure-web-applications-with-managed-authentication.md#step-1-set-up-managed-authentication-for-your-web-application).
- Promote and deploy the application to the environment where you want to enable local development.

    !!! note
        - The locally running web application will use the same managed authentication configuration as the environment where local development is configured.
        - Local development is only allowed in non-critical environments.

### Apply configurations

1. Sign in to the Choreo Console.
2. In the **Component Listing** pane, click on the component you created and deployed.
3. In the left navigation menu, click **Deploy**.
4. Go to the respective environment card and click **Local Development**.
5. In the **Local Development** pane, toggle **Local Development** to enable it.
6. (Optional) To update the port on which the local development proxy server runs, expand **Advanced Configurations** and specify a value for **Proxy Port**.
7. Click **Apply**.

You have now configured local development. The next section explains how to access your web application for local development.

## Access your web application locally

### Prerequisites

- Ensure local development is enabled in the desired environment.
- Ensure your web application is running locally on `http://localhost` on a specific port.

### Access your web application locally

You can use either the Choreo built-in identity provider or an external identity provider to access your web application locally.

=== "Use the Choreo built-in identity provider"

    1. Sign in to the Choreo Console.
    2. In the **Component Listing** pane, click on the component you created and deployed.
    3. In the left navigation menu, click **Deploy**.
    4. Go to the respective environment card and click **Local Development**.
    5. In the **Local Development** pane, copy the command under **Step 1**.
    6. Paste the command in a terminal, replace `[APP_PORT]` with the port on which your application is running locally, and run the command.
    7. To access the application, go to the URL provided under **Step 2** in the **Local Development** pane.

        !!! note
            The local development proxy runs on HTTPS using a self-signed certificate. Your browser may warn that the certificate is not valid. Accept the risk and proceed.

=== "Use an external identity provider"

    1. Sign in to the Choreo Console.
    2. In the **Component Listing** pane, click on the component you created and deployed.
    3. In the left navigation menu, click **Deploy**.
    4. Go to the respective environment card and click **Local Development**.
    5. In the **Local Development** pane, copy the redirect URLs under **Step 1**.
    6. Go to the settings in the OAuth application in your identity provider and specify the copied URLs as allowed redirect URLs.
    7. In the **Local Development** pane, copy the command under **Step 2**.
    8. Paste the command in a terminal, replace `[APP_PORT]` with the port on which your application is running locally, and run the command.
    9. To access the application, go to the URL provided under **Step 3** in the **Local Development** pane.

        !!! note
            The local development proxy runs on HTTPS using a self-signed certificate. Your browser may warn that the certificate is not valid. Accept the risk and proceed.


# Create a Connection

Connections in Choreo provide a simple and uniform approach to seamlessly integrate components with services or resources.

Choreo allows you to create connections to services deployed in Choreo or registered as external services. It also allows you to create connections to any Choreo-managed database.

To create a connection to a service or a database, follow the step-by-step instructions in the respective tab:

=== "Create a connection to a service"

    <h2>Create a connection to a Choreo service</h2>

    Follow these steps to create a connection to a service deployed in Choreo:

    1. In the Choreo Console, go to the top navigation menu and set the visibility level as [project](../../choreo-concepts/connections.md#project-connections) or [component](../../choreo-concepts/connections.md#component-connections) as follows: 

        - **Project Connection**: Select an organization and a project in that organization. 
        - **Component Connection**: Select an organization, a project in that organization, and a component in the selected project. 

    2. In the left navigation menu, click **Dependencies**  and then **Connections**. This page lists all the existing connections.
    3. Click **+Create**. This opens the Marketplace view where you can browse and search for services or databases.
    4. Click the **Services** tab. You can search and apply filters to efficiently find a service.
    5. Click on the service you want to connect to. 
    6. Enter a name and a description for the connection.
    7. Select an **Access Mode** and **Authentication Scheme** for the connection.
    8. Click **Create**.
   
    This creates the connection and displays its details for each environment, along with an inline guide on how to use the connection in your component. 

    !!! note
        During connection creation, secret values for the lowest environment are visible, allowing you to copy them for local use if necessary. Secret values for higher environments remain hidden to ensure security
     
    <h2>Create a connection to an external service</h2>

    Follow these steps to create a connection to an external service:

    1. Follow steps 1–5 from the previous section.
    2. Expand the **Environment to Endpoint** section and verify the service endpoints assigned to the Choreo environments.
    3. Click **Create**.

      For step-by-step instructions on using a connection in your service, see [Use a Connection in Your Service](./use-a-connection-in-your-service.md).

      For step-by-step instructions on using a connection in your web application, see [Use a Connection in Your Web Application](./use-a-connection-in-your-web-application.md).


=== "Create a connection to a database"

    Prerequisites:

     - Create a Choreo-managed database. For details, see [Choreo-Managed Databases and Caches](../../manage-databases-and-caches/choreo-managed-databases-and-caches.md).
     - Add the database to the Marketplace. For details, see [Add Choreo-Managed Databases and Caches to the Marketplace](../../manage-databases-and-caches/add-choreo-managed-databases-and-caches-to-the-marketplace.md).

    Follow these steps to create a connection to a Choreo-managed database:

    1. In the Choreo Console, go to the top navigation menu and set the visibility level as [project](../../choreo-concepts/connections.md#project-connections) or [component](../../choreo-concepts/connections.md#component-connections) as follows: 

        - **Project Connection**: Select an organization and a project in that organization. 
        - **Component Connection**: Select an organization, a project in that organization, and a component in the selected project. 

    2. In the left navigation menu, click **Dependencies**  and then **Connections**. This page lists all the existing connections.
    3. Click **+Create**. This opens the Marketplace view where you can browse and search for services or databases.
    4. Click the **Databases** tab. You can search and apply filters to efficiently find a database.
    5. Click on the database you want to connect to. 
    6. To create the connection, follow these steps:

        1. Enter a name and description.
        2. Under **Environment Configuration**, select credentials for each environment.

            !!! note
                 By default, the selected database is applied to all environments. To use different databases for specific environments, select the appropriate database and provide the corresponding credentials for each environment.

        3. Click **Create**.  
    
    This creates the connection and displays the database connection details for each environment, along with an inline guide on how to use the connection in your component. 

    !!! note
        During connection creation, secret values for the lowest environment are visible, allowing you to copy them for local use if necessary. Secret values for higher environments remain hidden to ensure security
    
    For step-by-step instructions on using a database in your component, see [Use a Database Connection in Your Component](./use-a-database-connection-in-your-component.md).


# Use a Connection in Your Service

Choreo allows you to share and reuse your services, accelerating development and enhancing efficiency in building integrated applications through connections.

For step-by-step on instruction on creating a connection, see [Create a Connection](create-a-connection.md).

To learn more about Choreo Connections, see the documentation on [Connections](../../choreo-concepts/connections.md).

## Consume a service through a connection

You can consume a Choreo-deployed service within another service. Consuming connections from within Choreo services is seamless and straightforward. Follow the steps below to consume a Choreo service:

### Step 1: Add connection configurations

To integrate another service into your application, click the appropriate tab below based on your current configuration file and follow the step-by-step instructions:

=== "Component.yaml file (v1.1)"

    1. Copy and paste the snippet from the in-line developer guide into the `component.yaml` file.

        The following is a sample snippet: 

        ``` yaml

        dependencies:
            connectionReferences:
            - name: <CONNECTION_NAME>
              resourceRef: <RESOURCE_IDENTIFIER>

        ```

          | Field            | Description                                                         |
          |------------------|---------------------------------------------------------------------|
          | name             | The name given to the connection.                                   |
          | resourceRef      | A unique, readable identifier of the service being connected to.    |


    2. If you've previously added a `connectionReferences` section under `dependencies`, append this as another item under `connectionReferences`. Upon deploying the component, Choreo automatically creates a subscription if applicable and the necessary configurations to establish the connection will be injected into the Choreo-defined environment variables.
      
          The following table details the Choreo-defined environment variables:

          | Configuration Key       | Choreo-Defined Environment Variable Name                       |
          |-------------------------|----------------------------------------------------------------|
          | ServiceURL              | CHOREO_<CONNECTION_NAME\>_SERVICEURL                           |
          | ConsumerKey             | CHOREO_<CONNECTION_NAME\>_CONSUMERKEY                          |
          | ConsumerSecret          | CHOREO_<CONNECTION_NAME\>_CONSUMERSECRET                       |
          | TokenURL                | CHOREO_<CONNECTION_NAME\>_TOKENURL                             |
          | ChoreoAPIKey            | CHOREO_<CONNECTION_NAME\>CHOREOAPIKEY                          |


          If you want to use custom environment variable names instead of the Choreo-defined ones, you must define the environment configurations under the `configuration` section in the same file.
          The following is a sample snippet: 

          ``` yaml
          configuration:
            env:
              - name: HR_SERVICE_URL
                valueFrom:
                  connectionRef:
                    name: hr-connection
                    key: ServiceURL
          ```

          The following table provides details on the configuration keys associated with the connection. These keys can be referenced as `env[i].valueFrom.connectionRef.key`.

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | ServiceURL     | string     | Service URL of the Choreo service     | false         | false        |
          | ConsumerKey    | string     | Consumer key of the Choreo service    | false         | false        |
          | ConsumerSecret | string     | Consumer secret of the Choreo service | false         | true         |
          | TokenURL       | string     | Token URL of the STS                  | false         | false        |
          | ChoreoAPIKey   | string     | API key of the Choreo service         | false         | true         |

          For more details, see the instructions under the **component.yaml file (v1.1)** tab.

    ### Step 2: Read configurations within the application

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const serviceURL = process.env.CHOREO_<CONNECTION_NAME>_SERVICEURL;
    ```

=== "Component.yaml file (v1.0)"

    !!! note
        This `component.yaml v1.0` is a legacy configuration format. For new projects, we recommend using the latest version (v1.1) of `component.yaml` for improved usability and features.
  
    1. Copy and paste the snippet from the in-line developer guide into the `component.yaml` file.
      
        The following is a sample snippet:

        ``` yaml

        dependencies:
            serviceReferences:
            - name: <SERVICE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: ServiceURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerSecret
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: TokenURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ChoreoAPIKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>

        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the service you are connecting to.              |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added a service reference section under `dependencies`, append this as another item under `serviceReferences`. 

          Upon deploying the component, Choreo automatically creates a subscription if applicable and populates the specified environment variables with actual values.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | ServiceURL     | string     | Service URL of the Choreo service     | false         | false        |
          | ConsumerKey    | string     | Consumer key of the Choreo service    | false         | false        |
          | ConsumerSecret | string     | Consumer secret of the Choreo service | false         | true         |
          | TokenURL       | string     | Token URL of the STS                  | false         | false        |
          | ChoreoAPIKey   | string     | API key of the Choreo service         | false         | true         |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const serviceURL = process.env.SVC_URL;
    ```

=== "Component-config.yaml file"

    !!! note
        This `component-config.yaml` is a legacy configuration format. For new projects, we recommend using the latest version (v1.1) of `component.yaml` for improved usability and features.

    1. Copy and paste the snippet from the in-line developer guide into the `component-config` file under the `spec` section.

        The following is a sample snippet:

        ``` yaml

        outbound:
            serviceReferences:
            - name: <SERVICE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: ServiceURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerSecret
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: TokenURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ChoreoAPIKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>

        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the service you are connecting to.              |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added an outbound service reference, append this as another item under `serviceReferences`. 

          Upon deploying the component, Choreo automatically creates a subscription if applicable and populates the specified environment variables with actual values.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | ServiceURL     | string     | Service URL of the Choreo service     | false         | false        |
          | ConsumerKey    | string     | Consumer key of the Choreo service    | false         | false        |
          | ConsumerSecret | string     | Consumer secret of the Choreo service | false         | true         |
          | TokenURL       | string     | Token URL of the STS                  | false         | false        |
          | ChoreoAPIKey   | string     | API key of the Choreo service         | false         | true         |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const serviceURL = process.env.SVC_URL;
    ```

If you're using the API key security scheme for the connection, skip Step 3 and follow the instructions in [Step 4: API key security scheme](#step-4-invoke-the-service) tab.

### Step 3: Acquire an OAuth 2.0 access token

To consume a Choreo service with the visibility level set to organization or public and secured by the OAuth 2.0 security scheme, you must obtain an OAuth 2.0 token from the token endpoint. Subsequently, you can use the token to invoke the service.

- For languages with OAuth 2.0-aware HTTP clients, you must pass the OAuth 2.0-related configurations such as client id, client secret and so on, obtained when creating the connection to your HTTP client configuration. The HTTP client autonomously manages token retrieval and refreshing.

- For languages without OAuth 2.0-aware HTTP clients, you must manually initiate a call to the token endpoint. This includes fetching the token and managing token expiration and refresh directly within your application code. The following is a sample curl command to obtain a token:


    ```bash
    CONSUMER_KEY="your_consumer_key"
    CONSUMER_SECRET="your_consumer_secret"
    TOKEN_URL="your_token_url"

    # Encode client credentials as Base64
    CLIENT_CREDENTIALS=$(echo -n "$CLIENT_ID:$CLIENT_SECRET" | base64)

    curl -X POST $TOKEN_URL \
      -H "Content-Type: application/x-www-form-urlencoded" \
      -H "Authorization: Basic $CLIENT_CREDENTIALS" \
      --data-urlencode "grant_type=client_credentials"

    ```

### Step 4: Invoke the service

Click the tab that matches the security scheme of your service and follow the instructions below:

=== "API key security scheme"

     To invoke the API, use the `choreo-api-key` header with the API key value retrieved from the corresponding environment variable as described in [step 2](#step-2-read-configurations-within-the-application).

     The following is a sample code snippet in NodeJS:

     ``` java
       const response = await axios.get(serviceURL/{RESOURCE_PATH}, {
           headers: {
             'Choreo-API-Key': `${choreoApiKey}`
           }
       });
     ```

=== "OAuth 2.0 security scheme"

     To invoke the service, use the following instructions based on your programming language:

      - For languages with OAuth 2.0-aware HTTP clients, use the service URL resolved in [Step 2](#step-2-read-configurations-within-the-application). The OAuth-aware client manages authentication automatically. For sample requests and responses, see the API definition provided via the Choreo marketplace for the service.

      - For languages without OAuth 2.0-aware HTTP clients, use the token obtained in [step 3](#step-3-acquire-an-oauth-20-access-token) to make calls to the dependent service. Subsequently, add the obtained token to the HTTP authorization header with the bearer prefix. As the service URL, use the URL resolved in [step 2](#step-2-read-configurations-within-the-application). For sample requests and responses, see the API definition of the service provided via the Choreo marketplace.

       The following is a sample code snippet in NodeJS:

       ``` java
       const response = await axios.get(serviceURL/{RESOURCE_PATH}, {
           headers: {
             'Authorization': `Bearer ${accessToken}`
             'Choreo-API-Key': `${choreoApiKey}`
           }
       });
       ```

    !!! note
        If you want to consume a Choreo service at the project visibility level, you don't need to obtain a token. You can directly invoke the service using the resolved URL.


# Use a Connection in Your Web Application

Choreo simplifies the process of integrating services into your web application. The approach to connect to a service can vary based on your web application. 

To connect to a selected service, follow the step-by-step instructions given below depending on the authentication mechanism used in your web application.

=== "Managed authentication"
    
    Choreo-managed authentication allows you to seamlessly handle authentication for your web application. You can configure your web application to work with the built-in identity provider of Choreo or any external identity provider that supports OIDC/OAuth2.0

    !!! note 
         Choreo's managed authentication is currently available only for web applications created with **React**, **Angular**, or **Vue.js** buildpacks.

    Follow the steps below to use an existing connection within your web application: 

    <h2> Step 1: Add the connection configuration</h2>

    To integrate a service into your application, you must first add the connection configuration as follows: 

    1. For single page applications (SPAs), you must add the connection configuration as a file mount. You can mount a file via the **Configurations** pane on the **Deploy** page. You must mount a file (for example, `config.js`) and add the configuration provided in the inline developer documentation into it. 

        The following is a sample configuration:

        ``` yaml
             window.configs = {
                 apiUrl: '<SERVICE_URL>',        
             };

        ```

    2.  To ensure accessibility of the `config.js` file via JavaScript at runtime, add a script tag as follows in the `index.html` file to reference the `config.js` file:

        ``` html
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="utf-8" />
            <title>My React App</title>
        </head>
        <body>
            <div id="root"></div>
            <script src="/public/config.js"></script>
        </body>
        </html>
        ``` 

        !!! note
             If you use an external IdP, you must add the IdP's configuration to the same file.
    
             For more information on working with IdPs, see [Configure Asgardeo as an External Identity Provider](https://wso2.com/choreo/docs/administer/configure-an-external-idp/configure-asgardeo-as-an-external-idp/).


    <h2> Step 2: Read the configuration</h2>

    Once you add the connection configuration, you can proceed to read the configuration from your application. The steps to read depend on the programming language you use.

    The following is a sample code snippet in NodeJS:

    ``` java
         const serviceURL = window?.configs?.apiUrl ? window.configs.apiUrl : "/";
    ```

    <h2> Step 3: Invoke the service</h2>

    If you use Choreo-managed authentication, Choreo handles the security handshaking for the application during deployment. The connected service will be accessible under the same domain as your application. Therefore, you can call the configured path directly using your preferred HTTP client.

    The following is a sample code snippet in NodeJS:

    ``` java
         const response = await axios.get(serviceURL/{RESOURCE_PATH});
    ```

    !!! note
         If you are using an external IdP provider instead of Choreo-managed authentication, you must obtain an access token from your IdP and add it to the HTTP authorization header with the bearer prefix.


=== "Custom authentication or no authentication"

    If you are not using Choreo-managed authentication or your web application lacks authentication, follow the steps below to connect to a service from your web application:

    <h2> Step 1: Add the connection configuration</h2>

    1. For single-page applications (SPAs), you must add the connection configuration as a file mount. You can mount a file via the **Configurations** pane on the **Deploy** page. You must mount a file (for example, `config.js`) and add the configuration provided in the inline developer documentation into it.
 
        The following is a sample configuration:

        ``` yaml
             window.configs = {
                 apiUrl: '<SERVICE_URL>',
                 consumerKey: '<CONSUMER_KEY>',
                 consumerSecret: '<CONSUMER_SECRET>',
                 tokenUrl: '<TOKEN_URL>',
             };
        ```

    2.  To ensure accessibility of the `config.js` file via JavaScript at runtime, add a script tag as follows in the `index.html` file to reference the `config.js` file:

        ``` html
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="utf-8" />
            <title>My React App</title>
        </head>
        <body>
            <div id="root"></div>
            <script src="/public/config.js"></script>
        </body>
        </html>
        ``` 

    For other types of web applications, you must add the respective configuration into your application.

    <h2> Step 2: Read the configuration</h2>

    Once you have added the connection configuration, you can proceed to read the configuration from your application. The steps to read depend on the programming language you use.

    The following is a sample code snippet in NodeJS:

    ``` java
         const serviceURL = window?.configs?.apiUrl ? window.configs.apiUrl : "/";
    ```

    <h2> Step 3: Acquire an OAuth 2.0 access token</h2>

    - For languages with OAuth 2.0-aware HTTP clients, you must pass the OAuth 2.0-related configurations such as client id, client secret and so on, obtained when creating the connection to your HTTP client configuration. The HTTP client autonomously manages token retrieval and refreshing.
  
    - For languages without OAuth 2.0-aware HTTP clients, you must manually initiate a call to the token endpoint. This includes fetching the token and managing token expiration and refresh directly within your application code. The following is a sample curl command to obtain a token:


        ```bash
        CONSUMER_KEY="your_consumer_key"
        CONSUMER_SECRET="your_consumer_secret"
        TOKEN_URL="your_token_url"

        # Encode client credentials as Base64
        CLIENT_CREDENTIALS=$(echo -n "$CLIENT_ID:$CLIENT_SECRET" | base64)

        curl -X POST $TOKEN_URL \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -H "Authorization: Basic $CLIENT_CREDENTIALS" \
        --data-urlencode "grant_type=client_credentials"

        ```

    <h2> Step 4: Invoke the service</h2>

    You can invoke the service as follows:

    - For languages with OAuth 2.0-aware HTTP clients, you can invoke the service in a straightforward manner. The HTTP client seamlessly manages OAuth 2.0 authentication without requiring additional intervention.

        As the service URL you can use the URL that you resolved in step 2 above. For sample requests and responses, see the API definition provided via the Choreo marketplace for the service.

    - For languages without OAuth 2.0-aware HTTP clients, you can use the token obtained in step 3 above to make calls to the dependent service. Subsequently, add the obtained token to the HTTP authorization header with the bearer prefix.

        As the service URL you can use the URL that you resolved in step 2 above. For sample requests and responses, see the API definition of the service provided via the Choreo marketplace.

        The following is a sample code snippet in NodeJS:

        ```java 
            const response = await axios.get(serviceURL/{RESOURCE_PATH}, {
                headers: {
                'Authorization': `Bearer ${accessToken}`
                }
            })
        ```


# Use a Database Connection in Your Component

Choreo allows you to share and reuse Choreo-managed databases, accelerating development and enhancing efficiency in building integrated applications through connections.

For step-by-step instructions on creating a database connection, see [Create a Connection](create-a-connection.md).

To learn more about Choreo Connections, see the documentation on [Connections](../../choreo-concepts/connections.md).

## Consume a database through a connection

To consume a Choreo-managed database via a connection, follow these steps:

### Step 1: Add connection configurations

To integrate a database into your application, click the appropriate tab below based on your current configuration file and follow the step-by-step instructions:

=== "Component.yaml file (v1.1)"

    1. Copy and paste the snippet from the  developer guide into the `component.yaml` file.

        The following is a sample snippet:

        ``` yaml

        dependencies:
            connectionReferences:
            - name: <CONNECTION_NAME>
              resourceRef: <RESOURCE_IDENTIFIER>

        ```

          | Field            | Description                                                         |
          |------------------|---------------------------------------------------------------------|
          | name             | The name given to the connection.                                   |
          | resourceRef      | A unique, readable identifier of the database being connected to.    |


    2. If you've previously added a `connectionReferences` section under `dependencies`, append this as another item under `connectionReferences`. Upon deploying the component, the necessary configurations to establish the connection will be injected into Choreo-defined environment variables.

          The following table details the Choreo-defined environment variables:

          | Configuration Key       | Choreo-Defined Environment Variable Name                       |
          |-------------------------|----------------------------------------------------------------|
          | HostName                | CHOREO_<CONNECTION_NAME\>_HOSTNAME                             |
          | Port                    | CHOREO_<CONNECTION_NAME\>_PORT                                 |
          | Username                | CHOREO_<CONNECTION_NAME\>_USERNAME                             |
          | Password                | CHOREO_<CONNECTION_NAME\>_PASSWORD                             |
          | DatabaseName            | CHOREO_<CONNECTION_NAME\>DATABASENAME                          |


          If you'd like to use custom environment variable names instead of the Choreo-defined ones, add the dependency as a service reference under `dependencies` in the same file. For more details, refer to the instructions under the `component.yaml file (v1.0)` tab.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | HostName       | string     | Hostname of the database server       | false         | false        |
          | Port           | string     | Port of the database server           | false         | false        |
          | Username | string           | Username of the database server       | false         | false        |
          | Password       | string     | Password of the database server       | false         | true         |
          | DatabaseName   | string     | Name of the database                  | false         | false        |
    ### Step 2: Read configurations within the application

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const hostName = process.env.CHOREO_<CONNECTION_NAME>_HOSTNAME;
    ```

=== "Component.yaml file (v1.0)"

    !!! note
        The `component.yaml v1.0` file is considered legacy. For new components, we recommend using the latest version, `component.yaml v1.1`, which offers enhanced usability and features.

    1. Copy and paste the snippet from the  developer guide into the `component.yaml` file.

        The following is a sample snippet:

        ``` yaml

        dependencies:
            serviceReferences:
            - name: database:<DATABASE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: HostName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Port
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Username
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Password
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: DatabaseName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>


        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the database you are connecting to.             |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added a service reference section under `dependencies`, append this as another item under `serviceReferences`.

          Upon deploying the component, Choreo automatically populates the specified environment variables with actual values.

          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | HostName       | string     | Hostname of the database server       | false         | false        |
          | Port           | string     | Port of the database server           | false         | false        |
          | Username | string           | Username of the database server       | false         | false        |
          | Password       | string     | Password of the database server       | false         | true         |
          | DatabaseName   | string     | Name of the database                  | false         | false        |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const hostName = process.env.HOSTNAME;
    ```

=== "Component-config.yaml file"

    !!! note
        The `component-config.yaml` file is considered legacy. For new components, we recommend using the latest version, `component.yaml v1.1`, which offers enhanced usability and features.

    1. Copy and paste the snippet from the  developer guide into the `component-config` file under the `spec` section.

        The following is a sample snippet:

        ``` yaml

        outbound:
            serviceReferences:
            - name: database:<DATABASE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: HostName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Port
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Username
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Password
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: DatabaseName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>

        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the database you are connecting to.              |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added an outbound service reference, append this as another item under `serviceReferences`.

          Upon deploying the component, Choreo automatically populates the specified environment variables with actual values.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | HostName       | string     | Hostname of the database server       | false         | false        |
          | Port           | string     | Port of the database server           | false         | false        |
          | Username | string           | Username of the database server       | false         | false        |
          | Password       | string     | Password of the database server       | false         | true         |
          | DatabaseName   | string     | Name of the database                  | false         | false        |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const hostName = process.env.HOSTNAME;
    ```

### Step 3: Initiate a database connection

To initiate a connection to the database, follow these steps:

In this example, you will connect to a MySQL database.

#### Step 3.1: Install the required packages

For the MySQL database, install the `mysql2` package using npm:

```bash
// Install the mysql2 package
npm install mysql2

```

#### Step 3.2: Import required packages

```java

const client = require('mysql2')

```

#### Step 3.3: Establish a connection

To establish the connection, use the environment variables for `hostName`, `username`, `password`, `databaseName`, and `port` as follows:

```java

var connection = client.createConnection({
      host: hostName,
      user: username,
      password: password,
      database: databaseName,
      port: port
});

connection.connect((err) => {
      if (err) {
          return;
      }
      // Connection is successful
});

```

By following these steps, your component can interact with the Choreo-managed database seamlessly.




# Integrate Unit Tests into the Build Pipeline

Choreo allows you to integrate unit tests into the build pipeline, enabling code validation before deployment. This ensures early testing of code changes, reducing the risk of defects in production.

!!! note
        Currently, Choreo supports unit tests only for the `WSO2 MI` buildpack.

## How it works

### Step 1: Write tests

You can create unit tests in your source code using standard testing libraries. For step-by-step instructions on creating unit tests for WSO2 Micro Integrator projects, see [Creating a Unit Test Suite](https://mi.docs.wso2.com/en/latest/develop/creating-unit-test-suite/).

### Step 2: Enable unit tests

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click the component for which you want to enable unit tests.
3. In the left navigation menu, click **Build**.
4. On the **Build** page, click to edit **Build Configurations**.
5. Turn on the **Unit Test** toggle.
6. Click **Save**.

### Step 3: Trigger a new build

- On the **Build** page, click **Build Latest**.

This starts a new build with unit tests enabled. You can monitor its progress in the **Build Details** pane.

## View failed unit tests

If a unit test fails during the build, you can view its detailed logs for troubleshooting. Click **View Details** corresponding to the failed build, then expand the failed unit test step to view the logs.

## Explore a sample

To see unit tests in action within the build pipeline, try out the [WSO2 MI helloworld](https://github.com/wso2/choreo-samples/tree/main/hello-world-mi) sample. 


# Manage Component Source Configurations

In Choreo, you can configure service endpoints and connections via the `component.yaml` source configuration file. This file ensures that the configurations required to initialize endpoints and connections are defined, as they cannot be inferred from the source code. This guide provides an overview of how to configure and manage these settings effectively.

The source configuration file must be committed to your repository within the `.choreo` directory at the root of the project directory. This ensures the ability to version the configuration files alongside repository commits, enabling better tracking and management of configurations.

!!! note
    -  The `component-config.yaml` and `endpoints.yaml` files will eventually be deprecated and replaced by the `component.yaml` file. 
        - For details on how to seamlessly update to the latest `component.yaml` file`, see [Update to the latest source configuration file](#update-to-the-latest-source-configuration-file).
    - Choreo prioritizes configuration files in the following order: `component.yaml` takes the highest precedence, followed by `component-config.yaml`, and then `endpoints.yaml`.

## Overview of the `component.yaml` file 

**File location**:

```bash
<build-context-path>/.choreo/component.yaml
```

!!! note
    - For components built using **Buildpacks**, replace `build-context-path` with the `<project-directory>`. 
    For example, `<project-directory>/.choreo/component.yaml`.
    - For components built using **Docker**, replace `build-context-path` with the `<docker-context-path>`. 
    For example, `<docker-context-path>/.choreo/component.yaml`.

**Sample `component.yaml` file content**:

Click the respective tab to view the structure for your current configuration file version:

=== "Version 1.1"

    ``` yaml
    # +required The configuration file schema version
    schemaVersion: 1.1

    # +optional Incoming connection details for the component
    endpoints:
      # +required Unique name for the endpoint.
      # This name will be used when generating the managed API
      - name: greeter-sample
        # +optional Display name for the endpoint.
        displayName: Go Greeter Sample
        # +required Service section has the user service endpoint details
        service:
          # +optional Context (base path) of the API that gets exposed via the endpoint.
          basePath: /greeting-service
          # +required Numeric port value that gets exposed via the endpoint
          port: 9090
        # +required Type of traffic that the endpoint is accepting.
        # Allowed values: REST, GraphQL, WS, GRPC, TCP, UDP.
        type: REST
        # +optional Network level visibilities of the endpoint.
        # Accepted values: Project|Organization|Public(Default).
        networkVisibilities: 
          - Public
          - Organization
        # +optional Path to the schema definition file. Defaults to wild card route if not provided
        # This is only applicable to REST or WS endpoint types.
        # The path should be relative to the docker context.
        schemaFilePath: openapi.yaml
      
      # +optional Outgoing connection details for the component.
      dependencies:
        # +optional Defines the connection references from the Internal Marketplace.
        connectionReferences:
          # +required Name of the connection.
          - name: hr-connection
            # +required service identifer of the dependent component.
            resourceRef: service:/HRProject/UserComponent/v1/ad088/PUBLIC
      # +optional Defines runtime configurations
      configurations:
        # +optional List of environment variables to be injected into the component.
        env:
          # +required Name of the environment variable
          - name: HR_SERVICE_URL
            # +required value source
            # Allowed value sources: connectionRef
            valueFrom:
              # +required Choreo connection value source
              connectionRef:
                # +required Choreo connection name to refer the value from
                name: hr-connection
                # +required Choreo connection configuration key to refer the value from
                key: ServiceURL
    ```

    The descriptor-based approach of the `component.yaml` file simplifies and streamlines endpoint and connection configuration management. The use of versioned schemas ensures backward compatibility, providing a seamless transition with future updates.

    You can define the following root-level configurations via the `component.yaml` file:

    | Configuration        | Required     | Description                                                              |
    |----------------------|--------------|--------------------------------------------------------------------------|
    | **schemaVersion**    | Required     | The version of the `component.yaml` file. Defaults to the latest version.|
    | **endpoints**        | Optional     | The list of endpoint configurations.                                     |
    | **dependencies**     | Optional     | The list of dependency configurations.                                   |
    | **configurations**    | Optional     | The runtime configuration definitions.                                   |

    ### Endpoint configurations
    In the `endpoints` section of the `component.yaml` file, you can define multiple service endpoint configurations. Each endpoint must have a unique name and the required fields specified in the schema overview.

    !!! tip "Why have a unique name?"
          When you define multiple endpoints, the `endpoint.name` is appended to the Choreo-generated URL. A unique name ensures the endpoint is easily recognizable and readable within the URL.
          
    | Configuration        | Required     | Description                                                                                             |
    |----------------------|--------------|---------------------------------------------------------------------------------------------------------|
    | **name**             | Required     | A unique identifier for the endpoint within the service component. Avoid using excessively long names.  |
    | **displayName**      | Optional     | A display name for the endpoint.                                                                        |
    | **service**          | Required     | Service details for the endpoint.                                                                       |
    | **.basePath**        | Required     | The base path of the API exposed via this endpoint.                                                     |
    | **.port**            | Required     | The numeric port value exposed via this endpoint.                                                       |
    | **type**             | Required     | The type of traffic the endpoint accepts. For example, `REST`, `GraphQL`, `WS`, `gRPC`, `UDP`, or `TCP`.|
    | **networkVisibilities** | Required | The network-level visibility of the endpoint. For example, project, organization, or public.             |
    | **schemaFilePath** | Required | The file path to the swagger definition  or AsyncAPI 2.0 specification file. Defaults to the wildcard route if not specified. This field should be a relative path to the project path when using **Java**, **Python**, **NodeJS**, **Go**, **PHP**, **Ruby**, or **WSO2 MI** buildpacks. For REST or WebSocket endpoint types, when using the **Ballerina** or **Dockerfile** buildpack, the path should be relative to the component root or Docker context. |

    ### Dependency configurations

    In the `dependencies` section of the `component.yaml` file, you can define multiple connection configurations under `dependencies.connectionReferences`. You can use the connection reference generated in the inline developer guide when creating a connection. For instructions on copying [connection configurations](https://wso2.com/choreo/docs/develop-components/sharing-and-reusing/use-a-connection-in-your-service/), see the inline developer guide displayed during connection creation.

    You must include the following configurations in the `dependencies.connectionReferences` schema:

    | Configuration        | Required     | Description                                                                      |
    |----------------------|--------------|----------------------------------------------------------------------------------|
    | **name**             | Required     | The name given to the connection.                                                |
    | **resourceRef**      | Required     | A unique, human-readable identifier for the service you are connecting.          |


    !!! note
        Choreo automatically generates connection configurations when you create a connection. The properties such as **name** and **resourceRef** are automatically generated. The configurations required to establish the connection will be injected into Choreo-defined environment variables.

        To use custom environment variable names instead of Choreo's default ones, add the dependency as a `serviceReference` in your `component.yaml v1.1` file. You can copy the `serviceReference` section from the `component.yaml v1.0` tab and paste it under `dependencies` in your `component.yaml v1.1` file, which maintains backward compatibility with the v1.0 format.

    ### Runtime configurations
    In the `configurations` section of the `component.yaml` file, you can define runtime configurations for the component. These configurations currently support environment variable injection related to dependencies.
    
    | Configuration                 | Required     | Description                                                                       |
    |-------------------------------|--------------|-----------------------------------------------------------------------------------|
    | **env**                       | Optional     | An array of env variable configurations.                                          |
    | **name**                      | Required     | A unique name for the environment variable, starting with a letter or an underscore, and containing only letters, numbers, or underscores. |
    | **valueFrom**                 | Required     | The source of the environment variable value.                                     |
    | **connectionRef**             | Required     | Connection reference value source definition.                                     |
    | **name**                      | Required     | The name of the Choreo connection to reference the value from.                    |
    | **key**                       | Required     | The Choreo connection configuration key to reference the value from. For details on available keys, see [connection configurations](https://wso2.com/choreo/docs/develop-components/sharing-and-reusing/use-a-connection-in-your-service/) or the inline developer guide. |

    !!! note
        Runtime configurations are supported starting from `component.yaml v1.1`.

        When an environment variable value is specified using `connectionRef`, the connection's environment variable is renamed to the environment variable name defined in the `configurations` section. For example, in the sample `component.yaml` file given above, the `CHOREO_HR_CONNECTION_SERVICEURL` variable in the `hr-connection` is renamed to `HR_SERVICE_URL`.

=== "Version 1.0"

    ``` yaml
    # +required The configuration file schema version
    schemaVersion: 1.0

    # +optional Incoming connection details for the component
    endpoints:
      # +required Unique name for the endpoint.
      # This name will be used when generating the managed API
      - name: greeter-sample
        # +optional Display name for the endpoint.
        displayName: Go Greeter Sample
        # +required Service section has the user service endpoint details
        service:
          # +optional Context (base path) of the API that gets exposed via the endpoint.
          basePath: /greeting-service
          # +required Numeric port value that gets exposed via the endpoint
          port: 9090
        # +required Type of traffic that the endpoint is accepting.
        # Allowed values: REST, GraphQL, WS, GRPC, TCP, UDP.
        type: REST
        # +optional Network level visibilities of the endpoint.
        # Accepted values: Project|Organization|Public(Default).
        networkVisibilities: 
          - Public
          - Organization
        # +optional Path to the schema definition file. Defaults to wild card route if not provided
        # This is only applicable to REST or WS endpoint types.
        # The path should be relative to the docker context.
        schemaFilePath: openapi.yaml
      
    # +optional Outgoing connection details for the component.
    dependencies:
      # +optional Defines the service references from the Internal Marketplace.
      serviceReferences:
        # +required Name of the service reference.
        - name: choreo:///apifirst/HRProject/UserComponent/ad088/v1/PUBLIC
          # +required Name of the connection instance.
          connectionConfig: 19d2648b-d29c-4452-afdd-1b9311e81412
          # +required Environment variables injected into the component for connection configuration.
          env:
            # +required Key name of the connection configuration.
            - from: ServiceURL
              # +required Environment variable injected into the container.
              to: SERVICE_URL
    ```

    The descriptor-based approach of the `component.yaml` file simplifies and streamlines endpoint and connection configuration management. The use of versioned schemas ensures backward compatibility, providing a seamless transition with future updates.

    You can define the following root-level configurations via the `component.yaml` file:

    | Configuration        | Required     | Description                                                              |
    |----------------------|--------------|--------------------------------------------------------------------------|
    | **schemaVersion**    | Required     | The version of the `component.yaml` file. Defaults to the latest version.|
    | **endpoints**        | Optional     | The list of endpoint configurations.                                     |
    | **dependencies**     | Optional     | The list of dependency configurations.                                   |

    <h3> Endpoint configurations </h3>
    In the `endpoints` section of the `component.yaml` file, you can define multiple service endpoint configurations. Each endpoint must have a unique name and the required fields specified in the schema overview.

    !!! tip "Why have a unique name?"
          When you define multiple endpoints, the `endpoint.name` is appended to the Choreo-generated URL. A unique name ensures the endpoint is easily recognizable and readable within the URL.
          
    | Configuration           | Required     | Description                                                                                             |
    |-------------------------|--------------|---------------------------------------------------------------------------------------------------------|
    | **name**                | Required     | A unique identifier for the endpoint within the service component. Avoid using excessively long names.  |
    | **displayName**         | Optional     | A display name for the endpoint.                                                                        |
    | **service**             | Required     | Service details for the endpoint.                                                                       |
    | **.basePath**           | Required     | The base path of the API exposed via this endpoint.                                                     |
    | **.port**               | Required     | The numeric port value exposed via this endpoint.                                                       |
    | **type**                | Required     | The type of traffic the endpoint accepts. For example, `REST`, `GraphQL`, `gRPC`, `WS`, `UDP`, or `TCP`.|
    | **networkVisibilities** | Required     | The network-level visibility of the endpoint. For example, project, organization, or public.            |
    | **schemaFilePath**      | Required     | The file path to the swagger definition or AsyncAPI 2.0 specification file. Defaults to the wildcard route if not specified. This field should be a relative path to the project path when using **Java**, **Python**, **NodeJS**, **Go**, **PHP**, **Ruby**, or **WSO2 MI** buildpacks. For REST or WebSocket endpoint types, when using the **Ballerina** or **Dockerfile** buildpack, the path should be relative to the component root or Docker context. |

    <h3> Dependency configurations </h3>

    In the `dependencies` section of the `component.yaml` file, you can define multiple service connection configurations under `dependencies.serviceReferences`. You can use the service references generated in the inline developer guide when creating a service connection. For instructions on copying [connection configurations](https://wso2.com/choreo/docs/develop-components/sharing-and-reusing/use-a-connection-in-your-service/), see the inline developer guide displayed during connection creation.

    You must include the following configurations in the `dependencies.serviceReferences` schema:

    | Configuration        | Required     | Description                                                                      |
    |----------------------|--------------|----------------------------------------------------------------------------------|
    | **name**             | Required     | A unique name for the service reference.                                         |
    | **connectionConfig** | Required     | A unique name for the connection instance.                                       |
    | **env**              | Required     | The list of environment variable mappings to inject into the container.          |
    | **.from**            | Required     | The key name of the connection configuration.                                    |
    | **.to**              | Required     | The environment variable to inject into the container.                           |

    !!! note
        Choreo automatically generates connection configurations when you create a connection. The properties such as **name**, **connectionConfig**, and **env.from** are automatically generated. However, you must manually set the **env.to** value.

## Overview of the `component-config.yaml` file 

**File location**:

```bash
<build-context-path>/.choreo/component-config.yaml
```

**Sample `component-config.yaml` file content**:

```yaml
apiVersion: core.choreo.dev/v1beta1
kind: ComponentConfig
spec:
  # +optional Incoming connection details for the component (AKA endpoints).
  inbound:
    # +required Unique name for the endpoint.
    # This name will be used when generating the managed API
    - name: Greeting Service
      # +required Numeric port value that gets exposed via the endpoint
      port: 9090
      # +required Type of traffic that the endpoint is accepting.
      # Allowed values: REST, GraphQL, GRPC, TCP, UDP, WS.
      type: REST
      # +optional Network level visibility of the endpoint. Defaults to Public
      # Accepted values: Project|Organization|Public.
      networkVisibility: Public
      # +optional Context (base path) of the API that gets exposed via the endpoint.
      # This is mandatory if the endpoint type is set to REST, GraphQL or WS.
      context: /greeting
      # +optional The path to the schema definition file. Defaults to wildcard route if not specified.
      # This is only applicable to REST and WS endpoint types.
      # The path should be relative to the Docker context.
      schemaFilePath: greeting_openapi.yaml
  # +optional Outgoing connection details for the component.
  outbound:
    # +optional Defines the service references from the Internal Marketplace.
    serviceReferences:
      # +required Name of the service reference.
      - name: choreo:///apifirst/mttm/mmvhxd/ad088/v1.0/PUBLIC
        # +required Name of the connection instance.
        connectionConfig: 19d2648b-d29c-4452-afdd-1b9311e81412
        # +required Environment variables injected to the component for connection configuration.
        env:
          # +required Key name of the connection configuration.
          - from: ServiceURL
            # +required Environment variable injected to the container.
            to: SERVICE_URL
```

The `component-config.yaml` file complements and enhances the existing endpoint configuration process. It allows you to define how the endpoints (inbound connections) in your service are exposed and how your service connects to external services or components (outbound connections).

You can define the following root-level configurations via the `component-config.yaml` file:

| Configuration        | Required     | Description                                                                           |
|----------------------|--------------|---------------------------------------------------------------------------------------|
| **apiVersion**       | Required     | The version of the `component-config.yaml` file defaults to `core.choreo.dev/v1beta1`.|
| **kind**             | Required     | The resource type of the file defaults to `ComponentConfig`.                          |
| **spec.inbound**     | Optional     | The list of inbound connection configurations.                                        |
| **spec.outbound**    | Optional     | The list of outbound connection configurations.                                       |

#### Inbound connection configurations (`spec.inbound`)

In the `spec.inbound` configuration section, you can specify endpoints to set up inbound connections. To specify endpoints, you can follow the existing endpoints schema structure. For details on the endpoints schema structure, see the [endpoints schema documentation](#overview-of-the-endpointsyaml-file).

#### Outbound connection configurations (`spec.outbound`)

In the `spec.outbound` section, you can define `serviceReferences`. To define `serviceReferences`, you can use the service references generated in the Internal Marketplace when creating a service connection. To copy the [outbound connection configurations](../sharing-and-reusing/use-a-connection-in-your-service/#use-a-connection-in-your-service), see the inline developer guide displayed when you create a connection.

You must include the following configurations in the `serviceReferences` schema:

| Configuration        | Required     | Description                                                                      |
|----------------------|--------------|----------------------------------------------------------------------------------|
| **name**             | Required     | A unique name for the service reference.                                         |
| **connectionConfig** | Required     | A unique name for the connection instance.                                       |
| **env**              | Optional     | The list of environment variable mappings to inject into the container.          |
| **env.from**         | Required     | The key name of the connection configuration.                                    |
| **env.to**           | Required     | The environment variable to inject into the container.                           |

## Overview of the `endpoints.yaml` file

**File location**:

```bash
<build-context-path>/.choreo/endpoints.yaml
```

**Sample `endpoints.yaml` file content**:

```yaml
# +required Version of the endpoint configuration YAML
version: 0.1

# +required List of endpoints to create
endpoints:
  # +required Unique name for the endpoint.
  # This name will be used when generating the managed API
- name: Greeting Service
  # +required Numeric port value that gets exposed via this endpoint
  port: 9090
  # +required Type of the traffic this endpoint is accepting.
  # Allowed values: REST, GraphQL, GRPC, UDP, TCP, WS.
  type: REST
  # +optional Network level visibility of this endpoint. Defaults to Public
  # Accepted values: Project|Organization|Public.
  networkVisibility: Project
  # +optional Context (base path) of the API that is exposed via this endpoint.
  # This is mandatory if the endpoint type is set to REST, GraphQL or WS.
  context: /greeting
  # +optional Path to the schema definition file. Defaults to wild card route if not provided
  # This is only applicable to REST and WS endpoint types.
  # The path should be relative to the docker context.
  schemaFilePath: greeting_openapi.yaml
```

The `endpoints.yaml` configuration file allows you to define configurations for multiple endpoints necessary for Choreo service components. This schema is essential to identify the context, port binding, network exposure level, and other attributes required to generate a Choreo endpoint.

You can define the following root-level configurations via the `endpoints.yaml` file:

| Configuration        | Required     | Description                                                                       |
|----------------------|--------------|-----------------------------------------------------------------------------------|
| **version**          | Required     | The version of the `endpoints.yaml` file.                                         |
| **name**             | Required     | A unique name for the endpoint, which Choreo will use to generate the managed API.|
| **port**             | Required     | The numeric port value that gets exposed via this endpoint.                       |
| **type**             | Required     | The type of traffic this endpoint accepts, such as `REST`, `GraphQL`, `gRPC`, `WS`, `UDP`, or `TCP`. Currently, the MI preset supports only the `REST` type.                                         |
| **networkVisibility**| Required     | The network level visibility of this endpoint, which defaults to `Public` if not specified. Accepted values are `Project`, `Organization`, or `Public`.|
| **context**          | Required     | The context (base path) of the API that Choreo exposes via this endpoint.         |
| **schemaFilePath**   | Required     | The swagger definition file path. Defaults to the wildcard route if not provided. This field should be a relative path to the project path when using the **Java**, **Python**, **NodeJS**, **Go**, **PHP**, **Ruby**, and **WSO2 MI** buildpacks. For REST endpoint types, when using the **Ballerina** or **Dockerfile** buildpack, this field should be a relative path to the component root or Docker context.|

## Update to the latest source configuration file

With the upcoming deprecation of the `component-config.yaml` file and the `endpoints.yaml` file, Choreo provides a seamless process to move to the latest `component.yaml`  version of the `component.yaml` file. Follow these steps to transition seamlessly:

### Step 1: Identify whether your current source configuration file is outdated

You can determine whether you’re using an outdated configuration file in the following ways:

- **During a build:**
     - On the **Build** page, after triggering a build, a warning will appear if your source configuration file is outdated. Click **View Details** in the **Initialization** -> **Source Config Validation** step. You will see an information banner with an option to update the file.

- **In existing deployments:**
     - If an existing deployment uses a build with an outdated source configuration file, you will see a warning icon on the build card of the relevant environment card.


### Step 2: Generate the latest `component.yaml` file

- In either of the scenarios above, click **Update** to initiate the process of generating the latest `component.yaml` file. The updated file will retain your existing configurations to ensure a smooth update process.


### Step 3: Add the generated configuration file to your repository

1. Download the generated `component.yaml` file.
2. Replace the existing source configuration file in the `.choreo` folder within your source repository.
    - Ensure the file name is `component.yaml`.


### Step 4: Trigger a new build

1. Commit the new `component.yaml` file to your repository. Push changes to the remote Git repository.
2. Trigger a build using the latest commit.


### Step 5: Verify the update

Once the build is complete:

  - Deploy the build.
  - Confirm that the warning messages no longer appear.

You can benefit from the latest features and enhancements provided by the updated source configuration file.


# Manage Deployment Tracks for Choreo Components

Choreo allows you to create and manage dedicated [deployment tracks](../choreo-concepts/deployment-tracks.md) for components, facilitating independent version control and deployment. This capability also allows you to unlink deployment tracks from associated branches or relink them to different branches so that you can align with your preferred Git workflows, such as the feature branch workflow or GitFlow workflow.

!!! info
     Deployment track creation and management does not apply to API Proxy and [BYOI components](../develop-components/bring-your-own-image.md).

## Create a deployment track

**Prerequisites**:

 - Create a component in Choreo.

Follow the steps below to create a deployment track for a component:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to create a deployment track for.
3. On the header of the component overview page, click the **Deployment Track** drop-down list.
4. Click **+ Create New** to open the **Create Deployment Track** dialog.
5. In the **Create Deployment Track** dialog, do the following:
    1. Select a branch to associate with the deployment track.
    2. Optionally, specify a description for the deployment track. 
    3. To create a deployment track for a service component, specify a unique API version indicating the major and minor version numbers.
6. Click **Create**.

## Unlink a deployment track

If you want to detach a branch reference from a deployment track, you must unlink the branch.

!!! info
     When you unlink the branch of a deployment track, the active deployments are unaffected. However, while you can redeploy the existing deployment, you cannot perform a new deployment.

Follow the steps below to unlink a deployment track of a component:
  
1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to unlink a deployment track.
3. On the header of the component overview page, click the **Deployment Track** drop-down list and then click **View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
4. Click the edit icon corresponding to the deployment track you want to unlink.
5. In the **Edit Branch** dialog that opens, click the **Branch Name** list and select **None**.
6. Click **Save**.

## Link a deployment track

To associate a branch reference to an unlinked deployment track, you must link a branch.

!!! info
    To build and deploy the contents of the linked branch,  you must perform a manual build and deploy.

**Prerequisites**:

 - A minimum of two branches in your GitHub repository.

Follow the steps below to link a branch to an unlinked deployment track:
  
1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to associate a branch reference for.
3. On the header of the component overview page, click the **Deployment Track** drop-down list and then click **View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
4. Click **+ Link Branch** corresponding to the unlinked deployment track for which you want to associate a branch.
5. In the **Link Branch** dialog that opens, click the **Branch Name** list and select the branch you want to relink.
6. Click **Save**.

## Relink a deployment track

To switch the branch reference of a linked deployment track, you must relink to an appropriate branch.

!!! info
      If you unlink the existing branch of a deployment track and link a different branch, you must perform a manual build and deploy to build and deploy the contents of the recently linked branch.

**Prerequisites**:

 - A minimum of two branches in your GitHub repository.

Follow the steps below to switch the branch reference of a linked deployment track:
  
1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to relink a deployment track for.
3. On the header of the component overview page,  click the **Deployment Track** drop-down list and then click **View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
4. Click the **Edit Branch** icon corresponding to the deployment track you want to relink.
5. In the **Edit Branch** dialog that opens, click the **Branch Name** list and select the branch you want to relink.
6. Click **Save**.

Now that you understand how to create and manage deployment tracks for components, let’s explore a sample scenario to see how a developer can use deployment tracks to manage version releases in Choreo.

## Sample Scenario: Manage version releases with deployment tracks

Let’s consider the following version release scenario: 

- To initiate work on a new feature, a developer creates a new branch, named `feature-x` from either the `main` or `dev` branch.
- Once development is complete, the developer proceeds to merge the `feature-x` branch into the `dev` branch for testing.
- Upon successful testing in the `dev` branch, the developer proceeds to merge all the changes into the `main` branch for production deployment.

Following are the actions you need to take from a deployment track perspective to manage the version release:

1. To prepare for the new version release, unlink the `main` branch from the associated deployment track (let’s consider this as the deployment track 1).
2. Proceed to merge the `dev` branch containing the tested changes into the `main` branch.
3. Unlink the `dev` branch from the associated deployment track (let’s consider this as deployment track 2).
4. Link deployment track 2 containing the latest version of the service to the `main` branch for deployment.
5. To facilitate ongoing development and testing, create another deployment track (let’s consider this as deployment track 3) and link it to the `dev` branch.

!!! tip
     - As a developer, you can strategically unlink and relink deployment tracks to effectively manage different versions of your services within Choreo.
     - You can create new deployment tracks for ongoing development branches like `dev` to ensure a continuous development and release cycle.

## Delete a deployment track

If you no longer need a deployment track, you can delete it.

!!! note
    If the component exposes an endpoint or proxy and you want to delete the last version in the major version range, the recommended approach is to retire that version first. This allows consumers to transition to the next major version and prevents a sudden break in their experience.
    For example, if you have deployment tracks for v1.0 and v2.0, notify consumers to switch to v2.0 before deleting v1.0. Then, retire the APIs in v1.0 and proceed to delete the associated deployment track.




**Prerequisites**:

- At least 2 deployment tracks in a component.

Follow the steps below to delete a deployment track:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to delete a deployment track.
3. On the header of the component overview page, click the **Deployment Track** drop-down list.
4. Click **+ View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
5. Click the **Delete** icon corresponding to the deployment track you want to delete.
6. Click **Delete** to confirm the deletion.

# Manage the Micro Integrator Runtime Version in Your Integration Project

Choreo allows you to use a preferred WSO2 Micro Integrator (MI) runtime version in your integration project. Currently, Choreo supports MI product versions 4.1.0 and 4.2.0. You have the flexibility to deploy WSO2 updates within these specified versions. 

When you create an integration project, you can specify a required runtime version to gain control over the environment in which your integration runs. This version management capability empowers you to tailor your projects depending on your runtime requirements, enhancing the customization and adaptability of your integration workflows.

## Understand the version string

WSO2 Micro Integrator (MI) utilizes a versioning system consisting of three-digit numbers, such as `4.1.0` and `4.2.0`, following semantic versioning principles. The product remains committed to receiving updates from WSO2, including security fixes, bug resolutions, and enhancements. Within the Choreo platform, the MI runtime version is constructed by combining the product release version with its corresponding update level.

In Choreo, the MI runtime version is structured as a four-digit number, for example, `4.1.0.14` or `4.2.0.17`. The first three digits represent the product release version, while the last digit signifies the update level of the product. The fourth digit is optional and can be omitted.

![Version string](../assets/img/develop-components/micro-integrator/version-string.png)

## Version management in WSO2 Integration Studio

If you are using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/) to build and deploy integration artifacts in WSO2 Micro Integrator, you can create multiple runtime environments and execute projects on any selected environment. WSO2 Integration Studio also allows you to configure multiple Micro Integrator runtime environments, offering flexibility and customization in the execution of integration processes.

You can specify the Runtime version when you create an integration project in WSO2 Integration Studio. In the project creation wizard, specify the runtime version in the **Runtime version** field, as shown below.
![Specify Runtime version](../assets/img/develop-components/micro-integrator/specify_runtime_version.png)


An integration project is structured as a Maven project with multiple sub-modules. The root `pom.xml` file holds crucial information about the target runtime. The runtime version you configure when you create a new project is saved within the root `pom.xml` file. The version information is stored in the <project.runtime.version> element under the <properties> in the `pom.xml` file. If there is a need to update the runtime version, you have the flexibility to modify the value to a valid runtime version and ensure that the project runs in the required runtime environment.

![project runtime version](../assets/img/develop-components/micro-integrator/project-runtime-version.png)

You can establish multiple runtime environments by utilizing updated MI instances. With a valid WSO2 subscription, you can also access and download updates to set up an updated MI server locally. This update process allows you to select a preferred update level as the runtime version. Consequently, you can run your integration on a runtime with the latest updates, ensuring optimal performance and access to new features.

### Configure a Micro Integrator runtime environment in Integration Studio

If you are using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), follow these steps to set up a remote server instance with a Micro Integrator runtime environment to execute your integration project:

!!! info "Note"
    If you have not downloaded and installed WSO2 Integration Studio, you can follow the [installation instructions](https://apim.docs.wso2.com/en/latest/integrate/develop/installing-wso2-integration-studio/) in the WSO2 API Manager documentation.

1. Launch WSO2 Integration Studio and click **Add Server** in the **Getting Started** view.
   ![Add server](../assets/img/develop-components/micro-integrator/add-server.png)
2. In the **Define a New Server** dialog, click to expand the `WSO2` directory and select **WSO2 Remote Server**.
   ![Define a remote server instance](../assets/img/develop-components/micro-integrator/define-a-remote-server-instance.png)
3. Enter the WSO2 Micro Integrator Management API URL in the **Server URL** field and click **Test Connection**.

    !!! info "Note"
        The Management API of WSO2 Micro Integrator is an internal REST API introduced to substitute MI admin services. The default HTTPS port of the Management API of WSO2 Micro Integrator is `9164`. If you have not manually changed the default port, you must set the Management API URL as `https://localhost:9164/management`.  If you have changed the default HTTPS port, you must set the port number appropriately when specifying the **Server URL**. For more information on the default ports of WSO2 Micro Integrator, see [WSO2 Micro Integrator default ports](https://apim.docs.wso2.com/en/latest/install-and-setup/setup/reference/default-product-ports/#micro-integrator-ports) in the WSO2 API Manager documentation.

    ![Set server URL](../assets/img/develop-components/micro-integrator/set-server-url.png)
    
4. Click **Finish**.
5. In the **Add and Remove** dialog, select the integration components to move from the left side to the right side.
6. Click **Add >**.
7. Click **Finish**. 

Your integration project is now running in a remote server instance with the Micro Integrator runtime environment you require.
If you need to make changes to the integration project, expand the remote server instance, right-click on the deployed exporter project, and select **Redeploy** to apply the changes.

![Redeploy project](../assets/img/develop-components/micro-integrator/redeploy-project.png)

## Convention for version interpretation in Choreo deployments

You can use the following convention to indicate the required MI runtime version in your integration project:


| **Version format**           | **Example**       | **Description**   |
|------------------------------|-------------------|-------------------|
| Product version              | `4.1.0`, `4.2.0`  | Deploy on the latest update level of the mentioned product version.                 |
| Product version with update level  | `4.1.0.15`, `4.2.0.17` |  Deploy on the exact update level of the mentioned product version.    |
| GA version                   | `4.1.0.0`, `4.2.0.0` | Deploy on the exact GA version without any update.                  |
| Default version            | Empty value         | Deploy on the latest update level of the default product version.                  |


Choreo utilizes Alpine images for configuring and deploying the Micro Integrator runtime. This includes automated configuration of the JRE/JDK, customized to the compatibility of the chosen runtime version, simplifying the setup procedure.

## Migrate between runtime versions

Changing the runtime version in an integration project may become necessary during product version upgrades or when you want to apply updates. 

To change the runtime version of a MI Integration, follow the below steps.

### Update the runtime version in the integration project
    
To change the runtime version in the integration project, follow the steps below:
1. Open the project in Integration Studio.
2. Right-click on the project and select **Change Runtime MI Version**.
    ![Update Runtime version](../assets/img/develop-components/micro-integrator/click_change_runtime.png)
3.  Specify the new runtime version as shown below:
    ![Update Runtime version](../assets/img/develop-components/micro-integrator/update_runtime_version.png)
4. Alternatively, you can manually update the version by opening the root `pom.xml` file.  Open pom.xml and change the required runtime version in `<project.runtime.version>` element under `<properties>` section.

To test the changes locally, you must download and set up the runtime environment locally. Then, you must [configure the Integration Studio runtime environment](#configure-a-micro-integrator-runtime-environment-in-integration-studio) by directing it to the locally installed MI runtime. Once the setup is complete, you can deploy your integrations on the MI runtime environment and proceed to the testing phase.

After completing the tests to ensure everything works as expected, you can follow below steps to deploy the project in Choreo:

1. Commit and push the changes to your repository.
2. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
3. Select your project from the **Project** list in the header.
4. Select your MI integration component from the **Component** list in the header.
5. In the left navigation menu, click **Build**.
6. Select the latest commit and click **Build**.
7. In the left navigation menu, click **Deploy**.
8. Click on the **Configure and Deploy** and deploy the component.
9. Verify the Runtime version by checking the logs by selecting the **Runtime Logs** under the **Observability** section.

  You will see the runtime version in the logs as shown below:
  ![Runtime version in logs](../assets/img/develop-components/micro-integrator/runtime_version_in_logs.png)

Next, you must conduct additional testing in the development environment on Choreo before you promote the integration to production environments.

## Troubleshoot errors

The following error codes can help you troubleshoot errors that occur during the integration component build:

| **Error code** | **Description**            |
|----------------|----------------------------|
| 110 - 119      | Internal server error.     |
| 121            | Malformed runtime version. |
| 122            | The specified runtime version is not available. Either the product or update level is not available.    |
| 123            | Trivy security vulnerabilities found in the `libs` directory. |
| 124            | Trivy security vulnerabilities found in the `dropins` directory. |
| 125            | Trivy security vulnerabilities found in the `libs` or `dropins` directory. |
| 126            | Error building integration project. |


# Submit and Manage Workflow Approval Requests

In Choreo, if an administrator [configures a workflow to require approval](../administer/configure-approvals-for-choreo-workflows.md), you must submit a request to obtain approval to perform the task.

Upon submitting a workflow approval request, Choreo notifies all authorized assignees via email about the [review request](../administer/review-workflow-approval-requests.md). When an authorized assignee approves or rejects the request, you will receive an email with details of the decision.

The approach to request approval can vary depending on the workflow. 

## Request approval for environment promotion

**Prerequisites**:

- Ensure you have a component created, built, and deployed to the development environment.
- Ensure that an approval workflow is configured for environment promotion.
- Ensure you are promoting the component to a critical environment, such as production.

To request approval to promote a component from the development environment to production, follow these steps:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to deploy. This takes you to the **Overview** page of the component.
3. In the left navigation menu, click **Deploy**.
4. Go to the **Development** card and click **Request to Promote**.
5. In the **Request Approval** pane that opens, enter your request details and click **Submit**. This creates a request and notifies all authorized assignees via email about the request.

    !!! note
         When an environment promotion request for a specific component is pending review, Choreo restricts other developers from making the same request until the pending request is either approved or rejected.

When an authorized assignee approves the request, you will receive a confirmation email and can proceed to promote the component to production.

## Cancel a workflow approval request

If you want to cancel a workflow approval request that is already submitted, you can do so before the request is approved or rejected. 

When you submit a workflow approval request, the **Request to Promote** button changes to **Cancel Request**. To cancel an approval request, click **Cancel Request**. Upon confirming the cancellation, all configured approvers are notified immediately, and the request will no longer be pending.


# Work with the Micro Integrator Runtime in Choreo

WSO2 Micro Integrator (WSO2 MI) is a lightweight, high-performance integration runtime. It allows you to run integrations developed using WSO2 Integration Studio within Choreo. 

The topics on this page walk you through the key aspects you need to understand to use the WSO2 MI runtime effectively in Choreo.

## Integration types

Choreo supports the following WSO2 MI integrations that cater to different use cases and requirements. Each integration type serves a specific purpose. Therefore, it is essential to understand their differences to easily choose the most appropriate integration for your use case.

- **Service**: Exposes an integration as an API via HTTP, making it possible to create a RESTful interface for your integration services. This type is ideal for scenarios where you need to provide an API for external systems or clients to interact with your integration.
- **Event Handler**: Triggers an integration based on external events such as messages arriving on a queue or updates in a database. This type is well-suited for implementing event-driven architectures or responding to changes in your system's environment.
- **Scheduled Task**: Runs an integration automatically at predefined time intervals, ensuring that specific integration tasks occur at regular intervals. This type is ideal for batch processing, data synchronization, or periodic maintenance tasks.
- **Manual Task**: Initiates an integration via user action, giving you full control over when the integration executes. This type is useful for on-demand tasks, testing, or debugging purposes.

## Develop integrations with WSO2 Integration Studio

[WSO2 Integration Studio](https://wso2.com/integration/integration-studio/) is a powerful, Eclipse-based graphical development environment that enables you to build and deploy integration artifacts in WSO2 Micro Integrator. This comprehensive IDE offers a robust set of tools for designing and testing integration flows and crafting integration artifacts. By utilizing the visual, drag-and-drop capabilities of WSO2 Integration Studio, developers can significantly reduce the time and effort needed to construct and deploy integration flows.

In addition to streamlining the development process, Integration Studio offers features such as debugging, testing, and version control to ensure the quality and reliability of integration flows. By creating an Integration project and Composite Exporter project in WSO2 Integration Studio, developers can export their integration projects as a single deployment artifact, known as a composite application. This composite application encompasses all the components and configurations necessary for deploying the integration project to WSO2 Micro Integrator.

The Composite Exporter project simplifies the deployment process by allowing developers to package their integration projects as a single, self-contained artifact that can be easily deployed and managed. This approach enhances the consistency and reliability of integration projects while streamlining the overall deployment process.

To start developing integrations with WSO2 Micro Integrator, see [WSO2 Micro Integrator documentation - Developing Integration Solutions](https://mi.docs.wso2.com/en/latest/develop/intro-integration-development/).

## Integration project directory structure

An Integration Project in WSO2 Integration Studio is a multi-module Maven project that can contain multiple modules with WSO2 Synapse configurations and a composite application module to export all the configurations as a single deployable artifact.

An integration project directory structure includes the following key components:

 - WSO2 Synapse configurations: These modules contain the essential configurations for the integration project.
 - Composite Application module: This module is responsible for exporting all the Synapse configurations as a single deployable artifact.

Optionally, you can include the following components in your integration project:

 - OpenAPI definition file: You can add the OpenAPI definition file to any location within the project. When creating a component, you'll need to define the path to this file. Choreo will automatically generate an OpenAPI definition for you based on your integration project, if you don't provide one.
 - Java libraries: If your integration project requires additional Java libraries, you can add them to the libs directory located in the project root.
 - deployment.toml file: This optional configuration file allows you to customize the preconfigured settings of WSO2 MI instances running on Choreo. By including this file, you can tailor the behavior of your WSO2 MI instances to better suit your project's specific requirements.

Understanding the Integration Project directory structure is crucial for organizing your project and ensuring that all necessary components are included in the final deployable artifact.

## OpenAPI support

OpenAPI Support plays a crucial role in enhancing the functionality of integrations exposed as APIs. By providing an OpenAPI definition for your exposed integration, you can streamline testing and management processes, ensuring a more efficient and user-friendly experience. Choreo will automatically generate an OpenAPI definition for you based on your integration project, if you don't provide one, saving you time and effort.

To incorporate OpenAPI support, store the OpenAPI definition file within the repository hosting your Integration Studio project. When creating the project, simply point to the file's location in the repository. If needed, you can change the location of the OpenAPI definition file later via the deploy page.

![Open API file](../assets/img/develop-components/micro-integrator/openapi_file.png)

By leveraging OpenAPI Support, you can optimize the way you test and manage your integrations, resulting in a more efficient development process and a smoother user experience.

## Work with third-party libraries

The use of third-party libraries in your Micro Integrator project can offer several advantages, such as enhanced functionality, improved integration capabilities, optimized performance, and reduced development time.

Here are some of the benefits of adding third-party JARs to the Micro Integrator:

 - Increased functionality: Third-party libraries can extend the core Micro Integrator distribution, allowing for greater flexibility and customization of integration solutions.
 - Enhanced integration capabilities: Third-party libraries enable the Micro Integrator to interact with existing systems such as databases or other APIs, improving overall integration capabilities.
 - Optimized performance: By offering optimized implementations of common functions, third-party libraries can improve the performance of the Micro Integrator.
 - Efficient development: Developers can avoid re-implementing commonly used functions, reducing development time and increasing efficiency.

To incorporate third-party libraries into your Micro Integrator project, create a new directory called `libs` at the
root of your project. If your project root and GitHub repository root are not the same, place the `libs` directory in
the project root. After adding the required JAR files to the `libs` directory, the Micro Integrator runtime will
automatically include them when deploying the component. This process ensures that any dependencies needed by your
integration flow are available at runtime.

In addition to `jar` libraries, you may also need to incorporate OSGi bundle JARs into your project. To do this,
create another directory called `dropins` at the root of your project. Similarly, if the project root and GitHub
repository root differ, place the `dropins` directory in the project root. Within the `dropins` directory, add the OSGi
bundle JAR files. The OSGI runtime will pick up these bundles during deployment, enabling you to utilize their
functionality within your Micro Integrator project.

![Libs directory](../assets/img/develop-components/micro-integrator/libs_dir.png)

## Importing custom certificates to MI

The feature enables Choreo MI users to import certificates into the MI `client-truststore.jks` file. This functionality
proves valuable when users need to establish connections with servers or services utilizing SSL/TLS encryption and
possessing self-signed certificates or certificates issued by private certificate authorities (CAs) that are not
automatically trusted. Importing the certificate to the MI `client-truststore.jks` file enables MI clients to establish secure connections with
the server or service seamlessly, eliminating SSL/TLS errors or warnings.

Before importing the certificate, it is necessary to obtain the certificate file, which can be in PEM or DER format. You
can get the certificate from the server or service provider or export it from a web browser. Certificates should be
added to the `/wso2mi/certs/` folder. Users need to verify that the mount path for the certificate file aligns with this
specific path.

1. In the Choreo console, select the component you wish to add a certificate to.
2. From the left navigation click **Deploy**.
3. Click on the **Configs and Secrets** tab.
4. Click **Create**.
5. Select **ConfigMap** as the **Config Type** and **File Mount** as the **Mount Type**.
6. Click **Next**.
7. Specify the following values as mount configurations:

    | **Field**       | **Value**                                              |                                    
    |-----------------|--------------------------------------------------------|
    | **Config Name** | An appropriate name for the certificate.             |
    | **Mount path**  | `/wso2mi/certs/<filename>`. For example, `/wso2mi/certs/certificate.crt` |

8. Click **Upload File** and attach the certificate.
9. Click **Create**.

## Working with sensitive data using MI Secure Vault

MI Secure Vault is a feature that allows users to securely store sensitive data, such as passwords and tokens, and
provide access to that data to MI Integrations. This feature provides an added layer of security to your integrations by
reducing the risk of accidental exposure of sensitive data.

To use MI Secure Vault to work with sensitive data, follow these steps:

1. Select the component from the Choreo Console.
2. From the left navigation, click Deploy.
3. Click on the **Configure and Deploy**.
4. Click on the **Add Environment Configurations**
5. Specify the following values as configurations:

    | **Field**       | **Value**                                 |                                    
    |-------------------------------------------|--------------------------------------------------------|
    | **Name** | An appropriate name for the secret/alias. |
    | **Value**       | Value for the secret                      |

6. Select **Mark as a Secret**.
7. Click **Add**.
8. Click **Deploy**.
9. Once the secret has been created, you can access it in your integration code using the following syntax:

```xml
<property name="secret_value_1" expression="wso2:vault-lookup('user_pass')" scope="default" type="STRING"/>
```
This code retrieves the secret named "user_pass" from the MI Secure Vault and stores it in the property named "
secret_value_1". You can then use this property in your integration code to access the secret value.

For more information on these features, see the [Accessing secrets](https://mi.docs.wso2.com/en/latest/install-and-setup/setup/security/encrypting-plain-text/#step-3-accessing-secrets) section of the MI Secure Vault documentation. By using MI
Secure Vault to store and access sensitive data in your integrations, you can ensure that your integrations
remain secure and protect sensitive data from unauthorized access.


## Scan third-party libraries to identify security vulnerabilities

Scanning third-party libraries for security vulnerabilities is essential for identifying potential weaknesses in an application that could be exploited by attackers. Taking a proactive approach to security helps organizations detect and mitigate risks before they can be exploited, preventing data breaches, system compromises, and other security incidents.

Choreo incorporates a security vulnerability scanning process during deployment. It uses Trivy to scan and detect critical vulnerabilities in third-party libraries added to the integration component. If the scan uncovers any critical vulnerabilities, the deployment process is halted. The deployment pane displays the Trivy scan status and any security failures in the Library (Trivy) vulnerable scan step, which can be accessed by clicking on it. Once the vulnerability has been addressed, you can redeploy the component.

## Customize WSO2 Micro Integrator preconfigured settings

Customizing WSO2 Micro Integrator Preconfigured Settings is essential for ensuring that the integration solution works optimally within the specific context of your organization. While WSO2 MI comes with preconfigured settings designed for general use, these settings may not be suitable for every organization's unique requirements. Customizing these settings can help optimize performance and ensure compatibility with your organization's systems and applications.

To customize the preconfigured settings of WSO2 MI instances running on Choreo, define a `deployment.toml` file in the GitHub repository subpath of your Micro Integrator project:

![deployment.toml](../assets/img/develop-components/micro-integrator/config_file.png)

!!! note
    If you change critical configuration parameters such as port offset and hostname, it can break internal communication.
    Therefore, the recommended approach is to update only the necessary configuration parameters.

Given below is a sample `deployment.toml` file that can be used to configure the JMS transport. For more information on WSO2 MI
configuration parameters, see the [MI Configuration Catalog](https://mi.docs.wso2.com/en/latest/reference/config-catalog-mi/).

```
[[transport.jms.sender]]
name = "myQueueSender"
parameter.initial_naming_factory = "org.apache.activemq.jndi.ActiveMQInitialContextFactory"
parameter.provider_url = "$env{JMS_PROVIDER_URL}"
parameter.connection_factory_name = "QueueConnectionFactory"
parameter.connection_factory_type = "queue"
parameter.cache_level = "producer"

[[transport.jms.listener]]
name = "myQueueListener"
parameter.initial_naming_factory = "org.apache.activemq.jndi.ActiveMQInitialContextFactory"
parameter.provider_url = "$env{JMS_PROVIDER_URL}"
parameter.connection_factory_name = "QueueConnectionFactory"
parameter.connection_factory_type = "queue"
parameter.cache_level = "consumer"
```

## Environment variables

Using environment variables is a recommended practice when developing integration artifacts with WSO2 Integration Studio, as it improves configuration management, security, portability, and manageability. By leveraging environment variables, organizations can streamline the management and maintenance of their integrations, ensuring that updates can be implemented quickly and efficiently.

The component's Deploy page provides a user-friendly interface to manage environment variables across different environments. For information on managing environment variables for complex use cases, see [Configurations and secrets](../devops-and-ci-cd/manage-configurations-and-secrets.md).

![Environment variables](../assets/img/develop-components/micro-integrator/env_variables.png)

Environment variables offer several benefits:

 - Configuration management: They simplify the process of managing and updating configuration settings, making it easier to maintain consistency across different environments.
 - Security: Environment variables help protect sensitive information by storing it securely and separating it from the main codebase.
 - Portability: By using environment variables, you can ensure that your integration artifacts can be easily migrated and deployed across various environments with minimal changes.
 - Manageability: Environment variables offer a centralized way to manage configuration settings, making it easier to update and maintain your integrations over time.

For a comprehensive list of parameters that can be configured as environment variables, see [WSO2 Micro Integrator documentation - Injecting Parameters - Supported parameters](https://mi.docs.wso2.com/en/latest/develop/injecting-parameters/#supported-parameters).

## Configure logging

Configuring logging is crucial when developing and maintaining a software system, as it can significantly improve efficiency during the development, testing, and maintenance phases of the software development process. Logging captures events and messages that occur during an application's execution, providing valuable insights for troubleshooting and debugging issues.

With Micro Integrator instances, you can configure and customize logging according to your requirements. Logging configurations can be added to each MI instance's environment, allowing you to fine-tune logging depending on the specific environment or deployment scenario.

To configure logging in MI instances, follow the steps given below: 

!!! tip
     You can use environment variables with specific naming conventions.

1. Start the variable name with `logging_level_` followed by the package or class name.
2. Replace the dot character in the package name with an underscore.
3. Set the variable value to the required logging level for the corresponding package or class.

    For example, to enable wire logs, change the logging level of the `org.apache.synapse.transport.http.wire` package to `debug`. 

To configure logging, set the environment variable as follows:

1. In the left navigation menu, click **Deploy** and then click **Configs & Secrets**. 
2. Click **+ Create**. 
3. Select **ConfigMap** as the **Config Type** and **Environment Variables** as the **Mount Type**. 
4. Click **Next**. 
5. Specify the following values as mount configurations:

    | **Field**       | **Value**                                              |                                    
    |-----------------|--------------------------------------------------------|
    | **Config Name** | An appropriate name for the configuration.             |
    | **Name**        | `logging_level_org_apache_synapse_transport_http_wire` |
    | **Value**       | `debug`                                                |

6. Click **Create**.

## Connectors

WSO2 Micro Integrator (MI) Connectors are prebuilt connectors designed to simplify integration between WSO2 MI and various other systems. They enable seamless connections to databases, message brokers, REST APIs, and more, allowing you to perform actions such as sending messages, executing queries, or retrieving data. These connectors are easy to use, making it straightforward to incorporate them into your WSO2 MI integration flows. Micro Integrator connectors are versatile and can be utilized in various integration scenarios, including data integration, service-oriented architecture (SOA) integration, and event-driven architecture (EDA) integration.

WSO2 Integration Studio is a comprehensive development environment that facilitates the creation of integration flows using WSO2 Micro Integrator Connectors. With Integration Studio, you can design and implement integration flows that connect diverse systems and execute various actions, such as sending messages, executing queries, or retrieving data. You can build integration flows using either prebuilt connectors provided by WSO2 MI or custom connectors developed using the Connector Development Toolkit. Integration Studio offers a graphical user interface that simplifies the process of building and testing integration flows while also providing a set of tools for managing and deploying these flows in a WSO2 MI runtime environment.

For more information, see the following topics in the WSO2 Micro Integrator documentation.

- [Connectors Overview](https://mi.docs.wso2.com/en/latest/reference/connectors/connectors-overview/)
- [Adding Connectors](https://mi.docs.wso2.com/en/latest/develop/creating-artifacts/adding-connectors/)

## Deploying integrations in Choreo 

WSO2 MI buildpack is where you can deploy integrations developed with WSO2 Micro Integrator as an API. In this preset, you have three different ways to define endpoints. Choreo gives priory to the definition of endpoints in the below-mentioned order. 

1. **Using component.yaml file**
This is the most flexible method to define endpoints. You can configure the endpoint details with the `component.yaml` configuration file. Place this file in the `.choreo` directory in the project path of the component. 
If the Micro Integrator project has inbound endpoints, you can expose them via different endpoints using the `component.yaml`file.

    To learn about the `component.yaml` file, see [Overview of the component.yaml file](../develop-components/manage-component-source-configurations.md#overview-of-the-componentyaml-file).

3. **Auto generating endpoints**
If `component.yaml` is not provided and if the source Micro Integrator project has APIs, Choreo scans the project and generates the API endpoints. If the project has few APIs, an endpoint will be generated for each API. The visibility of this auto-generated endpoint is set to `Public` by default. You can change the visibility in the deployment flow.

4. **Provide default endpoints**
If `component.yaml` is not provided and if the source Micro Integrator project doesn't have APIs, Choreo generates a default endpoint which will expose the default micro integrator port (8290) with `Public` visibility and wildcard context.

!!! note
    If you are currently using `component-config.yaml` or `endpoints.yaml` configuration files, see the respective [migration guide](../develop-components/manage-component-source-configurations.md#migration-guide) for instructions on migrating to the recommended `component.yaml` configuration file.

## Explore Choreo examples on GitHub

For a hands-on experience with MI-based integrations in Choreo, we recommend exploring our samples in Choreo Console. You can filter out the samples based on the buildpack `WSO2 MI`. This will point you to the samples in the [Choreo samples GitHub repository](https://github.com/wso2/choreo-samples)

### [Choreo samples - GitHub Repository](https://github.com/wso2/choreo-samples)

- **Fork the Repository**: Start by forking the repository to your account.

- **Explore & run**: Navigate through the different integration scenarios. Each example has a README.md with setup and execution instructions.



# Develop a Manual Task

This guide walks you through the steps to develop, deploy, test, and observe a manual task using Choreo.

In this guide, you will:

- Develop a manual task to fetch the weather forecast for a specified location for the next 24 hours from the [OpenWeatherMap](https://openweathermap.org) API.
- Process the weather data into a specific format.
- Send the formatted data to a specified email address.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

    !!! info "Repository File Structure"
        The sample code for this guide is in the `<sample-repository-dir>/weather-to-email-integration` directory. The following table describes the key files in the repository:

        | **File Path**         | **File Content**                                                     |
        | --------------------- | -------------------------------------------------------------------- |
        | **Ballerina.toml**    | Contains metadata about the project                                  |
        | **Dependencies.toml** | Lists the dependencies required for the project                      |
        | **main.bal**          | Contains the entry point of the project, including the main function |
        | **types.bal**         | Contains custom data types used in the project                       |
        | **utils.bal**         | Contains utility functions and helper functions used in the project  |

3. Go to [OpenWeatherMap](https://openweathermap.org/) and sign up to obtain an API key. For details, see the [OpenWeatherMap documentation](https://openweathermap.org/appid#signup).

## Step 1: Create a manual task component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Manual Task** card.
6. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:

        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

7. Enter the following information:

    | **Field**             | **Description**                                      |
    | ----------------------| -----------------------------------------------------|
    | **Organization**      | Your GitHub account                                  |
    | **Repository**        | `choreo-samples`                                     |
    | **Branch**            | `main`                                               |
    | **Component Directory** | `weather-to-email-integration`                       |

8. Select **Ballerina** as the **Build Pack**.

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Component Directory** specifies the location of the project to build the component.

4. Enter a unique name and description for the component. You can use the following values:

    | **Field**          | **Value**                        |
    | ------------------ | -------------------------------- |
    | **Component Name** | `WeatherToEmail`                 |
    | **Description**    | `My first manual task`           |


8. Click **Create**. Choreo initializes the component with the sample implementation and opens the **Overview** page of the component.

## Step 2: Build the manual task

1. In the left navigation menu, click **Build**.
2. In the **Builds** pane, click **Build**. This opens the **Commits** pane, where you can see all the commits related to the component.
3. Select the latest commit and click **Build**. This triggers the build process and displays the build progress in the **Build Logs** pane.

    !!! info
        The build process may take some time. Once complete, the build status will be listed in the **Builds** pane. Here, you will see the build status as **Success**.

## Step 3: Deploy the manual task

1. In the left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane, specify values for the configurable variables:

    !!! tip
        The configurable variables populated here are defined in the sample Ballerina project used in this guide. To learn how to declare configurable variables in Ballerina, see the [Ballerina documentation on declaring configurable variables](https://ballerina.io/learn/by-example/configurable-variables/).

    | **Field**     | **Value**                                                               |
    | ------------- | ----------------------------------------------------------------------- |
    | **apiKey**    | The API key you obtained in the prerequisites section                   |
    | **latitude**  | Latitude of the location to get the weather forecast                    |
    | **longitude** | Longitude of the location to get the weather forecast                   |
    | **email**     | The email address to receive the formatted weather forecast information |

    !!! note
        If you use **Ballerina** as the buildpack and want to set a configurable variable as a secret, click the lock icon corresponding to the configurable variable. This marks it as a secret and conceals the input value.

        For example, if you set the **apiKey** as a secret, its input value will be concealed. To update the input value later, click **Update Secret Content** and specify a new value.

4. Click **Deploy**.

## Step 4: Execute the manual task

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the task.

    !!! info "Inject Dynamic Values into Your Application as Command-Line Arguments"
        If you want to inject dynamic values into your application as command-line arguments when you run a manual task, follow these steps:
        1. Click the drop-down icon next to **Run Now** and then click **Run with Arguments**.
        2. In the **Runtime Arguments** pane, enter the arguments you want to pass to your application.
        3. Click **Execute**. This triggers the task with the specified arguments.

        The capability to run a manual task with arguments is supported for the following buildpacks:

        === "Dockerfile"
            To explore a Dockerfile-based manual task with arguments, try out the [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/docker-hello-world-manual-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on Docker projects, the **Run with Arguments** capability is not supported if the Dockerfile contains `CMD`. In such scenarios, use `ENTRYPOINT` to define your default commands.

        === "Go"
            To explore a Go-based manual task with arguments, try out the [Hello World Go Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-go-task) sample. For instructions, see the `readme.md` file in the sample repository.

        === "Java"
            To explore a Java-based manual task with arguments, try out the [Hello World Java Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-java-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on Java projects:
                - The **Run with Arguments** capability is not supported if `Procfile` is available in the project.
                - The `Main` class should be defined in the `manifest` file.
                - If Maven files such as `mvn.cmd` exist in the project without the `.mvn` directory, the build will fail. To ensure a successful build, either commit the `.mvn` directory along with any Maven files or exclude Maven files if you choose not to commit the `.mvn` directory.

        === "NodeJS"
            To explore a NodeJS-based manual task with arguments, try out the [Hello World NodeJS Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-nodejs-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on NodeJS projects:
                - The **Run with Arguments** capability is not supported if `Procfile` is available in the project.
                - The project root must contain the `package.json` file with the `main` attribute defined.

        === "WSO2 MI"
            To explore a WSO2 MI-based manual task with arguments, try out the [Weather to Logs Task](https://github.com/wso2/choreo-samples/tree/main/weather-to-logs-mi-manual-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on WSO2 MI projects and deploying a WSO2 MI integration as a manual task in Choreo, use the WSO2 MI automation mode. For details, see [Running the Micro Integrator in Automation Mode](https://apim.docs.wso2.com/en/latest/install-and-setup/install/running-the-mi-in-automation-mode/).

        === "Ballerina"
            To explore a Ballerina manual task with arguments, try out the [Weather to Email Task](https://github.com/wso2/choreo-samples/tree/main/weather-to-email-integration) sample. For instructions, see the README.md file in the sample repository.

            !!! info
                If you want to pass arguments to Ballerina main functions, use the **Run with Arguments** capability. For details on the arguments you can pass, see the [Ballerina documentation](https://ballerina.io/learn/by-example/main-function/). You can also override configurable values in the same manner. For more information, see [Provide values to configurable variables](https://ballerina.io/learn/provide-values-to-configurable-variables/#provide-via-command-line-arguments).

## Step 5: Test the manual task

Once the task is triggered, an email with the subject `[WSO2 Choreo Demo] Next 24H Weather Forecast` is sent from `choreo.demo@gmail.com` to the email address specified as the **email** configurable variable value in [Step 3](#step-3-deploy-the-manual-task).

If the manual task ran successfully, you should receive an email similar to the following:

![Received email](../../assets/img/develop-components/develop-a-scheduled-integration/Received-email.png)

## Step 6: Observe the manual task

The observability view in Choreo displays graphs that depict details such as throughput, latency, diagnostic data, and logs to identify and troubleshoot anomalies in components you deploy.

1. In the left navigation menu, click **Observability**.
2. Observe the following:
    - The throughput and latencies of requests served over a given period.
    - The logs generated over a given period.
    - The flame graph (Diagnostics View) generated over a given period.
    - The low-code diagram.

To learn more about the observability details you can view via Choreo observability, see [Observability Overview](../../monitoring-and-insights/observability-overview.md).

## Step 7: Monitor executions

To track and monitor executions associated with the deployed manual task, go to the left navigation menu and click **Execute**.

!!! tip
    The **Execute** view is applicable to both scheduled and manual tasks.

You can view the following information:

- **Total executions**: The total number of executions within the past 30 days.

    ![Total Execution](../../assets/img/develop-components/develop-a-scheduled-integration/total_executions.png)

- **Execution history**: The currently active executions and those that are already complete. You can view information such as the execution ID, the revision of the execution, and the time it was triggered.

    ![Execution History](../../assets/img/develop-components/develop-a-scheduled-integration/execution_history.png)

- **Detailed execution logs**: Click on an execution to view detailed logs related to it.

    !!! info
        It may take a few minutes for the logs to appear. You may need to manually refresh to view the latest logs.

    ![Execution Logs](../../assets/img/develop-components/develop-a-scheduled-integration/execution_logs.png)


# Develop a Scheduled Task

Choreo is a versatile integration platform that allows you to create various types of integrations depending on your requirements. If you need to automatically run a specific integration at regular intervals, you can use Choreo to develop a scheduled task. This type of integration can automate the synchronization of data between different systems at specified intervals, reducing errors and improving productivity by eliminating the need for manual intervention.

This guide walks you through the steps to develop, deploy, test, and observe a scheduled task using Choreo.

In this guide, you will:

- Develop a scheduled task to fetch the weather forecast for a specified location for the next 24 hours from the [OpenWeatherMap](https://openweathermap.org) API.
- Process the weather data into a specific format.
- Send the formatted data to a specified email address at a specific time every day.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

    !!! info "Repository File Structure"
        The sample code for this guide is in the `<sample-repository-dir>/weather-to-email-scheduled-task` directory. The following table describes the key files in the repository:

        | **File Path**         | **File Content**                                                     |
        | --------------------- | -------------------------------------------------------------------- |
        | **Ballerina.toml**    | Contains metadata about the project                                  |
        | **Dependencies.toml** | Lists the dependencies required for the project                      |
        | **main.bal**          | Contains the entry point of the project, including the main function |
        | **types.bal**         | Contains custom data types used in the project                       |
        | **utils.bal**         | Contains utility functions and helper functions used in the project  |

3. Go to [OpenWeatherMap](https://openweathermap.org/) and sign up to obtain an API key. For details, see the [OpenWeatherMap documentation](https://openweathermap.org/appid#signup).

## Step 1: Create a scheduled task component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Scheduled Task** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following information:

    | **Field**             | **Description**                                |
    | --------------------- | ---------------------------------------------- |
    | **Organization**      | Your GitHub account                            |
    | **Repository**        | `choreo-samples`                               |
    | **Branch**            | `main`                                         |
    | **Component Directory** | `weather-to-email-scheduled-task`              |

6. Select **Ballerina** as the build pack.

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Component Directory** specifies the location of the project to build the component.

7. Enter a unique name and description for the component. You can use the following values:

    | **Field**          | **Value**                        |
    | ------------------ | -------------------------------- |
    | **Component Name** | `WeatherToEmail`                 |
    | **Description**    | `My first scheduled task`        |

8. Click **Create**. Choreo initializes the component with the sample implementation and opens the **Overview** page of the component.

Now you can proceed to build and deploy the scheduled task.

## Step 2: Build the scheduled task

1. In the left navigation menu, click **Build**.
2. In the **Builds** pane, click **Build**. This opens the **Commits** pane, where you can see all the commits related to the component.
3. Select the latest commit and click **Build**. This triggers the build process and displays the build progress in the **Build Logs** pane.

    !!! info
        The build process may take some time. Once complete, the build status will be listed in the **Builds** pane. Here, you will see the build status as **Success**.

## Step 3: Deploy the scheduled task

1. In the left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane, specify values for the configurable variables:

    !!! tip
        The configurable variables populated here are defined in the sample Ballerina project used in this guide. To learn how to declare configurable variables in Ballerina, see the [Ballerina documentation on declaring configurable variables](https://ballerina.io/learn/by-example/configurable-variables/).

    | **Field**     | **Value**                                                               |
    | ------------- | ----------------------------------------------------------------------- |
    | **apiKey**    | The API key you obtained in the prerequisites section                   |
    | **latitude**  | Latitude of the location to get the weather forecast                    |
    | **longitude** | Longitude of the location to get the weather forecast                   |
    | **email**     | The email address to receive the formatted weather forecast information |

    !!! note
        If you use **Ballerina** as the buildpack and want to set a configurable variable as a secret, click the lock icon corresponding to the configurable variable. This marks it as a secret and conceals the input value.

        For example, if you set the **apiKey** as a secret, its input value will be concealed. To update the input value later, click **Update Secret Content** and specify a new value.

4. Click **Next**.
5. Define a schedule to run the task. In this guide, set the schedule to receive the weather information daily at 8:00 AM UTC. Enter the following values:

    | **Field**            | **Value**                                             |
    | -------------------- | ----------------------------------------------------- |
    | **Select Time Zone** | Select a time zone to schedule the task               |
    | **Select Range**     | **Day**                                               |
    | **Every**            | `1`                                                   |
    | **At**               | `08:00`                                               |

    !!! tip
        To test and verify the task immediately, you can schedule the deployment to run in just a few minutes after you create it. However, to avoid unnecessary expenses, reschedule or stop the deployment once you test and verify.

6. Click **Deploy**. This deploys the scheduled task to the development environment and indicates the **Scheduled Status** as **Active** in the **Development** card.

You can test the scheduled task when it runs at the configured time.

## Step 4: Test the scheduled task

When the scheduled task runs at the configured time, an email with the subject `[WSO2 Choreo Demo] Next 24H Weather Forecast` is sent from `choreo.demo@gmail.com` to the email address specified as the **email** configurable variable value in [Step 3](#step-3-deploy-the-scheduled-task).

If the scheduled task ran successfully, you should receive an email similar to the following:

![Received email](../../assets/img/develop-components/develop-a-scheduled-integration/Received-email.png)

## Step 5: Observe the scheduled task

The observability view in Choreo displays graphs that depict details such as throughput, latency, diagnostic data, and logs to identify and troubleshoot anomalies in components you deploy.

1. In the left navigation menu, click **Observability**.
2. Observe the following:
    - The throughput and latencies of requests served over a given period.
    - The logs generated over a given period.
    - The flame graph (Diagnostics View) generated over a given period.
    - The low-code diagram.

To learn more about the observability details you can view via Choreo observability, see [Observability Overview](../../monitoring-and-insights/observability-overview.md).

## Step 6: Monitor executions

To track and monitor executions associated with the deployed scheduled task, go to the left navigation menu and click **Execute**.

!!! tip
    The **Execute** view is applicable to both scheduled and manual tasks.

You can view the following information:

- **Total executions**: The total number of executions within the past 30 days.

    ![Total Execution](../../assets/img/develop-components/develop-a-scheduled-integration/total_executions.png)

- **Execution history**: The currently active executions and those that are already complete. You can view information such as the execution ID, the revision of the execution, and the time it was triggered.

    ![Execution History](../../assets/img/develop-components/develop-a-scheduled-integration/execution_history.png)

- **Detailed execution logs**: Click on an execution to view detailed logs related to it.

    !!! info
        It may take a few minutes for the logs to appear. You may need to manually refresh to view the latest logs.

    ![Execution Logs](../../assets/img/develop-components/develop-a-scheduled-integration/execution_logs.png)


# Develop an Event Handler

An event handler executes predefined actions in response to specific events. Choreo simplifies the process of creating and deploying such integrations.

This guide walks you through the steps to create and deploy an Event Handler using WSO2 MI and Choreo.

In this guide, you will build a simple event handler that monitors RabbitMQ for new messages and displays them once they become available.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Set up RabbitMQ:
    - Use an existing RabbitMQ instance or start a new [RabbitMQ](https://www.rabbitmq.com/download.html) instance on a server that can be accessed via the internet.
    - Obtain the `username`, `hostname`, `password`, and `vhost` from the RabbitMQ instance to use later as environment variables.

3. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

## Step 1: Create an event handler component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Event Handler** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following information:

    | **Field**             | **Description**              |
    |-----------------------|----------------------------- |
    | **Organization**      | Your GitHub account          |
    | **Repository**        | `choreo-samples`             |
    | **Branch**            | `main`                       |
    | **Component Directory** | `mi-rabbitmq-listener`       |

6. Select **WSO2 MI** as the build pack. (since you are creating the REST API from a [WSO2 Integration Studio](https://wso2.com/micro-integrator/) project)

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Component Directory** specifies the location of the project to build the component.

7. Enter a unique name and description for the component. You can use the following values:

    | **Field**          | **Value**              |
    |--------------------|------------------------|
    | **Component Name** | `SalesOrderListener`   |
    | **Description**    | `RabbitMQ integration` |

8. Click **Create**.

## Step 2: Deploy the integration

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**.
3. In the **Configurations** pane, click **+ Add** corresponding to **Environment Variables** and add the following environment variables:

    !!! tip
        Use the values from your RabbitMQ instance as per the [Prerequisites](#prerequisites) section for the environment variables.

    | **Name**     | **Value**                                         |
    | ------------- |--------------------------------------------------|
    | **HOSTNAME**  | Hostname of your RabbitMQ server                 |
    | **VHOST**     | Virtual hostname of your RabbitMQ server         |
    | **USERNAME**  | Username for connecting to RabbitMQ              |
    | **PASSWORD**  | Password associated with the RabbitMQ username   |

4. Click **Deploy**. This deploys the event handler to the development environment and indicates the **Deployment Status** as **Active** in the **Development** card.

## Step 3: Test the integration

1. Send a sales order message to the **SalesOrderQueue** on the RabbitMQ server. You can send a sample sales order message similar to the following:

    ```json
    {
        "order_id": "12345",
        "customer_name": "John Doe",
        "product": "Widget",
        "quantity": 10,
        "total_amount": 100.00
    }
    ```

2. Observe the logs:
    - In the left navigation menu, click **Logs** and then click **Runtime Logs**. You will see the order message in the logs.

Now you have gained hands-on experience in creating, configuring, and deploying an event handler.


# Develop an Integration with Integration Studio

Choreo simplifies the process of building, deploying, and managing integration components, making it easy to expose integrations as APIs. This guide walks you through the steps to expose an integration created in WSO2 Integration Studio as an API in Choreo.

In this guide, you will:
- Create a component to expose a sample integration from the [Choreo samples repository](https://github.com/wso2/choreo-samples) as an API.
- Deploy, test, and observe the integration component.
- Publish the integration component as an API to the Choreo Developer Portal.

!!! note
    - To develop integrations for **Manual Task** and **Schedule Task** components in Choreo, use the **automation mode** in the WSO2 Micro Integrator. See [Running MI in Automation Mode](https://apim.docs.wso2.com/en/4.2.0/install-and-setup/install/running-the-mi-in-automation-mode/).
    - For other component types (Service, webhook, event-handler, etc.), use the **server mode**.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    - Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    - Enter a unique organization name. For example, `Stark Industries`.
    - Read and accept the privacy policy and terms of use.
    - Click **Create**. This creates the organization and opens the **Project Home** page.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

## Step 1: Create the integration component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the **Project Home** page.

2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following repository details:

    | **Field**             | **Description**              |
    |-----------------------|----------------------------- |
    | **Organization**      | Your GitHub account          |
    | **Repository**        | `choreo-samples`            |
    | **Branch**            | **`main`**                   |
    | **Component Directory** | `hello-world-mi`             |

6. Select WSO2 MI as the build pack (since you're creating the REST API from a [WSO2 Integration Studio](https://wso2.com/micro-integrator/) project).

7. Provide a unique name and description for the component:

    | **Field**          | **Value**              |
    |--------------------|------------------------|
    | **Component Name** | `Hello World`          |
    | **Description**    | `Hello World REST API` |

8. Click **Create**. Choreo initializes the component with the sample integration.

## Step 2: Deploy the integration component

1. In the Choreo Console left navigation menu, click **Deploy**.

2. Configure and deploy:
   - In the **Build Area** card, click **Configure & Deploy**.
   - In the **Configurations** pane, click **Next**. This displays the endpoint details ready for deployment.
   - Click **Deploy**. This deploys the integration component to the development environment.

    !!! tip
        - Choreo uses [endpoints](../../choreo-concepts/endpoint.md) to expose **Service** components to the network. Learn more about configuring endpoints in [Configure Endpoints](../configure-endpoints.md).
        - Automatic deployment is enabled by default, so only the first deployment needs to be done manually.

   The **Development** card shows the **Deployment Status** as **Active** when the integration is successfully deployed.

## Step 3: Test the integration

1. In the Choreo Console left navigation menu, click **Test** and then click **Console**.
2. In the OpenAPI Console, select **Development** from the environment drop-down list.
3. Expand the **GET /integration** operation.
4. Click **Try it out**, then click **Execute**. This sends a request to your deployed integration.
5. Check the response:
    - In the **Response body** section, observe the response. If the integration works as expected, you should see:
     
     ```json
     {"Hello" : "Integration"}
     ```

## Step 4: Observe the integration

1. Click **Observability** in the left navigation menu to monitor the performance of the integration component.

2. View metrics:
   - Observe throughput and latencies of requests over time.
   - View logs generated during a specific period.
   - Analyze the flame graph (Diagnostics View) for performance insights.

   For more details, see [Observability Overview](../../monitoring-and-insights/observability-overview.md).

## Step 5: Publish the integration component

1. In the Choreo Console left navigation menu, click **Manage** and then click **Lifecycle**.
2. The **Lifecycle Management** pane shows the current lifecycle stage as **Created**.
3. Click **Publish**. This changes the lifecycle stage to **Published** and exposes the integration as an API in the Choreo Developer Portal.
   - To view the published API, click **Go to Devportal**. In the Developer Portal, you can manage subscriptions and generate access tokens for testing.

Now you have successfully exposed an integration designed in WSO2 Integration Studio as a REST API in Choreo!


# Develop an API Proxy from a GitHub Repository Source

An API proxy acts as an intermediary between an existing API and Choreo, intercepting all requests made to the API. It also functions as a managed API, allowing you to apply essential API management features such as security policies and rate limiting.

In this guide, you will:

- Create an API proxy component to expose an existing API.
- Deploy the API proxy.
- Test the API proxy to verify its functionality.
- Manage the API.
- Consume the API.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample proxy source](https://github.com/wso2/choreo-samples/tree/main/department-api-proxy-from-github).  

## Step 1: Create an API proxy

You can create an API proxy either by selecting the source from a GitHub repository, uploading an OpenAPI specification file, or providing an OpenAPI specification URL. This guide demonstrates how to create an API proxy using a GitHub repository as the source.

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **API Proxy** card. This opens the **Create an API Proxy** pane.

4. Click on **Authorize With GitHub** card under **Connect a Git Repository** section to connect your GitHub account.
    - If you haven’t connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
         - Read and write access to code and pull requests.
         - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.    

5. Enter the following repository details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **Repository**         | choreo-samples     |
    | **Branch**             | **`main`**         |
    | **API Directory**      | /department-api-proxy-from-github |

    !!! note
        To select the relevant directory, click on the **Edit** action next to the **API Directory** input field. Then, enter `department-api-proxy-from-github` as the directory name to quickly search and locate the correct directory.

6. Specify the following values as Proxy Metadata:

    !!! info
        The **Context** field must be unique and cannot be changed after creation.**Version** and **Target** are mandatory fields. **Target** can be changed at any time after the creation.

    | **Field**       | **Value**                                  |
    |-----------------|--------------------------------------------|
    | **Context**     | `department-service`                                   |
    | **Version**     | `v1.0`                                      |
    | **Target**      | `https://samples.choreoapps.dev/company/hr`|

7. Specify the following values as Component Details:

    !!! info
        The **Component Name** field must be unique and cannot be changed after creation. This value is automatically generated, but you can edit it if necessary.
        **Component Display Name** is a required field.

    | **Field**       | **Value**                                  |
    |-----------------|--------------------------------------------|
    | **Component Display Name**| `Department Service`                    |
    | **Component Name**        | `department-service`                    |
    | **Description**           | `This is a sample proxy for department service`     |    

8. Click **Create**. This creates the API proxy component and takes you to the **Build** page.

!!! note
    When you create an API proxy from a GitHub repository source, the GitHub source serves as the single source of truth. Therefore, any modifications, such as adding or deleting resources, must be made through the GitHub repository.

## Step 2: Build

!!! info
    The initial build starts automatically when you create the API proxy, and you will be redirected to the **Build** page. In this case, you can skip the steps below. If you need to manually trigger a build later, follow these steps.

1. On the project home page, click on the `Department Service` component you created. This takes you to the component overview page.
2. In the left navigation menu, click **Build**.
3. On the **Build** page, click **Build Latest**.

!!! note
    The build process may take some time. You can track progress in the **Build Details** pane. Once complete, the build status changes to **Success**.

## Step 3: Deploy the API proxy

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**. This opens the **Configure & Deploy** pane.
3. Select **External** as the **API Access Mode** and click **Deploy**. The **Development** card indicates the **Deployment Status** as **Active** when the API proxy is successfully deployed.

Now you are ready to test the API proxy.

## Step 4: Test the API proxy

Choreo allows you to test your API proxy using either the [integrated OpenAPI Console](../../testing/test-rest-endpoints-via-the-openapi-console.md) or [cURL](../../testing/test-apis-with-curl.md). In this guide, you will use the OpenAPI Console.

!!! tip
    Choreo enables OAuth 2.0 to secure APIs by default. Therefore, you need an access token to invoke an API.

    - Choreo automatically generates a key to test the API via the OpenAPI Console. To view the key, click the show key icon in the **Security Header** field.
    - To disable security for the entire API or a specific resource:
        1. In the left navigation menu, click **Deploy**.
        2. Go to the **Build Area** card and click **Security Settings**.
        3. In the **Security Settings** pane:
            - To disable security for the entire API, clear the **OAuth2** checkbox.
            - To disable security for a specific resource, expand the relevant resource and turn off the **Security** toggle.
        4. Click **Apply**.

1. In the left navigation menu, click **Test** and then click **OpenAPI Console**.
2. Select **Development** from the environment drop-down list.
3. Expand the `GET /department/{departmentId}` resource and click **Try it Out**.
4. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

    ![API proxy response](../../assets/img/develop-components/develop-a-rest-api-proxy/rest-api-proxy-response.png){.cInlineImage-full}

    This indicates that your API proxy is working as expected.

## Step 5: Manage the API proxy

Now that you have a tested API proxy, you can publish it and make it available for application developers to consume. In this guide, you will apply rate limiting to the API and publish it.

### Step 5.1: Apply rate limiting to the API proxy

1. In the left navigation menu, click **Deploy**.
2. Go to the required environment card and click the settings icon corresponding to **API Configuration**.
3. In the **CORS, Rate Limiting and Resiliency** pane, click **Rate Limiting** to expand the section.
4. Select **API Level** as the **Rate Limiting Level**.
5. Specify appropriate values for the **Request Limit** and **Time Unit** fields. You can proceed with the default values.
6. Click **Apply**. This applies the rate limiting level to the API proxy and redeploys it.

### Step 5.2: Publish the API proxy

1. In the left navigation menu, click **Lifecycle** under **Manage**. This takes you to the **Lifecycle** page.
2. Click **Publish**.
3. In the **Publish API** dialog, click **Confirm** to proceed with publishing the API. If you want to change the display name, make the necessary changes and then click **Confirm**. This changes the API lifecycle state to **Published**.

## Step 6: Invoke the API

To generate credentials for the published API and invoke it via the Choreo Developer Portal, follow these steps:

1. In the **Lifecycle** page, click **Go to Devportal**. This takes you to the `Department Service` in the Choreo Developer Portal.

2. **Invoke the API**:
    1. In the Developer Portal left navigation menu, click **Try Out**.
    2. In the **Endpoint** list, select **Development** as the environment to try out the API.
    3. Click **Get Test Key** to generate an access token.
    4. Expand the `GET /department/{departmentId}` resource and click **Try it out**.
    5. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

        ![Try out response](../../assets/img/develop-components/develop-a-rest-api-proxy/try-out-response.png){.cInlineImage-full}

Now, you have gained hands-on experience creating, deploying, testing, and publishing an API proxy using Choreo.


# Develop an API Proxy from Scratch

An API proxy acts as an intermediary between an existing API and Choreo, intercepting all requests made to the API. It also functions as a managed API, allowing you to apply essential API management features such as security policies and rate limiting.

In this guide, you will:

- Create an API proxy component to expose an existing API.
- Deploy the API proxy.
- Test the API proxy to verify its functionality.
- Manage the API.
- Consume the API.

## Prerequisites

- If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

## Step 1: Create an API proxy

To create an API proxy, you can either upload an OpenAPI specification or provide an OpenAPI specification URL. In this guide, you will specify a URL to an OpenAPI definition of a sample API.

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **API Proxy** card. This opens the **Create an API Proxy** pane.
4. Select **Creare from Scratch** option. 
5. Specify the following values as Proxy Metadata:

    | **Field**       | **Value**                                  |
    |-----------------|--------------------------------------------|
    | **Context**     | `department-service`                                   |
    | **Version**     | `v1.0`                                      |
    | **Target**      | `https://samples.choreoapps.dev/company/hr` |

6. Enter following details for the Component Details:

    !!! info
        The **Component Name** field must be unique and cannot be changed after creation.

    | **Field**                 | **Value**          |
    |---------------------------|--------------------|
    | **Component Display Name**| `Department Service`          |
    | **Component Name**        | `department-service`          |
    | **Description**           | `Sample proxy for department service`     |

7. Click **Create**. This creates the API proxy component and takes you to the **Deploy** page.

## Step 2: Define resources for the API proxy

To add a new resource that retrieves a department by the department ID, follow these steps:

1. In the left navigation menu, click **Develop** and then click **Resources**.
2. Select **GET** as the **HTTP Verb** and enter `/department/{departmentId}` as the **URI Pattern**.
3. Click **+** to add the resource.
4. Expand the added resource and specify the following values:

    | **Field**        | **Value**                            |
    |------------------|--------------------------------------|
    | **Operation ID** | `findDepartment`                     |
    | **Description**  | `Find a department by department ID` |

5. Remove the five default resources that start with `/*` by clicking the delete icon corresponding to each resource.
6. Click **Save**.

## Step 3: Deploy the API proxy

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**. This opens the **Configure & Deploy** pane.
3. Select **External** as the API access mode and click **Deploy**. The **Development** card indicates the **Deployment Status** as **Active** when the API proxy is successfully deployed.

Now you are ready to test the API proxy.

## Step 4: Test the API proxy

Choreo allows you to test your API proxy using either the [integrated OpenAPI Console](../../testing/test-rest-endpoints-via-the-openapi-console.md) or [cURL](../testing/test-apis-with-curl.md). In this guide, you will use the OpenAPI Console.

!!! tip
    Choreo enables OAuth 2.0 to secure APIs by default. Therefore, you need an access token to invoke an API.

    - Choreo automatically generates a key to test the API via the OpenAPI Console. To view the key, click the show key icon in the **Security Header** field.
    - To disable security for the entire API or a specific resource:
        1. In the left navigation menu, click **Deploy**.
        2. Go to the **Build Area** card and click **Security Settings**.
        3. In the **Security Settings** pane:
            - To disable security for the entire API, clear the **OAuth2** checkbox.
            - To disable security for a specific resource, expand the relevant resource and turn off the **Security** toggle.
        4. Click **Apply**.

1. In the left navigation menu, click **Test** and then click **OpenAPI Console**.
2. Select **Development** from the environment drop-down list.
3. Expand the `GET /department/{departmentId}` resource and click **Try it Out**.
4. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

    ![API proxy response](../../assets/img/develop-components/develop-a-rest-api-proxy/rest-api-proxy-response.png){.cInlineImage-full}

    This indicates that your API proxy is working as expected.

## Step 5: Manage the API proxy

Now that you have a tested API proxy, you can publish it and make it available for application developers to consume. In this guide, you will apply rate limiting to the API and publish it.

### Step 5.1: Apply rate limiting to the API proxy

1. In the left navigation menu, click **Deploy**.
2. Go to the required environment card and click the settings icon corresponding to **CORS, Rate Limiting and Resiliency**.
3. In the **CORS, Rate Limiting and Resiliency** pane, click **Rate Limiting** to expand the section.
4. Select **API Level** as the **Rate Limiting Level**.
5. Specify appropriate values for the **Request Limit** and **Time Unit** fields. You can proceed with the default values.
6. Click **Apply**. This applies the rate limiting level to the API proxy and redeploys it.

### Step 5.2: Publish the API proxy

1. In the left navigation menu, click **Lifecycle** under **Manage**. This takes you to the **Lifecycle** page.
2. Click **Publish**.
3. In the **Publish API** dialog, click **Confirm** to proceed with publishing the API. If you want to change the display name, make the necessary changes and then click **Confirm**. This changes the API lifecycle state to **Published**.

## Step 6: Invoke the API

To generate credentials for the published API and invoke it via the Choreo Developer Portal, follow these steps:

1. In the **Lifecycle** page, click **Go to Devportal**. This takes you to the `Department Service` in the Choreo Developer Portal.

2. **Invoke the API**:
    1. In the Developer Portal left navigation menu, click **Try Out**.
    2. In the **Endpoint** list, select **Development** as the environment to try out the API.
    3. Click **Get Test Key** to generate an access token.
    4. Expand the `GET /department/{departmentId}` resource and click **Try it out**.
    5. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

        ![Try out response](../../assets/img/develop-components/develop-a-rest-api-proxy/try-out-response.png){.cInlineImage-full}

Now, you have gained hands-on experience creating, deploying, testing, and publishing an API proxy using Choreo.

# Develop a Ballerina Service

Choreo allows you to develop and deploy applications using your preferred programming language. This guide demonstrates how to deploy a service component that exposes a REST API using the [Ballerina language](https://ballerina.io/). No prior knowledge of Ballerina is required to follow this guide.

A REST API is a web service that adheres to Representational State Transfer (REST) principles, using HTTP methods to access and manage resources. This guide walks you through building a Ballerina service component, deploying it on Choreo, and testing it with an HTTP client application.

In this guide, you will:

 - Build a simple greeting service using a sample implementation. The service has a single resource named `greet` that accepts a query parameter as input.
 - Deploy the service in Choreo.
 - Test the service.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    - Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    - Enter a unique organization name. For example, `Stark Industries`.
    - Read and accept the privacy policy and terms of use.
    - Click **Create**. This creates the organization and opens the **Project Home** page.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample greetings service](https://github.com/wso2/choreo-samples/tree/main/greeting-service) implementation in Ballerina.

### Learn the repository file structure

It’s important to understand the purpose of key files in the sample service. The table below provides an overview of each file in the greeter service:

!!! note
    The file paths are relative to `<sample-repository-dir>/greeting-service`.

| **Filepath**              | **Description**                                                |
|---------------------------|---------------------------------------------------------------|
| `service.bal`             | The greetings service code written in Ballerina.               |
| `tests/service_test.bal`  | Test files related to the `service.bal` file.                  |
| `Ballerina.toml`          | The Ballerina configuration file.                              |

Let’s get started!

## Step 1: Create a service component

To create a Ballerina service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the **Project Home** page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect your GitHub account. If you haven’t connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Provide the following repository details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **Repository**         | choreo-samples     |
    | **Branch**             | **`main`**         |
    |**Component Directory** | `/greeting-service` |

6. Select **Ballerina** as the buildpack.

7. Provide a display name, a unique name, and a description for the service component:

    !!! info
        The **Component Name** field specifies a unique identifier for the component. This name cannot be changed after creation.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Ballerina Greetings`   |
    | **Component Name**        | `ballerina-greetings`   |
    | **Description**           | Send greetings          |

8. Click **Create**. This creates the component and takes you to the **Overview** page.

You have successfully created a service that exposes a REST API written in Ballerina. Next, let’s build and deploy the service.

## Step 2: Build and deploy

Now that you’ve connected the source repository and configured the endpoint details, it’s time to build and deploy the service.

!!! note
    If you’re rebuilding the Ballerina service component after changing the Ballerina version, ensure that the version in the `Ballerina.toml` file matches the version in the `Dependencies.toml` file.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service may take a while. Track the progress via the logs in the **Build Details** pane. Once complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps:

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane, click **Next** to skip the configuration.
4. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service may take a while. Once deployed, the **Development** environment card shows the **Deployment Status** as **Active**.

Once deployed, you can test, manage, and observe the service like any other component in Choreo.

For detailed instructions, see the following sections:
- [Step 3: Test](../../testing/test-rest-endpoints-via-the-openapi-console.md)
- [Step 4: Manage](../../api-management/lifecycle-management.md)

## Manage the deployment

To view Kubernetes-level insights for detailed diagnosis of this Ballerina REST API, see Choreo’s [DevOps capabilities](../../devops-and-ci-cd/view-runtime-details.md).


# Develop a Service with Docker

Choreo allows you to create and deploy applications in any language. This guide demonstrates how to develop and deploy a containerized service component using a Dockerfile.

In this guide, you will:

 - Create a containerized service component using a sample service implementation. The sample service has a single resource named `greet` that accepts a query parameter as input.
 - Deploy the service in Choreo using a Dockerfile. The service will run on port 9090.
 - Test the service.

If you want to create a service component that exposes a Ballerina service, see [Develop a Ballerina Service](develop-a-ballerina-service.md).

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    - Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    - Enter a unique organization name. For example, `Stark Industries`.
    - Read and accept the privacy policy and terms of use.
    - Click **Create**. This creates the organization and opens the **Project Home** page.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample greetings service](https://github.com/wso2/choreo-samples/tree/main/greeting-service-go) implementation with the Dockerfile.

### Learn the repository file structure

It’s important to understand the purpose of key files in the sample service. The table below provides an overview of each file in the greeter service:

!!! note
    The file paths are relative to `<sample-repository-dir>/greeting-service-go`.

| **Filepath**               | **Description**                                                              |
|----------------------------|------------------------------------------------------------------------------|
| `main.go`                  | The Go-based greeter service code.                                           |
| `Dockerfile`               | The Dockerfile to build the container image of the application.              |
| `.choreo/component.yaml`   | Choreo-specific configuration that provides information about how Choreo exposes the service. |
| `openapi.yaml`             | The OpenAPI contract of the greeter service. This is required to publish the service as a managed API. This file is referenced by the `.choreo/component.yaml` file. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints. The greeter service runs on port 9090. To securely expose the service through Choreo, you must provide the port and other required information in the `component.yaml` file. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

In the greeter sample, the `component.yaml` file is located in the `greeting-service-go/.choreo/` directory.

## Step 1: Create a service component from a Dockerfile

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/cloud-native-app-developer) and sign in. This opens the **Project Home** page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect your GitHub account. If you haven’t connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
         - Read and write access to code and pull requests.
         - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following repository details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **Repository**         | choreo-samples     |
    | **Branch**             | `main`         |
    | **Component Directory** | `/greeting-service-go`         |

6. Select **Docker** as the buildpack.
7. Enter the following details:

    | **Field**                | **Value**                        |
    |--------------------------|----------------------------------|
    | **Dockerfile**           | `/greeting-service-go/Dockerfile`|

    !!! info
        1. To successfully build your container with Choreo, explicitly define a user ID (UID) under the `USER` instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-sample-apps/blob/main/go/greeter/Dockerfile).
           - A valid User ID is a numeric value between 10000-20000 (e.g., `10001` or `10500`).
           - Usernames are invalid and should not be used (e.g., `my-custom-user-12221` or `my-custom-user`).

        2. The Dockerfile used in this guide is a multi-stage Dockerfile, which keeps the final image size small and allows building the application with specific versions of tools and libraries.

8. Provide a display name, a unique name, and a description for the service component:

    !!! info
        The **Component Name** field specifies a unique identifier for the component. This name cannot be changed after creation.

    | **Field**                 | **Value**          |
    |---------------------------|--------------------|
    | **Component Display Name**| `Greetings`        |
    | **Component Name**        | `greetings`        |
    | **Description**           | Send greetings     |

9. Click **Create**. This creates the component and takes you to the **Overview** page.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you’ve connected the source repository and configured the endpoint details, it’s time to build the service and create an image. Then, you can deploy the image and test the greeter service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service may take a while. Track the progress via the logs in the **Build Details** pane. Once complete, the build status changes to **Success**.

    You can access the following scans under **Build**:
    - **Dockerfile Scan**: Choreo checks if a non-root user ID is assigned to the Docker container for security. If no non-root user is specified, the build will fail.
    - **Container (Trivy) Vulnerability Scan**: This detects vulnerabilities in the final Docker image. If critical vulnerabilities are found, the build will fail.

    !!! info
        If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps:

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service may take a while. Once deployed, the **Development** environment card shows the **Deployment Status** as **Active**.

Once deployed, you can [test](../../testing/test-rest-endpoints-via-the-openapi-console.md), [manage](../../api-management/lifecycle-management.md), and [observe](../../monitoring-and-insights/observability-overview.md) the service like any other component in Choreo.

To view Kubernetes-level insights for detailed diagnosis of this Dockerfile-based REST API, see [Choreo's DevOps capabilities](../../devops-and-ci-cd/view-runtime-details.md).


# Develop a Service

Choreo allows you to create and deploy applications in your preferred programming language. 

In this guide, you will:

- Build a simple greeting service using a sample service implementation. The sample implementation will have a single resource named `greet` that accepts a single query parameter as input.
- Deploy the service in Choreo using a `Go` buildpack. The service will run on port 9090.
- Test the service.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample greetings service](https://github.com/wso2/choreo-samples/tree/main/greeting-service-go) implementation in `Go`.

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the greeter service:

!!! note 
    The specified file paths are relative to `<sample-repository-dir>/greeting-service-go`.

| **Filepath**             | **Description**                                                               |
|--------------------------|-------------------------------------------------------------------------------|
| `main.go`                | The Go-based greeter service code.                                            |
| `.choreo/component.yaml` | Choreo-specific configuration that provides information about how Choreo exposes the service. |
| `openapi.yaml`           | The OpenAPI contract of the greeter service. This is required to publish the service as a managed API. This `openapi.yaml` file is referenced by the `.choreo/component.yaml` file. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints. To run the greeter service on port 9090 and securely expose it through Choreo, you must provide the port and other required information in the `component.yaml` file. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

In the greeter sample, the `component.yaml` file is located in the `greeting-service-go/.choreo/` directory.

## Step 1: Create a service component

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Public Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Under **Connect a Git Repository**, enter the following details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **GitHub Repository**  | choreo-samples     |
    | **Branch**             | main               |
    | **Component Directory** | `/greeting-service-go` |

6. Select **Go** as the buildpack.
7. Enter the following details:

    | **Field**                | **Value**              |
    |--------------------------|------------------------|
    | **Language Version**     | 1.x                    |

8. Provide component display name, name and description:

    !!! info
        The **Component Name** field must be unique and cannot be changed after creation.

    | **Field**                 | **Value**          |
    |---------------------------|--------------------|
    | **Component Display Name**| Greetings          |
    | **Component Name**        | greetings          |
    | **Description**           | Send greetings     |

9. Click **Create**. This creates the component and lists it under **Component Listing** on the project home page.

You have successfully created the service. The next step is to build and deploy it.

## Step 2: Build and deploy

Now that you have connected the source repository and configured the endpoint details, it's time to build and deploy the greeter service.

### Step 2.1: Build

1. On the project home page, click on the `Greetings` component you created. This takes you to the component overview page.
2. In the left navigation menu, click **Build**.
3. On the **Build** page, click **Build Latest**.

    !!! note
        The build process may take some time. You can track progress in the **Build Details** pane. Once complete, the build status changes to **Success**.

### Step 2.2: Deploy

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take some time. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

Once you have successfully deployed the service, you can [test](../../testing/test-rest-endpoints-via-the-openapi-console.md), [manage](../../api-management/lifecycle-management.md), and [observe](../../monitoring-and-insights/observability-overview.md) it like any other component type in Choreo.


# Expose a Ballerina GraphQL Endpoint via a Service

Choreo offers the flexibility to develop and deploy applications in a language of your preference. This guide shows you how to deploy a service component that exposes a GraphQL API using the Ballerina language in Choreo. No prior knowledge of the Ballerina language is required to follow this guide. 

GraphQL API is a query language and runtime that provides a single endpoint for retrieving flexible and efficient data in a strongly-typed and self-documenting way. By following this guide, you will build a service component in Ballerina and deploy it on Choreo for any GraphQL client application to utilize it.

This guide shows how to build a simple reading list service and deploy it in Choreo using Ballerina. The GraphQL endpoint you create in this guide has two operations: **Query** and **Mutation**. The Query type operations read the data in the data source, and the Mutation operations update the data in the data source. The reading list service has two queries and three mutations as follows:

### Queries

**Retrieve the reading list**

This resource accepts an optional filter, `status`, which filters the reading list by reading status. Accepted values for status are `reading`, `read`, and `to_read`.

**Sample request**:
```
$ curl -X POST -H "Content-Type: application/json" -d '{"query": "query {allBooks (status: \"reading\") { id title author status }}"}' http://localhost:8090
```

**Sample response**
```
$ {
  "data": {
    "allBooks": [
      {
        "id": 1,
        "title": "Sample Book",
        "author": "Test Author",
        "status": "to_read"
      }
    ]
  }
}
```

**Retrieve a book item from the reading list**

This resource accepts a filter, `id`, which will select the book item from the reading list by book id.  The id is an Integer value. 

**Sample request**
```
$ curl -X POST -H "Content-Type: application/json" -d '{"query": "query {book (id: 1) { id title author status }}"}' http://localhost:8090
```

**Sample response**
```
$ {
  "data": {
    "book": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "to_read"
    }
  }
}
```

### Mutations

**Add a book item to the reading list**

This remote function accepts a book record as the input and consists of the title and the author. When you add a new book to the reading list, the method updates the reading status of the newly added book to `to_read`. This method returns the added book item upon successful execution.


**Sample request**

```
$ curl -X POST -H "Content-type: application/json" -d '{ "query": "mutation { addBook(book: {title: \"Sample Book\", author: \"Test Author\"}) { id title author status } }" }' 'http://localhost:8090'
```

**Sample response**

```
$ {
  "data": {
    "addBook": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "to_read"
    }
  }
}
```

**Update the reading status of a book**

This remote function requires `id` and `status` as inputs to update the reading status of the selected book. The `id` refers to the id of the book. It is an integer.  The `status` refers to the reading status that needs to be updated. This method returns the updated book item upon successful execution.

**Sample request**

```
$ curl -X POST -H "Content-type: application/json" -d '{ "query": "mutation { setStatus(id: 1, status: \"reading\") { id title author status } }" }' 'http://localhost:8090'
```

**Sample response**

```
$ {
  "data": {
    "setStatus": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "reading"
    }
  }
}
```

**Delete a book item from the reading list**

This remote function requires the `id` as the input to delete the book item from the reading list. This method returns the removed book item upon successful execution.

**Sample request**

```
$ curl -X POST -H "Content-type: application/json" -d '{ "query": "mutation { deleteBook(id: 1) { id title author status } }" }' 'http://localhost:8090'
```

**Sample response**
```
$ {
  "data": {
    "deleteBook": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "reading"
    }
  }
}
```

Our next step is to set up the resources that you will require to follow the guide, including the sample reading list application and the Choreo GitHub app.

## Prerequisites

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample GraphQL service](https://github.com/wso2/choreo-samples/tree/main/reading-list-graphql) implementation for this guide.

Let's get started!

## Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the reading list service.

!!! note
    The following file paths are relative to the path `<sample-repository-dir>/reading-list-graphql`.

|Filepath                 | Description                                                     |
|-------------------------|-----------------------------------------------------------------|
| `service.bal`           | The reading list service code written in the Ballerina language.|
| `Ballerina.toml`        | The Ballerina configuration file.                               |
| `.choreo/component.yaml`| The configuration file with endpoint details.                   |

## Step 1: Create a service component 

To create a Ballerina service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**| `reading-list-graphql`    |.

6. Select **Ballerina** as the buildpack.

7. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Ballerina Reading List`|
    | **Component Name**        | `ballerina-reading-list`|
    | **Description**           | Manage a reading list   |

8. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service component that exposes a GraphQL API written in the Ballerina language. Next, let's build and deploy the service.

## Step 2: Build and deploy

Now that we have connected the source repository, it's time to build and deploy the reading list service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Configurations** pane that opens, click **Next** to skip the configuration.
4. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.
To build and deploy the service, follow the steps below:

Once you have successfully deployed your service, you can test, manage, and observe it like any other component type in Choreo.

For detailed instructions, see the following sections:

- [Step 3: Test](https://wso2.com/choreo/docs/testing/test-graphql-endpoints-via-the-graphql-console/)
- [Step 4: Manage](https://wso2.com/choreo/docs/manage/api-management/)


# Expose a gRPC Endpoint via a Service

Choreo allows you to create and deploy applications in your preferred programming language. One powerful option is gRPC, a high-performance and language-agnostic remote procedure call (RPC) framework. It utilizes [Protocol Buffers](https://github.com/protocolbuffers/protobuf) to define services and generate client/server code.

In this guide, you will learn to use Choreo to create a service component that exposes a gRPC server implemented in [Go](https://go.dev/), enabling efficient and scalable communication with any gRPC client application. No prior knowledge of the Go language is necessary to follow this guide.

By following this guide, you will:

- Create a simple gRPC server using a Service component.
- Link the containerized gRPC service to the Choreo component using the Dockerfile. 
    The greeter service has a single RPC method named `sayHello`. Following is the proto file the server and the client application are using:

    ```proto
    syntax = "proto3";
    option go_package = "github.com/wso2/choreo-samples/go-grpc/pkg";

    service greeter {
      rpc SayHello (HelloRequest) returns (HelloReply) {}
    }

    message HelloRequest {
      string name = 1;
    }

    message HelloReply {
      string message = 1;
    }
    ```

- Deploy the gRPC server component in Choreo. 
- Create a gRPC client using a Manual Trigger component. 
- Deploy the gRPC client.
- Invoke the gRPC server using a gRPC client and check the response through the Choreo log view.


## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample service](https://github.com/wso2/choreo-samples/tree/main/go-grpc) implementation for this guide.

Let's get started!

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the greeter service.

!!! note 
    The following file paths are relative to the path `<sample-repository-dir>/go-grpc`.

|File Path                |Description                                                                                   |
|-------------------------|----------------------------------------------------------------------------------------------|
| `main.go`               | The greeter service code written in the Go language.                                         |
| `greeter_client/main.go`| The greeter client application written in the Go language.                                   |
| `Dockerfile.server`     | The Dockerfile to build the container image of the server application.                       |
| `Dockerfile.client`     | The Dockerfile to build the container image of the client application.                       |
| `.choreo/component.yaml`| The Choreo-specific configuration that provides information about how Choreo exposes the service.|
| `pkg/greeter.proto`     | The interface definition of the gRPC service. This is used to generate the server and client stubs for the Go application.|

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints.

Let's run the gRPC server service component on port 8080. To securely expose the service through Choreo, you must provide the port and other required information to Choreo. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

Choreo looks for an `component.yaml` file inside the `.choreo` directory to configure the endpoint details of the containerized component. Ensure the `.choreo` directory is at the root of the Docker build context path.

In the gRPC server sample, the `component.yaml` file is at `go-grpc/.choreo/component.yaml`, where the build context path is `go-grpc`.

## Step 1: Create a service component with a gRPC endpoint

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
6. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

7. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory** | `go-grpc`                  |

8. Select **Docker** as the buildpack.
9. Enter the following information:
    
    | **Field**                | **Value**                  |
    |--------------------------|----------------------------|
    | **Dockerfile**           | `go-grpc/Dockerfile.server`|

    !!! info
        1.  To successfully build your container with Choreo, it is essential to explicitly define a User ID (UID) under the USER instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-samples/blob/main/go-grpc/Dockerfile.server).
        To ensure that the defined USER instruction is valid, it must conform to the following conditions:
            - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
            - Usernames are considered invalid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

        2. The Dockerfile utilized in this guide is a multi-stage Dockerfile, which is designed to keep the final image size small and provides the ability to build the application with a specific version of tools and libraries.

4. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go gRPC Server`        |
    | **Component Name**        | `go-grpc-server`        |
    | **Description**           | Send greetings          |
    
10. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you have connected the source repository, and configured the endpoint details, it's time to build the service and create an image. Then you can deploy the image and test the greeter service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

    You can access the following scans under **Build**. 

      - **The Dockerfile scan**: Choreo performs a scan to check if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
      - **Container (Trivy) vulnerability scan**: This detects vulnerabilities in the final docker image. 
      - **Container (Trivy) vulnerability scan**: The details of the vulnerabilities open in a separate pane. If this scan detects critical vulnerabilities, the build will fail.
     
        !!! info
            If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Environment Configurations** pane that opens, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

6. Once you have successfully deployed your service, navigate to the component overview page and copy the gRPC service URL. You need to provide that URL when setting up the client application later in this guide.

You have successfully deployed the gRPC server. Currently, the gRPC service is only accessible by the components deployed within the same project.

## Step 3: Invoke the gRPC service

Let's invoke the gRPC service that you created above, using a gRPC client. 

### Step 3.1: Create a manual task for the gRPC client

To create a manual task component, follow these steps:

1. On the Choreo Console header, click the **Project** list and select the project where you created the gRPC service component. This opens the project home page.
2. Go to the **Component Listing** section and click **+ Create**.
3. Click the **Manual Task** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**       | `go/grpc`                  |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                  |
    |--------------------------|----------------------------|
    | **Dockerfile**           | `go/grpc/Dockerfile.client`|

8. Enter a display name, a unique name, and a description for the component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go gRPC Client`        |
    | **Component Name**        | `go-grpc-client`        |
    | **Description**           | `Receive greetings`     |


9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

### Step 3.2: Build the gRPC client component

To build the component, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 3.3: Setup environment variables and deploy the gRPC client

The client application, in this case, the gRPC client, requires the server URL of the gRPC server service. This is read from the client application as an environment variable. Follow the steps below to configure the environment variable for the client application:

1. On the Choreo Console left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane that opens, click **+ Add**.
4. Specify the following name and value to configure the environment variable for the client application:

    | **Field**       | **Value**               |
    |-----------------|-------------------------|
    | **Name**        | `GREETER_SERVICE`       |
    | **Value**       | Paste the URL value copied after deploying the gRPC service via [step 2.2](#step-22-deploy) above.  Make sure to **drop the `http://` or `grpc://` part and the trailing `/` from the URL when copying**. For example, if the URL is `http://go-grpc-server-3192360657:8080/`, add only `go-grpc-server-3192360657:8080`.|

5.  Click **Add** and then click **Next**.
6.  Click **Deploy**.

### Step 3.4: Execute the gRPC client component

To execute the gRPC client, follow these steps:

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the gRPC client and generates logs.
   You can trigger multiple runs to generate multiple logs.

For details on what you can monitor via the execute page, see [Monitor executions](../develop-integrations/develop-a-manual-task.md#step-7-monitor-executions). 


# Expose a Prism-Based Mock Server Using an OpenAPI Specification

Choreo supports deploying [Prism-based](https://docs.stoplight.io/docs/prism/674b27b261c3c-prism-overview) mock servers using OpenAPI specifications. With the Choreo Prism mock service component, you can serve multiple mock servers, each based on a different OpenAPI specification, as separate endpoints.

By default, these mock servers serve static content generated from the examples in the configured OpenAPI Specification (OAS). 

## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [Prism mock service](https://github.com/wso2/choreo-samples/tree/main/prism-mock-service) artifacts for this guide.

## Step 1: Create a Prism mock service component

To create a Prism mock service component, follow these steps:
    
1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, you can paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    |**Component Directory**  | `prism-mock-service`    |

6. Select **Prism Mock** as the buildpack.
7. Enter a display name, a unique name, and a description for the service component.
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

8. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

## Step 2: Build and deploy the component

Now that you have successfully created the Prism mock service, it's time to build and deploy it.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**. This builds the service from the latest commit.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

Once you have successfully deployed the service, you can [test](../../testing/test-rest-endpoints-via-the-openapi-console.md), [manage](../../api-management/lifecycle-management.md), and [observe](../../monitoring-and-insights/observability-overview.md) it like any other component type in Choreo.

## Serve dynamic content

The Prism mock service can serve dynamic content according to the schema definitions in the OpenAPI specification. To use the Prism mock service with dynamic content, clients must add the `prefer:dynamic=true` header in the request.

To generate meaningful dynamic responses, you can use the `x-faker` attribute in schema definitions of the OpenAPI specification. For more information on dynamically generated responses with the `x-faker` attribute, see the [Prism documentation](https://docs.stoplight.io/docs/prism/9528b5a8272c0-dynamic-response-generation-with-faker).


# Expose a TCP Server via a Service

Choreo offers the flexibility to design and deploy applications in the programming language of your choice. One viable choice for specific network communication needs is TCP (Transmission Control Protocol). TCP provides a reliable, stream-oriented communication mechanism that ensures data integrity and orderliness during transmission. It's the go-to option for scenarios where guaranteed data delivery and error recovery are paramount.

In this guide, you will learn to use Choreo to create a service component that exposes a TCP server implemented in [Go](https://go.dev/), enabling efficient and scalable communication with any TCP client application. No prior knowledge of the Go language is necessary to follow this guide.

By following this guide, you will:

- Setup a TCP server
    - Create a simple TCP server using a service component.
    - Link the containerized TCP service to the Choreo component using a Dockerfile. 
    - Deploy the TCP server component in Choreo. 
- Setup a TCP client
    - Create a TCP client using a manual task component. 
    - Link the containerized TCP client to the Choreo component using a Dockerfile. 
    - Deploy the TCP client component in Choreo.
- Invoke the TCP server using a TCP client and observe the response through the Choreo log view.

## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample service](https://github.com/wso2/choreo-samples/tree/main/docker-tcp-service) implementation for this guide.

Let's get started!

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the sample service.

!!! note 
    The following file paths are relative to the path `<sample-repository-dir>/docker-tcp-service`.

|File Path                 |Description                                                                                   |
|--------------------------|----------------------------------------------------------------------------------------------|
| `server/main.go`         | The greeter service code written in the Go language.                                         |
| `client/main.go`         | The greeter client application written in the Go language.                                   |
| `Dockerfile.server`      | The Dockerfile to build the container image of the server application.                       |
| `Dockerfile.client`      | The Dockerfile to build the container image of the client application.                       |
| `.choreo/component.yaml` | The Choreo-specific configuration provides information about how Choreo exposes the service. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints.

Let's run the TCP server service component on port 5050. To securely expose the service through Choreo, you must provide the port and other required information to Choreo. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

Choreo looks for an `component.yaml` file inside the `.choreo` directory to configure the endpoint details of a containerized component. Place the `.choreo` directory at the root of the Docker build context path.

In our TCP server sample, the `component.yaml` file is at `docker-tcp-service/.choreo/component.yaml`, where the build context path is `docker-tcp-service`.

## Step 1: Create a service component with a TCP endpoint

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory** | `docker-tcp-service`                  |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-tcp-service/Dockerfile.server`|

    !!! info
        1.  To successfully build your container with Choreo, it is essential to explicitly define a User ID (UID) under the USER instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-samples/blob/main/docker-tcp-service/Dockerfile.server).
        To ensure that the defined USER instruction is valid, it must conform to the following conditions:
            - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
            - Usernames are considered invalid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

        2. The Dockerfile utilized in this guide is a multi-stage Dockerfile, which is designed to keep the final image size small and provides the ability to build the application with a specific version of tools and libraries.

8. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go TCP Server`         |
    | **Component Name**        | `go-tcp-server`         |
    | **Description**           | Send greetings          |
    
9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you have connected the source repository, and configured the endpoint details, it's time to build the service and create an image. Then you can deploy the image and test the service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

    You can access the following scans under **Build**. 

      - **The Dockerfile scan**: Choreo performs a scan to check if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
      - **Container (Trivy) vulnerability scan**: This detects vulnerabilities in the final docker image. 
      - **Container (Trivy) vulnerability scan**: The details of the vulnerabilities open in a separate pane. If this scan detects critical vulnerabilities, the build will fail.
     
        !!! info
            If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Environment Configurations** pane that opens, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

6. Once you have successfully deployed your service, navigate to the component overview page and copy the TCP service address. You need to provide that address when setting up the client application later in this guide.

You have successfully deployed the TCP server. Currently, the TCP service is only accessible by the components deployed within the same project.

## Step 3: Invoke the TCP service

Now let's use a TCP client to invoke the TCP service that you created above. To do this, you can create a manual trigger component as the TCP client. This is the recommended approach because, in this example, it's more efficient to have a client that connects to the server, sends a request, and then stops. Here, a continuously executing task isn't required. Furthermore, if you use a manual trigger component, you won't need to expose an endpoint in the client for invocation, unlike with an API.

### Step 3.1: Create a manual trigger for the TCP client

To create a manual task component, follow these steps:

1. On the Choreo Console header, click the **Project** list and select the project where you created the TCP service component. This opens the project home page.
2. Go to the **Component Listing** section and click **+ Create**.
3. Click the **Manual Task** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Docker Context**      |`docker-tcp-service`     |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-tcp-service/Dockerfile.client`|

8. Enter a display name, a unique name, and a description for the component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**              |
    |---------------------------|------------------------|
    | **Component Display Name**| `Go TCP Client`        |
    | **Component Name**        | `go-tcp-client`        |
    | **Description**           | `Receive greetings`    |


9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

### Step 3.2: Build the TCP client component

To build the component, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 3.3: Setup environment variables and deploy the TCP client

The client application, in this case, the TCP client, requires the server URL of the TCP server service. This is read from the client application as an environment variable. Follow the steps below to configure the environment variable for the client application:

1. On the Choreo Console left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane that opens, click **+ Add**.
4. Specify the following name and value to configure the environment variable for the client application:

    | **Field**       | **Value**               |
    |-----------------|-------------------------|
    | **Name**        | `SERVER_ADDRESS`       |
    | **Value**       | Paste the URL value copied after deploying the TCP service via [step 2.2](#step-22-deploy) above.  Make sure to **drop the `tcp://` part and the trailing `/` from the URL when copying**. For example, add only `go-tcp-server-1097922445:8080`.|

5.  Click **Add** and then click **Next**.
6.  Click **Deploy**.

### Step 3.4: Execute the TCP client component

To execute the TCP client, follow these steps:

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the TCP client and generates logs.
   You can trigger multiple runs to generate multiple logs.

For details on what you can monitor via the execute page, see [Monitor executions](../develop-integrations/develop-a-manual-task.md#step-7-monitor-executions).


# Expose a UDP Server via a Service

Choreo offers the flexibility to design and deploy applications in the programming language of your choice. One compelling choice for certain network communication needs is UDP (User Datagram Protocol). UDP is a high-speed, connectionless protocol ideal for scenarios where lightweight, real-time data transmission is essential.

In this guide, you will learn to use Choreo to create a Service component that exposes a UDP server implemented in [Go](https://go.dev/), enabling efficient and scalable communication with any UDP client application. No prior knowledge of the Go language is necessary to follow this guide.

By following this guide, you will:

- Setup a UDP server
    - Create a simple UDP server using a Service component.
    - Link the containerized UDP service to the Choreo component using the Dockerfile. 
    - Deploy the UDP server component in Choreo. 
- Setup a UDP client
    - Create a UDP client using a manual task component. 
    - Link the containerized UDP client to the Choreo component using the Dockerfile. 
    - Deploy the UDP client component in Choreo.
- Invoke the UDP server using a UDP client and check the response through the Choreo log view.

## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample service](https://github.com/wso2/choreo-samples/tree/main/docker-udp-service) implementation for this guide.

Let's get started!

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the sample service.

!!! note 
    The following file paths are relative to the path `<sample-repository-dir>/docker-udp-service`.

|File Path                |Description                                                                                   |
|-------------------------|----------------------------------------------------------------------------------------------|
| `server/main.go`        | The greeter service code written in the Go language.                                         |
| `client/main.go`        | The greeter client application written in the Go language.                                   |
| `Dockerfile.server`     | The Dockerfile to build the container image of the server application.                       |
| `Dockerfile.client`     | The Dockerfile to build the container image of the client application.                       |
| `.choreo/component.yaml`| The Choreo-specific configuration provides information about how Choreo exposes the service. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints.

Let's run the UDP server service component on port 5050. To securely expose the service through Choreo, you must provide the port and other required information to Choreo. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

Choreo looks for an `component.yaml` file inside the `.choreo` directory to configure the endpoint details of a containerized component. Place the `.choreo` directory at the root of the Docker build context path.

In our gRPC server sample, the `component.yaml` file is at `docker-udp-service/.choreo/component.yaml`, where the build context path is `docker-udp-service`.

## Step 1: Create a service component with a UDP endpoint

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
6. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

7. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**   | `docker-udp-service`    |    

8. Select **Docker** as the buildpack.
9. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-udp-service/Dockerfile.server`|

    !!! info
        1.  To successfully build your container with Choreo, it is essential to explicitly define a User ID (UID) under the USER instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-samples/blob/main/docker-udp-service/Dockerfile.server).
        To ensure that the defined USER instruction is valid, it must conform to the following conditions:
            - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
            - Usernames are considered invalid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

        2. The Dockerfile utilized in this guide is a multi-stage Dockerfile, which is designed to keep the final image size small and provides the ability to build the application with a specific version of tools and libraries.

4. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go UDP Server`         |
    | **Component Name**        | `go-udp-server`         |
    | **Description**           | Send greetings          |

10. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you have connected the source repository, and configured the endpoint details, it's time to build the service and create an image. Then you can deploy the image and test the service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

    You can access the following scans under **Build**. 

      - **The Dockerfile scan**: Choreo performs a scan to check if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
      - **Container (Trivy) vulnerability scan**: This detects vulnerabilities in the final docker image. 
      - **Container (Trivy) vulnerability scan**: The details of the vulnerabilities open in a separate pane. If this scan detects critical vulnerabilities, the build will fail.
     
        !!! info
            If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Environment Configurations** pane that opens, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

6. Once you have successfully deployed your service, navigate to the component overview page and copy the UDP service address. You must provide that address when setting up the client application later in this guide.

You have successfully deployed the UDP server. Currently, the UDP service is only accessible by the components deployed within the same project.

## Step 3: Invoke the UDP service

Now let's use a UDP client to invoke the UDP service that you created above. To do this, you can create a manual trigger component as the UDP client. This is the recommended approach because, in this example, it's more efficient to have a client that connects to the server, sends a request, and then stops. Here, a continuously executing task isn't required. Furthermore, if you use a manual trigger component, you won't need to expose an endpoint in the client for invocation, unlike with an API.

### Step 3.1: Create a manual trigger for the UDP client

To create a manual task component, follow these steps:

1. On the Choreo Console header, click the **Project** list and select the project where you created the UDP service component. This opens the project home page.
2. Go to the **Component Listing** section and click **+ Create**.
3. Click the **Manual Task** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory** | `docker-udp-service`    |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-udp-service/Dockerfile.client`|

8. Enter a display name, a unique name, and a description for the component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**              |
    |---------------------------|------------------------|
    | **Component Display Name**| `Go UDP Client`        |
    | **Component Name**        | `go-udp-client`        |
    | **Description**           | `Receive greetings`    |


9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

### Step 3.2: Build the UDP client component

To build the component, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 3.3: Setup environment variables and deploy the UDP client

The client application, in this case, the UDP client, requires the server URL of the UDP server service. This is read from the client application as an environment variable. Follow the steps below to configure the environment variable for the client application:

1. On the Choreo Console left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane that opens, click **+ Add**.
4. Specify the following name and value to configure the environment variable for the client application:

    | **Field**       | **Value**               |
    |-----------------|-------------------------|
    | **Name**        | `SERVER_ADDRESS`       |
    | **Value**       | Paste the URL value copied after deploying the UDP service via [step 2.2](#step-22-deploy) above.  Make sure to **drop the `udp://` part and the trailing `/` from the URL when copying**. For example, add only `go-udp-server-1097922445:8080`.|

5.  Click **Add** and then click **Next**.
6.  Click **Deploy**.

### Step 3.4: Execute the UDP client component

To execute the UDP client, follow these steps:

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the UDP client and generates logs.
   You can trigger multiple runs to generate multiple logs.

For details on what you can monitor via the execute page, see [Monitor executions](../develop-integrations/develop-a-manual-task.md#step-7-monitor-executions).


# Expose a WebSocket Endpoint via a Service

Choreo allows you to create and deploy applications in your preferred programming language, offering a seamless platform for building dynamic and scalable solutions. This guide walks you through the steps to deploy a WebSocket service using the NodeJS buildpack.

WebSockets provide real-time, two-way communication between a client and server over a persistent TCP connection. This makes WebSocket APIs ideal for applications that require real-time updates.

In this guide, you will:

- Build a simple WebSocket service using a sample implementation in NodeJS.
- Deploy the service in Choreo, allowing any WebSocket client application to establish a connection and exchange real-time messages with your service.

## Prerequisites

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample WebSocket service](https://github.com/wso2/choreo-samples/tree/main/websocket-chat-app) implementation for this guide.

Let's get started!

## Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the NodeJS chat Application.

!!! note
    The following file paths are relative to the path `<sample-repository-dir>/websocket-chat-app/websocket-chat-service-nodejs`.

|Filepath                        | Description                                                     |
|--------------------------------|-----------------------------------------------------------------|
| `server.js`                    | The NodeJS chat service.                                        |
| `.choreo/component.yaml`       | The configuration file with endpoint details.                   |

!!! note
    Choreo currently supports defining WebSocket APIs using the AsyncAPI 2.0 specification.

## Step 1: Create a service component 

To create a NodeJS service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**   | `websocket-chat-app/websocket-chat-service-nodejs`  |

6. Select **NodeJS** as the buildpack and **18.x.x** as the Language Version

8. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:

    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `NodeJS Chat Service`   |
    | **Component Name**        | `nodejs-chat-service`   |
    | **Description**           | Manage a chat service   |

9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service component that provides a WebSocket API built with NodeJS. The next step is to proceed with building and deploying the service.

## Step 2: Build and deploy

Now that you have connected the source repository, it's time to build and deploy the chat service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane that opens, click **Next** to skip the configuration.
4. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

Once you have successfully deployed your service, you can [test](../../testing/test-websocket-endpoints-via-the-websocket-console.md), [manage](../../api-management/lifecycle-management.md), and observe it like any other component type in Choreo.

During testing, once the WebSocket connection is established, you can send {"type": "Connect", "username": "user1"} to the WebSocket endpoint to connect to the chat service. You can then send chat messages by using {"type": "Data", "message": "Hello, World!"}.

!!! note
     Some clients, such as certain browsers, may not support adding headers to the WebSocket handshake. In these cases, you can include the access token or test key required for WebSocket API invocation within the `sec-websocket-protocol` header, along with any specified subprotocols.

     For example: `sec-websocket-protocol: choreo-oauth2-token, {access token}, subprotocols`

     If you are using a test key, replace `choreo-oauth2-token` with `choreo-test-key`.


# Service Component Overview

Explore how to create, deploy, manage, and observe service components in Choreo.

## What is a service component?

A service component in Choreo lets you deploy and expose REST, GraphQL, gRPC, UDP, WS or TCP services. It is a fundamental building block for creating cloud-native applications in Choreo. They provide a simple and effective way to expose functionality as a service to other components within Choreo or to the outside world.

Service components encapsulate business logic and provide standardized interfaces, called endpoints, for communicating with other components or systems. You can deploy and scale services independently, which makes them highly flexible and adaptable to changing workloads.

With the help of the service component, developers can quickly create APIs and microservices, making it easier to implement and manage complex software systems. Service components can also be integrated with other Choreo components, that acts as message processors, connectors, and data sources, etc to create powerful end-to-end solutions.

You can expose a service to other components through endpoints. For details on configuring endpoints, see [Configure Endpoints](../configure-endpoints.md).


# Build and Deploy a Single-Page Web Application

A web application is an application program hosted on a server and serves ingress traffic through a browser. In Choreo, you can deploy a web application by creating a Web Application component and connecting it to a Git repository that contains the implementation of the web application. Web applications can fall into one of the following categories:

- **Single page applications (SPAs)**: Examples include React, Angular, Vue, Svelte, etc.
- **Web servers**: These serve static content or provide server-side rendering/static site generation (SSR/SSG).
- **Static content**: Examples include websites and other static resources that do not require a backend, usually comprising static HTML/JS/CSS files.

## Prerequisites

- To deploy a web application component, you must have a GitHub account with a repository containing the web application's implementation. For this guide, fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample web application implementation.

## Create a web application

You can create a web application in Choreo as follows:

### Build and deploy a SPA from source code

1. To create a web application component, connect a repository that includes the web application source code.
2. Select the relevant buildpack: Default buildpacks include **React**, **Angular**, and **Vue.js**. If you are using a different SPA framework, you can try one of these buildpacks because the configurations can be overridden to support most JavaScript-based SPAs.
3. Enter the build command: Based on your package manager (NPM, yarn, or pnpm). The relevant package manager is run based on the dependency lock file in your repository (defaults to NPM if no lock file is present).
4. Specify the build output directory.
5. Specify the NodeJS version: Choreo does not pick the Node.js version from the `package.json` engine property. The required Node version must be explicitly set in the build configuration.

Once you create the Web Application component, Choreo automatically generates a build pipeline for your single-page application and deploys it.

### Bring your Dockerfile

1. To create a web application component, connect a repository that contains the Dockerfile for your containerized web application.
2. Commit a Dockerfile to your connected Git repository to have full control over your build process.

This approach is recommended if you are deploying a web server and not just a single-page application (or a single-page application with a complex build process).

### Host static websites

1. Create a web application component and connect it to the GitHub repository that contains the required static assets.
2. Select the **Static Websites** buildpack: This buildpack does not trigger a build process. It only fetches the files from the path specified in the repository and serves them as-is.

## Build and deploy a SPA from source code

Follow the steps below to create a sample Web Application component and deploy it in Choreo:

1. Sign in to the Choreo Console at [https://console.choreo.dev/login/](https://console.choreo.dev/login/). This opens the **Project Home** page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Web Application** card.
6. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

7. Enter the following information:

    | **Field**                 | **Description**        |
    |---------------------------|------------------------|
    | **GitHub Account**        | Your account           |
    | **GitHub Repository**     | choreo-samples         |
    | **Branch**                | main                   |
    | **Component Directory**     | /react-single-page-app |

8. Select **React** as the **Buildpack**.
9. Enter the following information:

    | **Field**                 | **Description**        |
    |---------------------------|------------------------|
    | **Build Command**         | `npm run build`        |
    | **Build Path**            | `build`                |
    | **Node Version**          | `18`                   |

    !!! tip
        Managed authentication is enabled by default when you create a web application using **React**, **Angular**, or **Vue.js** buildpacks. To learn how to set up authentication for your web application with Choreo's managed authentication, see [Secure Web Applications with Managed Authentication](../../authentication-and-authorization/secure-web-applications-with-managed-authentication.md).

4. Specify a display name, a unique name and description for the component.
10. Click **Create**. Choreo initializes the component with the sample implementation and opens the **Overview** page of the component.

You have successfully created a Web Application component from the source code. Now let's build and deploy the web application.

## Build your web application

1. In the left navigation menu, click **Build**.
2. In the **Builds** pane, click **Build**. This opens the **Commits** pane, where you can see all the commits related to the component.
3. Select the latest commit and click **Build**. This triggers the build process and displays the progress in the **Build Logs** pane.

    You can access the following scans in the **Build Logs** pane:

    - **Dockerfile Scan**: Choreo checks if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
    - **Container (Trivy) Vulnerability Scan**: Detects vulnerabilities in the final Docker image. If critical vulnerabilities are detected, the build will fail.

    !!! info
        If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

    !!! note
        The build process may take some time. Once complete, the build status will be listed in the **Builds** pane. Here, you will see the build status as **Success**.

## Deploy and access your web application

1. In the left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure and Deploy**. This opens the **Configure & Deploy** pane. In this guide, you do not need to add a file mount.
3. Click **Next** to proceed to the **Authentication Settings** pane.
4. Keep the default settings and click **Deploy**.

    !!! note
        The deployment process may take a few minutes. Once complete, the **Deployment Status** will show as **Active** in the **Development** card.

5. To verify that the web application is hosted successfully, click the **Web App URL** in the **Development** card. This takes you to the web application.

## Create a short URL for your web application in production

!!! info
    This feature is only available on the Choreo cloud data plane.

When you promote your component to the Production environment, you can create a personalized short URL for your web application. The URL follows the `https://{your-short-prefix}.choreoapps.dev` structure, where you can select a name of your preference for `{your-short-prefix}`.

1. Click **Promote** in the **Development** card and promote your web application to production.
2. In the **Production** card, click **Create a short URL**.
3. Specify a **Short URL prefix** of your choice and click **Save**.

    !!! note
        Short URL names/prefixes are subject to availability, provided on a first-come-first-serve basis.

## Manage runtime configurations for web applications

For web applications with a backend server, Choreo allows you to mount runtime configurations and secrets as environment variables and/or file mounts for a specific environment. Alternatively, you can also inject them into the client application during server-side rendering or when serving static content.

For SPAs that run completely on the browser, Choreo does not support *baking-in* environment variables or other configurations. Instead, Choreo recommends the following approach (applicable to most SPA frameworks, including React):

!!! note
    - With SPAs, anything you mount as a runtime config will be available to your users in the browser.
    - **Do not include sensitive secrets that are not browser-safe**.

1. Go to your forked [Choreo samples repository](https://github.com/wso2/choreo-samples).
2. Open the `public` directory.
3. Create and commit a new file named `config.js` in the `public` directory of your React application. This file should contain the runtime configuration variables you want to expose to your application, such as API endpoints or feature flags. For example:

    ```javascript
    window.config = {
        apiUrl: 'https://api.example.com',
        featureFlags: {
            enableNewFeature: true,
            enableExperimentalFeature: false,
        },
    };
    ```

4. In your `index.html` file inside the `public` directory, add a script tag to include the `config.js` file inside the `<body>` tag:

    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>My React App</title>
    </head>
    <body>
        <div id="root"></div>
        <script src="%PUBLIC_URL%/config.js"></script>
    </body>
    </html>
    ```

5. In your React component, access the configuration variables by referencing the `window.config` object:

    ```javascript
    import React from 'react';

    function MyComponent() {
        const apiUrl = window.config.apiUrl;
        const enableNewFeature = window.config.featureFlags.enableNewFeature;
        const enableExperimentalFeature = window.config.featureFlags.enableExperimentalFeature;

        // ...
    }
    ```

6. When you deploy your component to Choreo, create a config file mount in the specified path for each environment (where your `index.html` expects the `config.js` file). For more details, see [Manage Configurations and Secrets](https://wso2.com/choreo/docs/devops-and-ci-cd/manage-configurations-and-secrets/#apply-a-file-mount-to-your-container).

## Limitations

The following limitations are specific to the Choreo cloud data plane:

- **Request size limit**: 256KB (including headers, cookies, and payloads).
- **Response body size limit**: 20MB.
- **Open ports**: Only one open port is permitted per web application. While you can have multiple ports open for project-level communication within a data plane, incoming traffic from the internet can only be directed to one port. This differs from Service-type components, which support multiple endpoints.

## Troubleshoot a web application

- **Blank page or 502 error after deployment**:
    If you encounter a blank page or a 502 error after deploying your web application, it typically indicates that the wrong directory is being served. To resolve this issue:
    1. Double-check the build output directory, especially if you are using a Dockerfile-less buildpack.
    2. Ensure that the specified output directory matches the actual output directory generated during the build process. For example, if you have erroneously entered `public/` as the output directory when it should have been `build/`.

By verifying and correcting the output directory alignment, you should be able to address the issue of encountering a blank page or experiencing a 502 error on deploying your web application.


# Develop Web Applications Locally with Choreo’s Managed Authentication

Choreo’s managed authentication capability provides a set of backend for frontend (BFF) endpoints to facilitate authentication and authorization for web applications. These endpoints are readily available for single-page web applications deployed on Choreo.

As a web application developer, you may need to run the application on your local workstation. Choreo’s local development capability ensures that authentication and authorization during local development work the same way as they do when the application is deployed to Choreo, eliminating the need for code changes.

This guide explains how to configure and use Choreo’s local development capability to streamline your workflow.

## How local development works in Choreo

Local development uses a proxy that sits in front of the locally running web application. This proxy intercepts all incoming requests:
- Requests to `/choreo-apis/*` and `/auth/*` are forwarded to Choreo.
- All other requests are forwarded to the locally running web application.

The proxy runs on HTTPS using a self-signed certificate, which is essential for secure, HTTP-only cookie-based managed authentication. Once the proxy is running, you can access the web application using the proxy's URL and start developing locally. The behavior of the web application, in terms of managed authentication, will mirror its behavior when deployed to Choreo.

## Configure local development

### Prerequisites

- Create a single-page application (SPA) with managed authentication enabled. For details, see [Secure Web Applications with Managed Authentication](../../authentication-and-authorization/secure-web-applications-with-managed-authentication.md#step-1-set-up-managed-authentication-for-your-web-application).
- Promote and deploy the application to the environment where you want to enable local development.

    !!! note
        - The locally running web application will use the same managed authentication configuration as the environment where local development is configured.
        - Local development is only allowed in non-critical environments.

### Apply configurations

1. Sign in to the Choreo Console.
2. In the **Component Listing** pane, click on the component you created and deployed.
3. In the left navigation menu, click **Deploy**.
4. Go to the respective environment card and click **Local Development**.
5. In the **Local Development** pane, toggle **Local Development** to enable it.
6. (Optional) To update the port on which the local development proxy server runs, expand **Advanced Configurations** and specify a value for **Proxy Port**.
7. Click **Apply**.

You have now configured local development. The next section explains how to access your web application for local development.

## Access your web application locally

### Prerequisites

- Ensure local development is enabled in the desired environment.
- Ensure your web application is running locally on `http://localhost` on a specific port.

### Access your web application locally

You can use either the Choreo built-in identity provider or an external identity provider to access your web application locally.

=== "Use the Choreo built-in identity provider"

    1. Sign in to the Choreo Console.
    2. In the **Component Listing** pane, click on the component you created and deployed.
    3. In the left navigation menu, click **Deploy**.
    4. Go to the respective environment card and click **Local Development**.
    5. In the **Local Development** pane, copy the command under **Step 1**.
    6. Paste the command in a terminal, replace `[APP_PORT]` with the port on which your application is running locally, and run the command.
    7. To access the application, go to the URL provided under **Step 2** in the **Local Development** pane.

        !!! note
            The local development proxy runs on HTTPS using a self-signed certificate. Your browser may warn that the certificate is not valid. Accept the risk and proceed.

=== "Use an external identity provider"

    1. Sign in to the Choreo Console.
    2. In the **Component Listing** pane, click on the component you created and deployed.
    3. In the left navigation menu, click **Deploy**.
    4. Go to the respective environment card and click **Local Development**.
    5. In the **Local Development** pane, copy the redirect URLs under **Step 1**.
    6. Go to the settings in the OAuth application in your identity provider and specify the copied URLs as allowed redirect URLs.
    7. In the **Local Development** pane, copy the command under **Step 2**.
    8. Paste the command in a terminal, replace `[APP_PORT]` with the port on which your application is running locally, and run the command.
    9. To access the application, go to the URL provided under **Step 3** in the **Local Development** pane.

        !!! note
            The local development proxy runs on HTTPS using a self-signed certificate. Your browser may warn that the certificate is not valid. Accept the risk and proceed.


# Create a Connection

Connections in Choreo provide a simple and uniform approach to seamlessly integrate components with services or resources.

Choreo allows you to create connections to services deployed in Choreo or registered as external services. It also allows you to create connections to any Choreo-managed database.

To create a connection to a service or a database, follow the step-by-step instructions in the respective tab:

=== "Create a connection to a service"

    <h2>Create a connection to a Choreo service</h2>

    Follow these steps to create a connection to a service deployed in Choreo:

    1. In the Choreo Console, go to the top navigation menu and set the visibility level as [project](../../choreo-concepts/connections.md#project-connections) or [component](../../choreo-concepts/connections.md#component-connections) as follows: 

        - **Project Connection**: Select an organization and a project in that organization. 
        - **Component Connection**: Select an organization, a project in that organization, and a component in the selected project. 

    2. In the left navigation menu, click **Dependencies**  and then **Connections**. This page lists all the existing connections.
    3. Click **+Create**. This opens the Marketplace view where you can browse and search for services or databases.
    4. Click the **Services** tab. You can search and apply filters to efficiently find a service.
    5. Click on the service you want to connect to. 
    6. Enter a name and a description for the connection.
    7. Select an **Access Mode** and **Authentication Scheme** for the connection.
    8. Click **Create**.
   
    This creates the connection and displays its details for each environment, along with an inline guide on how to use the connection in your component. 

    !!! note
        During connection creation, secret values for the lowest environment are visible, allowing you to copy them for local use if necessary. Secret values for higher environments remain hidden to ensure security
     
    <h2>Create a connection to an external service</h2>

    Follow these steps to create a connection to an external service:

    1. Follow steps 1–5 from the previous section.
    2. Expand the **Environment to Endpoint** section and verify the service endpoints assigned to the Choreo environments.
    3. Click **Create**.

      For step-by-step instructions on using a connection in your service, see [Use a Connection in Your Service](./use-a-connection-in-your-service.md).

      For step-by-step instructions on using a connection in your web application, see [Use a Connection in Your Web Application](./use-a-connection-in-your-web-application.md).


=== "Create a connection to a database"

    Prerequisites:

     - Create a Choreo-managed database. For details, see [Choreo-Managed Databases and Caches](../../manage-databases-and-caches/choreo-managed-databases-and-caches.md).
     - Add the database to the Marketplace. For details, see [Add Choreo-Managed Databases and Caches to the Marketplace](../../manage-databases-and-caches/add-choreo-managed-databases-and-caches-to-the-marketplace.md).

    Follow these steps to create a connection to a Choreo-managed database:

    1. In the Choreo Console, go to the top navigation menu and set the visibility level as [project](../../choreo-concepts/connections.md#project-connections) or [component](../../choreo-concepts/connections.md#component-connections) as follows: 

        - **Project Connection**: Select an organization and a project in that organization. 
        - **Component Connection**: Select an organization, a project in that organization, and a component in the selected project. 

    2. In the left navigation menu, click **Dependencies**  and then **Connections**. This page lists all the existing connections.
    3. Click **+Create**. This opens the Marketplace view where you can browse and search for services or databases.
    4. Click the **Databases** tab. You can search and apply filters to efficiently find a database.
    5. Click on the database you want to connect to. 
    6. To create the connection, follow these steps:

        1. Enter a name and description.
        2. Under **Environment Configuration**, select credentials for each environment.

            !!! note
                 By default, the selected database is applied to all environments. To use different databases for specific environments, select the appropriate database and provide the corresponding credentials for each environment.

        3. Click **Create**.  
    
    This creates the connection and displays the database connection details for each environment, along with an inline guide on how to use the connection in your component. 

    !!! note
        During connection creation, secret values for the lowest environment are visible, allowing you to copy them for local use if necessary. Secret values for higher environments remain hidden to ensure security
    
    For step-by-step instructions on using a database in your component, see [Use a Database Connection in Your Component](./use-a-database-connection-in-your-component.md).


# Use a Connection in Your Service

Choreo allows you to share and reuse your services, accelerating development and enhancing efficiency in building integrated applications through connections.

For step-by-step on instruction on creating a connection, see [Create a Connection](create-a-connection.md).

To learn more about Choreo Connections, see the documentation on [Connections](../../choreo-concepts/connections.md).

## Consume a service through a connection

You can consume a Choreo-deployed service within another service. Consuming connections from within Choreo services is seamless and straightforward. Follow the steps below to consume a Choreo service:

### Step 1: Add connection configurations

To integrate another service into your application, click the appropriate tab below based on your current configuration file and follow the step-by-step instructions:

=== "Component.yaml file (v1.1)"

    1. Copy and paste the snippet from the in-line developer guide into the `component.yaml` file.

        The following is a sample snippet: 

        ``` yaml

        dependencies:
            connectionReferences:
            - name: <CONNECTION_NAME>
              resourceRef: <RESOURCE_IDENTIFIER>

        ```

          | Field            | Description                                                         |
          |------------------|---------------------------------------------------------------------|
          | name             | The name given to the connection.                                   |
          | resourceRef      | A unique, readable identifier of the service being connected to.    |


    2. If you've previously added a `connectionReferences` section under `dependencies`, append this as another item under `connectionReferences`. Upon deploying the component, Choreo automatically creates a subscription if applicable and the necessary configurations to establish the connection will be injected into the Choreo-defined environment variables.
      
          The following table details the Choreo-defined environment variables:

          | Configuration Key       | Choreo-Defined Environment Variable Name                       |
          |-------------------------|----------------------------------------------------------------|
          | ServiceURL              | CHOREO_<CONNECTION_NAME\>_SERVICEURL                           |
          | ConsumerKey             | CHOREO_<CONNECTION_NAME\>_CONSUMERKEY                          |
          | ConsumerSecret          | CHOREO_<CONNECTION_NAME\>_CONSUMERSECRET                       |
          | TokenURL                | CHOREO_<CONNECTION_NAME\>_TOKENURL                             |
          | ChoreoAPIKey            | CHOREO_<CONNECTION_NAME\>CHOREOAPIKEY                          |


          If you want to use custom environment variable names instead of the Choreo-defined ones, you must define the environment configurations under the `configuration` section in the same file.
          The following is a sample snippet: 

          ``` yaml
          configuration:
            env:
              - name: HR_SERVICE_URL
                valueFrom:
                  connectionRef:
                    name: hr-connection
                    key: ServiceURL
          ```

          The following table provides details on the configuration keys associated with the connection. These keys can be referenced as `env[i].valueFrom.connectionRef.key`.

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | ServiceURL     | string     | Service URL of the Choreo service     | false         | false        |
          | ConsumerKey    | string     | Consumer key of the Choreo service    | false         | false        |
          | ConsumerSecret | string     | Consumer secret of the Choreo service | false         | true         |
          | TokenURL       | string     | Token URL of the STS                  | false         | false        |
          | ChoreoAPIKey   | string     | API key of the Choreo service         | false         | true         |

          For more details, see the instructions under the **component.yaml file (v1.1)** tab.

    ### Step 2: Read configurations within the application

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const serviceURL = process.env.CHOREO_<CONNECTION_NAME>_SERVICEURL;
    ```

=== "Component.yaml file (v1.0)"

    !!! note
        This `component.yaml v1.0` is a legacy configuration format. For new projects, we recommend using the latest version (v1.1) of `component.yaml` for improved usability and features.
  
    1. Copy and paste the snippet from the in-line developer guide into the `component.yaml` file.
      
        The following is a sample snippet:

        ``` yaml

        dependencies:
            serviceReferences:
            - name: <SERVICE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: ServiceURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerSecret
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: TokenURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ChoreoAPIKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>

        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the service you are connecting to.              |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added a service reference section under `dependencies`, append this as another item under `serviceReferences`. 

          Upon deploying the component, Choreo automatically creates a subscription if applicable and populates the specified environment variables with actual values.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | ServiceURL     | string     | Service URL of the Choreo service     | false         | false        |
          | ConsumerKey    | string     | Consumer key of the Choreo service    | false         | false        |
          | ConsumerSecret | string     | Consumer secret of the Choreo service | false         | true         |
          | TokenURL       | string     | Token URL of the STS                  | false         | false        |
          | ChoreoAPIKey   | string     | API key of the Choreo service         | false         | true         |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const serviceURL = process.env.SVC_URL;
    ```

=== "Component-config.yaml file"

    !!! note
        This `component-config.yaml` is a legacy configuration format. For new projects, we recommend using the latest version (v1.1) of `component.yaml` for improved usability and features.

    1. Copy and paste the snippet from the in-line developer guide into the `component-config` file under the `spec` section.

        The following is a sample snippet:

        ``` yaml

        outbound:
            serviceReferences:
            - name: <SERVICE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: ServiceURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerSecret
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: TokenURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ChoreoAPIKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>

        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the service you are connecting to.              |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added an outbound service reference, append this as another item under `serviceReferences`. 

          Upon deploying the component, Choreo automatically creates a subscription if applicable and populates the specified environment variables with actual values.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | ServiceURL     | string     | Service URL of the Choreo service     | false         | false        |
          | ConsumerKey    | string     | Consumer key of the Choreo service    | false         | false        |
          | ConsumerSecret | string     | Consumer secret of the Choreo service | false         | true         |
          | TokenURL       | string     | Token URL of the STS                  | false         | false        |
          | ChoreoAPIKey   | string     | API key of the Choreo service         | false         | true         |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const serviceURL = process.env.SVC_URL;
    ```

If you're using the API key security scheme for the connection, skip Step 3 and follow the instructions in [Step 4: API key security scheme](#step-4-invoke-the-service) tab.

### Step 3: Acquire an OAuth 2.0 access token

To consume a Choreo service with the visibility level set to organization or public and secured by the OAuth 2.0 security scheme, you must obtain an OAuth 2.0 token from the token endpoint. Subsequently, you can use the token to invoke the service.

- For languages with OAuth 2.0-aware HTTP clients, you must pass the OAuth 2.0-related configurations such as client id, client secret and so on, obtained when creating the connection to your HTTP client configuration. The HTTP client autonomously manages token retrieval and refreshing.

- For languages without OAuth 2.0-aware HTTP clients, you must manually initiate a call to the token endpoint. This includes fetching the token and managing token expiration and refresh directly within your application code. The following is a sample curl command to obtain a token:


    ```bash
    CONSUMER_KEY="your_consumer_key"
    CONSUMER_SECRET="your_consumer_secret"
    TOKEN_URL="your_token_url"

    # Encode client credentials as Base64
    CLIENT_CREDENTIALS=$(echo -n "$CLIENT_ID:$CLIENT_SECRET" | base64)

    curl -X POST $TOKEN_URL \
      -H "Content-Type: application/x-www-form-urlencoded" \
      -H "Authorization: Basic $CLIENT_CREDENTIALS" \
      --data-urlencode "grant_type=client_credentials"

    ```

### Step 4: Invoke the service

Click the tab that matches the security scheme of your service and follow the instructions below:

=== "API key security scheme"

     To invoke the API, use the `choreo-api-key` header with the API key value retrieved from the corresponding environment variable as described in [step 2](#step-2-read-configurations-within-the-application).

     The following is a sample code snippet in NodeJS:

     ``` java
       const response = await axios.get(serviceURL/{RESOURCE_PATH}, {
           headers: {
             'Choreo-API-Key': `${choreoApiKey}`
           }
       });
     ```

=== "OAuth 2.0 security scheme"

     To invoke the service, use the following instructions based on your programming language:

      - For languages with OAuth 2.0-aware HTTP clients, use the service URL resolved in [Step 2](#step-2-read-configurations-within-the-application). The OAuth-aware client manages authentication automatically. For sample requests and responses, see the API definition provided via the Choreo marketplace for the service.

      - For languages without OAuth 2.0-aware HTTP clients, use the token obtained in [step 3](#step-3-acquire-an-oauth-20-access-token) to make calls to the dependent service. Subsequently, add the obtained token to the HTTP authorization header with the bearer prefix. As the service URL, use the URL resolved in [step 2](#step-2-read-configurations-within-the-application). For sample requests and responses, see the API definition of the service provided via the Choreo marketplace.

       The following is a sample code snippet in NodeJS:

       ``` java
       const response = await axios.get(serviceURL/{RESOURCE_PATH}, {
           headers: {
             'Authorization': `Bearer ${accessToken}`
             'Choreo-API-Key': `${choreoApiKey}`
           }
       });
       ```

    !!! note
        If you want to consume a Choreo service at the project visibility level, you don't need to obtain a token. You can directly invoke the service using the resolved URL.


# Use a Connection in Your Web Application

Choreo simplifies the process of integrating services into your web application. The approach to connect to a service can vary based on your web application. 

To connect to a selected service, follow the step-by-step instructions given below depending on the authentication mechanism used in your web application.

=== "Managed authentication"
    
    Choreo-managed authentication allows you to seamlessly handle authentication for your web application. You can configure your web application to work with the built-in identity provider of Choreo or any external identity provider that supports OIDC/OAuth2.0

    !!! note 
         Choreo's managed authentication is currently available only for web applications created with **React**, **Angular**, or **Vue.js** buildpacks.

    Follow the steps below to use an existing connection within your web application: 

    <h2> Step 1: Add the connection configuration</h2>

    To integrate a service into your application, you must first add the connection configuration as follows: 

    1. For single page applications (SPAs), you must add the connection configuration as a file mount. You can mount a file via the **Configurations** pane on the **Deploy** page. You must mount a file (for example, `config.js`) and add the configuration provided in the inline developer documentation into it. 

        The following is a sample configuration:

        ``` yaml
             window.configs = {
                 apiUrl: '<SERVICE_URL>',        
             };

        ```

    2.  To ensure accessibility of the `config.js` file via JavaScript at runtime, add a script tag as follows in the `index.html` file to reference the `config.js` file:

        ``` html
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="utf-8" />
            <title>My React App</title>
        </head>
        <body>
            <div id="root"></div>
            <script src="/public/config.js"></script>
        </body>
        </html>
        ``` 

        !!! note
             If you use an external IdP, you must add the IdP's configuration to the same file.
    
             For more information on working with IdPs, see [Configure Asgardeo as an External Identity Provider](https://wso2.com/choreo/docs/administer/configure-an-external-idp/configure-asgardeo-as-an-external-idp/).


    <h2> Step 2: Read the configuration</h2>

    Once you add the connection configuration, you can proceed to read the configuration from your application. The steps to read depend on the programming language you use.

    The following is a sample code snippet in NodeJS:

    ``` java
         const serviceURL = window?.configs?.apiUrl ? window.configs.apiUrl : "/";
    ```

    <h2> Step 3: Invoke the service</h2>

    If you use Choreo-managed authentication, Choreo handles the security handshaking for the application during deployment. The connected service will be accessible under the same domain as your application. Therefore, you can call the configured path directly using your preferred HTTP client.

    The following is a sample code snippet in NodeJS:

    ``` java
         const response = await axios.get(serviceURL/{RESOURCE_PATH});
    ```

    !!! note
         If you are using an external IdP provider instead of Choreo-managed authentication, you must obtain an access token from your IdP and add it to the HTTP authorization header with the bearer prefix.


=== "Custom authentication or no authentication"

    If you are not using Choreo-managed authentication or your web application lacks authentication, follow the steps below to connect to a service from your web application:

    <h2> Step 1: Add the connection configuration</h2>

    1. For single-page applications (SPAs), you must add the connection configuration as a file mount. You can mount a file via the **Configurations** pane on the **Deploy** page. You must mount a file (for example, `config.js`) and add the configuration provided in the inline developer documentation into it.
 
        The following is a sample configuration:

        ``` yaml
             window.configs = {
                 apiUrl: '<SERVICE_URL>',
                 consumerKey: '<CONSUMER_KEY>',
                 consumerSecret: '<CONSUMER_SECRET>',
                 tokenUrl: '<TOKEN_URL>',
             };
        ```

    2.  To ensure accessibility of the `config.js` file via JavaScript at runtime, add a script tag as follows in the `index.html` file to reference the `config.js` file:

        ``` html
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="utf-8" />
            <title>My React App</title>
        </head>
        <body>
            <div id="root"></div>
            <script src="/public/config.js"></script>
        </body>
        </html>
        ``` 

    For other types of web applications, you must add the respective configuration into your application.

    <h2> Step 2: Read the configuration</h2>

    Once you have added the connection configuration, you can proceed to read the configuration from your application. The steps to read depend on the programming language you use.

    The following is a sample code snippet in NodeJS:

    ``` java
         const serviceURL = window?.configs?.apiUrl ? window.configs.apiUrl : "/";
    ```

    <h2> Step 3: Acquire an OAuth 2.0 access token</h2>

    - For languages with OAuth 2.0-aware HTTP clients, you must pass the OAuth 2.0-related configurations such as client id, client secret and so on, obtained when creating the connection to your HTTP client configuration. The HTTP client autonomously manages token retrieval and refreshing.
  
    - For languages without OAuth 2.0-aware HTTP clients, you must manually initiate a call to the token endpoint. This includes fetching the token and managing token expiration and refresh directly within your application code. The following is a sample curl command to obtain a token:


        ```bash
        CONSUMER_KEY="your_consumer_key"
        CONSUMER_SECRET="your_consumer_secret"
        TOKEN_URL="your_token_url"

        # Encode client credentials as Base64
        CLIENT_CREDENTIALS=$(echo -n "$CLIENT_ID:$CLIENT_SECRET" | base64)

        curl -X POST $TOKEN_URL \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -H "Authorization: Basic $CLIENT_CREDENTIALS" \
        --data-urlencode "grant_type=client_credentials"

        ```

    <h2> Step 4: Invoke the service</h2>

    You can invoke the service as follows:

    - For languages with OAuth 2.0-aware HTTP clients, you can invoke the service in a straightforward manner. The HTTP client seamlessly manages OAuth 2.0 authentication without requiring additional intervention.

        As the service URL you can use the URL that you resolved in step 2 above. For sample requests and responses, see the API definition provided via the Choreo marketplace for the service.

    - For languages without OAuth 2.0-aware HTTP clients, you can use the token obtained in step 3 above to make calls to the dependent service. Subsequently, add the obtained token to the HTTP authorization header with the bearer prefix.

        As the service URL you can use the URL that you resolved in step 2 above. For sample requests and responses, see the API definition of the service provided via the Choreo marketplace.

        The following is a sample code snippet in NodeJS:

        ```java 
            const response = await axios.get(serviceURL/{RESOURCE_PATH}, {
                headers: {
                'Authorization': `Bearer ${accessToken}`
                }
            })
        ```


# Use a Database Connection in Your Component

Choreo allows you to share and reuse Choreo-managed databases, accelerating development and enhancing efficiency in building integrated applications through connections.

For step-by-step instructions on creating a database connection, see [Create a Connection](create-a-connection.md).

To learn more about Choreo Connections, see the documentation on [Connections](../../choreo-concepts/connections.md).

## Consume a database through a connection

To consume a Choreo-managed database via a connection, follow these steps:

### Step 1: Add connection configurations

To integrate a database into your application, click the appropriate tab below based on your current configuration file and follow the step-by-step instructions:

=== "Component.yaml file (v1.1)"

    1. Copy and paste the snippet from the  developer guide into the `component.yaml` file.

        The following is a sample snippet:

        ``` yaml

        dependencies:
            connectionReferences:
            - name: <CONNECTION_NAME>
              resourceRef: <RESOURCE_IDENTIFIER>

        ```

          | Field            | Description                                                         |
          |------------------|---------------------------------------------------------------------|
          | name             | The name given to the connection.                                   |
          | resourceRef      | A unique, readable identifier of the database being connected to.    |


    2. If you've previously added a `connectionReferences` section under `dependencies`, append this as another item under `connectionReferences`. Upon deploying the component, the necessary configurations to establish the connection will be injected into Choreo-defined environment variables.

          The following table details the Choreo-defined environment variables:

          | Configuration Key       | Choreo-Defined Environment Variable Name                       |
          |-------------------------|----------------------------------------------------------------|
          | HostName                | CHOREO_<CONNECTION_NAME\>_HOSTNAME                             |
          | Port                    | CHOREO_<CONNECTION_NAME\>_PORT                                 |
          | Username                | CHOREO_<CONNECTION_NAME\>_USERNAME                             |
          | Password                | CHOREO_<CONNECTION_NAME\>_PASSWORD                             |
          | DatabaseName            | CHOREO_<CONNECTION_NAME\>DATABASENAME                          |


          If you'd like to use custom environment variable names instead of the Choreo-defined ones, add the dependency as a service reference under `dependencies` in the same file. For more details, refer to the instructions under the `component.yaml file (v1.0)` tab.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | HostName       | string     | Hostname of the database server       | false         | false        |
          | Port           | string     | Port of the database server           | false         | false        |
          | Username | string           | Username of the database server       | false         | false        |
          | Password       | string     | Password of the database server       | false         | true         |
          | DatabaseName   | string     | Name of the database                  | false         | false        |
    ### Step 2: Read configurations within the application

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const hostName = process.env.CHOREO_<CONNECTION_NAME>_HOSTNAME;
    ```

=== "Component.yaml file (v1.0)"

    !!! note
        The `component.yaml v1.0` file is considered legacy. For new components, we recommend using the latest version, `component.yaml v1.1`, which offers enhanced usability and features.

    1. Copy and paste the snippet from the  developer guide into the `component.yaml` file.

        The following is a sample snippet:

        ``` yaml

        dependencies:
            serviceReferences:
            - name: database:<DATABASE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: HostName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Port
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Username
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Password
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: DatabaseName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>


        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the database you are connecting to.             |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added a service reference section under `dependencies`, append this as another item under `serviceReferences`.

          Upon deploying the component, Choreo automatically populates the specified environment variables with actual values.

          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | HostName       | string     | Hostname of the database server       | false         | false        |
          | Port           | string     | Port of the database server           | false         | false        |
          | Username | string           | Username of the database server       | false         | false        |
          | Password       | string     | Password of the database server       | false         | true         |
          | DatabaseName   | string     | Name of the database                  | false         | false        |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const hostName = process.env.HOSTNAME;
    ```

=== "Component-config.yaml file"

    !!! note
        The `component-config.yaml` file is considered legacy. For new components, we recommend using the latest version, `component.yaml v1.1`, which offers enhanced usability and features.

    1. Copy and paste the snippet from the  developer guide into the `component-config` file under the `spec` section.

        The following is a sample snippet:

        ``` yaml

        outbound:
            serviceReferences:
            - name: database:<DATABASE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: HostName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Port
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Username
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Password
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: DatabaseName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>

        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the database you are connecting to.              |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added an outbound service reference, append this as another item under `serviceReferences`.

          Upon deploying the component, Choreo automatically populates the specified environment variables with actual values.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | HostName       | string     | Hostname of the database server       | false         | false        |
          | Port           | string     | Port of the database server           | false         | false        |
          | Username | string           | Username of the database server       | false         | false        |
          | Password       | string     | Password of the database server       | false         | true         |
          | DatabaseName   | string     | Name of the database                  | false         | false        |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const hostName = process.env.HOSTNAME;
    ```

### Step 3: Initiate a database connection

To initiate a connection to the database, follow these steps:

In this example, you will connect to a MySQL database.

#### Step 3.1: Install the required packages

For the MySQL database, install the `mysql2` package using npm:

```bash
// Install the mysql2 package
npm install mysql2

```

#### Step 3.2: Import required packages

```java

const client = require('mysql2')

```

#### Step 3.3: Establish a connection

To establish the connection, use the environment variables for `hostName`, `username`, `password`, `databaseName`, and `port` as follows:

```java

var connection = client.createConnection({
      host: hostName,
      user: username,
      password: password,
      database: databaseName,
      port: port
});

connection.connect((err) => {
      if (err) {
          return;
      }
      // Connection is successful
});

```

By following these steps, your component can interact with the Choreo-managed database seamlessly.




# Integrate Unit Tests into the Build Pipeline

Choreo allows you to integrate unit tests into the build pipeline, enabling code validation before deployment. This ensures early testing of code changes, reducing the risk of defects in production.

!!! note
        Currently, Choreo supports unit tests only for the `WSO2 MI` buildpack.

## How it works

### Step 1: Write tests

You can create unit tests in your source code using standard testing libraries. For step-by-step instructions on creating unit tests for WSO2 Micro Integrator projects, see [Creating a Unit Test Suite](https://mi.docs.wso2.com/en/latest/develop/creating-unit-test-suite/).

### Step 2: Enable unit tests

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click the component for which you want to enable unit tests.
3. In the left navigation menu, click **Build**.
4. On the **Build** page, click to edit **Build Configurations**.
5. Turn on the **Unit Test** toggle.
6. Click **Save**.

### Step 3: Trigger a new build

- On the **Build** page, click **Build Latest**.

This starts a new build with unit tests enabled. You can monitor its progress in the **Build Details** pane.

## View failed unit tests

If a unit test fails during the build, you can view its detailed logs for troubleshooting. Click **View Details** corresponding to the failed build, then expand the failed unit test step to view the logs.

## Explore a sample

To see unit tests in action within the build pipeline, try out the [WSO2 MI helloworld](https://github.com/wso2/choreo-samples/tree/main/hello-world-mi) sample. 


# Manage Component Source Configurations

In Choreo, you can configure service endpoints and connections via the `component.yaml` source configuration file. This file ensures that the configurations required to initialize endpoints and connections are defined, as they cannot be inferred from the source code. This guide provides an overview of how to configure and manage these settings effectively.

The source configuration file must be committed to your repository within the `.choreo` directory at the root of the project directory. This ensures the ability to version the configuration files alongside repository commits, enabling better tracking and management of configurations.

!!! note
    -  The `component-config.yaml` and `endpoints.yaml` files will eventually be deprecated and replaced by the `component.yaml` file. 
        - For details on how to seamlessly update to the latest `component.yaml` file`, see [Update to the latest source configuration file](#update-to-the-latest-source-configuration-file).
    - Choreo prioritizes configuration files in the following order: `component.yaml` takes the highest precedence, followed by `component-config.yaml`, and then `endpoints.yaml`.

## Overview of the `component.yaml` file 

**File location**:

```bash
<build-context-path>/.choreo/component.yaml
```

!!! note
    - For components built using **Buildpacks**, replace `build-context-path` with the `<project-directory>`. 
    For example, `<project-directory>/.choreo/component.yaml`.
    - For components built using **Docker**, replace `build-context-path` with the `<docker-context-path>`. 
    For example, `<docker-context-path>/.choreo/component.yaml`.

**Sample `component.yaml` file content**:

Click the respective tab to view the structure for your current configuration file version:

=== "Version 1.1"

    ``` yaml
    # +required The configuration file schema version
    schemaVersion: 1.1

    # +optional Incoming connection details for the component
    endpoints:
      # +required Unique name for the endpoint.
      # This name will be used when generating the managed API
      - name: greeter-sample
        # +optional Display name for the endpoint.
        displayName: Go Greeter Sample
        # +required Service section has the user service endpoint details
        service:
          # +optional Context (base path) of the API that gets exposed via the endpoint.
          basePath: /greeting-service
          # +required Numeric port value that gets exposed via the endpoint
          port: 9090
        # +required Type of traffic that the endpoint is accepting.
        # Allowed values: REST, GraphQL, WS, GRPC, TCP, UDP.
        type: REST
        # +optional Network level visibilities of the endpoint.
        # Accepted values: Project|Organization|Public(Default).
        networkVisibilities: 
          - Public
          - Organization
        # +optional Path to the schema definition file. Defaults to wild card route if not provided
        # This is only applicable to REST or WS endpoint types.
        # The path should be relative to the docker context.
        schemaFilePath: openapi.yaml
      
      # +optional Outgoing connection details for the component.
      dependencies:
        # +optional Defines the connection references from the Internal Marketplace.
        connectionReferences:
          # +required Name of the connection.
          - name: hr-connection
            # +required service identifer of the dependent component.
            resourceRef: service:/HRProject/UserComponent/v1/ad088/PUBLIC
      # +optional Defines runtime configurations
      configurations:
        # +optional List of environment variables to be injected into the component.
        env:
          # +required Name of the environment variable
          - name: HR_SERVICE_URL
            # +required value source
            # Allowed value sources: connectionRef
            valueFrom:
              # +required Choreo connection value source
              connectionRef:
                # +required Choreo connection name to refer the value from
                name: hr-connection
                # +required Choreo connection configuration key to refer the value from
                key: ServiceURL
    ```

    The descriptor-based approach of the `component.yaml` file simplifies and streamlines endpoint and connection configuration management. The use of versioned schemas ensures backward compatibility, providing a seamless transition with future updates.

    You can define the following root-level configurations via the `component.yaml` file:

    | Configuration        | Required     | Description                                                              |
    |----------------------|--------------|--------------------------------------------------------------------------|
    | **schemaVersion**    | Required     | The version of the `component.yaml` file. Defaults to the latest version.|
    | **endpoints**        | Optional     | The list of endpoint configurations.                                     |
    | **dependencies**     | Optional     | The list of dependency configurations.                                   |
    | **configurations**    | Optional     | The runtime configuration definitions.                                   |

    ### Endpoint configurations
    In the `endpoints` section of the `component.yaml` file, you can define multiple service endpoint configurations. Each endpoint must have a unique name and the required fields specified in the schema overview.

    !!! tip "Why have a unique name?"
          When you define multiple endpoints, the `endpoint.name` is appended to the Choreo-generated URL. A unique name ensures the endpoint is easily recognizable and readable within the URL.
          
    | Configuration        | Required     | Description                                                                                             |
    |----------------------|--------------|---------------------------------------------------------------------------------------------------------|
    | **name**             | Required     | A unique identifier for the endpoint within the service component. Avoid using excessively long names.  |
    | **displayName**      | Optional     | A display name for the endpoint.                                                                        |
    | **service**          | Required     | Service details for the endpoint.                                                                       |
    | **.basePath**        | Required     | The base path of the API exposed via this endpoint.                                                     |
    | **.port**            | Required     | The numeric port value exposed via this endpoint.                                                       |
    | **type**             | Required     | The type of traffic the endpoint accepts. For example, `REST`, `GraphQL`, `WS`, `gRPC`, `UDP`, or `TCP`.|
    | **networkVisibilities** | Required | The network-level visibility of the endpoint. For example, project, organization, or public.             |
    | **schemaFilePath** | Required | The file path to the swagger definition  or AsyncAPI 2.0 specification file. Defaults to the wildcard route if not specified. This field should be a relative path to the project path when using **Java**, **Python**, **NodeJS**, **Go**, **PHP**, **Ruby**, or **WSO2 MI** buildpacks. For REST or WebSocket endpoint types, when using the **Ballerina** or **Dockerfile** buildpack, the path should be relative to the component root or Docker context. |

    ### Dependency configurations

    In the `dependencies` section of the `component.yaml` file, you can define multiple connection configurations under `dependencies.connectionReferences`. You can use the connection reference generated in the inline developer guide when creating a connection. For instructions on copying [connection configurations](https://wso2.com/choreo/docs/develop-components/sharing-and-reusing/use-a-connection-in-your-service/), see the inline developer guide displayed during connection creation.

    You must include the following configurations in the `dependencies.connectionReferences` schema:

    | Configuration        | Required     | Description                                                                      |
    |----------------------|--------------|----------------------------------------------------------------------------------|
    | **name**             | Required     | The name given to the connection.                                                |
    | **resourceRef**      | Required     | A unique, human-readable identifier for the service you are connecting.          |


    !!! note
        Choreo automatically generates connection configurations when you create a connection. The properties such as **name** and **resourceRef** are automatically generated. The configurations required to establish the connection will be injected into Choreo-defined environment variables.

        To use custom environment variable names instead of Choreo's default ones, add the dependency as a `serviceReference` in your `component.yaml v1.1` file. You can copy the `serviceReference` section from the `component.yaml v1.0` tab and paste it under `dependencies` in your `component.yaml v1.1` file, which maintains backward compatibility with the v1.0 format.

    ### Runtime configurations
    In the `configurations` section of the `component.yaml` file, you can define runtime configurations for the component. These configurations currently support environment variable injection related to dependencies.
    
    | Configuration                 | Required     | Description                                                                       |
    |-------------------------------|--------------|-----------------------------------------------------------------------------------|
    | **env**                       | Optional     | An array of env variable configurations.                                          |
    | **name**                      | Required     | A unique name for the environment variable, starting with a letter or an underscore, and containing only letters, numbers, or underscores. |
    | **valueFrom**                 | Required     | The source of the environment variable value.                                     |
    | **connectionRef**             | Required     | Connection reference value source definition.                                     |
    | **name**                      | Required     | The name of the Choreo connection to reference the value from.                    |
    | **key**                       | Required     | The Choreo connection configuration key to reference the value from. For details on available keys, see [connection configurations](https://wso2.com/choreo/docs/develop-components/sharing-and-reusing/use-a-connection-in-your-service/) or the inline developer guide. |

    !!! note
        Runtime configurations are supported starting from `component.yaml v1.1`.

        When an environment variable value is specified using `connectionRef`, the connection's environment variable is renamed to the environment variable name defined in the `configurations` section. For example, in the sample `component.yaml` file given above, the `CHOREO_HR_CONNECTION_SERVICEURL` variable in the `hr-connection` is renamed to `HR_SERVICE_URL`.

=== "Version 1.0"

    ``` yaml
    # +required The configuration file schema version
    schemaVersion: 1.0

    # +optional Incoming connection details for the component
    endpoints:
      # +required Unique name for the endpoint.
      # This name will be used when generating the managed API
      - name: greeter-sample
        # +optional Display name for the endpoint.
        displayName: Go Greeter Sample
        # +required Service section has the user service endpoint details
        service:
          # +optional Context (base path) of the API that gets exposed via the endpoint.
          basePath: /greeting-service
          # +required Numeric port value that gets exposed via the endpoint
          port: 9090
        # +required Type of traffic that the endpoint is accepting.
        # Allowed values: REST, GraphQL, WS, GRPC, TCP, UDP.
        type: REST
        # +optional Network level visibilities of the endpoint.
        # Accepted values: Project|Organization|Public(Default).
        networkVisibilities: 
          - Public
          - Organization
        # +optional Path to the schema definition file. Defaults to wild card route if not provided
        # This is only applicable to REST or WS endpoint types.
        # The path should be relative to the docker context.
        schemaFilePath: openapi.yaml
      
    # +optional Outgoing connection details for the component.
    dependencies:
      # +optional Defines the service references from the Internal Marketplace.
      serviceReferences:
        # +required Name of the service reference.
        - name: choreo:///apifirst/HRProject/UserComponent/ad088/v1/PUBLIC
          # +required Name of the connection instance.
          connectionConfig: 19d2648b-d29c-4452-afdd-1b9311e81412
          # +required Environment variables injected into the component for connection configuration.
          env:
            # +required Key name of the connection configuration.
            - from: ServiceURL
              # +required Environment variable injected into the container.
              to: SERVICE_URL
    ```

    The descriptor-based approach of the `component.yaml` file simplifies and streamlines endpoint and connection configuration management. The use of versioned schemas ensures backward compatibility, providing a seamless transition with future updates.

    You can define the following root-level configurations via the `component.yaml` file:

    | Configuration        | Required     | Description                                                              |
    |----------------------|--------------|--------------------------------------------------------------------------|
    | **schemaVersion**    | Required     | The version of the `component.yaml` file. Defaults to the latest version.|
    | **endpoints**        | Optional     | The list of endpoint configurations.                                     |
    | **dependencies**     | Optional     | The list of dependency configurations.                                   |

    <h3> Endpoint configurations </h3>
    In the `endpoints` section of the `component.yaml` file, you can define multiple service endpoint configurations. Each endpoint must have a unique name and the required fields specified in the schema overview.

    !!! tip "Why have a unique name?"
          When you define multiple endpoints, the `endpoint.name` is appended to the Choreo-generated URL. A unique name ensures the endpoint is easily recognizable and readable within the URL.
          
    | Configuration           | Required     | Description                                                                                             |
    |-------------------------|--------------|---------------------------------------------------------------------------------------------------------|
    | **name**                | Required     | A unique identifier for the endpoint within the service component. Avoid using excessively long names.  |
    | **displayName**         | Optional     | A display name for the endpoint.                                                                        |
    | **service**             | Required     | Service details for the endpoint.                                                                       |
    | **.basePath**           | Required     | The base path of the API exposed via this endpoint.                                                     |
    | **.port**               | Required     | The numeric port value exposed via this endpoint.                                                       |
    | **type**                | Required     | The type of traffic the endpoint accepts. For example, `REST`, `GraphQL`, `gRPC`, `WS`, `UDP`, or `TCP`.|
    | **networkVisibilities** | Required     | The network-level visibility of the endpoint. For example, project, organization, or public.            |
    | **schemaFilePath**      | Required     | The file path to the swagger definition or AsyncAPI 2.0 specification file. Defaults to the wildcard route if not specified. This field should be a relative path to the project path when using **Java**, **Python**, **NodeJS**, **Go**, **PHP**, **Ruby**, or **WSO2 MI** buildpacks. For REST or WebSocket endpoint types, when using the **Ballerina** or **Dockerfile** buildpack, the path should be relative to the component root or Docker context. |

    <h3> Dependency configurations </h3>

    In the `dependencies` section of the `component.yaml` file, you can define multiple service connection configurations under `dependencies.serviceReferences`. You can use the service references generated in the inline developer guide when creating a service connection. For instructions on copying [connection configurations](https://wso2.com/choreo/docs/develop-components/sharing-and-reusing/use-a-connection-in-your-service/), see the inline developer guide displayed during connection creation.

    You must include the following configurations in the `dependencies.serviceReferences` schema:

    | Configuration        | Required     | Description                                                                      |
    |----------------------|--------------|----------------------------------------------------------------------------------|
    | **name**             | Required     | A unique name for the service reference.                                         |
    | **connectionConfig** | Required     | A unique name for the connection instance.                                       |
    | **env**              | Required     | The list of environment variable mappings to inject into the container.          |
    | **.from**            | Required     | The key name of the connection configuration.                                    |
    | **.to**              | Required     | The environment variable to inject into the container.                           |

    !!! note
        Choreo automatically generates connection configurations when you create a connection. The properties such as **name**, **connectionConfig**, and **env.from** are automatically generated. However, you must manually set the **env.to** value.

## Overview of the `component-config.yaml` file 

**File location**:

```bash
<build-context-path>/.choreo/component-config.yaml
```

**Sample `component-config.yaml` file content**:

```yaml
apiVersion: core.choreo.dev/v1beta1
kind: ComponentConfig
spec:
  # +optional Incoming connection details for the component (AKA endpoints).
  inbound:
    # +required Unique name for the endpoint.
    # This name will be used when generating the managed API
    - name: Greeting Service
      # +required Numeric port value that gets exposed via the endpoint
      port: 9090
      # +required Type of traffic that the endpoint is accepting.
      # Allowed values: REST, GraphQL, GRPC, TCP, UDP, WS.
      type: REST
      # +optional Network level visibility of the endpoint. Defaults to Public
      # Accepted values: Project|Organization|Public.
      networkVisibility: Public
      # +optional Context (base path) of the API that gets exposed via the endpoint.
      # This is mandatory if the endpoint type is set to REST, GraphQL or WS.
      context: /greeting
      # +optional The path to the schema definition file. Defaults to wildcard route if not specified.
      # This is only applicable to REST and WS endpoint types.
      # The path should be relative to the Docker context.
      schemaFilePath: greeting_openapi.yaml
  # +optional Outgoing connection details for the component.
  outbound:
    # +optional Defines the service references from the Internal Marketplace.
    serviceReferences:
      # +required Name of the service reference.
      - name: choreo:///apifirst/mttm/mmvhxd/ad088/v1.0/PUBLIC
        # +required Name of the connection instance.
        connectionConfig: 19d2648b-d29c-4452-afdd-1b9311e81412
        # +required Environment variables injected to the component for connection configuration.
        env:
          # +required Key name of the connection configuration.
          - from: ServiceURL
            # +required Environment variable injected to the container.
            to: SERVICE_URL
```

The `component-config.yaml` file complements and enhances the existing endpoint configuration process. It allows you to define how the endpoints (inbound connections) in your service are exposed and how your service connects to external services or components (outbound connections).

You can define the following root-level configurations via the `component-config.yaml` file:

| Configuration        | Required     | Description                                                                           |
|----------------------|--------------|---------------------------------------------------------------------------------------|
| **apiVersion**       | Required     | The version of the `component-config.yaml` file defaults to `core.choreo.dev/v1beta1`.|
| **kind**             | Required     | The resource type of the file defaults to `ComponentConfig`.                          |
| **spec.inbound**     | Optional     | The list of inbound connection configurations.                                        |
| **spec.outbound**    | Optional     | The list of outbound connection configurations.                                       |

#### Inbound connection configurations (`spec.inbound`)

In the `spec.inbound` configuration section, you can specify endpoints to set up inbound connections. To specify endpoints, you can follow the existing endpoints schema structure. For details on the endpoints schema structure, see the [endpoints schema documentation](#overview-of-the-endpointsyaml-file).

#### Outbound connection configurations (`spec.outbound`)

In the `spec.outbound` section, you can define `serviceReferences`. To define `serviceReferences`, you can use the service references generated in the Internal Marketplace when creating a service connection. To copy the [outbound connection configurations](../sharing-and-reusing/use-a-connection-in-your-service/#use-a-connection-in-your-service), see the inline developer guide displayed when you create a connection.

You must include the following configurations in the `serviceReferences` schema:

| Configuration        | Required     | Description                                                                      |
|----------------------|--------------|----------------------------------------------------------------------------------|
| **name**             | Required     | A unique name for the service reference.                                         |
| **connectionConfig** | Required     | A unique name for the connection instance.                                       |
| **env**              | Optional     | The list of environment variable mappings to inject into the container.          |
| **env.from**         | Required     | The key name of the connection configuration.                                    |
| **env.to**           | Required     | The environment variable to inject into the container.                           |

## Overview of the `endpoints.yaml` file

**File location**:

```bash
<build-context-path>/.choreo/endpoints.yaml
```

**Sample `endpoints.yaml` file content**:

```yaml
# +required Version of the endpoint configuration YAML
version: 0.1

# +required List of endpoints to create
endpoints:
  # +required Unique name for the endpoint.
  # This name will be used when generating the managed API
- name: Greeting Service
  # +required Numeric port value that gets exposed via this endpoint
  port: 9090
  # +required Type of the traffic this endpoint is accepting.
  # Allowed values: REST, GraphQL, GRPC, UDP, TCP, WS.
  type: REST
  # +optional Network level visibility of this endpoint. Defaults to Public
  # Accepted values: Project|Organization|Public.
  networkVisibility: Project
  # +optional Context (base path) of the API that is exposed via this endpoint.
  # This is mandatory if the endpoint type is set to REST, GraphQL or WS.
  context: /greeting
  # +optional Path to the schema definition file. Defaults to wild card route if not provided
  # This is only applicable to REST and WS endpoint types.
  # The path should be relative to the docker context.
  schemaFilePath: greeting_openapi.yaml
```

The `endpoints.yaml` configuration file allows you to define configurations for multiple endpoints necessary for Choreo service components. This schema is essential to identify the context, port binding, network exposure level, and other attributes required to generate a Choreo endpoint.

You can define the following root-level configurations via the `endpoints.yaml` file:

| Configuration        | Required     | Description                                                                       |
|----------------------|--------------|-----------------------------------------------------------------------------------|
| **version**          | Required     | The version of the `endpoints.yaml` file.                                         |
| **name**             | Required     | A unique name for the endpoint, which Choreo will use to generate the managed API.|
| **port**             | Required     | The numeric port value that gets exposed via this endpoint.                       |
| **type**             | Required     | The type of traffic this endpoint accepts, such as `REST`, `GraphQL`, `gRPC`, `WS`, `UDP`, or `TCP`. Currently, the MI preset supports only the `REST` type.                                         |
| **networkVisibility**| Required     | The network level visibility of this endpoint, which defaults to `Public` if not specified. Accepted values are `Project`, `Organization`, or `Public`.|
| **context**          | Required     | The context (base path) of the API that Choreo exposes via this endpoint.         |
| **schemaFilePath**   | Required     | The swagger definition file path. Defaults to the wildcard route if not provided. This field should be a relative path to the project path when using the **Java**, **Python**, **NodeJS**, **Go**, **PHP**, **Ruby**, and **WSO2 MI** buildpacks. For REST endpoint types, when using the **Ballerina** or **Dockerfile** buildpack, this field should be a relative path to the component root or Docker context.|

## Update to the latest source configuration file

With the upcoming deprecation of the `component-config.yaml` file and the `endpoints.yaml` file, Choreo provides a seamless process to move to the latest `component.yaml`  version of the `component.yaml` file. Follow these steps to transition seamlessly:

### Step 1: Identify whether your current source configuration file is outdated

You can determine whether you’re using an outdated configuration file in the following ways:

- **During a build:**
     - On the **Build** page, after triggering a build, a warning will appear if your source configuration file is outdated. Click **View Details** in the **Initialization** -> **Source Config Validation** step. You will see an information banner with an option to update the file.

- **In existing deployments:**
     - If an existing deployment uses a build with an outdated source configuration file, you will see a warning icon on the build card of the relevant environment card.


### Step 2: Generate the latest `component.yaml` file

- In either of the scenarios above, click **Update** to initiate the process of generating the latest `component.yaml` file. The updated file will retain your existing configurations to ensure a smooth update process.


### Step 3: Add the generated configuration file to your repository

1. Download the generated `component.yaml` file.
2. Replace the existing source configuration file in the `.choreo` folder within your source repository.
    - Ensure the file name is `component.yaml`.


### Step 4: Trigger a new build

1. Commit the new `component.yaml` file to your repository. Push changes to the remote Git repository.
2. Trigger a build using the latest commit.


### Step 5: Verify the update

Once the build is complete:

  - Deploy the build.
  - Confirm that the warning messages no longer appear.

You can benefit from the latest features and enhancements provided by the updated source configuration file.


# Manage Deployment Tracks for Choreo Components

Choreo allows you to create and manage dedicated [deployment tracks](../choreo-concepts/deployment-tracks.md) for components, facilitating independent version control and deployment. This capability also allows you to unlink deployment tracks from associated branches or relink them to different branches so that you can align with your preferred Git workflows, such as the feature branch workflow or GitFlow workflow.

!!! info
     Deployment track creation and management does not apply to API Proxy and [BYOI components](../develop-components/bring-your-own-image.md).

## Create a deployment track

**Prerequisites**:

 - Create a component in Choreo.

Follow the steps below to create a deployment track for a component:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to create a deployment track for.
3. On the header of the component overview page, click the **Deployment Track** drop-down list.
4. Click **+ Create New** to open the **Create Deployment Track** dialog.
5. In the **Create Deployment Track** dialog, do the following:
    1. Select a branch to associate with the deployment track.
    2. Optionally, specify a description for the deployment track. 
    3. To create a deployment track for a service component, specify a unique API version indicating the major and minor version numbers.
6. Click **Create**.

## Unlink a deployment track

If you want to detach a branch reference from a deployment track, you must unlink the branch.

!!! info
     When you unlink the branch of a deployment track, the active deployments are unaffected. However, while you can redeploy the existing deployment, you cannot perform a new deployment.

Follow the steps below to unlink a deployment track of a component:
  
1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to unlink a deployment track.
3. On the header of the component overview page, click the **Deployment Track** drop-down list and then click **View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
4. Click the edit icon corresponding to the deployment track you want to unlink.
5. In the **Edit Branch** dialog that opens, click the **Branch Name** list and select **None**.
6. Click **Save**.

## Link a deployment track

To associate a branch reference to an unlinked deployment track, you must link a branch.

!!! info
    To build and deploy the contents of the linked branch,  you must perform a manual build and deploy.

**Prerequisites**:

 - A minimum of two branches in your GitHub repository.

Follow the steps below to link a branch to an unlinked deployment track:
  
1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to associate a branch reference for.
3. On the header of the component overview page, click the **Deployment Track** drop-down list and then click **View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
4. Click **+ Link Branch** corresponding to the unlinked deployment track for which you want to associate a branch.
5. In the **Link Branch** dialog that opens, click the **Branch Name** list and select the branch you want to relink.
6. Click **Save**.

## Relink a deployment track

To switch the branch reference of a linked deployment track, you must relink to an appropriate branch.

!!! info
      If you unlink the existing branch of a deployment track and link a different branch, you must perform a manual build and deploy to build and deploy the contents of the recently linked branch.

**Prerequisites**:

 - A minimum of two branches in your GitHub repository.

Follow the steps below to switch the branch reference of a linked deployment track:
  
1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to relink a deployment track for.
3. On the header of the component overview page,  click the **Deployment Track** drop-down list and then click **View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
4. Click the **Edit Branch** icon corresponding to the deployment track you want to relink.
5. In the **Edit Branch** dialog that opens, click the **Branch Name** list and select the branch you want to relink.
6. Click **Save**.

Now that you understand how to create and manage deployment tracks for components, let’s explore a sample scenario to see how a developer can use deployment tracks to manage version releases in Choreo.

## Sample Scenario: Manage version releases with deployment tracks

Let’s consider the following version release scenario: 

- To initiate work on a new feature, a developer creates a new branch, named `feature-x` from either the `main` or `dev` branch.
- Once development is complete, the developer proceeds to merge the `feature-x` branch into the `dev` branch for testing.
- Upon successful testing in the `dev` branch, the developer proceeds to merge all the changes into the `main` branch for production deployment.

Following are the actions you need to take from a deployment track perspective to manage the version release:

1. To prepare for the new version release, unlink the `main` branch from the associated deployment track (let’s consider this as the deployment track 1).
2. Proceed to merge the `dev` branch containing the tested changes into the `main` branch.
3. Unlink the `dev` branch from the associated deployment track (let’s consider this as deployment track 2).
4. Link deployment track 2 containing the latest version of the service to the `main` branch for deployment.
5. To facilitate ongoing development and testing, create another deployment track (let’s consider this as deployment track 3) and link it to the `dev` branch.

!!! tip
     - As a developer, you can strategically unlink and relink deployment tracks to effectively manage different versions of your services within Choreo.
     - You can create new deployment tracks for ongoing development branches like `dev` to ensure a continuous development and release cycle.

## Delete a deployment track

If you no longer need a deployment track, you can delete it.

!!! note
    If the component exposes an endpoint or proxy and you want to delete the last version in the major version range, the recommended approach is to retire that version first. This allows consumers to transition to the next major version and prevents a sudden break in their experience.
    For example, if you have deployment tracks for v1.0 and v2.0, notify consumers to switch to v2.0 before deleting v1.0. Then, retire the APIs in v1.0 and proceed to delete the associated deployment track.




**Prerequisites**:

- At least 2 deployment tracks in a component.

Follow the steps below to delete a deployment track:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to delete a deployment track.
3. On the header of the component overview page, click the **Deployment Track** drop-down list.
4. Click **+ View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
5. Click the **Delete** icon corresponding to the deployment track you want to delete.
6. Click **Delete** to confirm the deletion.

# Manage the Micro Integrator Runtime Version in Your Integration Project

Choreo allows you to use a preferred WSO2 Micro Integrator (MI) runtime version in your integration project. Currently, Choreo supports MI product versions 4.1.0 and 4.2.0. You have the flexibility to deploy WSO2 updates within these specified versions. 

When you create an integration project, you can specify a required runtime version to gain control over the environment in which your integration runs. This version management capability empowers you to tailor your projects depending on your runtime requirements, enhancing the customization and adaptability of your integration workflows.

## Understand the version string

WSO2 Micro Integrator (MI) utilizes a versioning system consisting of three-digit numbers, such as `4.1.0` and `4.2.0`, following semantic versioning principles. The product remains committed to receiving updates from WSO2, including security fixes, bug resolutions, and enhancements. Within the Choreo platform, the MI runtime version is constructed by combining the product release version with its corresponding update level.

In Choreo, the MI runtime version is structured as a four-digit number, for example, `4.1.0.14` or `4.2.0.17`. The first three digits represent the product release version, while the last digit signifies the update level of the product. The fourth digit is optional and can be omitted.

![Version string](../assets/img/develop-components/micro-integrator/version-string.png)

## Version management in WSO2 Integration Studio

If you are using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/) to build and deploy integration artifacts in WSO2 Micro Integrator, you can create multiple runtime environments and execute projects on any selected environment. WSO2 Integration Studio also allows you to configure multiple Micro Integrator runtime environments, offering flexibility and customization in the execution of integration processes.

You can specify the Runtime version when you create an integration project in WSO2 Integration Studio. In the project creation wizard, specify the runtime version in the **Runtime version** field, as shown below.
![Specify Runtime version](../assets/img/develop-components/micro-integrator/specify_runtime_version.png)


An integration project is structured as a Maven project with multiple sub-modules. The root `pom.xml` file holds crucial information about the target runtime. The runtime version you configure when you create a new project is saved within the root `pom.xml` file. The version information is stored in the <project.runtime.version> element under the <properties> in the `pom.xml` file. If there is a need to update the runtime version, you have the flexibility to modify the value to a valid runtime version and ensure that the project runs in the required runtime environment.

![project runtime version](../assets/img/develop-components/micro-integrator/project-runtime-version.png)

You can establish multiple runtime environments by utilizing updated MI instances. With a valid WSO2 subscription, you can also access and download updates to set up an updated MI server locally. This update process allows you to select a preferred update level as the runtime version. Consequently, you can run your integration on a runtime with the latest updates, ensuring optimal performance and access to new features.

### Configure a Micro Integrator runtime environment in Integration Studio

If you are using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), follow these steps to set up a remote server instance with a Micro Integrator runtime environment to execute your integration project:

!!! info "Note"
    If you have not downloaded and installed WSO2 Integration Studio, you can follow the [installation instructions](https://apim.docs.wso2.com/en/latest/integrate/develop/installing-wso2-integration-studio/) in the WSO2 API Manager documentation.

1. Launch WSO2 Integration Studio and click **Add Server** in the **Getting Started** view.
   ![Add server](../assets/img/develop-components/micro-integrator/add-server.png)
2. In the **Define a New Server** dialog, click to expand the `WSO2` directory and select **WSO2 Remote Server**.
   ![Define a remote server instance](../assets/img/develop-components/micro-integrator/define-a-remote-server-instance.png)
3. Enter the WSO2 Micro Integrator Management API URL in the **Server URL** field and click **Test Connection**.

    !!! info "Note"
        The Management API of WSO2 Micro Integrator is an internal REST API introduced to substitute MI admin services. The default HTTPS port of the Management API of WSO2 Micro Integrator is `9164`. If you have not manually changed the default port, you must set the Management API URL as `https://localhost:9164/management`.  If you have changed the default HTTPS port, you must set the port number appropriately when specifying the **Server URL**. For more information on the default ports of WSO2 Micro Integrator, see [WSO2 Micro Integrator default ports](https://apim.docs.wso2.com/en/latest/install-and-setup/setup/reference/default-product-ports/#micro-integrator-ports) in the WSO2 API Manager documentation.

    ![Set server URL](../assets/img/develop-components/micro-integrator/set-server-url.png)
    
4. Click **Finish**.
5. In the **Add and Remove** dialog, select the integration components to move from the left side to the right side.
6. Click **Add >**.
7. Click **Finish**. 

Your integration project is now running in a remote server instance with the Micro Integrator runtime environment you require.
If you need to make changes to the integration project, expand the remote server instance, right-click on the deployed exporter project, and select **Redeploy** to apply the changes.

![Redeploy project](../assets/img/develop-components/micro-integrator/redeploy-project.png)

## Convention for version interpretation in Choreo deployments

You can use the following convention to indicate the required MI runtime version in your integration project:


| **Version format**           | **Example**       | **Description**   |
|------------------------------|-------------------|-------------------|
| Product version              | `4.1.0`, `4.2.0`  | Deploy on the latest update level of the mentioned product version.                 |
| Product version with update level  | `4.1.0.15`, `4.2.0.17` |  Deploy on the exact update level of the mentioned product version.    |
| GA version                   | `4.1.0.0`, `4.2.0.0` | Deploy on the exact GA version without any update.                  |
| Default version            | Empty value         | Deploy on the latest update level of the default product version.                  |


Choreo utilizes Alpine images for configuring and deploying the Micro Integrator runtime. This includes automated configuration of the JRE/JDK, customized to the compatibility of the chosen runtime version, simplifying the setup procedure.

## Migrate between runtime versions

Changing the runtime version in an integration project may become necessary during product version upgrades or when you want to apply updates. 

To change the runtime version of a MI Integration, follow the below steps.

### Update the runtime version in the integration project
    
To change the runtime version in the integration project, follow the steps below:
1. Open the project in Integration Studio.
2. Right-click on the project and select **Change Runtime MI Version**.
    ![Update Runtime version](../assets/img/develop-components/micro-integrator/click_change_runtime.png)
3.  Specify the new runtime version as shown below:
    ![Update Runtime version](../assets/img/develop-components/micro-integrator/update_runtime_version.png)
4. Alternatively, you can manually update the version by opening the root `pom.xml` file.  Open pom.xml and change the required runtime version in `<project.runtime.version>` element under `<properties>` section.

To test the changes locally, you must download and set up the runtime environment locally. Then, you must [configure the Integration Studio runtime environment](#configure-a-micro-integrator-runtime-environment-in-integration-studio) by directing it to the locally installed MI runtime. Once the setup is complete, you can deploy your integrations on the MI runtime environment and proceed to the testing phase.

After completing the tests to ensure everything works as expected, you can follow below steps to deploy the project in Choreo:

1. Commit and push the changes to your repository.
2. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
3. Select your project from the **Project** list in the header.
4. Select your MI integration component from the **Component** list in the header.
5. In the left navigation menu, click **Build**.
6. Select the latest commit and click **Build**.
7. In the left navigation menu, click **Deploy**.
8. Click on the **Configure and Deploy** and deploy the component.
9. Verify the Runtime version by checking the logs by selecting the **Runtime Logs** under the **Observability** section.

  You will see the runtime version in the logs as shown below:
  ![Runtime version in logs](../assets/img/develop-components/micro-integrator/runtime_version_in_logs.png)

Next, you must conduct additional testing in the development environment on Choreo before you promote the integration to production environments.

## Troubleshoot errors

The following error codes can help you troubleshoot errors that occur during the integration component build:

| **Error code** | **Description**            |
|----------------|----------------------------|
| 110 - 119      | Internal server error.     |
| 121            | Malformed runtime version. |
| 122            | The specified runtime version is not available. Either the product or update level is not available.    |
| 123            | Trivy security vulnerabilities found in the `libs` directory. |
| 124            | Trivy security vulnerabilities found in the `dropins` directory. |
| 125            | Trivy security vulnerabilities found in the `libs` or `dropins` directory. |
| 126            | Error building integration project. |


# Submit and Manage Workflow Approval Requests

In Choreo, if an administrator [configures a workflow to require approval](../administer/configure-approvals-for-choreo-workflows.md), you must submit a request to obtain approval to perform the task.

Upon submitting a workflow approval request, Choreo notifies all authorized assignees via email about the [review request](../administer/review-workflow-approval-requests.md). When an authorized assignee approves or rejects the request, you will receive an email with details of the decision.

The approach to request approval can vary depending on the workflow. 

## Request approval for environment promotion

**Prerequisites**:

- Ensure you have a component created, built, and deployed to the development environment.
- Ensure that an approval workflow is configured for environment promotion.
- Ensure you are promoting the component to a critical environment, such as production.

To request approval to promote a component from the development environment to production, follow these steps:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to deploy. This takes you to the **Overview** page of the component.
3. In the left navigation menu, click **Deploy**.
4. Go to the **Development** card and click **Request to Promote**.
5. In the **Request Approval** pane that opens, enter your request details and click **Submit**. This creates a request and notifies all authorized assignees via email about the request.

    !!! note
         When an environment promotion request for a specific component is pending review, Choreo restricts other developers from making the same request until the pending request is either approved or rejected.

When an authorized assignee approves the request, you will receive a confirmation email and can proceed to promote the component to production.

## Cancel a workflow approval request

If you want to cancel a workflow approval request that is already submitted, you can do so before the request is approved or rejected. 

When you submit a workflow approval request, the **Request to Promote** button changes to **Cancel Request**. To cancel an approval request, click **Cancel Request**. Upon confirming the cancellation, all configured approvers are notified immediately, and the request will no longer be pending.


# Work with the Micro Integrator Runtime in Choreo

WSO2 Micro Integrator (WSO2 MI) is a lightweight, high-performance integration runtime. It allows you to run integrations developed using WSO2 Integration Studio within Choreo. 

The topics on this page walk you through the key aspects you need to understand to use the WSO2 MI runtime effectively in Choreo.

## Integration types

Choreo supports the following WSO2 MI integrations that cater to different use cases and requirements. Each integration type serves a specific purpose. Therefore, it is essential to understand their differences to easily choose the most appropriate integration for your use case.

- **Service**: Exposes an integration as an API via HTTP, making it possible to create a RESTful interface for your integration services. This type is ideal for scenarios where you need to provide an API for external systems or clients to interact with your integration.
- **Event Handler**: Triggers an integration based on external events such as messages arriving on a queue or updates in a database. This type is well-suited for implementing event-driven architectures or responding to changes in your system's environment.
- **Scheduled Task**: Runs an integration automatically at predefined time intervals, ensuring that specific integration tasks occur at regular intervals. This type is ideal for batch processing, data synchronization, or periodic maintenance tasks.
- **Manual Task**: Initiates an integration via user action, giving you full control over when the integration executes. This type is useful for on-demand tasks, testing, or debugging purposes.

## Develop integrations with WSO2 Integration Studio

[WSO2 Integration Studio](https://wso2.com/integration/integration-studio/) is a powerful, Eclipse-based graphical development environment that enables you to build and deploy integration artifacts in WSO2 Micro Integrator. This comprehensive IDE offers a robust set of tools for designing and testing integration flows and crafting integration artifacts. By utilizing the visual, drag-and-drop capabilities of WSO2 Integration Studio, developers can significantly reduce the time and effort needed to construct and deploy integration flows.

In addition to streamlining the development process, Integration Studio offers features such as debugging, testing, and version control to ensure the quality and reliability of integration flows. By creating an Integration project and Composite Exporter project in WSO2 Integration Studio, developers can export their integration projects as a single deployment artifact, known as a composite application. This composite application encompasses all the components and configurations necessary for deploying the integration project to WSO2 Micro Integrator.

The Composite Exporter project simplifies the deployment process by allowing developers to package their integration projects as a single, self-contained artifact that can be easily deployed and managed. This approach enhances the consistency and reliability of integration projects while streamlining the overall deployment process.

To start developing integrations with WSO2 Micro Integrator, see [WSO2 Micro Integrator documentation - Developing Integration Solutions](https://mi.docs.wso2.com/en/latest/develop/intro-integration-development/).

## Integration project directory structure

An Integration Project in WSO2 Integration Studio is a multi-module Maven project that can contain multiple modules with WSO2 Synapse configurations and a composite application module to export all the configurations as a single deployable artifact.

An integration project directory structure includes the following key components:

 - WSO2 Synapse configurations: These modules contain the essential configurations for the integration project.
 - Composite Application module: This module is responsible for exporting all the Synapse configurations as a single deployable artifact.

Optionally, you can include the following components in your integration project:

 - OpenAPI definition file: You can add the OpenAPI definition file to any location within the project. When creating a component, you'll need to define the path to this file. Choreo will automatically generate an OpenAPI definition for you based on your integration project, if you don't provide one.
 - Java libraries: If your integration project requires additional Java libraries, you can add them to the libs directory located in the project root.
 - deployment.toml file: This optional configuration file allows you to customize the preconfigured settings of WSO2 MI instances running on Choreo. By including this file, you can tailor the behavior of your WSO2 MI instances to better suit your project's specific requirements.

Understanding the Integration Project directory structure is crucial for organizing your project and ensuring that all necessary components are included in the final deployable artifact.

## OpenAPI support

OpenAPI Support plays a crucial role in enhancing the functionality of integrations exposed as APIs. By providing an OpenAPI definition for your exposed integration, you can streamline testing and management processes, ensuring a more efficient and user-friendly experience. Choreo will automatically generate an OpenAPI definition for you based on your integration project, if you don't provide one, saving you time and effort.

To incorporate OpenAPI support, store the OpenAPI definition file within the repository hosting your Integration Studio project. When creating the project, simply point to the file's location in the repository. If needed, you can change the location of the OpenAPI definition file later via the deploy page.

![Open API file](../assets/img/develop-components/micro-integrator/openapi_file.png)

By leveraging OpenAPI Support, you can optimize the way you test and manage your integrations, resulting in a more efficient development process and a smoother user experience.

## Work with third-party libraries

The use of third-party libraries in your Micro Integrator project can offer several advantages, such as enhanced functionality, improved integration capabilities, optimized performance, and reduced development time.

Here are some of the benefits of adding third-party JARs to the Micro Integrator:

 - Increased functionality: Third-party libraries can extend the core Micro Integrator distribution, allowing for greater flexibility and customization of integration solutions.
 - Enhanced integration capabilities: Third-party libraries enable the Micro Integrator to interact with existing systems such as databases or other APIs, improving overall integration capabilities.
 - Optimized performance: By offering optimized implementations of common functions, third-party libraries can improve the performance of the Micro Integrator.
 - Efficient development: Developers can avoid re-implementing commonly used functions, reducing development time and increasing efficiency.

To incorporate third-party libraries into your Micro Integrator project, create a new directory called `libs` at the
root of your project. If your project root and GitHub repository root are not the same, place the `libs` directory in
the project root. After adding the required JAR files to the `libs` directory, the Micro Integrator runtime will
automatically include them when deploying the component. This process ensures that any dependencies needed by your
integration flow are available at runtime.

In addition to `jar` libraries, you may also need to incorporate OSGi bundle JARs into your project. To do this,
create another directory called `dropins` at the root of your project. Similarly, if the project root and GitHub
repository root differ, place the `dropins` directory in the project root. Within the `dropins` directory, add the OSGi
bundle JAR files. The OSGI runtime will pick up these bundles during deployment, enabling you to utilize their
functionality within your Micro Integrator project.

![Libs directory](../assets/img/develop-components/micro-integrator/libs_dir.png)

## Importing custom certificates to MI

The feature enables Choreo MI users to import certificates into the MI `client-truststore.jks` file. This functionality
proves valuable when users need to establish connections with servers or services utilizing SSL/TLS encryption and
possessing self-signed certificates or certificates issued by private certificate authorities (CAs) that are not
automatically trusted. Importing the certificate to the MI `client-truststore.jks` file enables MI clients to establish secure connections with
the server or service seamlessly, eliminating SSL/TLS errors or warnings.

Before importing the certificate, it is necessary to obtain the certificate file, which can be in PEM or DER format. You
can get the certificate from the server or service provider or export it from a web browser. Certificates should be
added to the `/wso2mi/certs/` folder. Users need to verify that the mount path for the certificate file aligns with this
specific path.

1. In the Choreo console, select the component you wish to add a certificate to.
2. From the left navigation click **Deploy**.
3. Click on the **Configs and Secrets** tab.
4. Click **Create**.
5. Select **ConfigMap** as the **Config Type** and **File Mount** as the **Mount Type**.
6. Click **Next**.
7. Specify the following values as mount configurations:

    | **Field**       | **Value**                                              |                                    
    |-----------------|--------------------------------------------------------|
    | **Config Name** | An appropriate name for the certificate.             |
    | **Mount path**  | `/wso2mi/certs/<filename>`. For example, `/wso2mi/certs/certificate.crt` |

8. Click **Upload File** and attach the certificate.
9. Click **Create**.

## Working with sensitive data using MI Secure Vault

MI Secure Vault is a feature that allows users to securely store sensitive data, such as passwords and tokens, and
provide access to that data to MI Integrations. This feature provides an added layer of security to your integrations by
reducing the risk of accidental exposure of sensitive data.

To use MI Secure Vault to work with sensitive data, follow these steps:

1. Select the component from the Choreo Console.
2. From the left navigation, click Deploy.
3. Click on the **Configure and Deploy**.
4. Click on the **Add Environment Configurations**
5. Specify the following values as configurations:

    | **Field**       | **Value**                                 |                                    
    |-------------------------------------------|--------------------------------------------------------|
    | **Name** | An appropriate name for the secret/alias. |
    | **Value**       | Value for the secret                      |

6. Select **Mark as a Secret**.
7. Click **Add**.
8. Click **Deploy**.
9. Once the secret has been created, you can access it in your integration code using the following syntax:

```xml
<property name="secret_value_1" expression="wso2:vault-lookup('user_pass')" scope="default" type="STRING"/>
```
This code retrieves the secret named "user_pass" from the MI Secure Vault and stores it in the property named "
secret_value_1". You can then use this property in your integration code to access the secret value.

For more information on these features, see the [Accessing secrets](https://mi.docs.wso2.com/en/latest/install-and-setup/setup/security/encrypting-plain-text/#step-3-accessing-secrets) section of the MI Secure Vault documentation. By using MI
Secure Vault to store and access sensitive data in your integrations, you can ensure that your integrations
remain secure and protect sensitive data from unauthorized access.


## Scan third-party libraries to identify security vulnerabilities

Scanning third-party libraries for security vulnerabilities is essential for identifying potential weaknesses in an application that could be exploited by attackers. Taking a proactive approach to security helps organizations detect and mitigate risks before they can be exploited, preventing data breaches, system compromises, and other security incidents.

Choreo incorporates a security vulnerability scanning process during deployment. It uses Trivy to scan and detect critical vulnerabilities in third-party libraries added to the integration component. If the scan uncovers any critical vulnerabilities, the deployment process is halted. The deployment pane displays the Trivy scan status and any security failures in the Library (Trivy) vulnerable scan step, which can be accessed by clicking on it. Once the vulnerability has been addressed, you can redeploy the component.

## Customize WSO2 Micro Integrator preconfigured settings

Customizing WSO2 Micro Integrator Preconfigured Settings is essential for ensuring that the integration solution works optimally within the specific context of your organization. While WSO2 MI comes with preconfigured settings designed for general use, these settings may not be suitable for every organization's unique requirements. Customizing these settings can help optimize performance and ensure compatibility with your organization's systems and applications.

To customize the preconfigured settings of WSO2 MI instances running on Choreo, define a `deployment.toml` file in the GitHub repository subpath of your Micro Integrator project:

![deployment.toml](../assets/img/develop-components/micro-integrator/config_file.png)

!!! note
    If you change critical configuration parameters such as port offset and hostname, it can break internal communication.
    Therefore, the recommended approach is to update only the necessary configuration parameters.

Given below is a sample `deployment.toml` file that can be used to configure the JMS transport. For more information on WSO2 MI
configuration parameters, see the [MI Configuration Catalog](https://mi.docs.wso2.com/en/latest/reference/config-catalog-mi/).

```
[[transport.jms.sender]]
name = "myQueueSender"
parameter.initial_naming_factory = "org.apache.activemq.jndi.ActiveMQInitialContextFactory"
parameter.provider_url = "$env{JMS_PROVIDER_URL}"
parameter.connection_factory_name = "QueueConnectionFactory"
parameter.connection_factory_type = "queue"
parameter.cache_level = "producer"

[[transport.jms.listener]]
name = "myQueueListener"
parameter.initial_naming_factory = "org.apache.activemq.jndi.ActiveMQInitialContextFactory"
parameter.provider_url = "$env{JMS_PROVIDER_URL}"
parameter.connection_factory_name = "QueueConnectionFactory"
parameter.connection_factory_type = "queue"
parameter.cache_level = "consumer"
```

## Environment variables

Using environment variables is a recommended practice when developing integration artifacts with WSO2 Integration Studio, as it improves configuration management, security, portability, and manageability. By leveraging environment variables, organizations can streamline the management and maintenance of their integrations, ensuring that updates can be implemented quickly and efficiently.

The component's Deploy page provides a user-friendly interface to manage environment variables across different environments. For information on managing environment variables for complex use cases, see [Configurations and secrets](../devops-and-ci-cd/manage-configurations-and-secrets.md).

![Environment variables](../assets/img/develop-components/micro-integrator/env_variables.png)

Environment variables offer several benefits:

 - Configuration management: They simplify the process of managing and updating configuration settings, making it easier to maintain consistency across different environments.
 - Security: Environment variables help protect sensitive information by storing it securely and separating it from the main codebase.
 - Portability: By using environment variables, you can ensure that your integration artifacts can be easily migrated and deployed across various environments with minimal changes.
 - Manageability: Environment variables offer a centralized way to manage configuration settings, making it easier to update and maintain your integrations over time.

For a comprehensive list of parameters that can be configured as environment variables, see [WSO2 Micro Integrator documentation - Injecting Parameters - Supported parameters](https://mi.docs.wso2.com/en/latest/develop/injecting-parameters/#supported-parameters).

## Configure logging

Configuring logging is crucial when developing and maintaining a software system, as it can significantly improve efficiency during the development, testing, and maintenance phases of the software development process. Logging captures events and messages that occur during an application's execution, providing valuable insights for troubleshooting and debugging issues.

With Micro Integrator instances, you can configure and customize logging according to your requirements. Logging configurations can be added to each MI instance's environment, allowing you to fine-tune logging depending on the specific environment or deployment scenario.

To configure logging in MI instances, follow the steps given below: 

!!! tip
     You can use environment variables with specific naming conventions.

1. Start the variable name with `logging_level_` followed by the package or class name.
2. Replace the dot character in the package name with an underscore.
3. Set the variable value to the required logging level for the corresponding package or class.

    For example, to enable wire logs, change the logging level of the `org.apache.synapse.transport.http.wire` package to `debug`. 

To configure logging, set the environment variable as follows:

1. In the left navigation menu, click **Deploy** and then click **Configs & Secrets**. 
2. Click **+ Create**. 
3. Select **ConfigMap** as the **Config Type** and **Environment Variables** as the **Mount Type**. 
4. Click **Next**. 
5. Specify the following values as mount configurations:

    | **Field**       | **Value**                                              |                                    
    |-----------------|--------------------------------------------------------|
    | **Config Name** | An appropriate name for the configuration.             |
    | **Name**        | `logging_level_org_apache_synapse_transport_http_wire` |
    | **Value**       | `debug`                                                |

6. Click **Create**.

## Connectors

WSO2 Micro Integrator (MI) Connectors are prebuilt connectors designed to simplify integration between WSO2 MI and various other systems. They enable seamless connections to databases, message brokers, REST APIs, and more, allowing you to perform actions such as sending messages, executing queries, or retrieving data. These connectors are easy to use, making it straightforward to incorporate them into your WSO2 MI integration flows. Micro Integrator connectors are versatile and can be utilized in various integration scenarios, including data integration, service-oriented architecture (SOA) integration, and event-driven architecture (EDA) integration.

WSO2 Integration Studio is a comprehensive development environment that facilitates the creation of integration flows using WSO2 Micro Integrator Connectors. With Integration Studio, you can design and implement integration flows that connect diverse systems and execute various actions, such as sending messages, executing queries, or retrieving data. You can build integration flows using either prebuilt connectors provided by WSO2 MI or custom connectors developed using the Connector Development Toolkit. Integration Studio offers a graphical user interface that simplifies the process of building and testing integration flows while also providing a set of tools for managing and deploying these flows in a WSO2 MI runtime environment.

For more information, see the following topics in the WSO2 Micro Integrator documentation.

- [Connectors Overview](https://mi.docs.wso2.com/en/latest/reference/connectors/connectors-overview/)
- [Adding Connectors](https://mi.docs.wso2.com/en/latest/develop/creating-artifacts/adding-connectors/)

## Deploying integrations in Choreo 

WSO2 MI buildpack is where you can deploy integrations developed with WSO2 Micro Integrator as an API. In this preset, you have three different ways to define endpoints. Choreo gives priory to the definition of endpoints in the below-mentioned order. 

1. **Using component.yaml file**
This is the most flexible method to define endpoints. You can configure the endpoint details with the `component.yaml` configuration file. Place this file in the `.choreo` directory in the project path of the component. 
If the Micro Integrator project has inbound endpoints, you can expose them via different endpoints using the `component.yaml`file.

    To learn about the `component.yaml` file, see [Overview of the component.yaml file](../develop-components/manage-component-source-configurations.md#overview-of-the-componentyaml-file).

3. **Auto generating endpoints**
If `component.yaml` is not provided and if the source Micro Integrator project has APIs, Choreo scans the project and generates the API endpoints. If the project has few APIs, an endpoint will be generated for each API. The visibility of this auto-generated endpoint is set to `Public` by default. You can change the visibility in the deployment flow.

4. **Provide default endpoints**
If `component.yaml` is not provided and if the source Micro Integrator project doesn't have APIs, Choreo generates a default endpoint which will expose the default micro integrator port (8290) with `Public` visibility and wildcard context.

!!! note
    If you are currently using `component-config.yaml` or `endpoints.yaml` configuration files, see the respective [migration guide](../develop-components/manage-component-source-configurations.md#migration-guide) for instructions on migrating to the recommended `component.yaml` configuration file.

## Explore Choreo examples on GitHub

For a hands-on experience with MI-based integrations in Choreo, we recommend exploring our samples in Choreo Console. You can filter out the samples based on the buildpack `WSO2 MI`. This will point you to the samples in the [Choreo samples GitHub repository](https://github.com/wso2/choreo-samples)

### [Choreo samples - GitHub Repository](https://github.com/wso2/choreo-samples)

- **Fork the Repository**: Start by forking the repository to your account.

- **Explore & run**: Navigate through the different integration scenarios. Each example has a README.md with setup and execution instructions.



# Develop a Manual Task

This guide walks you through the steps to develop, deploy, test, and observe a manual task using Choreo.

In this guide, you will:

- Develop a manual task to fetch the weather forecast for a specified location for the next 24 hours from the [OpenWeatherMap](https://openweathermap.org) API.
- Process the weather data into a specific format.
- Send the formatted data to a specified email address.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

    !!! info "Repository File Structure"
        The sample code for this guide is in the `<sample-repository-dir>/weather-to-email-integration` directory. The following table describes the key files in the repository:

        | **File Path**         | **File Content**                                                     |
        | --------------------- | -------------------------------------------------------------------- |
        | **Ballerina.toml**    | Contains metadata about the project                                  |
        | **Dependencies.toml** | Lists the dependencies required for the project                      |
        | **main.bal**          | Contains the entry point of the project, including the main function |
        | **types.bal**         | Contains custom data types used in the project                       |
        | **utils.bal**         | Contains utility functions and helper functions used in the project  |

3. Go to [OpenWeatherMap](https://openweathermap.org/) and sign up to obtain an API key. For details, see the [OpenWeatherMap documentation](https://openweathermap.org/appid#signup).

## Step 1: Create a manual task component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Manual Task** card.
6. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:

        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

7. Enter the following information:

    | **Field**             | **Description**                                      |
    | ----------------------| -----------------------------------------------------|
    | **Organization**      | Your GitHub account                                  |
    | **Repository**        | `choreo-samples`                                     |
    | **Branch**            | `main`                                               |
    | **Component Directory** | `weather-to-email-integration`                       |

8. Select **Ballerina** as the **Build Pack**.

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Component Directory** specifies the location of the project to build the component.

4. Enter a unique name and description for the component. You can use the following values:

    | **Field**          | **Value**                        |
    | ------------------ | -------------------------------- |
    | **Component Name** | `WeatherToEmail`                 |
    | **Description**    | `My first manual task`           |


8. Click **Create**. Choreo initializes the component with the sample implementation and opens the **Overview** page of the component.

## Step 2: Build the manual task

1. In the left navigation menu, click **Build**.
2. In the **Builds** pane, click **Build**. This opens the **Commits** pane, where you can see all the commits related to the component.
3. Select the latest commit and click **Build**. This triggers the build process and displays the build progress in the **Build Logs** pane.

    !!! info
        The build process may take some time. Once complete, the build status will be listed in the **Builds** pane. Here, you will see the build status as **Success**.

## Step 3: Deploy the manual task

1. In the left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane, specify values for the configurable variables:

    !!! tip
        The configurable variables populated here are defined in the sample Ballerina project used in this guide. To learn how to declare configurable variables in Ballerina, see the [Ballerina documentation on declaring configurable variables](https://ballerina.io/learn/by-example/configurable-variables/).

    | **Field**     | **Value**                                                               |
    | ------------- | ----------------------------------------------------------------------- |
    | **apiKey**    | The API key you obtained in the prerequisites section                   |
    | **latitude**  | Latitude of the location to get the weather forecast                    |
    | **longitude** | Longitude of the location to get the weather forecast                   |
    | **email**     | The email address to receive the formatted weather forecast information |

    !!! note
        If you use **Ballerina** as the buildpack and want to set a configurable variable as a secret, click the lock icon corresponding to the configurable variable. This marks it as a secret and conceals the input value.

        For example, if you set the **apiKey** as a secret, its input value will be concealed. To update the input value later, click **Update Secret Content** and specify a new value.

4. Click **Deploy**.

## Step 4: Execute the manual task

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the task.

    !!! info "Inject Dynamic Values into Your Application as Command-Line Arguments"
        If you want to inject dynamic values into your application as command-line arguments when you run a manual task, follow these steps:
        1. Click the drop-down icon next to **Run Now** and then click **Run with Arguments**.
        2. In the **Runtime Arguments** pane, enter the arguments you want to pass to your application.
        3. Click **Execute**. This triggers the task with the specified arguments.

        The capability to run a manual task with arguments is supported for the following buildpacks:

        === "Dockerfile"
            To explore a Dockerfile-based manual task with arguments, try out the [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/docker-hello-world-manual-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on Docker projects, the **Run with Arguments** capability is not supported if the Dockerfile contains `CMD`. In such scenarios, use `ENTRYPOINT` to define your default commands.

        === "Go"
            To explore a Go-based manual task with arguments, try out the [Hello World Go Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-go-task) sample. For instructions, see the `readme.md` file in the sample repository.

        === "Java"
            To explore a Java-based manual task with arguments, try out the [Hello World Java Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-java-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on Java projects:
                - The **Run with Arguments** capability is not supported if `Procfile` is available in the project.
                - The `Main` class should be defined in the `manifest` file.
                - If Maven files such as `mvn.cmd` exist in the project without the `.mvn` directory, the build will fail. To ensure a successful build, either commit the `.mvn` directory along with any Maven files or exclude Maven files if you choose not to commit the `.mvn` directory.

        === "NodeJS"
            To explore a NodeJS-based manual task with arguments, try out the [Hello World NodeJS Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-nodejs-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on NodeJS projects:
                - The **Run with Arguments** capability is not supported if `Procfile` is available in the project.
                - The project root must contain the `package.json` file with the `main` attribute defined.

        === "WSO2 MI"
            To explore a WSO2 MI-based manual task with arguments, try out the [Weather to Logs Task](https://github.com/wso2/choreo-samples/tree/main/weather-to-logs-mi-manual-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on WSO2 MI projects and deploying a WSO2 MI integration as a manual task in Choreo, use the WSO2 MI automation mode. For details, see [Running the Micro Integrator in Automation Mode](https://apim.docs.wso2.com/en/latest/install-and-setup/install/running-the-mi-in-automation-mode/).

        === "Ballerina"
            To explore a Ballerina manual task with arguments, try out the [Weather to Email Task](https://github.com/wso2/choreo-samples/tree/main/weather-to-email-integration) sample. For instructions, see the README.md file in the sample repository.

            !!! info
                If you want to pass arguments to Ballerina main functions, use the **Run with Arguments** capability. For details on the arguments you can pass, see the [Ballerina documentation](https://ballerina.io/learn/by-example/main-function/). You can also override configurable values in the same manner. For more information, see [Provide values to configurable variables](https://ballerina.io/learn/provide-values-to-configurable-variables/#provide-via-command-line-arguments).

## Step 5: Test the manual task

Once the task is triggered, an email with the subject `[WSO2 Choreo Demo] Next 24H Weather Forecast` is sent from `choreo.demo@gmail.com` to the email address specified as the **email** configurable variable value in [Step 3](#step-3-deploy-the-manual-task).

If the manual task ran successfully, you should receive an email similar to the following:

![Received email](../../assets/img/develop-components/develop-a-scheduled-integration/Received-email.png)

## Step 6: Observe the manual task

The observability view in Choreo displays graphs that depict details such as throughput, latency, diagnostic data, and logs to identify and troubleshoot anomalies in components you deploy.

1. In the left navigation menu, click **Observability**.
2. Observe the following:
    - The throughput and latencies of requests served over a given period.
    - The logs generated over a given period.
    - The flame graph (Diagnostics View) generated over a given period.
    - The low-code diagram.

To learn more about the observability details you can view via Choreo observability, see [Observability Overview](../../monitoring-and-insights/observability-overview.md).

## Step 7: Monitor executions

To track and monitor executions associated with the deployed manual task, go to the left navigation menu and click **Execute**.

!!! tip
    The **Execute** view is applicable to both scheduled and manual tasks.

You can view the following information:

- **Total executions**: The total number of executions within the past 30 days.

    ![Total Execution](../../assets/img/develop-components/develop-a-scheduled-integration/total_executions.png)

- **Execution history**: The currently active executions and those that are already complete. You can view information such as the execution ID, the revision of the execution, and the time it was triggered.

    ![Execution History](../../assets/img/develop-components/develop-a-scheduled-integration/execution_history.png)

- **Detailed execution logs**: Click on an execution to view detailed logs related to it.

    !!! info
        It may take a few minutes for the logs to appear. You may need to manually refresh to view the latest logs.

    ![Execution Logs](../../assets/img/develop-components/develop-a-scheduled-integration/execution_logs.png)


# Develop a Scheduled Task

Choreo is a versatile integration platform that allows you to create various types of integrations depending on your requirements. If you need to automatically run a specific integration at regular intervals, you can use Choreo to develop a scheduled task. This type of integration can automate the synchronization of data between different systems at specified intervals, reducing errors and improving productivity by eliminating the need for manual intervention.

This guide walks you through the steps to develop, deploy, test, and observe a scheduled task using Choreo.

In this guide, you will:

- Develop a scheduled task to fetch the weather forecast for a specified location for the next 24 hours from the [OpenWeatherMap](https://openweathermap.org) API.
- Process the weather data into a specific format.
- Send the formatted data to a specified email address at a specific time every day.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

    !!! info "Repository File Structure"
        The sample code for this guide is in the `<sample-repository-dir>/weather-to-email-scheduled-task` directory. The following table describes the key files in the repository:

        | **File Path**         | **File Content**                                                     |
        | --------------------- | -------------------------------------------------------------------- |
        | **Ballerina.toml**    | Contains metadata about the project                                  |
        | **Dependencies.toml** | Lists the dependencies required for the project                      |
        | **main.bal**          | Contains the entry point of the project, including the main function |
        | **types.bal**         | Contains custom data types used in the project                       |
        | **utils.bal**         | Contains utility functions and helper functions used in the project  |

3. Go to [OpenWeatherMap](https://openweathermap.org/) and sign up to obtain an API key. For details, see the [OpenWeatherMap documentation](https://openweathermap.org/appid#signup).

## Step 1: Create a scheduled task component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Scheduled Task** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following information:

    | **Field**             | **Description**                                |
    | --------------------- | ---------------------------------------------- |
    | **Organization**      | Your GitHub account                            |
    | **Repository**        | `choreo-samples`                               |
    | **Branch**            | `main`                                         |
    | **Component Directory** | `weather-to-email-scheduled-task`              |

6. Select **Ballerina** as the build pack.

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Component Directory** specifies the location of the project to build the component.

7. Enter a unique name and description for the component. You can use the following values:

    | **Field**          | **Value**                        |
    | ------------------ | -------------------------------- |
    | **Component Name** | `WeatherToEmail`                 |
    | **Description**    | `My first scheduled task`        |

8. Click **Create**. Choreo initializes the component with the sample implementation and opens the **Overview** page of the component.

Now you can proceed to build and deploy the scheduled task.

## Step 2: Build the scheduled task

1. In the left navigation menu, click **Build**.
2. In the **Builds** pane, click **Build**. This opens the **Commits** pane, where you can see all the commits related to the component.
3. Select the latest commit and click **Build**. This triggers the build process and displays the build progress in the **Build Logs** pane.

    !!! info
        The build process may take some time. Once complete, the build status will be listed in the **Builds** pane. Here, you will see the build status as **Success**.

## Step 3: Deploy the scheduled task

1. In the left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane, specify values for the configurable variables:

    !!! tip
        The configurable variables populated here are defined in the sample Ballerina project used in this guide. To learn how to declare configurable variables in Ballerina, see the [Ballerina documentation on declaring configurable variables](https://ballerina.io/learn/by-example/configurable-variables/).

    | **Field**     | **Value**                                                               |
    | ------------- | ----------------------------------------------------------------------- |
    | **apiKey**    | The API key you obtained in the prerequisites section                   |
    | **latitude**  | Latitude of the location to get the weather forecast                    |
    | **longitude** | Longitude of the location to get the weather forecast                   |
    | **email**     | The email address to receive the formatted weather forecast information |

    !!! note
        If you use **Ballerina** as the buildpack and want to set a configurable variable as a secret, click the lock icon corresponding to the configurable variable. This marks it as a secret and conceals the input value.

        For example, if you set the **apiKey** as a secret, its input value will be concealed. To update the input value later, click **Update Secret Content** and specify a new value.

4. Click **Next**.
5. Define a schedule to run the task. In this guide, set the schedule to receive the weather information daily at 8:00 AM UTC. Enter the following values:

    | **Field**            | **Value**                                             |
    | -------------------- | ----------------------------------------------------- |
    | **Select Time Zone** | Select a time zone to schedule the task               |
    | **Select Range**     | **Day**                                               |
    | **Every**            | `1`                                                   |
    | **At**               | `08:00`                                               |

    !!! tip
        To test and verify the task immediately, you can schedule the deployment to run in just a few minutes after you create it. However, to avoid unnecessary expenses, reschedule or stop the deployment once you test and verify.

6. Click **Deploy**. This deploys the scheduled task to the development environment and indicates the **Scheduled Status** as **Active** in the **Development** card.

You can test the scheduled task when it runs at the configured time.

## Step 4: Test the scheduled task

When the scheduled task runs at the configured time, an email with the subject `[WSO2 Choreo Demo] Next 24H Weather Forecast` is sent from `choreo.demo@gmail.com` to the email address specified as the **email** configurable variable value in [Step 3](#step-3-deploy-the-scheduled-task).

If the scheduled task ran successfully, you should receive an email similar to the following:

![Received email](../../assets/img/develop-components/develop-a-scheduled-integration/Received-email.png)

## Step 5: Observe the scheduled task

The observability view in Choreo displays graphs that depict details such as throughput, latency, diagnostic data, and logs to identify and troubleshoot anomalies in components you deploy.

1. In the left navigation menu, click **Observability**.
2. Observe the following:
    - The throughput and latencies of requests served over a given period.
    - The logs generated over a given period.
    - The flame graph (Diagnostics View) generated over a given period.
    - The low-code diagram.

To learn more about the observability details you can view via Choreo observability, see [Observability Overview](../../monitoring-and-insights/observability-overview.md).

## Step 6: Monitor executions

To track and monitor executions associated with the deployed scheduled task, go to the left navigation menu and click **Execute**.

!!! tip
    The **Execute** view is applicable to both scheduled and manual tasks.

You can view the following information:

- **Total executions**: The total number of executions within the past 30 days.

    ![Total Execution](../../assets/img/develop-components/develop-a-scheduled-integration/total_executions.png)

- **Execution history**: The currently active executions and those that are already complete. You can view information such as the execution ID, the revision of the execution, and the time it was triggered.

    ![Execution History](../../assets/img/develop-components/develop-a-scheduled-integration/execution_history.png)

- **Detailed execution logs**: Click on an execution to view detailed logs related to it.

    !!! info
        It may take a few minutes for the logs to appear. You may need to manually refresh to view the latest logs.

    ![Execution Logs](../../assets/img/develop-components/develop-a-scheduled-integration/execution_logs.png)


# Develop an Event Handler

An event handler executes predefined actions in response to specific events. Choreo simplifies the process of creating and deploying such integrations.

This guide walks you through the steps to create and deploy an Event Handler using WSO2 MI and Choreo.

In this guide, you will build a simple event handler that monitors RabbitMQ for new messages and displays them once they become available.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Set up RabbitMQ:
    - Use an existing RabbitMQ instance or start a new [RabbitMQ](https://www.rabbitmq.com/download.html) instance on a server that can be accessed via the internet.
    - Obtain the `username`, `hostname`, `password`, and `vhost` from the RabbitMQ instance to use later as environment variables.

3. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

## Step 1: Create an event handler component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Event Handler** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following information:

    | **Field**             | **Description**              |
    |-----------------------|----------------------------- |
    | **Organization**      | Your GitHub account          |
    | **Repository**        | `choreo-samples`             |
    | **Branch**            | `main`                       |
    | **Component Directory** | `mi-rabbitmq-listener`       |

6. Select **WSO2 MI** as the build pack. (since you are creating the REST API from a [WSO2 Integration Studio](https://wso2.com/micro-integrator/) project)

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Component Directory** specifies the location of the project to build the component.

7. Enter a unique name and description for the component. You can use the following values:

    | **Field**          | **Value**              |
    |--------------------|------------------------|
    | **Component Name** | `SalesOrderListener`   |
    | **Description**    | `RabbitMQ integration` |

8. Click **Create**.

## Step 2: Deploy the integration

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**.
3. In the **Configurations** pane, click **+ Add** corresponding to **Environment Variables** and add the following environment variables:

    !!! tip
        Use the values from your RabbitMQ instance as per the [Prerequisites](#prerequisites) section for the environment variables.

    | **Name**     | **Value**                                         |
    | ------------- |--------------------------------------------------|
    | **HOSTNAME**  | Hostname of your RabbitMQ server                 |
    | **VHOST**     | Virtual hostname of your RabbitMQ server         |
    | **USERNAME**  | Username for connecting to RabbitMQ              |
    | **PASSWORD**  | Password associated with the RabbitMQ username   |

4. Click **Deploy**. This deploys the event handler to the development environment and indicates the **Deployment Status** as **Active** in the **Development** card.

## Step 3: Test the integration

1. Send a sales order message to the **SalesOrderQueue** on the RabbitMQ server. You can send a sample sales order message similar to the following:

    ```json
    {
        "order_id": "12345",
        "customer_name": "John Doe",
        "product": "Widget",
        "quantity": 10,
        "total_amount": 100.00
    }
    ```

2. Observe the logs:
    - In the left navigation menu, click **Logs** and then click **Runtime Logs**. You will see the order message in the logs.

Now you have gained hands-on experience in creating, configuring, and deploying an event handler.


# Develop an Integration with Integration Studio

Choreo simplifies the process of building, deploying, and managing integration components, making it easy to expose integrations as APIs. This guide walks you through the steps to expose an integration created in WSO2 Integration Studio as an API in Choreo.

In this guide, you will:
- Create a component to expose a sample integration from the [Choreo samples repository](https://github.com/wso2/choreo-samples) as an API.
- Deploy, test, and observe the integration component.
- Publish the integration component as an API to the Choreo Developer Portal.

!!! note
    - To develop integrations for **Manual Task** and **Schedule Task** components in Choreo, use the **automation mode** in the WSO2 Micro Integrator. See [Running MI in Automation Mode](https://apim.docs.wso2.com/en/4.2.0/install-and-setup/install/running-the-mi-in-automation-mode/).
    - For other component types (Service, webhook, event-handler, etc.), use the **server mode**.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    - Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    - Enter a unique organization name. For example, `Stark Industries`.
    - Read and accept the privacy policy and terms of use.
    - Click **Create**. This creates the organization and opens the **Project Home** page.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

## Step 1: Create the integration component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the **Project Home** page.

2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following repository details:

    | **Field**             | **Description**              |
    |-----------------------|----------------------------- |
    | **Organization**      | Your GitHub account          |
    | **Repository**        | `choreo-samples`            |
    | **Branch**            | **`main`**                   |
    | **Component Directory** | `hello-world-mi`             |

6. Select WSO2 MI as the build pack (since you're creating the REST API from a [WSO2 Integration Studio](https://wso2.com/micro-integrator/) project).

7. Provide a unique name and description for the component:

    | **Field**          | **Value**              |
    |--------------------|------------------------|
    | **Component Name** | `Hello World`          |
    | **Description**    | `Hello World REST API` |

8. Click **Create**. Choreo initializes the component with the sample integration.

## Step 2: Deploy the integration component

1. In the Choreo Console left navigation menu, click **Deploy**.

2. Configure and deploy:
   - In the **Build Area** card, click **Configure & Deploy**.
   - In the **Configurations** pane, click **Next**. This displays the endpoint details ready for deployment.
   - Click **Deploy**. This deploys the integration component to the development environment.

    !!! tip
        - Choreo uses [endpoints](../../choreo-concepts/endpoint.md) to expose **Service** components to the network. Learn more about configuring endpoints in [Configure Endpoints](../configure-endpoints.md).
        - Automatic deployment is enabled by default, so only the first deployment needs to be done manually.

   The **Development** card shows the **Deployment Status** as **Active** when the integration is successfully deployed.

## Step 3: Test the integration

1. In the Choreo Console left navigation menu, click **Test** and then click **Console**.
2. In the OpenAPI Console, select **Development** from the environment drop-down list.
3. Expand the **GET /integration** operation.
4. Click **Try it out**, then click **Execute**. This sends a request to your deployed integration.
5. Check the response:
    - In the **Response body** section, observe the response. If the integration works as expected, you should see:
     
     ```json
     {"Hello" : "Integration"}
     ```

## Step 4: Observe the integration

1. Click **Observability** in the left navigation menu to monitor the performance of the integration component.

2. View metrics:
   - Observe throughput and latencies of requests over time.
   - View logs generated during a specific period.
   - Analyze the flame graph (Diagnostics View) for performance insights.

   For more details, see [Observability Overview](../../monitoring-and-insights/observability-overview.md).

## Step 5: Publish the integration component

1. In the Choreo Console left navigation menu, click **Manage** and then click **Lifecycle**.
2. The **Lifecycle Management** pane shows the current lifecycle stage as **Created**.
3. Click **Publish**. This changes the lifecycle stage to **Published** and exposes the integration as an API in the Choreo Developer Portal.
   - To view the published API, click **Go to Devportal**. In the Developer Portal, you can manage subscriptions and generate access tokens for testing.

Now you have successfully exposed an integration designed in WSO2 Integration Studio as a REST API in Choreo!


# Develop an API Proxy from a GitHub Repository Source

An API proxy acts as an intermediary between an existing API and Choreo, intercepting all requests made to the API. It also functions as a managed API, allowing you to apply essential API management features such as security policies and rate limiting.

In this guide, you will:

- Create an API proxy component to expose an existing API.
- Deploy the API proxy.
- Test the API proxy to verify its functionality.
- Manage the API.
- Consume the API.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample proxy source](https://github.com/wso2/choreo-samples/tree/main/department-api-proxy-from-github).  

## Step 1: Create an API proxy

You can create an API proxy either by selecting the source from a GitHub repository, uploading an OpenAPI specification file, or providing an OpenAPI specification URL. This guide demonstrates how to create an API proxy using a GitHub repository as the source.

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **API Proxy** card. This opens the **Create an API Proxy** pane.

4. Click on **Authorize With GitHub** card under **Connect a Git Repository** section to connect your GitHub account.
    - If you haven’t connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
         - Read and write access to code and pull requests.
         - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.    

5. Enter the following repository details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **Repository**         | choreo-samples     |
    | **Branch**             | **`main`**         |
    | **API Directory**      | /department-api-proxy-from-github |

    !!! note
        To select the relevant directory, click on the **Edit** action next to the **API Directory** input field. Then, enter `department-api-proxy-from-github` as the directory name to quickly search and locate the correct directory.

6. Specify the following values as Proxy Metadata:

    !!! info
        The **Context** field must be unique and cannot be changed after creation.**Version** and **Target** are mandatory fields. **Target** can be changed at any time after the creation.

    | **Field**       | **Value**                                  |
    |-----------------|--------------------------------------------|
    | **Context**     | `department-service`                                   |
    | **Version**     | `v1.0`                                      |
    | **Target**      | `https://samples.choreoapps.dev/company/hr`|

7. Specify the following values as Component Details:

    !!! info
        The **Component Name** field must be unique and cannot be changed after creation. This value is automatically generated, but you can edit it if necessary.
        **Component Display Name** is a required field.

    | **Field**       | **Value**                                  |
    |-----------------|--------------------------------------------|
    | **Component Display Name**| `Department Service`                    |
    | **Component Name**        | `department-service`                    |
    | **Description**           | `This is a sample proxy for department service`     |    

8. Click **Create**. This creates the API proxy component and takes you to the **Build** page.

!!! note
    When you create an API proxy from a GitHub repository source, the GitHub source serves as the single source of truth. Therefore, any modifications, such as adding or deleting resources, must be made through the GitHub repository.

## Step 2: Build

!!! info
    The initial build starts automatically when you create the API proxy, and you will be redirected to the **Build** page. In this case, you can skip the steps below. If you need to manually trigger a build later, follow these steps.

1. On the project home page, click on the `Department Service` component you created. This takes you to the component overview page.
2. In the left navigation menu, click **Build**.
3. On the **Build** page, click **Build Latest**.

!!! note
    The build process may take some time. You can track progress in the **Build Details** pane. Once complete, the build status changes to **Success**.

## Step 3: Deploy the API proxy

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**. This opens the **Configure & Deploy** pane.
3. Select **External** as the **API Access Mode** and click **Deploy**. The **Development** card indicates the **Deployment Status** as **Active** when the API proxy is successfully deployed.

Now you are ready to test the API proxy.

## Step 4: Test the API proxy

Choreo allows you to test your API proxy using either the [integrated OpenAPI Console](../../testing/test-rest-endpoints-via-the-openapi-console.md) or [cURL](../../testing/test-apis-with-curl.md). In this guide, you will use the OpenAPI Console.

!!! tip
    Choreo enables OAuth 2.0 to secure APIs by default. Therefore, you need an access token to invoke an API.

    - Choreo automatically generates a key to test the API via the OpenAPI Console. To view the key, click the show key icon in the **Security Header** field.
    - To disable security for the entire API or a specific resource:
        1. In the left navigation menu, click **Deploy**.
        2. Go to the **Build Area** card and click **Security Settings**.
        3. In the **Security Settings** pane:
            - To disable security for the entire API, clear the **OAuth2** checkbox.
            - To disable security for a specific resource, expand the relevant resource and turn off the **Security** toggle.
        4. Click **Apply**.

1. In the left navigation menu, click **Test** and then click **OpenAPI Console**.
2. Select **Development** from the environment drop-down list.
3. Expand the `GET /department/{departmentId}` resource and click **Try it Out**.
4. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

    ![API proxy response](../../assets/img/develop-components/develop-a-rest-api-proxy/rest-api-proxy-response.png){.cInlineImage-full}

    This indicates that your API proxy is working as expected.

## Step 5: Manage the API proxy

Now that you have a tested API proxy, you can publish it and make it available for application developers to consume. In this guide, you will apply rate limiting to the API and publish it.

### Step 5.1: Apply rate limiting to the API proxy

1. In the left navigation menu, click **Deploy**.
2. Go to the required environment card and click the settings icon corresponding to **API Configuration**.
3. In the **CORS, Rate Limiting and Resiliency** pane, click **Rate Limiting** to expand the section.
4. Select **API Level** as the **Rate Limiting Level**.
5. Specify appropriate values for the **Request Limit** and **Time Unit** fields. You can proceed with the default values.
6. Click **Apply**. This applies the rate limiting level to the API proxy and redeploys it.

### Step 5.2: Publish the API proxy

1. In the left navigation menu, click **Lifecycle** under **Manage**. This takes you to the **Lifecycle** page.
2. Click **Publish**.
3. In the **Publish API** dialog, click **Confirm** to proceed with publishing the API. If you want to change the display name, make the necessary changes and then click **Confirm**. This changes the API lifecycle state to **Published**.

## Step 6: Invoke the API

To generate credentials for the published API and invoke it via the Choreo Developer Portal, follow these steps:

1. In the **Lifecycle** page, click **Go to Devportal**. This takes you to the `Department Service` in the Choreo Developer Portal.

2. **Invoke the API**:
    1. In the Developer Portal left navigation menu, click **Try Out**.
    2. In the **Endpoint** list, select **Development** as the environment to try out the API.
    3. Click **Get Test Key** to generate an access token.
    4. Expand the `GET /department/{departmentId}` resource and click **Try it out**.
    5. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

        ![Try out response](../../assets/img/develop-components/develop-a-rest-api-proxy/try-out-response.png){.cInlineImage-full}

Now, you have gained hands-on experience creating, deploying, testing, and publishing an API proxy using Choreo.


# Develop an API Proxy from Scratch

An API proxy acts as an intermediary between an existing API and Choreo, intercepting all requests made to the API. It also functions as a managed API, allowing you to apply essential API management features such as security policies and rate limiting.

In this guide, you will:

- Create an API proxy component to expose an existing API.
- Deploy the API proxy.
- Test the API proxy to verify its functionality.
- Manage the API.
- Consume the API.

## Prerequisites

- If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

## Step 1: Create an API proxy

To create an API proxy, you can either upload an OpenAPI specification or provide an OpenAPI specification URL. In this guide, you will specify a URL to an OpenAPI definition of a sample API.

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **API Proxy** card. This opens the **Create an API Proxy** pane.
4. Select **Creare from Scratch** option. 
5. Specify the following values as Proxy Metadata:

    | **Field**       | **Value**                                  |
    |-----------------|--------------------------------------------|
    | **Context**     | `department-service`                                   |
    | **Version**     | `v1.0`                                      |
    | **Target**      | `https://samples.choreoapps.dev/company/hr` |

6. Enter following details for the Component Details:

    !!! info
        The **Component Name** field must be unique and cannot be changed after creation.

    | **Field**                 | **Value**          |
    |---------------------------|--------------------|
    | **Component Display Name**| `Department Service`          |
    | **Component Name**        | `department-service`          |
    | **Description**           | `Sample proxy for department service`     |

7. Click **Create**. This creates the API proxy component and takes you to the **Deploy** page.

## Step 2: Define resources for the API proxy

To add a new resource that retrieves a department by the department ID, follow these steps:

1. In the left navigation menu, click **Develop** and then click **Resources**.
2. Select **GET** as the **HTTP Verb** and enter `/department/{departmentId}` as the **URI Pattern**.
3. Click **+** to add the resource.
4. Expand the added resource and specify the following values:

    | **Field**        | **Value**                            |
    |------------------|--------------------------------------|
    | **Operation ID** | `findDepartment`                     |
    | **Description**  | `Find a department by department ID` |

5. Remove the five default resources that start with `/*` by clicking the delete icon corresponding to each resource.
6. Click **Save**.

## Step 3: Deploy the API proxy

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**. This opens the **Configure & Deploy** pane.
3. Select **External** as the API access mode and click **Deploy**. The **Development** card indicates the **Deployment Status** as **Active** when the API proxy is successfully deployed.

Now you are ready to test the API proxy.

## Step 4: Test the API proxy

Choreo allows you to test your API proxy using either the [integrated OpenAPI Console](../../testing/test-rest-endpoints-via-the-openapi-console.md) or [cURL](../testing/test-apis-with-curl.md). In this guide, you will use the OpenAPI Console.

!!! tip
    Choreo enables OAuth 2.0 to secure APIs by default. Therefore, you need an access token to invoke an API.

    - Choreo automatically generates a key to test the API via the OpenAPI Console. To view the key, click the show key icon in the **Security Header** field.
    - To disable security for the entire API or a specific resource:
        1. In the left navigation menu, click **Deploy**.
        2. Go to the **Build Area** card and click **Security Settings**.
        3. In the **Security Settings** pane:
            - To disable security for the entire API, clear the **OAuth2** checkbox.
            - To disable security for a specific resource, expand the relevant resource and turn off the **Security** toggle.
        4. Click **Apply**.

1. In the left navigation menu, click **Test** and then click **OpenAPI Console**.
2. Select **Development** from the environment drop-down list.
3. Expand the `GET /department/{departmentId}` resource and click **Try it Out**.
4. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

    ![API proxy response](../../assets/img/develop-components/develop-a-rest-api-proxy/rest-api-proxy-response.png){.cInlineImage-full}

    This indicates that your API proxy is working as expected.

## Step 5: Manage the API proxy

Now that you have a tested API proxy, you can publish it and make it available for application developers to consume. In this guide, you will apply rate limiting to the API and publish it.

### Step 5.1: Apply rate limiting to the API proxy

1. In the left navigation menu, click **Deploy**.
2. Go to the required environment card and click the settings icon corresponding to **CORS, Rate Limiting and Resiliency**.
3. In the **CORS, Rate Limiting and Resiliency** pane, click **Rate Limiting** to expand the section.
4. Select **API Level** as the **Rate Limiting Level**.
5. Specify appropriate values for the **Request Limit** and **Time Unit** fields. You can proceed with the default values.
6. Click **Apply**. This applies the rate limiting level to the API proxy and redeploys it.

### Step 5.2: Publish the API proxy

1. In the left navigation menu, click **Lifecycle** under **Manage**. This takes you to the **Lifecycle** page.
2. Click **Publish**.
3. In the **Publish API** dialog, click **Confirm** to proceed with publishing the API. If you want to change the display name, make the necessary changes and then click **Confirm**. This changes the API lifecycle state to **Published**.

## Step 6: Invoke the API

To generate credentials for the published API and invoke it via the Choreo Developer Portal, follow these steps:

1. In the **Lifecycle** page, click **Go to Devportal**. This takes you to the `Department Service` in the Choreo Developer Portal.

2. **Invoke the API**:
    1. In the Developer Portal left navigation menu, click **Try Out**.
    2. In the **Endpoint** list, select **Development** as the environment to try out the API.
    3. Click **Get Test Key** to generate an access token.
    4. Expand the `GET /department/{departmentId}` resource and click **Try it out**.
    5. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

        ![Try out response](../../assets/img/develop-components/develop-a-rest-api-proxy/try-out-response.png){.cInlineImage-full}

Now, you have gained hands-on experience creating, deploying, testing, and publishing an API proxy using Choreo.

# Develop a Ballerina Service

Choreo allows you to develop and deploy applications using your preferred programming language. This guide demonstrates how to deploy a service component that exposes a REST API using the [Ballerina language](https://ballerina.io/). No prior knowledge of Ballerina is required to follow this guide.

A REST API is a web service that adheres to Representational State Transfer (REST) principles, using HTTP methods to access and manage resources. This guide walks you through building a Ballerina service component, deploying it on Choreo, and testing it with an HTTP client application.

In this guide, you will:

 - Build a simple greeting service using a sample implementation. The service has a single resource named `greet` that accepts a query parameter as input.
 - Deploy the service in Choreo.
 - Test the service.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    - Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    - Enter a unique organization name. For example, `Stark Industries`.
    - Read and accept the privacy policy and terms of use.
    - Click **Create**. This creates the organization and opens the **Project Home** page.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample greetings service](https://github.com/wso2/choreo-samples/tree/main/greeting-service) implementation in Ballerina.

### Learn the repository file structure

It’s important to understand the purpose of key files in the sample service. The table below provides an overview of each file in the greeter service:

!!! note
    The file paths are relative to `<sample-repository-dir>/greeting-service`.

| **Filepath**              | **Description**                                                |
|---------------------------|---------------------------------------------------------------|
| `service.bal`             | The greetings service code written in Ballerina.               |
| `tests/service_test.bal`  | Test files related to the `service.bal` file.                  |
| `Ballerina.toml`          | The Ballerina configuration file.                              |

Let’s get started!

## Step 1: Create a service component

To create a Ballerina service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the **Project Home** page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect your GitHub account. If you haven’t connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Provide the following repository details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **Repository**         | choreo-samples     |
    | **Branch**             | **`main`**         |
    |**Component Directory** | `/greeting-service` |

6. Select **Ballerina** as the buildpack.

7. Provide a display name, a unique name, and a description for the service component:

    !!! info
        The **Component Name** field specifies a unique identifier for the component. This name cannot be changed after creation.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Ballerina Greetings`   |
    | **Component Name**        | `ballerina-greetings`   |
    | **Description**           | Send greetings          |

8. Click **Create**. This creates the component and takes you to the **Overview** page.

You have successfully created a service that exposes a REST API written in Ballerina. Next, let’s build and deploy the service.

## Step 2: Build and deploy

Now that you’ve connected the source repository and configured the endpoint details, it’s time to build and deploy the service.

!!! note
    If you’re rebuilding the Ballerina service component after changing the Ballerina version, ensure that the version in the `Ballerina.toml` file matches the version in the `Dependencies.toml` file.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service may take a while. Track the progress via the logs in the **Build Details** pane. Once complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps:

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane, click **Next** to skip the configuration.
4. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service may take a while. Once deployed, the **Development** environment card shows the **Deployment Status** as **Active**.

Once deployed, you can test, manage, and observe the service like any other component in Choreo.

For detailed instructions, see the following sections:
- [Step 3: Test](../../testing/test-rest-endpoints-via-the-openapi-console.md)
- [Step 4: Manage](../../api-management/lifecycle-management.md)

## Manage the deployment

To view Kubernetes-level insights for detailed diagnosis of this Ballerina REST API, see Choreo’s [DevOps capabilities](../../devops-and-ci-cd/view-runtime-details.md).


# Develop a Service with Docker

Choreo allows you to create and deploy applications in any language. This guide demonstrates how to develop and deploy a containerized service component using a Dockerfile.

In this guide, you will:

 - Create a containerized service component using a sample service implementation. The sample service has a single resource named `greet` that accepts a query parameter as input.
 - Deploy the service in Choreo using a Dockerfile. The service will run on port 9090.
 - Test the service.

If you want to create a service component that exposes a Ballerina service, see [Develop a Ballerina Service](develop-a-ballerina-service.md).

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    - Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    - Enter a unique organization name. For example, `Stark Industries`.
    - Read and accept the privacy policy and terms of use.
    - Click **Create**. This creates the organization and opens the **Project Home** page.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample greetings service](https://github.com/wso2/choreo-samples/tree/main/greeting-service-go) implementation with the Dockerfile.

### Learn the repository file structure

It’s important to understand the purpose of key files in the sample service. The table below provides an overview of each file in the greeter service:

!!! note
    The file paths are relative to `<sample-repository-dir>/greeting-service-go`.

| **Filepath**               | **Description**                                                              |
|----------------------------|------------------------------------------------------------------------------|
| `main.go`                  | The Go-based greeter service code.                                           |
| `Dockerfile`               | The Dockerfile to build the container image of the application.              |
| `.choreo/component.yaml`   | Choreo-specific configuration that provides information about how Choreo exposes the service. |
| `openapi.yaml`             | The OpenAPI contract of the greeter service. This is required to publish the service as a managed API. This file is referenced by the `.choreo/component.yaml` file. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints. The greeter service runs on port 9090. To securely expose the service through Choreo, you must provide the port and other required information in the `component.yaml` file. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

In the greeter sample, the `component.yaml` file is located in the `greeting-service-go/.choreo/` directory.

## Step 1: Create a service component from a Dockerfile

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/cloud-native-app-developer) and sign in. This opens the **Project Home** page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect your GitHub account. If you haven’t connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
         - Read and write access to code and pull requests.
         - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following repository details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **Repository**         | choreo-samples     |
    | **Branch**             | `main`         |
    | **Component Directory** | `/greeting-service-go`         |

6. Select **Docker** as the buildpack.
7. Enter the following details:

    | **Field**                | **Value**                        |
    |--------------------------|----------------------------------|
    | **Dockerfile**           | `/greeting-service-go/Dockerfile`|

    !!! info
        1. To successfully build your container with Choreo, explicitly define a user ID (UID) under the `USER` instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-sample-apps/blob/main/go/greeter/Dockerfile).
           - A valid User ID is a numeric value between 10000-20000 (e.g., `10001` or `10500`).
           - Usernames are invalid and should not be used (e.g., `my-custom-user-12221` or `my-custom-user`).

        2. The Dockerfile used in this guide is a multi-stage Dockerfile, which keeps the final image size small and allows building the application with specific versions of tools and libraries.

8. Provide a display name, a unique name, and a description for the service component:

    !!! info
        The **Component Name** field specifies a unique identifier for the component. This name cannot be changed after creation.

    | **Field**                 | **Value**          |
    |---------------------------|--------------------|
    | **Component Display Name**| `Greetings`        |
    | **Component Name**        | `greetings`        |
    | **Description**           | Send greetings     |

9. Click **Create**. This creates the component and takes you to the **Overview** page.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you’ve connected the source repository and configured the endpoint details, it’s time to build the service and create an image. Then, you can deploy the image and test the greeter service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service may take a while. Track the progress via the logs in the **Build Details** pane. Once complete, the build status changes to **Success**.

    You can access the following scans under **Build**:
    - **Dockerfile Scan**: Choreo checks if a non-root user ID is assigned to the Docker container for security. If no non-root user is specified, the build will fail.
    - **Container (Trivy) Vulnerability Scan**: This detects vulnerabilities in the final Docker image. If critical vulnerabilities are found, the build will fail.

    !!! info
        If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps:

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service may take a while. Once deployed, the **Development** environment card shows the **Deployment Status** as **Active**.

Once deployed, you can [test](../../testing/test-rest-endpoints-via-the-openapi-console.md), [manage](../../api-management/lifecycle-management.md), and [observe](../../monitoring-and-insights/observability-overview.md) the service like any other component in Choreo.

To view Kubernetes-level insights for detailed diagnosis of this Dockerfile-based REST API, see [Choreo's DevOps capabilities](../../devops-and-ci-cd/view-runtime-details.md).


# Develop a Service

Choreo allows you to create and deploy applications in your preferred programming language. 

In this guide, you will:

- Build a simple greeting service using a sample service implementation. The sample implementation will have a single resource named `greet` that accepts a single query parameter as input.
- Deploy the service in Choreo using a `Go` buildpack. The service will run on port 9090.
- Test the service.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample greetings service](https://github.com/wso2/choreo-samples/tree/main/greeting-service-go) implementation in `Go`.

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the greeter service:

!!! note 
    The specified file paths are relative to `<sample-repository-dir>/greeting-service-go`.

| **Filepath**             | **Description**                                                               |
|--------------------------|-------------------------------------------------------------------------------|
| `main.go`                | The Go-based greeter service code.                                            |
| `.choreo/component.yaml` | Choreo-specific configuration that provides information about how Choreo exposes the service. |
| `openapi.yaml`           | The OpenAPI contract of the greeter service. This is required to publish the service as a managed API. This `openapi.yaml` file is referenced by the `.choreo/component.yaml` file. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints. To run the greeter service on port 9090 and securely expose it through Choreo, you must provide the port and other required information in the `component.yaml` file. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

In the greeter sample, the `component.yaml` file is located in the `greeting-service-go/.choreo/` directory.

## Step 1: Create a service component

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Public Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Under **Connect a Git Repository**, enter the following details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **GitHub Repository**  | choreo-samples     |
    | **Branch**             | main               |
    | **Component Directory** | `/greeting-service-go` |

6. Select **Go** as the buildpack.
7. Enter the following details:

    | **Field**                | **Value**              |
    |--------------------------|------------------------|
    | **Language Version**     | 1.x                    |

8. Provide component display name, name and description:

    !!! info
        The **Component Name** field must be unique and cannot be changed after creation.

    | **Field**                 | **Value**          |
    |---------------------------|--------------------|
    | **Component Display Name**| Greetings          |
    | **Component Name**        | greetings          |
    | **Description**           | Send greetings     |

9. Click **Create**. This creates the component and lists it under **Component Listing** on the project home page.

You have successfully created the service. The next step is to build and deploy it.

## Step 2: Build and deploy

Now that you have connected the source repository and configured the endpoint details, it's time to build and deploy the greeter service.

### Step 2.1: Build

1. On the project home page, click on the `Greetings` component you created. This takes you to the component overview page.
2. In the left navigation menu, click **Build**.
3. On the **Build** page, click **Build Latest**.

    !!! note
        The build process may take some time. You can track progress in the **Build Details** pane. Once complete, the build status changes to **Success**.

### Step 2.2: Deploy

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take some time. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

Once you have successfully deployed the service, you can [test](../../testing/test-rest-endpoints-via-the-openapi-console.md), [manage](../../api-management/lifecycle-management.md), and [observe](../../monitoring-and-insights/observability-overview.md) it like any other component type in Choreo.


# Expose a Ballerina GraphQL Endpoint via a Service

Choreo offers the flexibility to develop and deploy applications in a language of your preference. This guide shows you how to deploy a service component that exposes a GraphQL API using the Ballerina language in Choreo. No prior knowledge of the Ballerina language is required to follow this guide. 

GraphQL API is a query language and runtime that provides a single endpoint for retrieving flexible and efficient data in a strongly-typed and self-documenting way. By following this guide, you will build a service component in Ballerina and deploy it on Choreo for any GraphQL client application to utilize it.

This guide shows how to build a simple reading list service and deploy it in Choreo using Ballerina. The GraphQL endpoint you create in this guide has two operations: **Query** and **Mutation**. The Query type operations read the data in the data source, and the Mutation operations update the data in the data source. The reading list service has two queries and three mutations as follows:

### Queries

**Retrieve the reading list**

This resource accepts an optional filter, `status`, which filters the reading list by reading status. Accepted values for status are `reading`, `read`, and `to_read`.

**Sample request**:
```
$ curl -X POST -H "Content-Type: application/json" -d '{"query": "query {allBooks (status: \"reading\") { id title author status }}"}' http://localhost:8090
```

**Sample response**
```
$ {
  "data": {
    "allBooks": [
      {
        "id": 1,
        "title": "Sample Book",
        "author": "Test Author",
        "status": "to_read"
      }
    ]
  }
}
```

**Retrieve a book item from the reading list**

This resource accepts a filter, `id`, which will select the book item from the reading list by book id.  The id is an Integer value. 

**Sample request**
```
$ curl -X POST -H "Content-Type: application/json" -d '{"query": "query {book (id: 1) { id title author status }}"}' http://localhost:8090
```

**Sample response**
```
$ {
  "data": {
    "book": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "to_read"
    }
  }
}
```

### Mutations

**Add a book item to the reading list**

This remote function accepts a book record as the input and consists of the title and the author. When you add a new book to the reading list, the method updates the reading status of the newly added book to `to_read`. This method returns the added book item upon successful execution.


**Sample request**

```
$ curl -X POST -H "Content-type: application/json" -d '{ "query": "mutation { addBook(book: {title: \"Sample Book\", author: \"Test Author\"}) { id title author status } }" }' 'http://localhost:8090'
```

**Sample response**

```
$ {
  "data": {
    "addBook": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "to_read"
    }
  }
}
```

**Update the reading status of a book**

This remote function requires `id` and `status` as inputs to update the reading status of the selected book. The `id` refers to the id of the book. It is an integer.  The `status` refers to the reading status that needs to be updated. This method returns the updated book item upon successful execution.

**Sample request**

```
$ curl -X POST -H "Content-type: application/json" -d '{ "query": "mutation { setStatus(id: 1, status: \"reading\") { id title author status } }" }' 'http://localhost:8090'
```

**Sample response**

```
$ {
  "data": {
    "setStatus": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "reading"
    }
  }
}
```

**Delete a book item from the reading list**

This remote function requires the `id` as the input to delete the book item from the reading list. This method returns the removed book item upon successful execution.

**Sample request**

```
$ curl -X POST -H "Content-type: application/json" -d '{ "query": "mutation { deleteBook(id: 1) { id title author status } }" }' 'http://localhost:8090'
```

**Sample response**
```
$ {
  "data": {
    "deleteBook": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "reading"
    }
  }
}
```

Our next step is to set up the resources that you will require to follow the guide, including the sample reading list application and the Choreo GitHub app.

## Prerequisites

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample GraphQL service](https://github.com/wso2/choreo-samples/tree/main/reading-list-graphql) implementation for this guide.

Let's get started!

## Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the reading list service.

!!! note
    The following file paths are relative to the path `<sample-repository-dir>/reading-list-graphql`.

|Filepath                 | Description                                                     |
|-------------------------|-----------------------------------------------------------------|
| `service.bal`           | The reading list service code written in the Ballerina language.|
| `Ballerina.toml`        | The Ballerina configuration file.                               |
| `.choreo/component.yaml`| The configuration file with endpoint details.                   |

## Step 1: Create a service component 

To create a Ballerina service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**| `reading-list-graphql`    |.

6. Select **Ballerina** as the buildpack.

7. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Ballerina Reading List`|
    | **Component Name**        | `ballerina-reading-list`|
    | **Description**           | Manage a reading list   |

8. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service component that exposes a GraphQL API written in the Ballerina language. Next, let's build and deploy the service.

## Step 2: Build and deploy

Now that we have connected the source repository, it's time to build and deploy the reading list service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Configurations** pane that opens, click **Next** to skip the configuration.
4. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.
To build and deploy the service, follow the steps below:

Once you have successfully deployed your service, you can test, manage, and observe it like any other component type in Choreo.

For detailed instructions, see the following sections:

- [Step 3: Test](https://wso2.com/choreo/docs/testing/test-graphql-endpoints-via-the-graphql-console/)
- [Step 4: Manage](https://wso2.com/choreo/docs/manage/api-management/)


# Expose a gRPC Endpoint via a Service

Choreo allows you to create and deploy applications in your preferred programming language. One powerful option is gRPC, a high-performance and language-agnostic remote procedure call (RPC) framework. It utilizes [Protocol Buffers](https://github.com/protocolbuffers/protobuf) to define services and generate client/server code.

In this guide, you will learn to use Choreo to create a service component that exposes a gRPC server implemented in [Go](https://go.dev/), enabling efficient and scalable communication with any gRPC client application. No prior knowledge of the Go language is necessary to follow this guide.

By following this guide, you will:

- Create a simple gRPC server using a Service component.
- Link the containerized gRPC service to the Choreo component using the Dockerfile. 
    The greeter service has a single RPC method named `sayHello`. Following is the proto file the server and the client application are using:

    ```proto
    syntax = "proto3";
    option go_package = "github.com/wso2/choreo-samples/go-grpc/pkg";

    service greeter {
      rpc SayHello (HelloRequest) returns (HelloReply) {}
    }

    message HelloRequest {
      string name = 1;
    }

    message HelloReply {
      string message = 1;
    }
    ```

- Deploy the gRPC server component in Choreo. 
- Create a gRPC client using a Manual Trigger component. 
- Deploy the gRPC client.
- Invoke the gRPC server using a gRPC client and check the response through the Choreo log view.


## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample service](https://github.com/wso2/choreo-samples/tree/main/go-grpc) implementation for this guide.

Let's get started!

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the greeter service.

!!! note 
    The following file paths are relative to the path `<sample-repository-dir>/go-grpc`.

|File Path                |Description                                                                                   |
|-------------------------|----------------------------------------------------------------------------------------------|
| `main.go`               | The greeter service code written in the Go language.                                         |
| `greeter_client/main.go`| The greeter client application written in the Go language.                                   |
| `Dockerfile.server`     | The Dockerfile to build the container image of the server application.                       |
| `Dockerfile.client`     | The Dockerfile to build the container image of the client application.                       |
| `.choreo/component.yaml`| The Choreo-specific configuration that provides information about how Choreo exposes the service.|
| `pkg/greeter.proto`     | The interface definition of the gRPC service. This is used to generate the server and client stubs for the Go application.|

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints.

Let's run the gRPC server service component on port 8080. To securely expose the service through Choreo, you must provide the port and other required information to Choreo. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

Choreo looks for an `component.yaml` file inside the `.choreo` directory to configure the endpoint details of the containerized component. Ensure the `.choreo` directory is at the root of the Docker build context path.

In the gRPC server sample, the `component.yaml` file is at `go-grpc/.choreo/component.yaml`, where the build context path is `go-grpc`.

## Step 1: Create a service component with a gRPC endpoint

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
6. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

7. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory** | `go-grpc`                  |

8. Select **Docker** as the buildpack.
9. Enter the following information:
    
    | **Field**                | **Value**                  |
    |--------------------------|----------------------------|
    | **Dockerfile**           | `go-grpc/Dockerfile.server`|

    !!! info
        1.  To successfully build your container with Choreo, it is essential to explicitly define a User ID (UID) under the USER instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-samples/blob/main/go-grpc/Dockerfile.server).
        To ensure that the defined USER instruction is valid, it must conform to the following conditions:
            - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
            - Usernames are considered invalid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

        2. The Dockerfile utilized in this guide is a multi-stage Dockerfile, which is designed to keep the final image size small and provides the ability to build the application with a specific version of tools and libraries.

4. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go gRPC Server`        |
    | **Component Name**        | `go-grpc-server`        |
    | **Description**           | Send greetings          |
    
10. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you have connected the source repository, and configured the endpoint details, it's time to build the service and create an image. Then you can deploy the image and test the greeter service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

    You can access the following scans under **Build**. 

      - **The Dockerfile scan**: Choreo performs a scan to check if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
      - **Container (Trivy) vulnerability scan**: This detects vulnerabilities in the final docker image. 
      - **Container (Trivy) vulnerability scan**: The details of the vulnerabilities open in a separate pane. If this scan detects critical vulnerabilities, the build will fail.
     
        !!! info
            If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Environment Configurations** pane that opens, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

6. Once you have successfully deployed your service, navigate to the component overview page and copy the gRPC service URL. You need to provide that URL when setting up the client application later in this guide.

You have successfully deployed the gRPC server. Currently, the gRPC service is only accessible by the components deployed within the same project.

## Step 3: Invoke the gRPC service

Let's invoke the gRPC service that you created above, using a gRPC client. 

### Step 3.1: Create a manual task for the gRPC client

To create a manual task component, follow these steps:

1. On the Choreo Console header, click the **Project** list and select the project where you created the gRPC service component. This opens the project home page.
2. Go to the **Component Listing** section and click **+ Create**.
3. Click the **Manual Task** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**       | `go/grpc`                  |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                  |
    |--------------------------|----------------------------|
    | **Dockerfile**           | `go/grpc/Dockerfile.client`|

8. Enter a display name, a unique name, and a description for the component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go gRPC Client`        |
    | **Component Name**        | `go-grpc-client`        |
    | **Description**           | `Receive greetings`     |


9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

### Step 3.2: Build the gRPC client component

To build the component, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 3.3: Setup environment variables and deploy the gRPC client

The client application, in this case, the gRPC client, requires the server URL of the gRPC server service. This is read from the client application as an environment variable. Follow the steps below to configure the environment variable for the client application:

1. On the Choreo Console left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane that opens, click **+ Add**.
4. Specify the following name and value to configure the environment variable for the client application:

    | **Field**       | **Value**               |
    |-----------------|-------------------------|
    | **Name**        | `GREETER_SERVICE`       |
    | **Value**       | Paste the URL value copied after deploying the gRPC service via [step 2.2](#step-22-deploy) above.  Make sure to **drop the `http://` or `grpc://` part and the trailing `/` from the URL when copying**. For example, if the URL is `http://go-grpc-server-3192360657:8080/`, add only `go-grpc-server-3192360657:8080`.|

5.  Click **Add** and then click **Next**.
6.  Click **Deploy**.

### Step 3.4: Execute the gRPC client component

To execute the gRPC client, follow these steps:

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the gRPC client and generates logs.
   You can trigger multiple runs to generate multiple logs.

For details on what you can monitor via the execute page, see [Monitor executions](../develop-integrations/develop-a-manual-task.md#step-7-monitor-executions). 


# Expose a Prism-Based Mock Server Using an OpenAPI Specification

Choreo supports deploying [Prism-based](https://docs.stoplight.io/docs/prism/674b27b261c3c-prism-overview) mock servers using OpenAPI specifications. With the Choreo Prism mock service component, you can serve multiple mock servers, each based on a different OpenAPI specification, as separate endpoints.

By default, these mock servers serve static content generated from the examples in the configured OpenAPI Specification (OAS). 

## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [Prism mock service](https://github.com/wso2/choreo-samples/tree/main/prism-mock-service) artifacts for this guide.

## Step 1: Create a Prism mock service component

To create a Prism mock service component, follow these steps:
    
1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, you can paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    |**Component Directory**  | `prism-mock-service`    |

6. Select **Prism Mock** as the buildpack.
7. Enter a display name, a unique name, and a description for the service component.
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

8. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

## Step 2: Build and deploy the component

Now that you have successfully created the Prism mock service, it's time to build and deploy it.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**. This builds the service from the latest commit.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

Once you have successfully deployed the service, you can [test](../../testing/test-rest-endpoints-via-the-openapi-console.md), [manage](../../api-management/lifecycle-management.md), and [observe](../../monitoring-and-insights/observability-overview.md) it like any other component type in Choreo.

## Serve dynamic content

The Prism mock service can serve dynamic content according to the schema definitions in the OpenAPI specification. To use the Prism mock service with dynamic content, clients must add the `prefer:dynamic=true` header in the request.

To generate meaningful dynamic responses, you can use the `x-faker` attribute in schema definitions of the OpenAPI specification. For more information on dynamically generated responses with the `x-faker` attribute, see the [Prism documentation](https://docs.stoplight.io/docs/prism/9528b5a8272c0-dynamic-response-generation-with-faker).


# Expose a TCP Server via a Service

Choreo offers the flexibility to design and deploy applications in the programming language of your choice. One viable choice for specific network communication needs is TCP (Transmission Control Protocol). TCP provides a reliable, stream-oriented communication mechanism that ensures data integrity and orderliness during transmission. It's the go-to option for scenarios where guaranteed data delivery and error recovery are paramount.

In this guide, you will learn to use Choreo to create a service component that exposes a TCP server implemented in [Go](https://go.dev/), enabling efficient and scalable communication with any TCP client application. No prior knowledge of the Go language is necessary to follow this guide.

By following this guide, you will:

- Setup a TCP server
    - Create a simple TCP server using a service component.
    - Link the containerized TCP service to the Choreo component using a Dockerfile. 
    - Deploy the TCP server component in Choreo. 
- Setup a TCP client
    - Create a TCP client using a manual task component. 
    - Link the containerized TCP client to the Choreo component using a Dockerfile. 
    - Deploy the TCP client component in Choreo.
- Invoke the TCP server using a TCP client and observe the response through the Choreo log view.

## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample service](https://github.com/wso2/choreo-samples/tree/main/docker-tcp-service) implementation for this guide.

Let's get started!

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the sample service.

!!! note 
    The following file paths are relative to the path `<sample-repository-dir>/docker-tcp-service`.

|File Path                 |Description                                                                                   |
|--------------------------|----------------------------------------------------------------------------------------------|
| `server/main.go`         | The greeter service code written in the Go language.                                         |
| `client/main.go`         | The greeter client application written in the Go language.                                   |
| `Dockerfile.server`      | The Dockerfile to build the container image of the server application.                       |
| `Dockerfile.client`      | The Dockerfile to build the container image of the client application.                       |
| `.choreo/component.yaml` | The Choreo-specific configuration provides information about how Choreo exposes the service. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints.

Let's run the TCP server service component on port 5050. To securely expose the service through Choreo, you must provide the port and other required information to Choreo. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

Choreo looks for an `component.yaml` file inside the `.choreo` directory to configure the endpoint details of a containerized component. Place the `.choreo` directory at the root of the Docker build context path.

In our TCP server sample, the `component.yaml` file is at `docker-tcp-service/.choreo/component.yaml`, where the build context path is `docker-tcp-service`.

## Step 1: Create a service component with a TCP endpoint

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory** | `docker-tcp-service`                  |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-tcp-service/Dockerfile.server`|

    !!! info
        1.  To successfully build your container with Choreo, it is essential to explicitly define a User ID (UID) under the USER instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-samples/blob/main/docker-tcp-service/Dockerfile.server).
        To ensure that the defined USER instruction is valid, it must conform to the following conditions:
            - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
            - Usernames are considered invalid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

        2. The Dockerfile utilized in this guide is a multi-stage Dockerfile, which is designed to keep the final image size small and provides the ability to build the application with a specific version of tools and libraries.

8. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go TCP Server`         |
    | **Component Name**        | `go-tcp-server`         |
    | **Description**           | Send greetings          |
    
9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you have connected the source repository, and configured the endpoint details, it's time to build the service and create an image. Then you can deploy the image and test the service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

    You can access the following scans under **Build**. 

      - **The Dockerfile scan**: Choreo performs a scan to check if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
      - **Container (Trivy) vulnerability scan**: This detects vulnerabilities in the final docker image. 
      - **Container (Trivy) vulnerability scan**: The details of the vulnerabilities open in a separate pane. If this scan detects critical vulnerabilities, the build will fail.
     
        !!! info
            If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Environment Configurations** pane that opens, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

6. Once you have successfully deployed your service, navigate to the component overview page and copy the TCP service address. You need to provide that address when setting up the client application later in this guide.

You have successfully deployed the TCP server. Currently, the TCP service is only accessible by the components deployed within the same project.

## Step 3: Invoke the TCP service

Now let's use a TCP client to invoke the TCP service that you created above. To do this, you can create a manual trigger component as the TCP client. This is the recommended approach because, in this example, it's more efficient to have a client that connects to the server, sends a request, and then stops. Here, a continuously executing task isn't required. Furthermore, if you use a manual trigger component, you won't need to expose an endpoint in the client for invocation, unlike with an API.

### Step 3.1: Create a manual trigger for the TCP client

To create a manual task component, follow these steps:

1. On the Choreo Console header, click the **Project** list and select the project where you created the TCP service component. This opens the project home page.
2. Go to the **Component Listing** section and click **+ Create**.
3. Click the **Manual Task** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Docker Context**      |`docker-tcp-service`     |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-tcp-service/Dockerfile.client`|

8. Enter a display name, a unique name, and a description for the component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**              |
    |---------------------------|------------------------|
    | **Component Display Name**| `Go TCP Client`        |
    | **Component Name**        | `go-tcp-client`        |
    | **Description**           | `Receive greetings`    |


9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

### Step 3.2: Build the TCP client component

To build the component, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 3.3: Setup environment variables and deploy the TCP client

The client application, in this case, the TCP client, requires the server URL of the TCP server service. This is read from the client application as an environment variable. Follow the steps below to configure the environment variable for the client application:

1. On the Choreo Console left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane that opens, click **+ Add**.
4. Specify the following name and value to configure the environment variable for the client application:

    | **Field**       | **Value**               |
    |-----------------|-------------------------|
    | **Name**        | `SERVER_ADDRESS`       |
    | **Value**       | Paste the URL value copied after deploying the TCP service via [step 2.2](#step-22-deploy) above.  Make sure to **drop the `tcp://` part and the trailing `/` from the URL when copying**. For example, add only `go-tcp-server-1097922445:8080`.|

5.  Click **Add** and then click **Next**.
6.  Click **Deploy**.

### Step 3.4: Execute the TCP client component

To execute the TCP client, follow these steps:

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the TCP client and generates logs.
   You can trigger multiple runs to generate multiple logs.

For details on what you can monitor via the execute page, see [Monitor executions](../develop-integrations/develop-a-manual-task.md#step-7-monitor-executions).


# Expose a UDP Server via a Service

Choreo offers the flexibility to design and deploy applications in the programming language of your choice. One compelling choice for certain network communication needs is UDP (User Datagram Protocol). UDP is a high-speed, connectionless protocol ideal for scenarios where lightweight, real-time data transmission is essential.

In this guide, you will learn to use Choreo to create a Service component that exposes a UDP server implemented in [Go](https://go.dev/), enabling efficient and scalable communication with any UDP client application. No prior knowledge of the Go language is necessary to follow this guide.

By following this guide, you will:

- Setup a UDP server
    - Create a simple UDP server using a Service component.
    - Link the containerized UDP service to the Choreo component using the Dockerfile. 
    - Deploy the UDP server component in Choreo. 
- Setup a UDP client
    - Create a UDP client using a manual task component. 
    - Link the containerized UDP client to the Choreo component using the Dockerfile. 
    - Deploy the UDP client component in Choreo.
- Invoke the UDP server using a UDP client and check the response through the Choreo log view.

## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample service](https://github.com/wso2/choreo-samples/tree/main/docker-udp-service) implementation for this guide.

Let's get started!

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the sample service.

!!! note 
    The following file paths are relative to the path `<sample-repository-dir>/docker-udp-service`.

|File Path                |Description                                                                                   |
|-------------------------|----------------------------------------------------------------------------------------------|
| `server/main.go`        | The greeter service code written in the Go language.                                         |
| `client/main.go`        | The greeter client application written in the Go language.                                   |
| `Dockerfile.server`     | The Dockerfile to build the container image of the server application.                       |
| `Dockerfile.client`     | The Dockerfile to build the container image of the client application.                       |
| `.choreo/component.yaml`| The Choreo-specific configuration provides information about how Choreo exposes the service. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints.

Let's run the UDP server service component on port 5050. To securely expose the service through Choreo, you must provide the port and other required information to Choreo. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

Choreo looks for an `component.yaml` file inside the `.choreo` directory to configure the endpoint details of a containerized component. Place the `.choreo` directory at the root of the Docker build context path.

In our gRPC server sample, the `component.yaml` file is at `docker-udp-service/.choreo/component.yaml`, where the build context path is `docker-udp-service`.

## Step 1: Create a service component with a UDP endpoint

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
6. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

7. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**   | `docker-udp-service`    |    

8. Select **Docker** as the buildpack.
9. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-udp-service/Dockerfile.server`|

    !!! info
        1.  To successfully build your container with Choreo, it is essential to explicitly define a User ID (UID) under the USER instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-samples/blob/main/docker-udp-service/Dockerfile.server).
        To ensure that the defined USER instruction is valid, it must conform to the following conditions:
            - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
            - Usernames are considered invalid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

        2. The Dockerfile utilized in this guide is a multi-stage Dockerfile, which is designed to keep the final image size small and provides the ability to build the application with a specific version of tools and libraries.

4. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go UDP Server`         |
    | **Component Name**        | `go-udp-server`         |
    | **Description**           | Send greetings          |

10. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you have connected the source repository, and configured the endpoint details, it's time to build the service and create an image. Then you can deploy the image and test the service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

    You can access the following scans under **Build**. 

      - **The Dockerfile scan**: Choreo performs a scan to check if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
      - **Container (Trivy) vulnerability scan**: This detects vulnerabilities in the final docker image. 
      - **Container (Trivy) vulnerability scan**: The details of the vulnerabilities open in a separate pane. If this scan detects critical vulnerabilities, the build will fail.
     
        !!! info
            If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Environment Configurations** pane that opens, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

6. Once you have successfully deployed your service, navigate to the component overview page and copy the UDP service address. You must provide that address when setting up the client application later in this guide.

You have successfully deployed the UDP server. Currently, the UDP service is only accessible by the components deployed within the same project.

## Step 3: Invoke the UDP service

Now let's use a UDP client to invoke the UDP service that you created above. To do this, you can create a manual trigger component as the UDP client. This is the recommended approach because, in this example, it's more efficient to have a client that connects to the server, sends a request, and then stops. Here, a continuously executing task isn't required. Furthermore, if you use a manual trigger component, you won't need to expose an endpoint in the client for invocation, unlike with an API.

### Step 3.1: Create a manual trigger for the UDP client

To create a manual task component, follow these steps:

1. On the Choreo Console header, click the **Project** list and select the project where you created the UDP service component. This opens the project home page.
2. Go to the **Component Listing** section and click **+ Create**.
3. Click the **Manual Task** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory** | `docker-udp-service`    |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-udp-service/Dockerfile.client`|

8. Enter a display name, a unique name, and a description for the component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**              |
    |---------------------------|------------------------|
    | **Component Display Name**| `Go UDP Client`        |
    | **Component Name**        | `go-udp-client`        |
    | **Description**           | `Receive greetings`    |


9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

### Step 3.2: Build the UDP client component

To build the component, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 3.3: Setup environment variables and deploy the UDP client

The client application, in this case, the UDP client, requires the server URL of the UDP server service. This is read from the client application as an environment variable. Follow the steps below to configure the environment variable for the client application:

1. On the Choreo Console left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane that opens, click **+ Add**.
4. Specify the following name and value to configure the environment variable for the client application:

    | **Field**       | **Value**               |
    |-----------------|-------------------------|
    | **Name**        | `SERVER_ADDRESS`       |
    | **Value**       | Paste the URL value copied after deploying the UDP service via [step 2.2](#step-22-deploy) above.  Make sure to **drop the `udp://` part and the trailing `/` from the URL when copying**. For example, add only `go-udp-server-1097922445:8080`.|

5.  Click **Add** and then click **Next**.
6.  Click **Deploy**.

### Step 3.4: Execute the UDP client component

To execute the UDP client, follow these steps:

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the UDP client and generates logs.
   You can trigger multiple runs to generate multiple logs.

For details on what you can monitor via the execute page, see [Monitor executions](../develop-integrations/develop-a-manual-task.md#step-7-monitor-executions).


# Expose a WebSocket Endpoint via a Service

Choreo allows you to create and deploy applications in your preferred programming language, offering a seamless platform for building dynamic and scalable solutions. This guide walks you through the steps to deploy a WebSocket service using the NodeJS buildpack.

WebSockets provide real-time, two-way communication between a client and server over a persistent TCP connection. This makes WebSocket APIs ideal for applications that require real-time updates.

In this guide, you will:

- Build a simple WebSocket service using a sample implementation in NodeJS.
- Deploy the service in Choreo, allowing any WebSocket client application to establish a connection and exchange real-time messages with your service.

## Prerequisites

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample WebSocket service](https://github.com/wso2/choreo-samples/tree/main/websocket-chat-app) implementation for this guide.

Let's get started!

## Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the NodeJS chat Application.

!!! note
    The following file paths are relative to the path `<sample-repository-dir>/websocket-chat-app/websocket-chat-service-nodejs`.

|Filepath                        | Description                                                     |
|--------------------------------|-----------------------------------------------------------------|
| `server.js`                    | The NodeJS chat service.                                        |
| `.choreo/component.yaml`       | The configuration file with endpoint details.                   |

!!! note
    Choreo currently supports defining WebSocket APIs using the AsyncAPI 2.0 specification.

## Step 1: Create a service component 

To create a NodeJS service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**   | `websocket-chat-app/websocket-chat-service-nodejs`  |

6. Select **NodeJS** as the buildpack and **18.x.x** as the Language Version

8. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:

    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `NodeJS Chat Service`   |
    | **Component Name**        | `nodejs-chat-service`   |
    | **Description**           | Manage a chat service   |

9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service component that provides a WebSocket API built with NodeJS. The next step is to proceed with building and deploying the service.

## Step 2: Build and deploy

Now that you have connected the source repository, it's time to build and deploy the chat service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane that opens, click **Next** to skip the configuration.
4. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

Once you have successfully deployed your service, you can [test](../../testing/test-websocket-endpoints-via-the-websocket-console.md), [manage](../../api-management/lifecycle-management.md), and observe it like any other component type in Choreo.

During testing, once the WebSocket connection is established, you can send {"type": "Connect", "username": "user1"} to the WebSocket endpoint to connect to the chat service. You can then send chat messages by using {"type": "Data", "message": "Hello, World!"}.

!!! note
     Some clients, such as certain browsers, may not support adding headers to the WebSocket handshake. In these cases, you can include the access token or test key required for WebSocket API invocation within the `sec-websocket-protocol` header, along with any specified subprotocols.

     For example: `sec-websocket-protocol: choreo-oauth2-token, {access token}, subprotocols`

     If you are using a test key, replace `choreo-oauth2-token` with `choreo-test-key`.


# Service Component Overview

Explore how to create, deploy, manage, and observe service components in Choreo.

## What is a service component?

A service component in Choreo lets you deploy and expose REST, GraphQL, gRPC, UDP, WS or TCP services. It is a fundamental building block for creating cloud-native applications in Choreo. They provide a simple and effective way to expose functionality as a service to other components within Choreo or to the outside world.

Service components encapsulate business logic and provide standardized interfaces, called endpoints, for communicating with other components or systems. You can deploy and scale services independently, which makes them highly flexible and adaptable to changing workloads.

With the help of the service component, developers can quickly create APIs and microservices, making it easier to implement and manage complex software systems. Service components can also be integrated with other Choreo components, that acts as message processors, connectors, and data sources, etc to create powerful end-to-end solutions.

You can expose a service to other components through endpoints. For details on configuring endpoints, see [Configure Endpoints](../configure-endpoints.md).


# Build and Deploy a Single-Page Web Application

A web application is an application program hosted on a server and serves ingress traffic through a browser. In Choreo, you can deploy a web application by creating a Web Application component and connecting it to a Git repository that contains the implementation of the web application. Web applications can fall into one of the following categories:

- **Single page applications (SPAs)**: Examples include React, Angular, Vue, Svelte, etc.
- **Web servers**: These serve static content or provide server-side rendering/static site generation (SSR/SSG).
- **Static content**: Examples include websites and other static resources that do not require a backend, usually comprising static HTML/JS/CSS files.

## Prerequisites

- To deploy a web application component, you must have a GitHub account with a repository containing the web application's implementation. For this guide, fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample web application implementation.

## Create a web application

You can create a web application in Choreo as follows:

### Build and deploy a SPA from source code

1. To create a web application component, connect a repository that includes the web application source code.
2. Select the relevant buildpack: Default buildpacks include **React**, **Angular**, and **Vue.js**. If you are using a different SPA framework, you can try one of these buildpacks because the configurations can be overridden to support most JavaScript-based SPAs.
3. Enter the build command: Based on your package manager (NPM, yarn, or pnpm). The relevant package manager is run based on the dependency lock file in your repository (defaults to NPM if no lock file is present).
4. Specify the build output directory.
5. Specify the NodeJS version: Choreo does not pick the Node.js version from the `package.json` engine property. The required Node version must be explicitly set in the build configuration.

Once you create the Web Application component, Choreo automatically generates a build pipeline for your single-page application and deploys it.

### Bring your Dockerfile

1. To create a web application component, connect a repository that contains the Dockerfile for your containerized web application.
2. Commit a Dockerfile to your connected Git repository to have full control over your build process.

This approach is recommended if you are deploying a web server and not just a single-page application (or a single-page application with a complex build process).

### Host static websites

1. Create a web application component and connect it to the GitHub repository that contains the required static assets.
2. Select the **Static Websites** buildpack: This buildpack does not trigger a build process. It only fetches the files from the path specified in the repository and serves them as-is.

## Build and deploy a SPA from source code

Follow the steps below to create a sample Web Application component and deploy it in Choreo:

1. Sign in to the Choreo Console at [https://console.choreo.dev/login/](https://console.choreo.dev/login/). This opens the **Project Home** page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Web Application** card.
6. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

7. Enter the following information:

    | **Field**                 | **Description**        |
    |---------------------------|------------------------|
    | **GitHub Account**        | Your account           |
    | **GitHub Repository**     | choreo-samples         |
    | **Branch**                | main                   |
    | **Component Directory**     | /react-single-page-app |

8. Select **React** as the **Buildpack**.
9. Enter the following information:

    | **Field**                 | **Description**        |
    |---------------------------|------------------------|
    | **Build Command**         | `npm run build`        |
    | **Build Path**            | `build`                |
    | **Node Version**          | `18`                   |

    !!! tip
        Managed authentication is enabled by default when you create a web application using **React**, **Angular**, or **Vue.js** buildpacks. To learn how to set up authentication for your web application with Choreo's managed authentication, see [Secure Web Applications with Managed Authentication](../../authentication-and-authorization/secure-web-applications-with-managed-authentication.md).

4. Specify a display name, a unique name and description for the component.
10. Click **Create**. Choreo initializes the component with the sample implementation and opens the **Overview** page of the component.

You have successfully created a Web Application component from the source code. Now let's build and deploy the web application.

## Build your web application

1. In the left navigation menu, click **Build**.
2. In the **Builds** pane, click **Build**. This opens the **Commits** pane, where you can see all the commits related to the component.
3. Select the latest commit and click **Build**. This triggers the build process and displays the progress in the **Build Logs** pane.

    You can access the following scans in the **Build Logs** pane:

    - **Dockerfile Scan**: Choreo checks if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
    - **Container (Trivy) Vulnerability Scan**: Detects vulnerabilities in the final Docker image. If critical vulnerabilities are detected, the build will fail.

    !!! info
        If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

    !!! note
        The build process may take some time. Once complete, the build status will be listed in the **Builds** pane. Here, you will see the build status as **Success**.

## Deploy and access your web application

1. In the left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure and Deploy**. This opens the **Configure & Deploy** pane. In this guide, you do not need to add a file mount.
3. Click **Next** to proceed to the **Authentication Settings** pane.
4. Keep the default settings and click **Deploy**.

    !!! note
        The deployment process may take a few minutes. Once complete, the **Deployment Status** will show as **Active** in the **Development** card.

5. To verify that the web application is hosted successfully, click the **Web App URL** in the **Development** card. This takes you to the web application.

## Create a short URL for your web application in production

!!! info
    This feature is only available on the Choreo cloud data plane.

When you promote your component to the Production environment, you can create a personalized short URL for your web application. The URL follows the `https://{your-short-prefix}.choreoapps.dev` structure, where you can select a name of your preference for `{your-short-prefix}`.

1. Click **Promote** in the **Development** card and promote your web application to production.
2. In the **Production** card, click **Create a short URL**.
3. Specify a **Short URL prefix** of your choice and click **Save**.

    !!! note
        Short URL names/prefixes are subject to availability, provided on a first-come-first-serve basis.

## Manage runtime configurations for web applications

For web applications with a backend server, Choreo allows you to mount runtime configurations and secrets as environment variables and/or file mounts for a specific environment. Alternatively, you can also inject them into the client application during server-side rendering or when serving static content.

For SPAs that run completely on the browser, Choreo does not support *baking-in* environment variables or other configurations. Instead, Choreo recommends the following approach (applicable to most SPA frameworks, including React):

!!! note
    - With SPAs, anything you mount as a runtime config will be available to your users in the browser.
    - **Do not include sensitive secrets that are not browser-safe**.

1. Go to your forked [Choreo samples repository](https://github.com/wso2/choreo-samples).
2. Open the `public` directory.
3. Create and commit a new file named `config.js` in the `public` directory of your React application. This file should contain the runtime configuration variables you want to expose to your application, such as API endpoints or feature flags. For example:

    ```javascript
    window.config = {
        apiUrl: 'https://api.example.com',
        featureFlags: {
            enableNewFeature: true,
            enableExperimentalFeature: false,
        },
    };
    ```

4. In your `index.html` file inside the `public` directory, add a script tag to include the `config.js` file inside the `<body>` tag:

    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>My React App</title>
    </head>
    <body>
        <div id="root"></div>
        <script src="%PUBLIC_URL%/config.js"></script>
    </body>
    </html>
    ```

5. In your React component, access the configuration variables by referencing the `window.config` object:

    ```javascript
    import React from 'react';

    function MyComponent() {
        const apiUrl = window.config.apiUrl;
        const enableNewFeature = window.config.featureFlags.enableNewFeature;
        const enableExperimentalFeature = window.config.featureFlags.enableExperimentalFeature;

        // ...
    }
    ```

6. When you deploy your component to Choreo, create a config file mount in the specified path for each environment (where your `index.html` expects the `config.js` file). For more details, see [Manage Configurations and Secrets](https://wso2.com/choreo/docs/devops-and-ci-cd/manage-configurations-and-secrets/#apply-a-file-mount-to-your-container).

## Limitations

The following limitations are specific to the Choreo cloud data plane:

- **Request size limit**: 256KB (including headers, cookies, and payloads).
- **Response body size limit**: 20MB.
- **Open ports**: Only one open port is permitted per web application. While you can have multiple ports open for project-level communication within a data plane, incoming traffic from the internet can only be directed to one port. This differs from Service-type components, which support multiple endpoints.

## Troubleshoot a web application

- **Blank page or 502 error after deployment**:
    If you encounter a blank page or a 502 error after deploying your web application, it typically indicates that the wrong directory is being served. To resolve this issue:
    1. Double-check the build output directory, especially if you are using a Dockerfile-less buildpack.
    2. Ensure that the specified output directory matches the actual output directory generated during the build process. For example, if you have erroneously entered `public/` as the output directory when it should have been `build/`.

By verifying and correcting the output directory alignment, you should be able to address the issue of encountering a blank page or experiencing a 502 error on deploying your web application.


# Develop Web Applications Locally with Choreo’s Managed Authentication

Choreo’s managed authentication capability provides a set of backend for frontend (BFF) endpoints to facilitate authentication and authorization for web applications. These endpoints are readily available for single-page web applications deployed on Choreo.

As a web application developer, you may need to run the application on your local workstation. Choreo’s local development capability ensures that authentication and authorization during local development work the same way as they do when the application is deployed to Choreo, eliminating the need for code changes.

This guide explains how to configure and use Choreo’s local development capability to streamline your workflow.

## How local development works in Choreo

Local development uses a proxy that sits in front of the locally running web application. This proxy intercepts all incoming requests:
- Requests to `/choreo-apis/*` and `/auth/*` are forwarded to Choreo.
- All other requests are forwarded to the locally running web application.

The proxy runs on HTTPS using a self-signed certificate, which is essential for secure, HTTP-only cookie-based managed authentication. Once the proxy is running, you can access the web application using the proxy's URL and start developing locally. The behavior of the web application, in terms of managed authentication, will mirror its behavior when deployed to Choreo.

## Configure local development

### Prerequisites

- Create a single-page application (SPA) with managed authentication enabled. For details, see [Secure Web Applications with Managed Authentication](../../authentication-and-authorization/secure-web-applications-with-managed-authentication.md#step-1-set-up-managed-authentication-for-your-web-application).
- Promote and deploy the application to the environment where you want to enable local development.

    !!! note
        - The locally running web application will use the same managed authentication configuration as the environment where local development is configured.
        - Local development is only allowed in non-critical environments.

### Apply configurations

1. Sign in to the Choreo Console.
2. In the **Component Listing** pane, click on the component you created and deployed.
3. In the left navigation menu, click **Deploy**.
4. Go to the respective environment card and click **Local Development**.
5. In the **Local Development** pane, toggle **Local Development** to enable it.
6. (Optional) To update the port on which the local development proxy server runs, expand **Advanced Configurations** and specify a value for **Proxy Port**.
7. Click **Apply**.

You have now configured local development. The next section explains how to access your web application for local development.

## Access your web application locally

### Prerequisites

- Ensure local development is enabled in the desired environment.
- Ensure your web application is running locally on `http://localhost` on a specific port.

### Access your web application locally

You can use either the Choreo built-in identity provider or an external identity provider to access your web application locally.

=== "Use the Choreo built-in identity provider"

    1. Sign in to the Choreo Console.
    2. In the **Component Listing** pane, click on the component you created and deployed.
    3. In the left navigation menu, click **Deploy**.
    4. Go to the respective environment card and click **Local Development**.
    5. In the **Local Development** pane, copy the command under **Step 1**.
    6. Paste the command in a terminal, replace `[APP_PORT]` with the port on which your application is running locally, and run the command.
    7. To access the application, go to the URL provided under **Step 2** in the **Local Development** pane.

        !!! note
            The local development proxy runs on HTTPS using a self-signed certificate. Your browser may warn that the certificate is not valid. Accept the risk and proceed.

=== "Use an external identity provider"

    1. Sign in to the Choreo Console.
    2. In the **Component Listing** pane, click on the component you created and deployed.
    3. In the left navigation menu, click **Deploy**.
    4. Go to the respective environment card and click **Local Development**.
    5. In the **Local Development** pane, copy the redirect URLs under **Step 1**.
    6. Go to the settings in the OAuth application in your identity provider and specify the copied URLs as allowed redirect URLs.
    7. In the **Local Development** pane, copy the command under **Step 2**.
    8. Paste the command in a terminal, replace `[APP_PORT]` with the port on which your application is running locally, and run the command.
    9. To access the application, go to the URL provided under **Step 3** in the **Local Development** pane.

        !!! note
            The local development proxy runs on HTTPS using a self-signed certificate. Your browser may warn that the certificate is not valid. Accept the risk and proceed.


# Create a Connection

Connections in Choreo provide a simple and uniform approach to seamlessly integrate components with services or resources.

Choreo allows you to create connections to services deployed in Choreo or registered as external services. It also allows you to create connections to any Choreo-managed database.

To create a connection to a service or a database, follow the step-by-step instructions in the respective tab:

=== "Create a connection to a service"

    <h2>Create a connection to a Choreo service</h2>

    Follow these steps to create a connection to a service deployed in Choreo:

    1. In the Choreo Console, go to the top navigation menu and set the visibility level as [project](../../choreo-concepts/connections.md#project-connections) or [component](../../choreo-concepts/connections.md#component-connections) as follows: 

        - **Project Connection**: Select an organization and a project in that organization. 
        - **Component Connection**: Select an organization, a project in that organization, and a component in the selected project. 

    2. In the left navigation menu, click **Dependencies**  and then **Connections**. This page lists all the existing connections.
    3. Click **+Create**. This opens the Marketplace view where you can browse and search for services or databases.
    4. Click the **Services** tab. You can search and apply filters to efficiently find a service.
    5. Click on the service you want to connect to. 
    6. Enter a name and a description for the connection.
    7. Select an **Access Mode** and **Authentication Scheme** for the connection.
    8. Click **Create**.
   
    This creates the connection and displays its details for each environment, along with an inline guide on how to use the connection in your component. 

    !!! note
        During connection creation, secret values for the lowest environment are visible, allowing you to copy them for local use if necessary. Secret values for higher environments remain hidden to ensure security
     
    <h2>Create a connection to an external service</h2>

    Follow these steps to create a connection to an external service:

    1. Follow steps 1–5 from the previous section.
    2. Expand the **Environment to Endpoint** section and verify the service endpoints assigned to the Choreo environments.
    3. Click **Create**.

      For step-by-step instructions on using a connection in your service, see [Use a Connection in Your Service](./use-a-connection-in-your-service.md).

      For step-by-step instructions on using a connection in your web application, see [Use a Connection in Your Web Application](./use-a-connection-in-your-web-application.md).


=== "Create a connection to a database"

    Prerequisites:

     - Create a Choreo-managed database. For details, see [Choreo-Managed Databases and Caches](../../manage-databases-and-caches/choreo-managed-databases-and-caches.md).
     - Add the database to the Marketplace. For details, see [Add Choreo-Managed Databases and Caches to the Marketplace](../../manage-databases-and-caches/add-choreo-managed-databases-and-caches-to-the-marketplace.md).

    Follow these steps to create a connection to a Choreo-managed database:

    1. In the Choreo Console, go to the top navigation menu and set the visibility level as [project](../../choreo-concepts/connections.md#project-connections) or [component](../../choreo-concepts/connections.md#component-connections) as follows: 

        - **Project Connection**: Select an organization and a project in that organization. 
        - **Component Connection**: Select an organization, a project in that organization, and a component in the selected project. 

    2. In the left navigation menu, click **Dependencies**  and then **Connections**. This page lists all the existing connections.
    3. Click **+Create**. This opens the Marketplace view where you can browse and search for services or databases.
    4. Click the **Databases** tab. You can search and apply filters to efficiently find a database.
    5. Click on the database you want to connect to. 
    6. To create the connection, follow these steps:

        1. Enter a name and description.
        2. Under **Environment Configuration**, select credentials for each environment.

            !!! note
                 By default, the selected database is applied to all environments. To use different databases for specific environments, select the appropriate database and provide the corresponding credentials for each environment.

        3. Click **Create**.  
    
    This creates the connection and displays the database connection details for each environment, along with an inline guide on how to use the connection in your component. 

    !!! note
        During connection creation, secret values for the lowest environment are visible, allowing you to copy them for local use if necessary. Secret values for higher environments remain hidden to ensure security
    
    For step-by-step instructions on using a database in your component, see [Use a Database Connection in Your Component](./use-a-database-connection-in-your-component.md).


# Use a Connection in Your Service

Choreo allows you to share and reuse your services, accelerating development and enhancing efficiency in building integrated applications through connections.

For step-by-step on instruction on creating a connection, see [Create a Connection](create-a-connection.md).

To learn more about Choreo Connections, see the documentation on [Connections](../../choreo-concepts/connections.md).

## Consume a service through a connection

You can consume a Choreo-deployed service within another service. Consuming connections from within Choreo services is seamless and straightforward. Follow the steps below to consume a Choreo service:

### Step 1: Add connection configurations

To integrate another service into your application, click the appropriate tab below based on your current configuration file and follow the step-by-step instructions:

=== "Component.yaml file (v1.1)"

    1. Copy and paste the snippet from the in-line developer guide into the `component.yaml` file.

        The following is a sample snippet: 

        ``` yaml

        dependencies:
            connectionReferences:
            - name: <CONNECTION_NAME>
              resourceRef: <RESOURCE_IDENTIFIER>

        ```

          | Field            | Description                                                         |
          |------------------|---------------------------------------------------------------------|
          | name             | The name given to the connection.                                   |
          | resourceRef      | A unique, readable identifier of the service being connected to.    |


    2. If you've previously added a `connectionReferences` section under `dependencies`, append this as another item under `connectionReferences`. Upon deploying the component, Choreo automatically creates a subscription if applicable and the necessary configurations to establish the connection will be injected into the Choreo-defined environment variables.
      
          The following table details the Choreo-defined environment variables:

          | Configuration Key       | Choreo-Defined Environment Variable Name                       |
          |-------------------------|----------------------------------------------------------------|
          | ServiceURL              | CHOREO_<CONNECTION_NAME\>_SERVICEURL                           |
          | ConsumerKey             | CHOREO_<CONNECTION_NAME\>_CONSUMERKEY                          |
          | ConsumerSecret          | CHOREO_<CONNECTION_NAME\>_CONSUMERSECRET                       |
          | TokenURL                | CHOREO_<CONNECTION_NAME\>_TOKENURL                             |
          | ChoreoAPIKey            | CHOREO_<CONNECTION_NAME\>CHOREOAPIKEY                          |


          If you want to use custom environment variable names instead of the Choreo-defined ones, you must define the environment configurations under the `configuration` section in the same file.
          The following is a sample snippet: 

          ``` yaml
          configuration:
            env:
              - name: HR_SERVICE_URL
                valueFrom:
                  connectionRef:
                    name: hr-connection
                    key: ServiceURL
          ```

          The following table provides details on the configuration keys associated with the connection. These keys can be referenced as `env[i].valueFrom.connectionRef.key`.

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | ServiceURL     | string     | Service URL of the Choreo service     | false         | false        |
          | ConsumerKey    | string     | Consumer key of the Choreo service    | false         | false        |
          | ConsumerSecret | string     | Consumer secret of the Choreo service | false         | true         |
          | TokenURL       | string     | Token URL of the STS                  | false         | false        |
          | ChoreoAPIKey   | string     | API key of the Choreo service         | false         | true         |

          For more details, see the instructions under the **component.yaml file (v1.1)** tab.

    ### Step 2: Read configurations within the application

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const serviceURL = process.env.CHOREO_<CONNECTION_NAME>_SERVICEURL;
    ```

=== "Component.yaml file (v1.0)"

    !!! note
        This `component.yaml v1.0` is a legacy configuration format. For new projects, we recommend using the latest version (v1.1) of `component.yaml` for improved usability and features.
  
    1. Copy and paste the snippet from the in-line developer guide into the `component.yaml` file.
      
        The following is a sample snippet:

        ``` yaml

        dependencies:
            serviceReferences:
            - name: <SERVICE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: ServiceURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerSecret
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: TokenURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ChoreoAPIKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>

        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the service you are connecting to.              |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added a service reference section under `dependencies`, append this as another item under `serviceReferences`. 

          Upon deploying the component, Choreo automatically creates a subscription if applicable and populates the specified environment variables with actual values.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | ServiceURL     | string     | Service URL of the Choreo service     | false         | false        |
          | ConsumerKey    | string     | Consumer key of the Choreo service    | false         | false        |
          | ConsumerSecret | string     | Consumer secret of the Choreo service | false         | true         |
          | TokenURL       | string     | Token URL of the STS                  | false         | false        |
          | ChoreoAPIKey   | string     | API key of the Choreo service         | false         | true         |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const serviceURL = process.env.SVC_URL;
    ```

=== "Component-config.yaml file"

    !!! note
        This `component-config.yaml` is a legacy configuration format. For new projects, we recommend using the latest version (v1.1) of `component.yaml` for improved usability and features.

    1. Copy and paste the snippet from the in-line developer guide into the `component-config` file under the `spec` section.

        The following is a sample snippet:

        ``` yaml

        outbound:
            serviceReferences:
            - name: <SERVICE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: ServiceURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerSecret
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: TokenURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ChoreoAPIKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>

        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the service you are connecting to.              |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added an outbound service reference, append this as another item under `serviceReferences`. 

          Upon deploying the component, Choreo automatically creates a subscription if applicable and populates the specified environment variables with actual values.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | ServiceURL     | string     | Service URL of the Choreo service     | false         | false        |
          | ConsumerKey    | string     | Consumer key of the Choreo service    | false         | false        |
          | ConsumerSecret | string     | Consumer secret of the Choreo service | false         | true         |
          | TokenURL       | string     | Token URL of the STS                  | false         | false        |
          | ChoreoAPIKey   | string     | API key of the Choreo service         | false         | true         |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const serviceURL = process.env.SVC_URL;
    ```

If you're using the API key security scheme for the connection, skip Step 3 and follow the instructions in [Step 4: API key security scheme](#step-4-invoke-the-service) tab.

### Step 3: Acquire an OAuth 2.0 access token

To consume a Choreo service with the visibility level set to organization or public and secured by the OAuth 2.0 security scheme, you must obtain an OAuth 2.0 token from the token endpoint. Subsequently, you can use the token to invoke the service.

- For languages with OAuth 2.0-aware HTTP clients, you must pass the OAuth 2.0-related configurations such as client id, client secret and so on, obtained when creating the connection to your HTTP client configuration. The HTTP client autonomously manages token retrieval and refreshing.

- For languages without OAuth 2.0-aware HTTP clients, you must manually initiate a call to the token endpoint. This includes fetching the token and managing token expiration and refresh directly within your application code. The following is a sample curl command to obtain a token:


    ```bash
    CONSUMER_KEY="your_consumer_key"
    CONSUMER_SECRET="your_consumer_secret"
    TOKEN_URL="your_token_url"

    # Encode client credentials as Base64
    CLIENT_CREDENTIALS=$(echo -n "$CLIENT_ID:$CLIENT_SECRET" | base64)

    curl -X POST $TOKEN_URL \
      -H "Content-Type: application/x-www-form-urlencoded" \
      -H "Authorization: Basic $CLIENT_CREDENTIALS" \
      --data-urlencode "grant_type=client_credentials"

    ```

### Step 4: Invoke the service

Click the tab that matches the security scheme of your service and follow the instructions below:

=== "API key security scheme"

     To invoke the API, use the `choreo-api-key` header with the API key value retrieved from the corresponding environment variable as described in [step 2](#step-2-read-configurations-within-the-application).

     The following is a sample code snippet in NodeJS:

     ``` java
       const response = await axios.get(serviceURL/{RESOURCE_PATH}, {
           headers: {
             'Choreo-API-Key': `${choreoApiKey}`
           }
       });
     ```

=== "OAuth 2.0 security scheme"

     To invoke the service, use the following instructions based on your programming language:

      - For languages with OAuth 2.0-aware HTTP clients, use the service URL resolved in [Step 2](#step-2-read-configurations-within-the-application). The OAuth-aware client manages authentication automatically. For sample requests and responses, see the API definition provided via the Choreo marketplace for the service.

      - For languages without OAuth 2.0-aware HTTP clients, use the token obtained in [step 3](#step-3-acquire-an-oauth-20-access-token) to make calls to the dependent service. Subsequently, add the obtained token to the HTTP authorization header with the bearer prefix. As the service URL, use the URL resolved in [step 2](#step-2-read-configurations-within-the-application). For sample requests and responses, see the API definition of the service provided via the Choreo marketplace.

       The following is a sample code snippet in NodeJS:

       ``` java
       const response = await axios.get(serviceURL/{RESOURCE_PATH}, {
           headers: {
             'Authorization': `Bearer ${accessToken}`
             'Choreo-API-Key': `${choreoApiKey}`
           }
       });
       ```

    !!! note
        If you want to consume a Choreo service at the project visibility level, you don't need to obtain a token. You can directly invoke the service using the resolved URL.


# Use a Connection in Your Web Application

Choreo simplifies the process of integrating services into your web application. The approach to connect to a service can vary based on your web application. 

To connect to a selected service, follow the step-by-step instructions given below depending on the authentication mechanism used in your web application.

=== "Managed authentication"
    
    Choreo-managed authentication allows you to seamlessly handle authentication for your web application. You can configure your web application to work with the built-in identity provider of Choreo or any external identity provider that supports OIDC/OAuth2.0

    !!! note 
         Choreo's managed authentication is currently available only for web applications created with **React**, **Angular**, or **Vue.js** buildpacks.

    Follow the steps below to use an existing connection within your web application: 

    <h2> Step 1: Add the connection configuration</h2>

    To integrate a service into your application, you must first add the connection configuration as follows: 

    1. For single page applications (SPAs), you must add the connection configuration as a file mount. You can mount a file via the **Configurations** pane on the **Deploy** page. You must mount a file (for example, `config.js`) and add the configuration provided in the inline developer documentation into it. 

        The following is a sample configuration:

        ``` yaml
             window.configs = {
                 apiUrl: '<SERVICE_URL>',        
             };

        ```

    2.  To ensure accessibility of the `config.js` file via JavaScript at runtime, add a script tag as follows in the `index.html` file to reference the `config.js` file:

        ``` html
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="utf-8" />
            <title>My React App</title>
        </head>
        <body>
            <div id="root"></div>
            <script src="/public/config.js"></script>
        </body>
        </html>
        ``` 

        !!! note
             If you use an external IdP, you must add the IdP's configuration to the same file.
    
             For more information on working with IdPs, see [Configure Asgardeo as an External Identity Provider](https://wso2.com/choreo/docs/administer/configure-an-external-idp/configure-asgardeo-as-an-external-idp/).


    <h2> Step 2: Read the configuration</h2>

    Once you add the connection configuration, you can proceed to read the configuration from your application. The steps to read depend on the programming language you use.

    The following is a sample code snippet in NodeJS:

    ``` java
         const serviceURL = window?.configs?.apiUrl ? window.configs.apiUrl : "/";
    ```

    <h2> Step 3: Invoke the service</h2>

    If you use Choreo-managed authentication, Choreo handles the security handshaking for the application during deployment. The connected service will be accessible under the same domain as your application. Therefore, you can call the configured path directly using your preferred HTTP client.

    The following is a sample code snippet in NodeJS:

    ``` java
         const response = await axios.get(serviceURL/{RESOURCE_PATH});
    ```

    !!! note
         If you are using an external IdP provider instead of Choreo-managed authentication, you must obtain an access token from your IdP and add it to the HTTP authorization header with the bearer prefix.


=== "Custom authentication or no authentication"

    If you are not using Choreo-managed authentication or your web application lacks authentication, follow the steps below to connect to a service from your web application:

    <h2> Step 1: Add the connection configuration</h2>

    1. For single-page applications (SPAs), you must add the connection configuration as a file mount. You can mount a file via the **Configurations** pane on the **Deploy** page. You must mount a file (for example, `config.js`) and add the configuration provided in the inline developer documentation into it.
 
        The following is a sample configuration:

        ``` yaml
             window.configs = {
                 apiUrl: '<SERVICE_URL>',
                 consumerKey: '<CONSUMER_KEY>',
                 consumerSecret: '<CONSUMER_SECRET>',
                 tokenUrl: '<TOKEN_URL>',
             };
        ```

    2.  To ensure accessibility of the `config.js` file via JavaScript at runtime, add a script tag as follows in the `index.html` file to reference the `config.js` file:

        ``` html
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="utf-8" />
            <title>My React App</title>
        </head>
        <body>
            <div id="root"></div>
            <script src="/public/config.js"></script>
        </body>
        </html>
        ``` 

    For other types of web applications, you must add the respective configuration into your application.

    <h2> Step 2: Read the configuration</h2>

    Once you have added the connection configuration, you can proceed to read the configuration from your application. The steps to read depend on the programming language you use.

    The following is a sample code snippet in NodeJS:

    ``` java
         const serviceURL = window?.configs?.apiUrl ? window.configs.apiUrl : "/";
    ```

    <h2> Step 3: Acquire an OAuth 2.0 access token</h2>

    - For languages with OAuth 2.0-aware HTTP clients, you must pass the OAuth 2.0-related configurations such as client id, client secret and so on, obtained when creating the connection to your HTTP client configuration. The HTTP client autonomously manages token retrieval and refreshing.
  
    - For languages without OAuth 2.0-aware HTTP clients, you must manually initiate a call to the token endpoint. This includes fetching the token and managing token expiration and refresh directly within your application code. The following is a sample curl command to obtain a token:


        ```bash
        CONSUMER_KEY="your_consumer_key"
        CONSUMER_SECRET="your_consumer_secret"
        TOKEN_URL="your_token_url"

        # Encode client credentials as Base64
        CLIENT_CREDENTIALS=$(echo -n "$CLIENT_ID:$CLIENT_SECRET" | base64)

        curl -X POST $TOKEN_URL \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -H "Authorization: Basic $CLIENT_CREDENTIALS" \
        --data-urlencode "grant_type=client_credentials"

        ```

    <h2> Step 4: Invoke the service</h2>

    You can invoke the service as follows:

    - For languages with OAuth 2.0-aware HTTP clients, you can invoke the service in a straightforward manner. The HTTP client seamlessly manages OAuth 2.0 authentication without requiring additional intervention.

        As the service URL you can use the URL that you resolved in step 2 above. For sample requests and responses, see the API definition provided via the Choreo marketplace for the service.

    - For languages without OAuth 2.0-aware HTTP clients, you can use the token obtained in step 3 above to make calls to the dependent service. Subsequently, add the obtained token to the HTTP authorization header with the bearer prefix.

        As the service URL you can use the URL that you resolved in step 2 above. For sample requests and responses, see the API definition of the service provided via the Choreo marketplace.

        The following is a sample code snippet in NodeJS:

        ```java 
            const response = await axios.get(serviceURL/{RESOURCE_PATH}, {
                headers: {
                'Authorization': `Bearer ${accessToken}`
                }
            })
        ```


# Use a Database Connection in Your Component

Choreo allows you to share and reuse Choreo-managed databases, accelerating development and enhancing efficiency in building integrated applications through connections.

For step-by-step instructions on creating a database connection, see [Create a Connection](create-a-connection.md).

To learn more about Choreo Connections, see the documentation on [Connections](../../choreo-concepts/connections.md).

## Consume a database through a connection

To consume a Choreo-managed database via a connection, follow these steps:

### Step 1: Add connection configurations

To integrate a database into your application, click the appropriate tab below based on your current configuration file and follow the step-by-step instructions:

=== "Component.yaml file (v1.1)"

    1. Copy and paste the snippet from the  developer guide into the `component.yaml` file.

        The following is a sample snippet:

        ``` yaml

        dependencies:
            connectionReferences:
            - name: <CONNECTION_NAME>
              resourceRef: <RESOURCE_IDENTIFIER>

        ```

          | Field            | Description                                                         |
          |------------------|---------------------------------------------------------------------|
          | name             | The name given to the connection.                                   |
          | resourceRef      | A unique, readable identifier of the database being connected to.    |


    2. If you've previously added a `connectionReferences` section under `dependencies`, append this as another item under `connectionReferences`. Upon deploying the component, the necessary configurations to establish the connection will be injected into Choreo-defined environment variables.

          The following table details the Choreo-defined environment variables:

          | Configuration Key       | Choreo-Defined Environment Variable Name                       |
          |-------------------------|----------------------------------------------------------------|
          | HostName                | CHOREO_<CONNECTION_NAME\>_HOSTNAME                             |
          | Port                    | CHOREO_<CONNECTION_NAME\>_PORT                                 |
          | Username                | CHOREO_<CONNECTION_NAME\>_USERNAME                             |
          | Password                | CHOREO_<CONNECTION_NAME\>_PASSWORD                             |
          | DatabaseName            | CHOREO_<CONNECTION_NAME\>DATABASENAME                          |


          If you'd like to use custom environment variable names instead of the Choreo-defined ones, add the dependency as a service reference under `dependencies` in the same file. For more details, refer to the instructions under the `component.yaml file (v1.0)` tab.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | HostName       | string     | Hostname of the database server       | false         | false        |
          | Port           | string     | Port of the database server           | false         | false        |
          | Username | string           | Username of the database server       | false         | false        |
          | Password       | string     | Password of the database server       | false         | true         |
          | DatabaseName   | string     | Name of the database                  | false         | false        |
    ### Step 2: Read configurations within the application

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const hostName = process.env.CHOREO_<CONNECTION_NAME>_HOSTNAME;
    ```

=== "Component.yaml file (v1.0)"

    !!! note
        The `component.yaml v1.0` file is considered legacy. For new components, we recommend using the latest version, `component.yaml v1.1`, which offers enhanced usability and features.

    1. Copy and paste the snippet from the  developer guide into the `component.yaml` file.

        The following is a sample snippet:

        ``` yaml

        dependencies:
            serviceReferences:
            - name: database:<DATABASE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: HostName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Port
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Username
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Password
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: DatabaseName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>


        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the database you are connecting to.             |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added a service reference section under `dependencies`, append this as another item under `serviceReferences`.

          Upon deploying the component, Choreo automatically populates the specified environment variables with actual values.

          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | HostName       | string     | Hostname of the database server       | false         | false        |
          | Port           | string     | Port of the database server           | false         | false        |
          | Username | string           | Username of the database server       | false         | false        |
          | Password       | string     | Password of the database server       | false         | true         |
          | DatabaseName   | string     | Name of the database                  | false         | false        |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const hostName = process.env.HOSTNAME;
    ```

=== "Component-config.yaml file"

    !!! note
        The `component-config.yaml` file is considered legacy. For new components, we recommend using the latest version, `component.yaml v1.1`, which offers enhanced usability and features.

    1. Copy and paste the snippet from the  developer guide into the `component-config` file under the `spec` section.

        The following is a sample snippet:

        ``` yaml

        outbound:
            serviceReferences:
            - name: database:<DATABASE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: HostName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Port
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Username
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Password
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: DatabaseName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>

        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the database you are connecting to.              |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added an outbound service reference, append this as another item under `serviceReferences`.

          Upon deploying the component, Choreo automatically populates the specified environment variables with actual values.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | HostName       | string     | Hostname of the database server       | false         | false        |
          | Port           | string     | Port of the database server           | false         | false        |
          | Username | string           | Username of the database server       | false         | false        |
          | Password       | string     | Password of the database server       | false         | true         |
          | DatabaseName   | string     | Name of the database                  | false         | false        |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const hostName = process.env.HOSTNAME;
    ```

### Step 3: Initiate a database connection

To initiate a connection to the database, follow these steps:

In this example, you will connect to a MySQL database.

#### Step 3.1: Install the required packages

For the MySQL database, install the `mysql2` package using npm:

```bash
// Install the mysql2 package
npm install mysql2

```

#### Step 3.2: Import required packages

```java

const client = require('mysql2')

```

#### Step 3.3: Establish a connection

To establish the connection, use the environment variables for `hostName`, `username`, `password`, `databaseName`, and `port` as follows:

```java

var connection = client.createConnection({
      host: hostName,
      user: username,
      password: password,
      database: databaseName,
      port: port
});

connection.connect((err) => {
      if (err) {
          return;
      }
      // Connection is successful
});

```

By following these steps, your component can interact with the Choreo-managed database seamlessly.




# Integrate Unit Tests into the Build Pipeline

Choreo allows you to integrate unit tests into the build pipeline, enabling code validation before deployment. This ensures early testing of code changes, reducing the risk of defects in production.

!!! note
        Currently, Choreo supports unit tests only for the `WSO2 MI` buildpack.

## How it works

### Step 1: Write tests

You can create unit tests in your source code using standard testing libraries. For step-by-step instructions on creating unit tests for WSO2 Micro Integrator projects, see [Creating a Unit Test Suite](https://mi.docs.wso2.com/en/latest/develop/creating-unit-test-suite/).

### Step 2: Enable unit tests

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click the component for which you want to enable unit tests.
3. In the left navigation menu, click **Build**.
4. On the **Build** page, click to edit **Build Configurations**.
5. Turn on the **Unit Test** toggle.
6. Click **Save**.

### Step 3: Trigger a new build

- On the **Build** page, click **Build Latest**.

This starts a new build with unit tests enabled. You can monitor its progress in the **Build Details** pane.

## View failed unit tests

If a unit test fails during the build, you can view its detailed logs for troubleshooting. Click **View Details** corresponding to the failed build, then expand the failed unit test step to view the logs.

## Explore a sample

To see unit tests in action within the build pipeline, try out the [WSO2 MI helloworld](https://github.com/wso2/choreo-samples/tree/main/hello-world-mi) sample. 


# Manage Component Source Configurations

In Choreo, you can configure service endpoints and connections via the `component.yaml` source configuration file. This file ensures that the configurations required to initialize endpoints and connections are defined, as they cannot be inferred from the source code. This guide provides an overview of how to configure and manage these settings effectively.

The source configuration file must be committed to your repository within the `.choreo` directory at the root of the project directory. This ensures the ability to version the configuration files alongside repository commits, enabling better tracking and management of configurations.

!!! note
    -  The `component-config.yaml` and `endpoints.yaml` files will eventually be deprecated and replaced by the `component.yaml` file. 
        - For details on how to seamlessly update to the latest `component.yaml` file`, see [Update to the latest source configuration file](#update-to-the-latest-source-configuration-file).
    - Choreo prioritizes configuration files in the following order: `component.yaml` takes the highest precedence, followed by `component-config.yaml`, and then `endpoints.yaml`.

## Overview of the `component.yaml` file 

**File location**:

```bash
<build-context-path>/.choreo/component.yaml
```

!!! note
    - For components built using **Buildpacks**, replace `build-context-path` with the `<project-directory>`. 
    For example, `<project-directory>/.choreo/component.yaml`.
    - For components built using **Docker**, replace `build-context-path` with the `<docker-context-path>`. 
    For example, `<docker-context-path>/.choreo/component.yaml`.

**Sample `component.yaml` file content**:

Click the respective tab to view the structure for your current configuration file version:

=== "Version 1.1"

    ``` yaml
    # +required The configuration file schema version
    schemaVersion: 1.1

    # +optional Incoming connection details for the component
    endpoints:
      # +required Unique name for the endpoint.
      # This name will be used when generating the managed API
      - name: greeter-sample
        # +optional Display name for the endpoint.
        displayName: Go Greeter Sample
        # +required Service section has the user service endpoint details
        service:
          # +optional Context (base path) of the API that gets exposed via the endpoint.
          basePath: /greeting-service
          # +required Numeric port value that gets exposed via the endpoint
          port: 9090
        # +required Type of traffic that the endpoint is accepting.
        # Allowed values: REST, GraphQL, WS, GRPC, TCP, UDP.
        type: REST
        # +optional Network level visibilities of the endpoint.
        # Accepted values: Project|Organization|Public(Default).
        networkVisibilities: 
          - Public
          - Organization
        # +optional Path to the schema definition file. Defaults to wild card route if not provided
        # This is only applicable to REST or WS endpoint types.
        # The path should be relative to the docker context.
        schemaFilePath: openapi.yaml
      
      # +optional Outgoing connection details for the component.
      dependencies:
        # +optional Defines the connection references from the Internal Marketplace.
        connectionReferences:
          # +required Name of the connection.
          - name: hr-connection
            # +required service identifer of the dependent component.
            resourceRef: service:/HRProject/UserComponent/v1/ad088/PUBLIC
      # +optional Defines runtime configurations
      configurations:
        # +optional List of environment variables to be injected into the component.
        env:
          # +required Name of the environment variable
          - name: HR_SERVICE_URL
            # +required value source
            # Allowed value sources: connectionRef
            valueFrom:
              # +required Choreo connection value source
              connectionRef:
                # +required Choreo connection name to refer the value from
                name: hr-connection
                # +required Choreo connection configuration key to refer the value from
                key: ServiceURL
    ```

    The descriptor-based approach of the `component.yaml` file simplifies and streamlines endpoint and connection configuration management. The use of versioned schemas ensures backward compatibility, providing a seamless transition with future updates.

    You can define the following root-level configurations via the `component.yaml` file:

    | Configuration        | Required     | Description                                                              |
    |----------------------|--------------|--------------------------------------------------------------------------|
    | **schemaVersion**    | Required     | The version of the `component.yaml` file. Defaults to the latest version.|
    | **endpoints**        | Optional     | The list of endpoint configurations.                                     |
    | **dependencies**     | Optional     | The list of dependency configurations.                                   |
    | **configurations**    | Optional     | The runtime configuration definitions.                                   |

    ### Endpoint configurations
    In the `endpoints` section of the `component.yaml` file, you can define multiple service endpoint configurations. Each endpoint must have a unique name and the required fields specified in the schema overview.

    !!! tip "Why have a unique name?"
          When you define multiple endpoints, the `endpoint.name` is appended to the Choreo-generated URL. A unique name ensures the endpoint is easily recognizable and readable within the URL.
          
    | Configuration        | Required     | Description                                                                                             |
    |----------------------|--------------|---------------------------------------------------------------------------------------------------------|
    | **name**             | Required     | A unique identifier for the endpoint within the service component. Avoid using excessively long names.  |
    | **displayName**      | Optional     | A display name for the endpoint.                                                                        |
    | **service**          | Required     | Service details for the endpoint.                                                                       |
    | **.basePath**        | Required     | The base path of the API exposed via this endpoint.                                                     |
    | **.port**            | Required     | The numeric port value exposed via this endpoint.                                                       |
    | **type**             | Required     | The type of traffic the endpoint accepts. For example, `REST`, `GraphQL`, `WS`, `gRPC`, `UDP`, or `TCP`.|
    | **networkVisibilities** | Required | The network-level visibility of the endpoint. For example, project, organization, or public.             |
    | **schemaFilePath** | Required | The file path to the swagger definition  or AsyncAPI 2.0 specification file. Defaults to the wildcard route if not specified. This field should be a relative path to the project path when using **Java**, **Python**, **NodeJS**, **Go**, **PHP**, **Ruby**, or **WSO2 MI** buildpacks. For REST or WebSocket endpoint types, when using the **Ballerina** or **Dockerfile** buildpack, the path should be relative to the component root or Docker context. |

    ### Dependency configurations

    In the `dependencies` section of the `component.yaml` file, you can define multiple connection configurations under `dependencies.connectionReferences`. You can use the connection reference generated in the inline developer guide when creating a connection. For instructions on copying [connection configurations](https://wso2.com/choreo/docs/develop-components/sharing-and-reusing/use-a-connection-in-your-service/), see the inline developer guide displayed during connection creation.

    You must include the following configurations in the `dependencies.connectionReferences` schema:

    | Configuration        | Required     | Description                                                                      |
    |----------------------|--------------|----------------------------------------------------------------------------------|
    | **name**             | Required     | The name given to the connection.                                                |
    | **resourceRef**      | Required     | A unique, human-readable identifier for the service you are connecting.          |


    !!! note
        Choreo automatically generates connection configurations when you create a connection. The properties such as **name** and **resourceRef** are automatically generated. The configurations required to establish the connection will be injected into Choreo-defined environment variables.

        To use custom environment variable names instead of Choreo's default ones, add the dependency as a `serviceReference` in your `component.yaml v1.1` file. You can copy the `serviceReference` section from the `component.yaml v1.0` tab and paste it under `dependencies` in your `component.yaml v1.1` file, which maintains backward compatibility with the v1.0 format.

    ### Runtime configurations
    In the `configurations` section of the `component.yaml` file, you can define runtime configurations for the component. These configurations currently support environment variable injection related to dependencies.
    
    | Configuration                 | Required     | Description                                                                       |
    |-------------------------------|--------------|-----------------------------------------------------------------------------------|
    | **env**                       | Optional     | An array of env variable configurations.                                          |
    | **name**                      | Required     | A unique name for the environment variable, starting with a letter or an underscore, and containing only letters, numbers, or underscores. |
    | **valueFrom**                 | Required     | The source of the environment variable value.                                     |
    | **connectionRef**             | Required     | Connection reference value source definition.                                     |
    | **name**                      | Required     | The name of the Choreo connection to reference the value from.                    |
    | **key**                       | Required     | The Choreo connection configuration key to reference the value from. For details on available keys, see [connection configurations](https://wso2.com/choreo/docs/develop-components/sharing-and-reusing/use-a-connection-in-your-service/) or the inline developer guide. |

    !!! note
        Runtime configurations are supported starting from `component.yaml v1.1`.

        When an environment variable value is specified using `connectionRef`, the connection's environment variable is renamed to the environment variable name defined in the `configurations` section. For example, in the sample `component.yaml` file given above, the `CHOREO_HR_CONNECTION_SERVICEURL` variable in the `hr-connection` is renamed to `HR_SERVICE_URL`.

=== "Version 1.0"

    ``` yaml
    # +required The configuration file schema version
    schemaVersion: 1.0

    # +optional Incoming connection details for the component
    endpoints:
      # +required Unique name for the endpoint.
      # This name will be used when generating the managed API
      - name: greeter-sample
        # +optional Display name for the endpoint.
        displayName: Go Greeter Sample
        # +required Service section has the user service endpoint details
        service:
          # +optional Context (base path) of the API that gets exposed via the endpoint.
          basePath: /greeting-service
          # +required Numeric port value that gets exposed via the endpoint
          port: 9090
        # +required Type of traffic that the endpoint is accepting.
        # Allowed values: REST, GraphQL, WS, GRPC, TCP, UDP.
        type: REST
        # +optional Network level visibilities of the endpoint.
        # Accepted values: Project|Organization|Public(Default).
        networkVisibilities: 
          - Public
          - Organization
        # +optional Path to the schema definition file. Defaults to wild card route if not provided
        # This is only applicable to REST or WS endpoint types.
        # The path should be relative to the docker context.
        schemaFilePath: openapi.yaml
      
    # +optional Outgoing connection details for the component.
    dependencies:
      # +optional Defines the service references from the Internal Marketplace.
      serviceReferences:
        # +required Name of the service reference.
        - name: choreo:///apifirst/HRProject/UserComponent/ad088/v1/PUBLIC
          # +required Name of the connection instance.
          connectionConfig: 19d2648b-d29c-4452-afdd-1b9311e81412
          # +required Environment variables injected into the component for connection configuration.
          env:
            # +required Key name of the connection configuration.
            - from: ServiceURL
              # +required Environment variable injected into the container.
              to: SERVICE_URL
    ```

    The descriptor-based approach of the `component.yaml` file simplifies and streamlines endpoint and connection configuration management. The use of versioned schemas ensures backward compatibility, providing a seamless transition with future updates.

    You can define the following root-level configurations via the `component.yaml` file:

    | Configuration        | Required     | Description                                                              |
    |----------------------|--------------|--------------------------------------------------------------------------|
    | **schemaVersion**    | Required     | The version of the `component.yaml` file. Defaults to the latest version.|
    | **endpoints**        | Optional     | The list of endpoint configurations.                                     |
    | **dependencies**     | Optional     | The list of dependency configurations.                                   |

    <h3> Endpoint configurations </h3>
    In the `endpoints` section of the `component.yaml` file, you can define multiple service endpoint configurations. Each endpoint must have a unique name and the required fields specified in the schema overview.

    !!! tip "Why have a unique name?"
          When you define multiple endpoints, the `endpoint.name` is appended to the Choreo-generated URL. A unique name ensures the endpoint is easily recognizable and readable within the URL.
          
    | Configuration           | Required     | Description                                                                                             |
    |-------------------------|--------------|---------------------------------------------------------------------------------------------------------|
    | **name**                | Required     | A unique identifier for the endpoint within the service component. Avoid using excessively long names.  |
    | **displayName**         | Optional     | A display name for the endpoint.                                                                        |
    | **service**             | Required     | Service details for the endpoint.                                                                       |
    | **.basePath**           | Required     | The base path of the API exposed via this endpoint.                                                     |
    | **.port**               | Required     | The numeric port value exposed via this endpoint.                                                       |
    | **type**                | Required     | The type of traffic the endpoint accepts. For example, `REST`, `GraphQL`, `gRPC`, `WS`, `UDP`, or `TCP`.|
    | **networkVisibilities** | Required     | The network-level visibility of the endpoint. For example, project, organization, or public.            |
    | **schemaFilePath**      | Required     | The file path to the swagger definition or AsyncAPI 2.0 specification file. Defaults to the wildcard route if not specified. This field should be a relative path to the project path when using **Java**, **Python**, **NodeJS**, **Go**, **PHP**, **Ruby**, or **WSO2 MI** buildpacks. For REST or WebSocket endpoint types, when using the **Ballerina** or **Dockerfile** buildpack, the path should be relative to the component root or Docker context. |

    <h3> Dependency configurations </h3>

    In the `dependencies` section of the `component.yaml` file, you can define multiple service connection configurations under `dependencies.serviceReferences`. You can use the service references generated in the inline developer guide when creating a service connection. For instructions on copying [connection configurations](https://wso2.com/choreo/docs/develop-components/sharing-and-reusing/use-a-connection-in-your-service/), see the inline developer guide displayed during connection creation.

    You must include the following configurations in the `dependencies.serviceReferences` schema:

    | Configuration        | Required     | Description                                                                      |
    |----------------------|--------------|----------------------------------------------------------------------------------|
    | **name**             | Required     | A unique name for the service reference.                                         |
    | **connectionConfig** | Required     | A unique name for the connection instance.                                       |
    | **env**              | Required     | The list of environment variable mappings to inject into the container.          |
    | **.from**            | Required     | The key name of the connection configuration.                                    |
    | **.to**              | Required     | The environment variable to inject into the container.                           |

    !!! note
        Choreo automatically generates connection configurations when you create a connection. The properties such as **name**, **connectionConfig**, and **env.from** are automatically generated. However, you must manually set the **env.to** value.

## Overview of the `component-config.yaml` file 

**File location**:

```bash
<build-context-path>/.choreo/component-config.yaml
```

**Sample `component-config.yaml` file content**:

```yaml
apiVersion: core.choreo.dev/v1beta1
kind: ComponentConfig
spec:
  # +optional Incoming connection details for the component (AKA endpoints).
  inbound:
    # +required Unique name for the endpoint.
    # This name will be used when generating the managed API
    - name: Greeting Service
      # +required Numeric port value that gets exposed via the endpoint
      port: 9090
      # +required Type of traffic that the endpoint is accepting.
      # Allowed values: REST, GraphQL, GRPC, TCP, UDP, WS.
      type: REST
      # +optional Network level visibility of the endpoint. Defaults to Public
      # Accepted values: Project|Organization|Public.
      networkVisibility: Public
      # +optional Context (base path) of the API that gets exposed via the endpoint.
      # This is mandatory if the endpoint type is set to REST, GraphQL or WS.
      context: /greeting
      # +optional The path to the schema definition file. Defaults to wildcard route if not specified.
      # This is only applicable to REST and WS endpoint types.
      # The path should be relative to the Docker context.
      schemaFilePath: greeting_openapi.yaml
  # +optional Outgoing connection details for the component.
  outbound:
    # +optional Defines the service references from the Internal Marketplace.
    serviceReferences:
      # +required Name of the service reference.
      - name: choreo:///apifirst/mttm/mmvhxd/ad088/v1.0/PUBLIC
        # +required Name of the connection instance.
        connectionConfig: 19d2648b-d29c-4452-afdd-1b9311e81412
        # +required Environment variables injected to the component for connection configuration.
        env:
          # +required Key name of the connection configuration.
          - from: ServiceURL
            # +required Environment variable injected to the container.
            to: SERVICE_URL
```

The `component-config.yaml` file complements and enhances the existing endpoint configuration process. It allows you to define how the endpoints (inbound connections) in your service are exposed and how your service connects to external services or components (outbound connections).

You can define the following root-level configurations via the `component-config.yaml` file:

| Configuration        | Required     | Description                                                                           |
|----------------------|--------------|---------------------------------------------------------------------------------------|
| **apiVersion**       | Required     | The version of the `component-config.yaml` file defaults to `core.choreo.dev/v1beta1`.|
| **kind**             | Required     | The resource type of the file defaults to `ComponentConfig`.                          |
| **spec.inbound**     | Optional     | The list of inbound connection configurations.                                        |
| **spec.outbound**    | Optional     | The list of outbound connection configurations.                                       |

#### Inbound connection configurations (`spec.inbound`)

In the `spec.inbound` configuration section, you can specify endpoints to set up inbound connections. To specify endpoints, you can follow the existing endpoints schema structure. For details on the endpoints schema structure, see the [endpoints schema documentation](#overview-of-the-endpointsyaml-file).

#### Outbound connection configurations (`spec.outbound`)

In the `spec.outbound` section, you can define `serviceReferences`. To define `serviceReferences`, you can use the service references generated in the Internal Marketplace when creating a service connection. To copy the [outbound connection configurations](../sharing-and-reusing/use-a-connection-in-your-service/#use-a-connection-in-your-service), see the inline developer guide displayed when you create a connection.

You must include the following configurations in the `serviceReferences` schema:

| Configuration        | Required     | Description                                                                      |
|----------------------|--------------|----------------------------------------------------------------------------------|
| **name**             | Required     | A unique name for the service reference.                                         |
| **connectionConfig** | Required     | A unique name for the connection instance.                                       |
| **env**              | Optional     | The list of environment variable mappings to inject into the container.          |
| **env.from**         | Required     | The key name of the connection configuration.                                    |
| **env.to**           | Required     | The environment variable to inject into the container.                           |

## Overview of the `endpoints.yaml` file

**File location**:

```bash
<build-context-path>/.choreo/endpoints.yaml
```

**Sample `endpoints.yaml` file content**:

```yaml
# +required Version of the endpoint configuration YAML
version: 0.1

# +required List of endpoints to create
endpoints:
  # +required Unique name for the endpoint.
  # This name will be used when generating the managed API
- name: Greeting Service
  # +required Numeric port value that gets exposed via this endpoint
  port: 9090
  # +required Type of the traffic this endpoint is accepting.
  # Allowed values: REST, GraphQL, GRPC, UDP, TCP, WS.
  type: REST
  # +optional Network level visibility of this endpoint. Defaults to Public
  # Accepted values: Project|Organization|Public.
  networkVisibility: Project
  # +optional Context (base path) of the API that is exposed via this endpoint.
  # This is mandatory if the endpoint type is set to REST, GraphQL or WS.
  context: /greeting
  # +optional Path to the schema definition file. Defaults to wild card route if not provided
  # This is only applicable to REST and WS endpoint types.
  # The path should be relative to the docker context.
  schemaFilePath: greeting_openapi.yaml
```

The `endpoints.yaml` configuration file allows you to define configurations for multiple endpoints necessary for Choreo service components. This schema is essential to identify the context, port binding, network exposure level, and other attributes required to generate a Choreo endpoint.

You can define the following root-level configurations via the `endpoints.yaml` file:

| Configuration        | Required     | Description                                                                       |
|----------------------|--------------|-----------------------------------------------------------------------------------|
| **version**          | Required     | The version of the `endpoints.yaml` file.                                         |
| **name**             | Required     | A unique name for the endpoint, which Choreo will use to generate the managed API.|
| **port**             | Required     | The numeric port value that gets exposed via this endpoint.                       |
| **type**             | Required     | The type of traffic this endpoint accepts, such as `REST`, `GraphQL`, `gRPC`, `WS`, `UDP`, or `TCP`. Currently, the MI preset supports only the `REST` type.                                         |
| **networkVisibility**| Required     | The network level visibility of this endpoint, which defaults to `Public` if not specified. Accepted values are `Project`, `Organization`, or `Public`.|
| **context**          | Required     | The context (base path) of the API that Choreo exposes via this endpoint.         |
| **schemaFilePath**   | Required     | The swagger definition file path. Defaults to the wildcard route if not provided. This field should be a relative path to the project path when using the **Java**, **Python**, **NodeJS**, **Go**, **PHP**, **Ruby**, and **WSO2 MI** buildpacks. For REST endpoint types, when using the **Ballerina** or **Dockerfile** buildpack, this field should be a relative path to the component root or Docker context.|

## Update to the latest source configuration file

With the upcoming deprecation of the `component-config.yaml` file and the `endpoints.yaml` file, Choreo provides a seamless process to move to the latest `component.yaml`  version of the `component.yaml` file. Follow these steps to transition seamlessly:

### Step 1: Identify whether your current source configuration file is outdated

You can determine whether you’re using an outdated configuration file in the following ways:

- **During a build:**
     - On the **Build** page, after triggering a build, a warning will appear if your source configuration file is outdated. Click **View Details** in the **Initialization** -> **Source Config Validation** step. You will see an information banner with an option to update the file.

- **In existing deployments:**
     - If an existing deployment uses a build with an outdated source configuration file, you will see a warning icon on the build card of the relevant environment card.


### Step 2: Generate the latest `component.yaml` file

- In either of the scenarios above, click **Update** to initiate the process of generating the latest `component.yaml` file. The updated file will retain your existing configurations to ensure a smooth update process.


### Step 3: Add the generated configuration file to your repository

1. Download the generated `component.yaml` file.
2. Replace the existing source configuration file in the `.choreo` folder within your source repository.
    - Ensure the file name is `component.yaml`.


### Step 4: Trigger a new build

1. Commit the new `component.yaml` file to your repository. Push changes to the remote Git repository.
2. Trigger a build using the latest commit.


### Step 5: Verify the update

Once the build is complete:

  - Deploy the build.
  - Confirm that the warning messages no longer appear.

You can benefit from the latest features and enhancements provided by the updated source configuration file.


# Manage Deployment Tracks for Choreo Components

Choreo allows you to create and manage dedicated [deployment tracks](../choreo-concepts/deployment-tracks.md) for components, facilitating independent version control and deployment. This capability also allows you to unlink deployment tracks from associated branches or relink them to different branches so that you can align with your preferred Git workflows, such as the feature branch workflow or GitFlow workflow.

!!! info
     Deployment track creation and management does not apply to API Proxy and [BYOI components](../develop-components/bring-your-own-image.md).

## Create a deployment track

**Prerequisites**:

 - Create a component in Choreo.

Follow the steps below to create a deployment track for a component:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to create a deployment track for.
3. On the header of the component overview page, click the **Deployment Track** drop-down list.
4. Click **+ Create New** to open the **Create Deployment Track** dialog.
5. In the **Create Deployment Track** dialog, do the following:
    1. Select a branch to associate with the deployment track.
    2. Optionally, specify a description for the deployment track. 
    3. To create a deployment track for a service component, specify a unique API version indicating the major and minor version numbers.
6. Click **Create**.

## Unlink a deployment track

If you want to detach a branch reference from a deployment track, you must unlink the branch.

!!! info
     When you unlink the branch of a deployment track, the active deployments are unaffected. However, while you can redeploy the existing deployment, you cannot perform a new deployment.

Follow the steps below to unlink a deployment track of a component:
  
1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to unlink a deployment track.
3. On the header of the component overview page, click the **Deployment Track** drop-down list and then click **View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
4. Click the edit icon corresponding to the deployment track you want to unlink.
5. In the **Edit Branch** dialog that opens, click the **Branch Name** list and select **None**.
6. Click **Save**.

## Link a deployment track

To associate a branch reference to an unlinked deployment track, you must link a branch.

!!! info
    To build and deploy the contents of the linked branch,  you must perform a manual build and deploy.

**Prerequisites**:

 - A minimum of two branches in your GitHub repository.

Follow the steps below to link a branch to an unlinked deployment track:
  
1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to associate a branch reference for.
3. On the header of the component overview page, click the **Deployment Track** drop-down list and then click **View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
4. Click **+ Link Branch** corresponding to the unlinked deployment track for which you want to associate a branch.
5. In the **Link Branch** dialog that opens, click the **Branch Name** list and select the branch you want to relink.
6. Click **Save**.

## Relink a deployment track

To switch the branch reference of a linked deployment track, you must relink to an appropriate branch.

!!! info
      If you unlink the existing branch of a deployment track and link a different branch, you must perform a manual build and deploy to build and deploy the contents of the recently linked branch.

**Prerequisites**:

 - A minimum of two branches in your GitHub repository.

Follow the steps below to switch the branch reference of a linked deployment track:
  
1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to relink a deployment track for.
3. On the header of the component overview page,  click the **Deployment Track** drop-down list and then click **View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
4. Click the **Edit Branch** icon corresponding to the deployment track you want to relink.
5. In the **Edit Branch** dialog that opens, click the **Branch Name** list and select the branch you want to relink.
6. Click **Save**.

Now that you understand how to create and manage deployment tracks for components, let’s explore a sample scenario to see how a developer can use deployment tracks to manage version releases in Choreo.

## Sample Scenario: Manage version releases with deployment tracks

Let’s consider the following version release scenario: 

- To initiate work on a new feature, a developer creates a new branch, named `feature-x` from either the `main` or `dev` branch.
- Once development is complete, the developer proceeds to merge the `feature-x` branch into the `dev` branch for testing.
- Upon successful testing in the `dev` branch, the developer proceeds to merge all the changes into the `main` branch for production deployment.

Following are the actions you need to take from a deployment track perspective to manage the version release:

1. To prepare for the new version release, unlink the `main` branch from the associated deployment track (let’s consider this as the deployment track 1).
2. Proceed to merge the `dev` branch containing the tested changes into the `main` branch.
3. Unlink the `dev` branch from the associated deployment track (let’s consider this as deployment track 2).
4. Link deployment track 2 containing the latest version of the service to the `main` branch for deployment.
5. To facilitate ongoing development and testing, create another deployment track (let’s consider this as deployment track 3) and link it to the `dev` branch.

!!! tip
     - As a developer, you can strategically unlink and relink deployment tracks to effectively manage different versions of your services within Choreo.
     - You can create new deployment tracks for ongoing development branches like `dev` to ensure a continuous development and release cycle.

## Delete a deployment track

If you no longer need a deployment track, you can delete it.

!!! note
    If the component exposes an endpoint or proxy and you want to delete the last version in the major version range, the recommended approach is to retire that version first. This allows consumers to transition to the next major version and prevents a sudden break in their experience.
    For example, if you have deployment tracks for v1.0 and v2.0, notify consumers to switch to v2.0 before deleting v1.0. Then, retire the APIs in v1.0 and proceed to delete the associated deployment track.




**Prerequisites**:

- At least 2 deployment tracks in a component.

Follow the steps below to delete a deployment track:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to delete a deployment track.
3. On the header of the component overview page, click the **Deployment Track** drop-down list.
4. Click **+ View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
5. Click the **Delete** icon corresponding to the deployment track you want to delete.
6. Click **Delete** to confirm the deletion.

# Manage the Micro Integrator Runtime Version in Your Integration Project

Choreo allows you to use a preferred WSO2 Micro Integrator (MI) runtime version in your integration project. Currently, Choreo supports MI product versions 4.1.0 and 4.2.0. You have the flexibility to deploy WSO2 updates within these specified versions. 

When you create an integration project, you can specify a required runtime version to gain control over the environment in which your integration runs. This version management capability empowers you to tailor your projects depending on your runtime requirements, enhancing the customization and adaptability of your integration workflows.

## Understand the version string

WSO2 Micro Integrator (MI) utilizes a versioning system consisting of three-digit numbers, such as `4.1.0` and `4.2.0`, following semantic versioning principles. The product remains committed to receiving updates from WSO2, including security fixes, bug resolutions, and enhancements. Within the Choreo platform, the MI runtime version is constructed by combining the product release version with its corresponding update level.

In Choreo, the MI runtime version is structured as a four-digit number, for example, `4.1.0.14` or `4.2.0.17`. The first three digits represent the product release version, while the last digit signifies the update level of the product. The fourth digit is optional and can be omitted.

![Version string](../assets/img/develop-components/micro-integrator/version-string.png)

## Version management in WSO2 Integration Studio

If you are using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/) to build and deploy integration artifacts in WSO2 Micro Integrator, you can create multiple runtime environments and execute projects on any selected environment. WSO2 Integration Studio also allows you to configure multiple Micro Integrator runtime environments, offering flexibility and customization in the execution of integration processes.

You can specify the Runtime version when you create an integration project in WSO2 Integration Studio. In the project creation wizard, specify the runtime version in the **Runtime version** field, as shown below.
![Specify Runtime version](../assets/img/develop-components/micro-integrator/specify_runtime_version.png)


An integration project is structured as a Maven project with multiple sub-modules. The root `pom.xml` file holds crucial information about the target runtime. The runtime version you configure when you create a new project is saved within the root `pom.xml` file. The version information is stored in the <project.runtime.version> element under the <properties> in the `pom.xml` file. If there is a need to update the runtime version, you have the flexibility to modify the value to a valid runtime version and ensure that the project runs in the required runtime environment.

![project runtime version](../assets/img/develop-components/micro-integrator/project-runtime-version.png)

You can establish multiple runtime environments by utilizing updated MI instances. With a valid WSO2 subscription, you can also access and download updates to set up an updated MI server locally. This update process allows you to select a preferred update level as the runtime version. Consequently, you can run your integration on a runtime with the latest updates, ensuring optimal performance and access to new features.

### Configure a Micro Integrator runtime environment in Integration Studio

If you are using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), follow these steps to set up a remote server instance with a Micro Integrator runtime environment to execute your integration project:

!!! info "Note"
    If you have not downloaded and installed WSO2 Integration Studio, you can follow the [installation instructions](https://apim.docs.wso2.com/en/latest/integrate/develop/installing-wso2-integration-studio/) in the WSO2 API Manager documentation.

1. Launch WSO2 Integration Studio and click **Add Server** in the **Getting Started** view.
   ![Add server](../assets/img/develop-components/micro-integrator/add-server.png)
2. In the **Define a New Server** dialog, click to expand the `WSO2` directory and select **WSO2 Remote Server**.
   ![Define a remote server instance](../assets/img/develop-components/micro-integrator/define-a-remote-server-instance.png)
3. Enter the WSO2 Micro Integrator Management API URL in the **Server URL** field and click **Test Connection**.

    !!! info "Note"
        The Management API of WSO2 Micro Integrator is an internal REST API introduced to substitute MI admin services. The default HTTPS port of the Management API of WSO2 Micro Integrator is `9164`. If you have not manually changed the default port, you must set the Management API URL as `https://localhost:9164/management`.  If you have changed the default HTTPS port, you must set the port number appropriately when specifying the **Server URL**. For more information on the default ports of WSO2 Micro Integrator, see [WSO2 Micro Integrator default ports](https://apim.docs.wso2.com/en/latest/install-and-setup/setup/reference/default-product-ports/#micro-integrator-ports) in the WSO2 API Manager documentation.

    ![Set server URL](../assets/img/develop-components/micro-integrator/set-server-url.png)
    
4. Click **Finish**.
5. In the **Add and Remove** dialog, select the integration components to move from the left side to the right side.
6. Click **Add >**.
7. Click **Finish**. 

Your integration project is now running in a remote server instance with the Micro Integrator runtime environment you require.
If you need to make changes to the integration project, expand the remote server instance, right-click on the deployed exporter project, and select **Redeploy** to apply the changes.

![Redeploy project](../assets/img/develop-components/micro-integrator/redeploy-project.png)

## Convention for version interpretation in Choreo deployments

You can use the following convention to indicate the required MI runtime version in your integration project:


| **Version format**           | **Example**       | **Description**   |
|------------------------------|-------------------|-------------------|
| Product version              | `4.1.0`, `4.2.0`  | Deploy on the latest update level of the mentioned product version.                 |
| Product version with update level  | `4.1.0.15`, `4.2.0.17` |  Deploy on the exact update level of the mentioned product version.    |
| GA version                   | `4.1.0.0`, `4.2.0.0` | Deploy on the exact GA version without any update.                  |
| Default version            | Empty value         | Deploy on the latest update level of the default product version.                  |


Choreo utilizes Alpine images for configuring and deploying the Micro Integrator runtime. This includes automated configuration of the JRE/JDK, customized to the compatibility of the chosen runtime version, simplifying the setup procedure.

## Migrate between runtime versions

Changing the runtime version in an integration project may become necessary during product version upgrades or when you want to apply updates. 

To change the runtime version of a MI Integration, follow the below steps.

### Update the runtime version in the integration project
    
To change the runtime version in the integration project, follow the steps below:
1. Open the project in Integration Studio.
2. Right-click on the project and select **Change Runtime MI Version**.
    ![Update Runtime version](../assets/img/develop-components/micro-integrator/click_change_runtime.png)
3.  Specify the new runtime version as shown below:
    ![Update Runtime version](../assets/img/develop-components/micro-integrator/update_runtime_version.png)
4. Alternatively, you can manually update the version by opening the root `pom.xml` file.  Open pom.xml and change the required runtime version in `<project.runtime.version>` element under `<properties>` section.

To test the changes locally, you must download and set up the runtime environment locally. Then, you must [configure the Integration Studio runtime environment](#configure-a-micro-integrator-runtime-environment-in-integration-studio) by directing it to the locally installed MI runtime. Once the setup is complete, you can deploy your integrations on the MI runtime environment and proceed to the testing phase.

After completing the tests to ensure everything works as expected, you can follow below steps to deploy the project in Choreo:

1. Commit and push the changes to your repository.
2. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
3. Select your project from the **Project** list in the header.
4. Select your MI integration component from the **Component** list in the header.
5. In the left navigation menu, click **Build**.
6. Select the latest commit and click **Build**.
7. In the left navigation menu, click **Deploy**.
8. Click on the **Configure and Deploy** and deploy the component.
9. Verify the Runtime version by checking the logs by selecting the **Runtime Logs** under the **Observability** section.

  You will see the runtime version in the logs as shown below:
  ![Runtime version in logs](../assets/img/develop-components/micro-integrator/runtime_version_in_logs.png)

Next, you must conduct additional testing in the development environment on Choreo before you promote the integration to production environments.

## Troubleshoot errors

The following error codes can help you troubleshoot errors that occur during the integration component build:

| **Error code** | **Description**            |
|----------------|----------------------------|
| 110 - 119      | Internal server error.     |
| 121            | Malformed runtime version. |
| 122            | The specified runtime version is not available. Either the product or update level is not available.    |
| 123            | Trivy security vulnerabilities found in the `libs` directory. |
| 124            | Trivy security vulnerabilities found in the `dropins` directory. |
| 125            | Trivy security vulnerabilities found in the `libs` or `dropins` directory. |
| 126            | Error building integration project. |


# Submit and Manage Workflow Approval Requests

In Choreo, if an administrator [configures a workflow to require approval](../administer/configure-approvals-for-choreo-workflows.md), you must submit a request to obtain approval to perform the task.

Upon submitting a workflow approval request, Choreo notifies all authorized assignees via email about the [review request](../administer/review-workflow-approval-requests.md). When an authorized assignee approves or rejects the request, you will receive an email with details of the decision.

The approach to request approval can vary depending on the workflow. 

## Request approval for environment promotion

**Prerequisites**:

- Ensure you have a component created, built, and deployed to the development environment.
- Ensure that an approval workflow is configured for environment promotion.
- Ensure you are promoting the component to a critical environment, such as production.

To request approval to promote a component from the development environment to production, follow these steps:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to deploy. This takes you to the **Overview** page of the component.
3. In the left navigation menu, click **Deploy**.
4. Go to the **Development** card and click **Request to Promote**.
5. In the **Request Approval** pane that opens, enter your request details and click **Submit**. This creates a request and notifies all authorized assignees via email about the request.

    !!! note
         When an environment promotion request for a specific component is pending review, Choreo restricts other developers from making the same request until the pending request is either approved or rejected.

When an authorized assignee approves the request, you will receive a confirmation email and can proceed to promote the component to production.

## Cancel a workflow approval request

If you want to cancel a workflow approval request that is already submitted, you can do so before the request is approved or rejected. 

When you submit a workflow approval request, the **Request to Promote** button changes to **Cancel Request**. To cancel an approval request, click **Cancel Request**. Upon confirming the cancellation, all configured approvers are notified immediately, and the request will no longer be pending.


# Work with the Micro Integrator Runtime in Choreo

WSO2 Micro Integrator (WSO2 MI) is a lightweight, high-performance integration runtime. It allows you to run integrations developed using WSO2 Integration Studio within Choreo. 

The topics on this page walk you through the key aspects you need to understand to use the WSO2 MI runtime effectively in Choreo.

## Integration types

Choreo supports the following WSO2 MI integrations that cater to different use cases and requirements. Each integration type serves a specific purpose. Therefore, it is essential to understand their differences to easily choose the most appropriate integration for your use case.

- **Service**: Exposes an integration as an API via HTTP, making it possible to create a RESTful interface for your integration services. This type is ideal for scenarios where you need to provide an API for external systems or clients to interact with your integration.
- **Event Handler**: Triggers an integration based on external events such as messages arriving on a queue or updates in a database. This type is well-suited for implementing event-driven architectures or responding to changes in your system's environment.
- **Scheduled Task**: Runs an integration automatically at predefined time intervals, ensuring that specific integration tasks occur at regular intervals. This type is ideal for batch processing, data synchronization, or periodic maintenance tasks.
- **Manual Task**: Initiates an integration via user action, giving you full control over when the integration executes. This type is useful for on-demand tasks, testing, or debugging purposes.

## Develop integrations with WSO2 Integration Studio

[WSO2 Integration Studio](https://wso2.com/integration/integration-studio/) is a powerful, Eclipse-based graphical development environment that enables you to build and deploy integration artifacts in WSO2 Micro Integrator. This comprehensive IDE offers a robust set of tools for designing and testing integration flows and crafting integration artifacts. By utilizing the visual, drag-and-drop capabilities of WSO2 Integration Studio, developers can significantly reduce the time and effort needed to construct and deploy integration flows.

In addition to streamlining the development process, Integration Studio offers features such as debugging, testing, and version control to ensure the quality and reliability of integration flows. By creating an Integration project and Composite Exporter project in WSO2 Integration Studio, developers can export their integration projects as a single deployment artifact, known as a composite application. This composite application encompasses all the components and configurations necessary for deploying the integration project to WSO2 Micro Integrator.

The Composite Exporter project simplifies the deployment process by allowing developers to package their integration projects as a single, self-contained artifact that can be easily deployed and managed. This approach enhances the consistency and reliability of integration projects while streamlining the overall deployment process.

To start developing integrations with WSO2 Micro Integrator, see [WSO2 Micro Integrator documentation - Developing Integration Solutions](https://mi.docs.wso2.com/en/latest/develop/intro-integration-development/).

## Integration project directory structure

An Integration Project in WSO2 Integration Studio is a multi-module Maven project that can contain multiple modules with WSO2 Synapse configurations and a composite application module to export all the configurations as a single deployable artifact.

An integration project directory structure includes the following key components:

 - WSO2 Synapse configurations: These modules contain the essential configurations for the integration project.
 - Composite Application module: This module is responsible for exporting all the Synapse configurations as a single deployable artifact.

Optionally, you can include the following components in your integration project:

 - OpenAPI definition file: You can add the OpenAPI definition file to any location within the project. When creating a component, you'll need to define the path to this file. Choreo will automatically generate an OpenAPI definition for you based on your integration project, if you don't provide one.
 - Java libraries: If your integration project requires additional Java libraries, you can add them to the libs directory located in the project root.
 - deployment.toml file: This optional configuration file allows you to customize the preconfigured settings of WSO2 MI instances running on Choreo. By including this file, you can tailor the behavior of your WSO2 MI instances to better suit your project's specific requirements.

Understanding the Integration Project directory structure is crucial for organizing your project and ensuring that all necessary components are included in the final deployable artifact.

## OpenAPI support

OpenAPI Support plays a crucial role in enhancing the functionality of integrations exposed as APIs. By providing an OpenAPI definition for your exposed integration, you can streamline testing and management processes, ensuring a more efficient and user-friendly experience. Choreo will automatically generate an OpenAPI definition for you based on your integration project, if you don't provide one, saving you time and effort.

To incorporate OpenAPI support, store the OpenAPI definition file within the repository hosting your Integration Studio project. When creating the project, simply point to the file's location in the repository. If needed, you can change the location of the OpenAPI definition file later via the deploy page.

![Open API file](../assets/img/develop-components/micro-integrator/openapi_file.png)

By leveraging OpenAPI Support, you can optimize the way you test and manage your integrations, resulting in a more efficient development process and a smoother user experience.

## Work with third-party libraries

The use of third-party libraries in your Micro Integrator project can offer several advantages, such as enhanced functionality, improved integration capabilities, optimized performance, and reduced development time.

Here are some of the benefits of adding third-party JARs to the Micro Integrator:

 - Increased functionality: Third-party libraries can extend the core Micro Integrator distribution, allowing for greater flexibility and customization of integration solutions.
 - Enhanced integration capabilities: Third-party libraries enable the Micro Integrator to interact with existing systems such as databases or other APIs, improving overall integration capabilities.
 - Optimized performance: By offering optimized implementations of common functions, third-party libraries can improve the performance of the Micro Integrator.
 - Efficient development: Developers can avoid re-implementing commonly used functions, reducing development time and increasing efficiency.

To incorporate third-party libraries into your Micro Integrator project, create a new directory called `libs` at the
root of your project. If your project root and GitHub repository root are not the same, place the `libs` directory in
the project root. After adding the required JAR files to the `libs` directory, the Micro Integrator runtime will
automatically include them when deploying the component. This process ensures that any dependencies needed by your
integration flow are available at runtime.

In addition to `jar` libraries, you may also need to incorporate OSGi bundle JARs into your project. To do this,
create another directory called `dropins` at the root of your project. Similarly, if the project root and GitHub
repository root differ, place the `dropins` directory in the project root. Within the `dropins` directory, add the OSGi
bundle JAR files. The OSGI runtime will pick up these bundles during deployment, enabling you to utilize their
functionality within your Micro Integrator project.

![Libs directory](../assets/img/develop-components/micro-integrator/libs_dir.png)

## Importing custom certificates to MI

The feature enables Choreo MI users to import certificates into the MI `client-truststore.jks` file. This functionality
proves valuable when users need to establish connections with servers or services utilizing SSL/TLS encryption and
possessing self-signed certificates or certificates issued by private certificate authorities (CAs) that are not
automatically trusted. Importing the certificate to the MI `client-truststore.jks` file enables MI clients to establish secure connections with
the server or service seamlessly, eliminating SSL/TLS errors or warnings.

Before importing the certificate, it is necessary to obtain the certificate file, which can be in PEM or DER format. You
can get the certificate from the server or service provider or export it from a web browser. Certificates should be
added to the `/wso2mi/certs/` folder. Users need to verify that the mount path for the certificate file aligns with this
specific path.

1. In the Choreo console, select the component you wish to add a certificate to.
2. From the left navigation click **Deploy**.
3. Click on the **Configs and Secrets** tab.
4. Click **Create**.
5. Select **ConfigMap** as the **Config Type** and **File Mount** as the **Mount Type**.
6. Click **Next**.
7. Specify the following values as mount configurations:

    | **Field**       | **Value**                                              |                                    
    |-----------------|--------------------------------------------------------|
    | **Config Name** | An appropriate name for the certificate.             |
    | **Mount path**  | `/wso2mi/certs/<filename>`. For example, `/wso2mi/certs/certificate.crt` |

8. Click **Upload File** and attach the certificate.
9. Click **Create**.

## Working with sensitive data using MI Secure Vault

MI Secure Vault is a feature that allows users to securely store sensitive data, such as passwords and tokens, and
provide access to that data to MI Integrations. This feature provides an added layer of security to your integrations by
reducing the risk of accidental exposure of sensitive data.

To use MI Secure Vault to work with sensitive data, follow these steps:

1. Select the component from the Choreo Console.
2. From the left navigation, click Deploy.
3. Click on the **Configure and Deploy**.
4. Click on the **Add Environment Configurations**
5. Specify the following values as configurations:

    | **Field**       | **Value**                                 |                                    
    |-------------------------------------------|--------------------------------------------------------|
    | **Name** | An appropriate name for the secret/alias. |
    | **Value**       | Value for the secret                      |

6. Select **Mark as a Secret**.
7. Click **Add**.
8. Click **Deploy**.
9. Once the secret has been created, you can access it in your integration code using the following syntax:

```xml
<property name="secret_value_1" expression="wso2:vault-lookup('user_pass')" scope="default" type="STRING"/>
```
This code retrieves the secret named "user_pass" from the MI Secure Vault and stores it in the property named "
secret_value_1". You can then use this property in your integration code to access the secret value.

For more information on these features, see the [Accessing secrets](https://mi.docs.wso2.com/en/latest/install-and-setup/setup/security/encrypting-plain-text/#step-3-accessing-secrets) section of the MI Secure Vault documentation. By using MI
Secure Vault to store and access sensitive data in your integrations, you can ensure that your integrations
remain secure and protect sensitive data from unauthorized access.


## Scan third-party libraries to identify security vulnerabilities

Scanning third-party libraries for security vulnerabilities is essential for identifying potential weaknesses in an application that could be exploited by attackers. Taking a proactive approach to security helps organizations detect and mitigate risks before they can be exploited, preventing data breaches, system compromises, and other security incidents.

Choreo incorporates a security vulnerability scanning process during deployment. It uses Trivy to scan and detect critical vulnerabilities in third-party libraries added to the integration component. If the scan uncovers any critical vulnerabilities, the deployment process is halted. The deployment pane displays the Trivy scan status and any security failures in the Library (Trivy) vulnerable scan step, which can be accessed by clicking on it. Once the vulnerability has been addressed, you can redeploy the component.

## Customize WSO2 Micro Integrator preconfigured settings

Customizing WSO2 Micro Integrator Preconfigured Settings is essential for ensuring that the integration solution works optimally within the specific context of your organization. While WSO2 MI comes with preconfigured settings designed for general use, these settings may not be suitable for every organization's unique requirements. Customizing these settings can help optimize performance and ensure compatibility with your organization's systems and applications.

To customize the preconfigured settings of WSO2 MI instances running on Choreo, define a `deployment.toml` file in the GitHub repository subpath of your Micro Integrator project:

![deployment.toml](../assets/img/develop-components/micro-integrator/config_file.png)

!!! note
    If you change critical configuration parameters such as port offset and hostname, it can break internal communication.
    Therefore, the recommended approach is to update only the necessary configuration parameters.

Given below is a sample `deployment.toml` file that can be used to configure the JMS transport. For more information on WSO2 MI
configuration parameters, see the [MI Configuration Catalog](https://mi.docs.wso2.com/en/latest/reference/config-catalog-mi/).

```
[[transport.jms.sender]]
name = "myQueueSender"
parameter.initial_naming_factory = "org.apache.activemq.jndi.ActiveMQInitialContextFactory"
parameter.provider_url = "$env{JMS_PROVIDER_URL}"
parameter.connection_factory_name = "QueueConnectionFactory"
parameter.connection_factory_type = "queue"
parameter.cache_level = "producer"

[[transport.jms.listener]]
name = "myQueueListener"
parameter.initial_naming_factory = "org.apache.activemq.jndi.ActiveMQInitialContextFactory"
parameter.provider_url = "$env{JMS_PROVIDER_URL}"
parameter.connection_factory_name = "QueueConnectionFactory"
parameter.connection_factory_type = "queue"
parameter.cache_level = "consumer"
```

## Environment variables

Using environment variables is a recommended practice when developing integration artifacts with WSO2 Integration Studio, as it improves configuration management, security, portability, and manageability. By leveraging environment variables, organizations can streamline the management and maintenance of their integrations, ensuring that updates can be implemented quickly and efficiently.

The component's Deploy page provides a user-friendly interface to manage environment variables across different environments. For information on managing environment variables for complex use cases, see [Configurations and secrets](../devops-and-ci-cd/manage-configurations-and-secrets.md).

![Environment variables](../assets/img/develop-components/micro-integrator/env_variables.png)

Environment variables offer several benefits:

 - Configuration management: They simplify the process of managing and updating configuration settings, making it easier to maintain consistency across different environments.
 - Security: Environment variables help protect sensitive information by storing it securely and separating it from the main codebase.
 - Portability: By using environment variables, you can ensure that your integration artifacts can be easily migrated and deployed across various environments with minimal changes.
 - Manageability: Environment variables offer a centralized way to manage configuration settings, making it easier to update and maintain your integrations over time.

For a comprehensive list of parameters that can be configured as environment variables, see [WSO2 Micro Integrator documentation - Injecting Parameters - Supported parameters](https://mi.docs.wso2.com/en/latest/develop/injecting-parameters/#supported-parameters).

## Configure logging

Configuring logging is crucial when developing and maintaining a software system, as it can significantly improve efficiency during the development, testing, and maintenance phases of the software development process. Logging captures events and messages that occur during an application's execution, providing valuable insights for troubleshooting and debugging issues.

With Micro Integrator instances, you can configure and customize logging according to your requirements. Logging configurations can be added to each MI instance's environment, allowing you to fine-tune logging depending on the specific environment or deployment scenario.

To configure logging in MI instances, follow the steps given below: 

!!! tip
     You can use environment variables with specific naming conventions.

1. Start the variable name with `logging_level_` followed by the package or class name.
2. Replace the dot character in the package name with an underscore.
3. Set the variable value to the required logging level for the corresponding package or class.

    For example, to enable wire logs, change the logging level of the `org.apache.synapse.transport.http.wire` package to `debug`. 

To configure logging, set the environment variable as follows:

1. In the left navigation menu, click **Deploy** and then click **Configs & Secrets**. 
2. Click **+ Create**. 
3. Select **ConfigMap** as the **Config Type** and **Environment Variables** as the **Mount Type**. 
4. Click **Next**. 
5. Specify the following values as mount configurations:

    | **Field**       | **Value**                                              |                                    
    |-----------------|--------------------------------------------------------|
    | **Config Name** | An appropriate name for the configuration.             |
    | **Name**        | `logging_level_org_apache_synapse_transport_http_wire` |
    | **Value**       | `debug`                                                |

6. Click **Create**.

## Connectors

WSO2 Micro Integrator (MI) Connectors are prebuilt connectors designed to simplify integration between WSO2 MI and various other systems. They enable seamless connections to databases, message brokers, REST APIs, and more, allowing you to perform actions such as sending messages, executing queries, or retrieving data. These connectors are easy to use, making it straightforward to incorporate them into your WSO2 MI integration flows. Micro Integrator connectors are versatile and can be utilized in various integration scenarios, including data integration, service-oriented architecture (SOA) integration, and event-driven architecture (EDA) integration.

WSO2 Integration Studio is a comprehensive development environment that facilitates the creation of integration flows using WSO2 Micro Integrator Connectors. With Integration Studio, you can design and implement integration flows that connect diverse systems and execute various actions, such as sending messages, executing queries, or retrieving data. You can build integration flows using either prebuilt connectors provided by WSO2 MI or custom connectors developed using the Connector Development Toolkit. Integration Studio offers a graphical user interface that simplifies the process of building and testing integration flows while also providing a set of tools for managing and deploying these flows in a WSO2 MI runtime environment.

For more information, see the following topics in the WSO2 Micro Integrator documentation.

- [Connectors Overview](https://mi.docs.wso2.com/en/latest/reference/connectors/connectors-overview/)
- [Adding Connectors](https://mi.docs.wso2.com/en/latest/develop/creating-artifacts/adding-connectors/)

## Deploying integrations in Choreo 

WSO2 MI buildpack is where you can deploy integrations developed with WSO2 Micro Integrator as an API. In this preset, you have three different ways to define endpoints. Choreo gives priory to the definition of endpoints in the below-mentioned order. 

1. **Using component.yaml file**
This is the most flexible method to define endpoints. You can configure the endpoint details with the `component.yaml` configuration file. Place this file in the `.choreo` directory in the project path of the component. 
If the Micro Integrator project has inbound endpoints, you can expose them via different endpoints using the `component.yaml`file.

    To learn about the `component.yaml` file, see [Overview of the component.yaml file](../develop-components/manage-component-source-configurations.md#overview-of-the-componentyaml-file).

3. **Auto generating endpoints**
If `component.yaml` is not provided and if the source Micro Integrator project has APIs, Choreo scans the project and generates the API endpoints. If the project has few APIs, an endpoint will be generated for each API. The visibility of this auto-generated endpoint is set to `Public` by default. You can change the visibility in the deployment flow.

4. **Provide default endpoints**
If `component.yaml` is not provided and if the source Micro Integrator project doesn't have APIs, Choreo generates a default endpoint which will expose the default micro integrator port (8290) with `Public` visibility and wildcard context.

!!! note
    If you are currently using `component-config.yaml` or `endpoints.yaml` configuration files, see the respective [migration guide](../develop-components/manage-component-source-configurations.md#migration-guide) for instructions on migrating to the recommended `component.yaml` configuration file.

## Explore Choreo examples on GitHub

For a hands-on experience with MI-based integrations in Choreo, we recommend exploring our samples in Choreo Console. You can filter out the samples based on the buildpack `WSO2 MI`. This will point you to the samples in the [Choreo samples GitHub repository](https://github.com/wso2/choreo-samples)

### [Choreo samples - GitHub Repository](https://github.com/wso2/choreo-samples)

- **Fork the Repository**: Start by forking the repository to your account.

- **Explore & run**: Navigate through the different integration scenarios. Each example has a README.md with setup and execution instructions.



# Develop a Manual Task

This guide walks you through the steps to develop, deploy, test, and observe a manual task using Choreo.

In this guide, you will:

- Develop a manual task to fetch the weather forecast for a specified location for the next 24 hours from the [OpenWeatherMap](https://openweathermap.org) API.
- Process the weather data into a specific format.
- Send the formatted data to a specified email address.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

    !!! info "Repository File Structure"
        The sample code for this guide is in the `<sample-repository-dir>/weather-to-email-integration` directory. The following table describes the key files in the repository:

        | **File Path**         | **File Content**                                                     |
        | --------------------- | -------------------------------------------------------------------- |
        | **Ballerina.toml**    | Contains metadata about the project                                  |
        | **Dependencies.toml** | Lists the dependencies required for the project                      |
        | **main.bal**          | Contains the entry point of the project, including the main function |
        | **types.bal**         | Contains custom data types used in the project                       |
        | **utils.bal**         | Contains utility functions and helper functions used in the project  |

3. Go to [OpenWeatherMap](https://openweathermap.org/) and sign up to obtain an API key. For details, see the [OpenWeatherMap documentation](https://openweathermap.org/appid#signup).

## Step 1: Create a manual task component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Manual Task** card.
6. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:

        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

7. Enter the following information:

    | **Field**             | **Description**                                      |
    | ----------------------| -----------------------------------------------------|
    | **Organization**      | Your GitHub account                                  |
    | **Repository**        | `choreo-samples`                                     |
    | **Branch**            | `main`                                               |
    | **Component Directory** | `weather-to-email-integration`                       |

8. Select **Ballerina** as the **Build Pack**.

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Component Directory** specifies the location of the project to build the component.

4. Enter a unique name and description for the component. You can use the following values:

    | **Field**          | **Value**                        |
    | ------------------ | -------------------------------- |
    | **Component Name** | `WeatherToEmail`                 |
    | **Description**    | `My first manual task`           |


8. Click **Create**. Choreo initializes the component with the sample implementation and opens the **Overview** page of the component.

## Step 2: Build the manual task

1. In the left navigation menu, click **Build**.
2. In the **Builds** pane, click **Build**. This opens the **Commits** pane, where you can see all the commits related to the component.
3. Select the latest commit and click **Build**. This triggers the build process and displays the build progress in the **Build Logs** pane.

    !!! info
        The build process may take some time. Once complete, the build status will be listed in the **Builds** pane. Here, you will see the build status as **Success**.

## Step 3: Deploy the manual task

1. In the left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane, specify values for the configurable variables:

    !!! tip
        The configurable variables populated here are defined in the sample Ballerina project used in this guide. To learn how to declare configurable variables in Ballerina, see the [Ballerina documentation on declaring configurable variables](https://ballerina.io/learn/by-example/configurable-variables/).

    | **Field**     | **Value**                                                               |
    | ------------- | ----------------------------------------------------------------------- |
    | **apiKey**    | The API key you obtained in the prerequisites section                   |
    | **latitude**  | Latitude of the location to get the weather forecast                    |
    | **longitude** | Longitude of the location to get the weather forecast                   |
    | **email**     | The email address to receive the formatted weather forecast information |

    !!! note
        If you use **Ballerina** as the buildpack and want to set a configurable variable as a secret, click the lock icon corresponding to the configurable variable. This marks it as a secret and conceals the input value.

        For example, if you set the **apiKey** as a secret, its input value will be concealed. To update the input value later, click **Update Secret Content** and specify a new value.

4. Click **Deploy**.

## Step 4: Execute the manual task

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the task.

    !!! info "Inject Dynamic Values into Your Application as Command-Line Arguments"
        If you want to inject dynamic values into your application as command-line arguments when you run a manual task, follow these steps:
        1. Click the drop-down icon next to **Run Now** and then click **Run with Arguments**.
        2. In the **Runtime Arguments** pane, enter the arguments you want to pass to your application.
        3. Click **Execute**. This triggers the task with the specified arguments.

        The capability to run a manual task with arguments is supported for the following buildpacks:

        === "Dockerfile"
            To explore a Dockerfile-based manual task with arguments, try out the [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/docker-hello-world-manual-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on Docker projects, the **Run with Arguments** capability is not supported if the Dockerfile contains `CMD`. In such scenarios, use `ENTRYPOINT` to define your default commands.

        === "Go"
            To explore a Go-based manual task with arguments, try out the [Hello World Go Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-go-task) sample. For instructions, see the `readme.md` file in the sample repository.

        === "Java"
            To explore a Java-based manual task with arguments, try out the [Hello World Java Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-java-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on Java projects:
                - The **Run with Arguments** capability is not supported if `Procfile` is available in the project.
                - The `Main` class should be defined in the `manifest` file.
                - If Maven files such as `mvn.cmd` exist in the project without the `.mvn` directory, the build will fail. To ensure a successful build, either commit the `.mvn` directory along with any Maven files or exclude Maven files if you choose not to commit the `.mvn` directory.

        === "NodeJS"
            To explore a NodeJS-based manual task with arguments, try out the [Hello World NodeJS Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-nodejs-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on NodeJS projects:
                - The **Run with Arguments** capability is not supported if `Procfile` is available in the project.
                - The project root must contain the `package.json` file with the `main` attribute defined.

        === "WSO2 MI"
            To explore a WSO2 MI-based manual task with arguments, try out the [Weather to Logs Task](https://github.com/wso2/choreo-samples/tree/main/weather-to-logs-mi-manual-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on WSO2 MI projects and deploying a WSO2 MI integration as a manual task in Choreo, use the WSO2 MI automation mode. For details, see [Running the Micro Integrator in Automation Mode](https://apim.docs.wso2.com/en/latest/install-and-setup/install/running-the-mi-in-automation-mode/).

        === "Ballerina"
            To explore a Ballerina manual task with arguments, try out the [Weather to Email Task](https://github.com/wso2/choreo-samples/tree/main/weather-to-email-integration) sample. For instructions, see the README.md file in the sample repository.

            !!! info
                If you want to pass arguments to Ballerina main functions, use the **Run with Arguments** capability. For details on the arguments you can pass, see the [Ballerina documentation](https://ballerina.io/learn/by-example/main-function/). You can also override configurable values in the same manner. For more information, see [Provide values to configurable variables](https://ballerina.io/learn/provide-values-to-configurable-variables/#provide-via-command-line-arguments).

## Step 5: Test the manual task

Once the task is triggered, an email with the subject `[WSO2 Choreo Demo] Next 24H Weather Forecast` is sent from `choreo.demo@gmail.com` to the email address specified as the **email** configurable variable value in [Step 3](#step-3-deploy-the-manual-task).

If the manual task ran successfully, you should receive an email similar to the following:

![Received email](../../assets/img/develop-components/develop-a-scheduled-integration/Received-email.png)

## Step 6: Observe the manual task

The observability view in Choreo displays graphs that depict details such as throughput, latency, diagnostic data, and logs to identify and troubleshoot anomalies in components you deploy.

1. In the left navigation menu, click **Observability**.
2. Observe the following:
    - The throughput and latencies of requests served over a given period.
    - The logs generated over a given period.
    - The flame graph (Diagnostics View) generated over a given period.
    - The low-code diagram.

To learn more about the observability details you can view via Choreo observability, see [Observability Overview](../../monitoring-and-insights/observability-overview.md).

## Step 7: Monitor executions

To track and monitor executions associated with the deployed manual task, go to the left navigation menu and click **Execute**.

!!! tip
    The **Execute** view is applicable to both scheduled and manual tasks.

You can view the following information:

- **Total executions**: The total number of executions within the past 30 days.

    ![Total Execution](../../assets/img/develop-components/develop-a-scheduled-integration/total_executions.png)

- **Execution history**: The currently active executions and those that are already complete. You can view information such as the execution ID, the revision of the execution, and the time it was triggered.

    ![Execution History](../../assets/img/develop-components/develop-a-scheduled-integration/execution_history.png)

- **Detailed execution logs**: Click on an execution to view detailed logs related to it.

    !!! info
        It may take a few minutes for the logs to appear. You may need to manually refresh to view the latest logs.

    ![Execution Logs](../../assets/img/develop-components/develop-a-scheduled-integration/execution_logs.png)


# Develop a Scheduled Task

Choreo is a versatile integration platform that allows you to create various types of integrations depending on your requirements. If you need to automatically run a specific integration at regular intervals, you can use Choreo to develop a scheduled task. This type of integration can automate the synchronization of data between different systems at specified intervals, reducing errors and improving productivity by eliminating the need for manual intervention.

This guide walks you through the steps to develop, deploy, test, and observe a scheduled task using Choreo.

In this guide, you will:

- Develop a scheduled task to fetch the weather forecast for a specified location for the next 24 hours from the [OpenWeatherMap](https://openweathermap.org) API.
- Process the weather data into a specific format.
- Send the formatted data to a specified email address at a specific time every day.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

    !!! info "Repository File Structure"
        The sample code for this guide is in the `<sample-repository-dir>/weather-to-email-scheduled-task` directory. The following table describes the key files in the repository:

        | **File Path**         | **File Content**                                                     |
        | --------------------- | -------------------------------------------------------------------- |
        | **Ballerina.toml**    | Contains metadata about the project                                  |
        | **Dependencies.toml** | Lists the dependencies required for the project                      |
        | **main.bal**          | Contains the entry point of the project, including the main function |
        | **types.bal**         | Contains custom data types used in the project                       |
        | **utils.bal**         | Contains utility functions and helper functions used in the project  |

3. Go to [OpenWeatherMap](https://openweathermap.org/) and sign up to obtain an API key. For details, see the [OpenWeatherMap documentation](https://openweathermap.org/appid#signup).

## Step 1: Create a scheduled task component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Scheduled Task** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following information:

    | **Field**             | **Description**                                |
    | --------------------- | ---------------------------------------------- |
    | **Organization**      | Your GitHub account                            |
    | **Repository**        | `choreo-samples`                               |
    | **Branch**            | `main`                                         |
    | **Component Directory** | `weather-to-email-scheduled-task`              |

6. Select **Ballerina** as the build pack.

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Component Directory** specifies the location of the project to build the component.

7. Enter a unique name and description for the component. You can use the following values:

    | **Field**          | **Value**                        |
    | ------------------ | -------------------------------- |
    | **Component Name** | `WeatherToEmail`                 |
    | **Description**    | `My first scheduled task`        |

8. Click **Create**. Choreo initializes the component with the sample implementation and opens the **Overview** page of the component.

Now you can proceed to build and deploy the scheduled task.

## Step 2: Build the scheduled task

1. In the left navigation menu, click **Build**.
2. In the **Builds** pane, click **Build**. This opens the **Commits** pane, where you can see all the commits related to the component.
3. Select the latest commit and click **Build**. This triggers the build process and displays the build progress in the **Build Logs** pane.

    !!! info
        The build process may take some time. Once complete, the build status will be listed in the **Builds** pane. Here, you will see the build status as **Success**.

## Step 3: Deploy the scheduled task

1. In the left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane, specify values for the configurable variables:

    !!! tip
        The configurable variables populated here are defined in the sample Ballerina project used in this guide. To learn how to declare configurable variables in Ballerina, see the [Ballerina documentation on declaring configurable variables](https://ballerina.io/learn/by-example/configurable-variables/).

    | **Field**     | **Value**                                                               |
    | ------------- | ----------------------------------------------------------------------- |
    | **apiKey**    | The API key you obtained in the prerequisites section                   |
    | **latitude**  | Latitude of the location to get the weather forecast                    |
    | **longitude** | Longitude of the location to get the weather forecast                   |
    | **email**     | The email address to receive the formatted weather forecast information |

    !!! note
        If you use **Ballerina** as the buildpack and want to set a configurable variable as a secret, click the lock icon corresponding to the configurable variable. This marks it as a secret and conceals the input value.

        For example, if you set the **apiKey** as a secret, its input value will be concealed. To update the input value later, click **Update Secret Content** and specify a new value.

4. Click **Next**.
5. Define a schedule to run the task. In this guide, set the schedule to receive the weather information daily at 8:00 AM UTC. Enter the following values:

    | **Field**            | **Value**                                             |
    | -------------------- | ----------------------------------------------------- |
    | **Select Time Zone** | Select a time zone to schedule the task               |
    | **Select Range**     | **Day**                                               |
    | **Every**            | `1`                                                   |
    | **At**               | `08:00`                                               |

    !!! tip
        To test and verify the task immediately, you can schedule the deployment to run in just a few minutes after you create it. However, to avoid unnecessary expenses, reschedule or stop the deployment once you test and verify.

6. Click **Deploy**. This deploys the scheduled task to the development environment and indicates the **Scheduled Status** as **Active** in the **Development** card.

You can test the scheduled task when it runs at the configured time.

## Step 4: Test the scheduled task

When the scheduled task runs at the configured time, an email with the subject `[WSO2 Choreo Demo] Next 24H Weather Forecast` is sent from `choreo.demo@gmail.com` to the email address specified as the **email** configurable variable value in [Step 3](#step-3-deploy-the-scheduled-task).

If the scheduled task ran successfully, you should receive an email similar to the following:

![Received email](../../assets/img/develop-components/develop-a-scheduled-integration/Received-email.png)

## Step 5: Observe the scheduled task

The observability view in Choreo displays graphs that depict details such as throughput, latency, diagnostic data, and logs to identify and troubleshoot anomalies in components you deploy.

1. In the left navigation menu, click **Observability**.
2. Observe the following:
    - The throughput and latencies of requests served over a given period.
    - The logs generated over a given period.
    - The flame graph (Diagnostics View) generated over a given period.
    - The low-code diagram.

To learn more about the observability details you can view via Choreo observability, see [Observability Overview](../../monitoring-and-insights/observability-overview.md).

## Step 6: Monitor executions

To track and monitor executions associated with the deployed scheduled task, go to the left navigation menu and click **Execute**.

!!! tip
    The **Execute** view is applicable to both scheduled and manual tasks.

You can view the following information:

- **Total executions**: The total number of executions within the past 30 days.

    ![Total Execution](../../assets/img/develop-components/develop-a-scheduled-integration/total_executions.png)

- **Execution history**: The currently active executions and those that are already complete. You can view information such as the execution ID, the revision of the execution, and the time it was triggered.

    ![Execution History](../../assets/img/develop-components/develop-a-scheduled-integration/execution_history.png)

- **Detailed execution logs**: Click on an execution to view detailed logs related to it.

    !!! info
        It may take a few minutes for the logs to appear. You may need to manually refresh to view the latest logs.

    ![Execution Logs](../../assets/img/develop-components/develop-a-scheduled-integration/execution_logs.png)


# Develop an Event Handler

An event handler executes predefined actions in response to specific events. Choreo simplifies the process of creating and deploying such integrations.

This guide walks you through the steps to create and deploy an Event Handler using WSO2 MI and Choreo.

In this guide, you will build a simple event handler that monitors RabbitMQ for new messages and displays them once they become available.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Set up RabbitMQ:
    - Use an existing RabbitMQ instance or start a new [RabbitMQ](https://www.rabbitmq.com/download.html) instance on a server that can be accessed via the internet.
    - Obtain the `username`, `hostname`, `password`, and `vhost` from the RabbitMQ instance to use later as environment variables.

3. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

## Step 1: Create an event handler component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Event Handler** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following information:

    | **Field**             | **Description**              |
    |-----------------------|----------------------------- |
    | **Organization**      | Your GitHub account          |
    | **Repository**        | `choreo-samples`             |
    | **Branch**            | `main`                       |
    | **Component Directory** | `mi-rabbitmq-listener`       |

6. Select **WSO2 MI** as the build pack. (since you are creating the REST API from a [WSO2 Integration Studio](https://wso2.com/micro-integrator/) project)

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Component Directory** specifies the location of the project to build the component.

7. Enter a unique name and description for the component. You can use the following values:

    | **Field**          | **Value**              |
    |--------------------|------------------------|
    | **Component Name** | `SalesOrderListener`   |
    | **Description**    | `RabbitMQ integration` |

8. Click **Create**.

## Step 2: Deploy the integration

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**.
3. In the **Configurations** pane, click **+ Add** corresponding to **Environment Variables** and add the following environment variables:

    !!! tip
        Use the values from your RabbitMQ instance as per the [Prerequisites](#prerequisites) section for the environment variables.

    | **Name**     | **Value**                                         |
    | ------------- |--------------------------------------------------|
    | **HOSTNAME**  | Hostname of your RabbitMQ server                 |
    | **VHOST**     | Virtual hostname of your RabbitMQ server         |
    | **USERNAME**  | Username for connecting to RabbitMQ              |
    | **PASSWORD**  | Password associated with the RabbitMQ username   |

4. Click **Deploy**. This deploys the event handler to the development environment and indicates the **Deployment Status** as **Active** in the **Development** card.

## Step 3: Test the integration

1. Send a sales order message to the **SalesOrderQueue** on the RabbitMQ server. You can send a sample sales order message similar to the following:

    ```json
    {
        "order_id": "12345",
        "customer_name": "John Doe",
        "product": "Widget",
        "quantity": 10,
        "total_amount": 100.00
    }
    ```

2. Observe the logs:
    - In the left navigation menu, click **Logs** and then click **Runtime Logs**. You will see the order message in the logs.

Now you have gained hands-on experience in creating, configuring, and deploying an event handler.


# Develop an Integration with Integration Studio

Choreo simplifies the process of building, deploying, and managing integration components, making it easy to expose integrations as APIs. This guide walks you through the steps to expose an integration created in WSO2 Integration Studio as an API in Choreo.

In this guide, you will:
- Create a component to expose a sample integration from the [Choreo samples repository](https://github.com/wso2/choreo-samples) as an API.
- Deploy, test, and observe the integration component.
- Publish the integration component as an API to the Choreo Developer Portal.

!!! note
    - To develop integrations for **Manual Task** and **Schedule Task** components in Choreo, use the **automation mode** in the WSO2 Micro Integrator. See [Running MI in Automation Mode](https://apim.docs.wso2.com/en/4.2.0/install-and-setup/install/running-the-mi-in-automation-mode/).
    - For other component types (Service, webhook, event-handler, etc.), use the **server mode**.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    - Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    - Enter a unique organization name. For example, `Stark Industries`.
    - Read and accept the privacy policy and terms of use.
    - Click **Create**. This creates the organization and opens the **Project Home** page.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

## Step 1: Create the integration component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the **Project Home** page.

2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following repository details:

    | **Field**             | **Description**              |
    |-----------------------|----------------------------- |
    | **Organization**      | Your GitHub account          |
    | **Repository**        | `choreo-samples`            |
    | **Branch**            | **`main`**                   |
    | **Component Directory** | `hello-world-mi`             |

6. Select WSO2 MI as the build pack (since you're creating the REST API from a [WSO2 Integration Studio](https://wso2.com/micro-integrator/) project).

7. Provide a unique name and description for the component:

    | **Field**          | **Value**              |
    |--------------------|------------------------|
    | **Component Name** | `Hello World`          |
    | **Description**    | `Hello World REST API` |

8. Click **Create**. Choreo initializes the component with the sample integration.

## Step 2: Deploy the integration component

1. In the Choreo Console left navigation menu, click **Deploy**.

2. Configure and deploy:
   - In the **Build Area** card, click **Configure & Deploy**.
   - In the **Configurations** pane, click **Next**. This displays the endpoint details ready for deployment.
   - Click **Deploy**. This deploys the integration component to the development environment.

    !!! tip
        - Choreo uses [endpoints](../../choreo-concepts/endpoint.md) to expose **Service** components to the network. Learn more about configuring endpoints in [Configure Endpoints](../configure-endpoints.md).
        - Automatic deployment is enabled by default, so only the first deployment needs to be done manually.

   The **Development** card shows the **Deployment Status** as **Active** when the integration is successfully deployed.

## Step 3: Test the integration

1. In the Choreo Console left navigation menu, click **Test** and then click **Console**.
2. In the OpenAPI Console, select **Development** from the environment drop-down list.
3. Expand the **GET /integration** operation.
4. Click **Try it out**, then click **Execute**. This sends a request to your deployed integration.
5. Check the response:
    - In the **Response body** section, observe the response. If the integration works as expected, you should see:
     
     ```json
     {"Hello" : "Integration"}
     ```

## Step 4: Observe the integration

1. Click **Observability** in the left navigation menu to monitor the performance of the integration component.

2. View metrics:
   - Observe throughput and latencies of requests over time.
   - View logs generated during a specific period.
   - Analyze the flame graph (Diagnostics View) for performance insights.

   For more details, see [Observability Overview](../../monitoring-and-insights/observability-overview.md).

## Step 5: Publish the integration component

1. In the Choreo Console left navigation menu, click **Manage** and then click **Lifecycle**.
2. The **Lifecycle Management** pane shows the current lifecycle stage as **Created**.
3. Click **Publish**. This changes the lifecycle stage to **Published** and exposes the integration as an API in the Choreo Developer Portal.
   - To view the published API, click **Go to Devportal**. In the Developer Portal, you can manage subscriptions and generate access tokens for testing.

Now you have successfully exposed an integration designed in WSO2 Integration Studio as a REST API in Choreo!


# Develop an API Proxy from a GitHub Repository Source

An API proxy acts as an intermediary between an existing API and Choreo, intercepting all requests made to the API. It also functions as a managed API, allowing you to apply essential API management features such as security policies and rate limiting.

In this guide, you will:

- Create an API proxy component to expose an existing API.
- Deploy the API proxy.
- Test the API proxy to verify its functionality.
- Manage the API.
- Consume the API.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample proxy source](https://github.com/wso2/choreo-samples/tree/main/department-api-proxy-from-github).  

## Step 1: Create an API proxy

You can create an API proxy either by selecting the source from a GitHub repository, uploading an OpenAPI specification file, or providing an OpenAPI specification URL. This guide demonstrates how to create an API proxy using a GitHub repository as the source.

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **API Proxy** card. This opens the **Create an API Proxy** pane.

4. Click on **Authorize With GitHub** card under **Connect a Git Repository** section to connect your GitHub account.
    - If you haven’t connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
         - Read and write access to code and pull requests.
         - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.    

5. Enter the following repository details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **Repository**         | choreo-samples     |
    | **Branch**             | **`main`**         |
    | **API Directory**      | /department-api-proxy-from-github |

    !!! note
        To select the relevant directory, click on the **Edit** action next to the **API Directory** input field. Then, enter `department-api-proxy-from-github` as the directory name to quickly search and locate the correct directory.

6. Specify the following values as Proxy Metadata:

    !!! info
        The **Context** field must be unique and cannot be changed after creation.**Version** and **Target** are mandatory fields. **Target** can be changed at any time after the creation.

    | **Field**       | **Value**                                  |
    |-----------------|--------------------------------------------|
    | **Context**     | `department-service`                                   |
    | **Version**     | `v1.0`                                      |
    | **Target**      | `https://samples.choreoapps.dev/company/hr`|

7. Specify the following values as Component Details:

    !!! info
        The **Component Name** field must be unique and cannot be changed after creation. This value is automatically generated, but you can edit it if necessary.
        **Component Display Name** is a required field.

    | **Field**       | **Value**                                  |
    |-----------------|--------------------------------------------|
    | **Component Display Name**| `Department Service`                    |
    | **Component Name**        | `department-service`                    |
    | **Description**           | `This is a sample proxy for department service`     |    

8. Click **Create**. This creates the API proxy component and takes you to the **Build** page.

!!! note
    When you create an API proxy from a GitHub repository source, the GitHub source serves as the single source of truth. Therefore, any modifications, such as adding or deleting resources, must be made through the GitHub repository.

## Step 2: Build

!!! info
    The initial build starts automatically when you create the API proxy, and you will be redirected to the **Build** page. In this case, you can skip the steps below. If you need to manually trigger a build later, follow these steps.

1. On the project home page, click on the `Department Service` component you created. This takes you to the component overview page.
2. In the left navigation menu, click **Build**.
3. On the **Build** page, click **Build Latest**.

!!! note
    The build process may take some time. You can track progress in the **Build Details** pane. Once complete, the build status changes to **Success**.

## Step 3: Deploy the API proxy

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**. This opens the **Configure & Deploy** pane.
3. Select **External** as the **API Access Mode** and click **Deploy**. The **Development** card indicates the **Deployment Status** as **Active** when the API proxy is successfully deployed.

Now you are ready to test the API proxy.

## Step 4: Test the API proxy

Choreo allows you to test your API proxy using either the [integrated OpenAPI Console](../../testing/test-rest-endpoints-via-the-openapi-console.md) or [cURL](../../testing/test-apis-with-curl.md). In this guide, you will use the OpenAPI Console.

!!! tip
    Choreo enables OAuth 2.0 to secure APIs by default. Therefore, you need an access token to invoke an API.

    - Choreo automatically generates a key to test the API via the OpenAPI Console. To view the key, click the show key icon in the **Security Header** field.
    - To disable security for the entire API or a specific resource:
        1. In the left navigation menu, click **Deploy**.
        2. Go to the **Build Area** card and click **Security Settings**.
        3. In the **Security Settings** pane:
            - To disable security for the entire API, clear the **OAuth2** checkbox.
            - To disable security for a specific resource, expand the relevant resource and turn off the **Security** toggle.
        4. Click **Apply**.

1. In the left navigation menu, click **Test** and then click **OpenAPI Console**.
2. Select **Development** from the environment drop-down list.
3. Expand the `GET /department/{departmentId}` resource and click **Try it Out**.
4. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

    ![API proxy response](../../assets/img/develop-components/develop-a-rest-api-proxy/rest-api-proxy-response.png){.cInlineImage-full}

    This indicates that your API proxy is working as expected.

## Step 5: Manage the API proxy

Now that you have a tested API proxy, you can publish it and make it available for application developers to consume. In this guide, you will apply rate limiting to the API and publish it.

### Step 5.1: Apply rate limiting to the API proxy

1. In the left navigation menu, click **Deploy**.
2. Go to the required environment card and click the settings icon corresponding to **API Configuration**.
3. In the **CORS, Rate Limiting and Resiliency** pane, click **Rate Limiting** to expand the section.
4. Select **API Level** as the **Rate Limiting Level**.
5. Specify appropriate values for the **Request Limit** and **Time Unit** fields. You can proceed with the default values.
6. Click **Apply**. This applies the rate limiting level to the API proxy and redeploys it.

### Step 5.2: Publish the API proxy

1. In the left navigation menu, click **Lifecycle** under **Manage**. This takes you to the **Lifecycle** page.
2. Click **Publish**.
3. In the **Publish API** dialog, click **Confirm** to proceed with publishing the API. If you want to change the display name, make the necessary changes and then click **Confirm**. This changes the API lifecycle state to **Published**.

## Step 6: Invoke the API

To generate credentials for the published API and invoke it via the Choreo Developer Portal, follow these steps:

1. In the **Lifecycle** page, click **Go to Devportal**. This takes you to the `Department Service` in the Choreo Developer Portal.

2. **Invoke the API**:
    1. In the Developer Portal left navigation menu, click **Try Out**.
    2. In the **Endpoint** list, select **Development** as the environment to try out the API.
    3. Click **Get Test Key** to generate an access token.
    4. Expand the `GET /department/{departmentId}` resource and click **Try it out**.
    5. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

        ![Try out response](../../assets/img/develop-components/develop-a-rest-api-proxy/try-out-response.png){.cInlineImage-full}

Now, you have gained hands-on experience creating, deploying, testing, and publishing an API proxy using Choreo.


# Develop an API Proxy from Scratch

An API proxy acts as an intermediary between an existing API and Choreo, intercepting all requests made to the API. It also functions as a managed API, allowing you to apply essential API management features such as security policies and rate limiting.

In this guide, you will:

- Create an API proxy component to expose an existing API.
- Deploy the API proxy.
- Test the API proxy to verify its functionality.
- Manage the API.
- Consume the API.

## Prerequisites

- If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

## Step 1: Create an API proxy

To create an API proxy, you can either upload an OpenAPI specification or provide an OpenAPI specification URL. In this guide, you will specify a URL to an OpenAPI definition of a sample API.

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **API Proxy** card. This opens the **Create an API Proxy** pane.
4. Select **Creare from Scratch** option. 
5. Specify the following values as Proxy Metadata:

    | **Field**       | **Value**                                  |
    |-----------------|--------------------------------------------|
    | **Context**     | `department-service`                                   |
    | **Version**     | `v1.0`                                      |
    | **Target**      | `https://samples.choreoapps.dev/company/hr` |

6. Enter following details for the Component Details:

    !!! info
        The **Component Name** field must be unique and cannot be changed after creation.

    | **Field**                 | **Value**          |
    |---------------------------|--------------------|
    | **Component Display Name**| `Department Service`          |
    | **Component Name**        | `department-service`          |
    | **Description**           | `Sample proxy for department service`     |

7. Click **Create**. This creates the API proxy component and takes you to the **Deploy** page.

## Step 2: Define resources for the API proxy

To add a new resource that retrieves a department by the department ID, follow these steps:

1. In the left navigation menu, click **Develop** and then click **Resources**.
2. Select **GET** as the **HTTP Verb** and enter `/department/{departmentId}` as the **URI Pattern**.
3. Click **+** to add the resource.
4. Expand the added resource and specify the following values:

    | **Field**        | **Value**                            |
    |------------------|--------------------------------------|
    | **Operation ID** | `findDepartment`                     |
    | **Description**  | `Find a department by department ID` |

5. Remove the five default resources that start with `/*` by clicking the delete icon corresponding to each resource.
6. Click **Save**.

## Step 3: Deploy the API proxy

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**. This opens the **Configure & Deploy** pane.
3. Select **External** as the API access mode and click **Deploy**. The **Development** card indicates the **Deployment Status** as **Active** when the API proxy is successfully deployed.

Now you are ready to test the API proxy.

## Step 4: Test the API proxy

Choreo allows you to test your API proxy using either the [integrated OpenAPI Console](../../testing/test-rest-endpoints-via-the-openapi-console.md) or [cURL](../testing/test-apis-with-curl.md). In this guide, you will use the OpenAPI Console.

!!! tip
    Choreo enables OAuth 2.0 to secure APIs by default. Therefore, you need an access token to invoke an API.

    - Choreo automatically generates a key to test the API via the OpenAPI Console. To view the key, click the show key icon in the **Security Header** field.
    - To disable security for the entire API or a specific resource:
        1. In the left navigation menu, click **Deploy**.
        2. Go to the **Build Area** card and click **Security Settings**.
        3. In the **Security Settings** pane:
            - To disable security for the entire API, clear the **OAuth2** checkbox.
            - To disable security for a specific resource, expand the relevant resource and turn off the **Security** toggle.
        4. Click **Apply**.

1. In the left navigation menu, click **Test** and then click **OpenAPI Console**.
2. Select **Development** from the environment drop-down list.
3. Expand the `GET /department/{departmentId}` resource and click **Try it Out**.
4. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

    ![API proxy response](../../assets/img/develop-components/develop-a-rest-api-proxy/rest-api-proxy-response.png){.cInlineImage-full}

    This indicates that your API proxy is working as expected.

## Step 5: Manage the API proxy

Now that you have a tested API proxy, you can publish it and make it available for application developers to consume. In this guide, you will apply rate limiting to the API and publish it.

### Step 5.1: Apply rate limiting to the API proxy

1. In the left navigation menu, click **Deploy**.
2. Go to the required environment card and click the settings icon corresponding to **CORS, Rate Limiting and Resiliency**.
3. In the **CORS, Rate Limiting and Resiliency** pane, click **Rate Limiting** to expand the section.
4. Select **API Level** as the **Rate Limiting Level**.
5. Specify appropriate values for the **Request Limit** and **Time Unit** fields. You can proceed with the default values.
6. Click **Apply**. This applies the rate limiting level to the API proxy and redeploys it.

### Step 5.2: Publish the API proxy

1. In the left navigation menu, click **Lifecycle** under **Manage**. This takes you to the **Lifecycle** page.
2. Click **Publish**.
3. In the **Publish API** dialog, click **Confirm** to proceed with publishing the API. If you want to change the display name, make the necessary changes and then click **Confirm**. This changes the API lifecycle state to **Published**.

## Step 6: Invoke the API

To generate credentials for the published API and invoke it via the Choreo Developer Portal, follow these steps:

1. In the **Lifecycle** page, click **Go to Devportal**. This takes you to the `Department Service` in the Choreo Developer Portal.

2. **Invoke the API**:
    1. In the Developer Portal left navigation menu, click **Try Out**.
    2. In the **Endpoint** list, select **Development** as the environment to try out the API.
    3. Click **Get Test Key** to generate an access token.
    4. Expand the `GET /department/{departmentId}` resource and click **Try it out**.
    5. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

        ![Try out response](../../assets/img/develop-components/develop-a-rest-api-proxy/try-out-response.png){.cInlineImage-full}

Now, you have gained hands-on experience creating, deploying, testing, and publishing an API proxy using Choreo.

# Develop a Ballerina Service

Choreo allows you to develop and deploy applications using your preferred programming language. This guide demonstrates how to deploy a service component that exposes a REST API using the [Ballerina language](https://ballerina.io/). No prior knowledge of Ballerina is required to follow this guide.

A REST API is a web service that adheres to Representational State Transfer (REST) principles, using HTTP methods to access and manage resources. This guide walks you through building a Ballerina service component, deploying it on Choreo, and testing it with an HTTP client application.

In this guide, you will:

 - Build a simple greeting service using a sample implementation. The service has a single resource named `greet` that accepts a query parameter as input.
 - Deploy the service in Choreo.
 - Test the service.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    - Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    - Enter a unique organization name. For example, `Stark Industries`.
    - Read and accept the privacy policy and terms of use.
    - Click **Create**. This creates the organization and opens the **Project Home** page.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample greetings service](https://github.com/wso2/choreo-samples/tree/main/greeting-service) implementation in Ballerina.

### Learn the repository file structure

It’s important to understand the purpose of key files in the sample service. The table below provides an overview of each file in the greeter service:

!!! note
    The file paths are relative to `<sample-repository-dir>/greeting-service`.

| **Filepath**              | **Description**                                                |
|---------------------------|---------------------------------------------------------------|
| `service.bal`             | The greetings service code written in Ballerina.               |
| `tests/service_test.bal`  | Test files related to the `service.bal` file.                  |
| `Ballerina.toml`          | The Ballerina configuration file.                              |

Let’s get started!

## Step 1: Create a service component

To create a Ballerina service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the **Project Home** page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect your GitHub account. If you haven’t connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Provide the following repository details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **Repository**         | choreo-samples     |
    | **Branch**             | **`main`**         |
    |**Component Directory** | `/greeting-service` |

6. Select **Ballerina** as the buildpack.

7. Provide a display name, a unique name, and a description for the service component:

    !!! info
        The **Component Name** field specifies a unique identifier for the component. This name cannot be changed after creation.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Ballerina Greetings`   |
    | **Component Name**        | `ballerina-greetings`   |
    | **Description**           | Send greetings          |

8. Click **Create**. This creates the component and takes you to the **Overview** page.

You have successfully created a service that exposes a REST API written in Ballerina. Next, let’s build and deploy the service.

## Step 2: Build and deploy

Now that you’ve connected the source repository and configured the endpoint details, it’s time to build and deploy the service.

!!! note
    If you’re rebuilding the Ballerina service component after changing the Ballerina version, ensure that the version in the `Ballerina.toml` file matches the version in the `Dependencies.toml` file.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service may take a while. Track the progress via the logs in the **Build Details** pane. Once complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps:

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane, click **Next** to skip the configuration.
4. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service may take a while. Once deployed, the **Development** environment card shows the **Deployment Status** as **Active**.

Once deployed, you can test, manage, and observe the service like any other component in Choreo.

For detailed instructions, see the following sections:
- [Step 3: Test](../../testing/test-rest-endpoints-via-the-openapi-console.md)
- [Step 4: Manage](../../api-management/lifecycle-management.md)

## Manage the deployment

To view Kubernetes-level insights for detailed diagnosis of this Ballerina REST API, see Choreo’s [DevOps capabilities](../../devops-and-ci-cd/view-runtime-details.md).


# Develop a Service with Docker

Choreo allows you to create and deploy applications in any language. This guide demonstrates how to develop and deploy a containerized service component using a Dockerfile.

In this guide, you will:

 - Create a containerized service component using a sample service implementation. The sample service has a single resource named `greet` that accepts a query parameter as input.
 - Deploy the service in Choreo using a Dockerfile. The service will run on port 9090.
 - Test the service.

If you want to create a service component that exposes a Ballerina service, see [Develop a Ballerina Service](develop-a-ballerina-service.md).

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    - Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    - Enter a unique organization name. For example, `Stark Industries`.
    - Read and accept the privacy policy and terms of use.
    - Click **Create**. This creates the organization and opens the **Project Home** page.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample greetings service](https://github.com/wso2/choreo-samples/tree/main/greeting-service-go) implementation with the Dockerfile.

### Learn the repository file structure

It’s important to understand the purpose of key files in the sample service. The table below provides an overview of each file in the greeter service:

!!! note
    The file paths are relative to `<sample-repository-dir>/greeting-service-go`.

| **Filepath**               | **Description**                                                              |
|----------------------------|------------------------------------------------------------------------------|
| `main.go`                  | The Go-based greeter service code.                                           |
| `Dockerfile`               | The Dockerfile to build the container image of the application.              |
| `.choreo/component.yaml`   | Choreo-specific configuration that provides information about how Choreo exposes the service. |
| `openapi.yaml`             | The OpenAPI contract of the greeter service. This is required to publish the service as a managed API. This file is referenced by the `.choreo/component.yaml` file. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints. The greeter service runs on port 9090. To securely expose the service through Choreo, you must provide the port and other required information in the `component.yaml` file. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

In the greeter sample, the `component.yaml` file is located in the `greeting-service-go/.choreo/` directory.

## Step 1: Create a service component from a Dockerfile

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/cloud-native-app-developer) and sign in. This opens the **Project Home** page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect your GitHub account. If you haven’t connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
         - Read and write access to code and pull requests.
         - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following repository details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **Repository**         | choreo-samples     |
    | **Branch**             | `main`         |
    | **Component Directory** | `/greeting-service-go`         |

6. Select **Docker** as the buildpack.
7. Enter the following details:

    | **Field**                | **Value**                        |
    |--------------------------|----------------------------------|
    | **Dockerfile**           | `/greeting-service-go/Dockerfile`|

    !!! info
        1. To successfully build your container with Choreo, explicitly define a user ID (UID) under the `USER` instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-sample-apps/blob/main/go/greeter/Dockerfile).
           - A valid User ID is a numeric value between 10000-20000 (e.g., `10001` or `10500`).
           - Usernames are invalid and should not be used (e.g., `my-custom-user-12221` or `my-custom-user`).

        2. The Dockerfile used in this guide is a multi-stage Dockerfile, which keeps the final image size small and allows building the application with specific versions of tools and libraries.

8. Provide a display name, a unique name, and a description for the service component:

    !!! info
        The **Component Name** field specifies a unique identifier for the component. This name cannot be changed after creation.

    | **Field**                 | **Value**          |
    |---------------------------|--------------------|
    | **Component Display Name**| `Greetings`        |
    | **Component Name**        | `greetings`        |
    | **Description**           | Send greetings     |

9. Click **Create**. This creates the component and takes you to the **Overview** page.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you’ve connected the source repository and configured the endpoint details, it’s time to build the service and create an image. Then, you can deploy the image and test the greeter service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service may take a while. Track the progress via the logs in the **Build Details** pane. Once complete, the build status changes to **Success**.

    You can access the following scans under **Build**:
    - **Dockerfile Scan**: Choreo checks if a non-root user ID is assigned to the Docker container for security. If no non-root user is specified, the build will fail.
    - **Container (Trivy) Vulnerability Scan**: This detects vulnerabilities in the final Docker image. If critical vulnerabilities are found, the build will fail.

    !!! info
        If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps:

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service may take a while. Once deployed, the **Development** environment card shows the **Deployment Status** as **Active**.

Once deployed, you can [test](../../testing/test-rest-endpoints-via-the-openapi-console.md), [manage](../../api-management/lifecycle-management.md), and [observe](../../monitoring-and-insights/observability-overview.md) the service like any other component in Choreo.

To view Kubernetes-level insights for detailed diagnosis of this Dockerfile-based REST API, see [Choreo's DevOps capabilities](../../devops-and-ci-cd/view-runtime-details.md).


# Develop a Service

Choreo allows you to create and deploy applications in your preferred programming language. 

In this guide, you will:

- Build a simple greeting service using a sample service implementation. The sample implementation will have a single resource named `greet` that accepts a single query parameter as input.
- Deploy the service in Choreo using a `Go` buildpack. The service will run on port 9090.
- Test the service.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample greetings service](https://github.com/wso2/choreo-samples/tree/main/greeting-service-go) implementation in `Go`.

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the greeter service:

!!! note 
    The specified file paths are relative to `<sample-repository-dir>/greeting-service-go`.

| **Filepath**             | **Description**                                                               |
|--------------------------|-------------------------------------------------------------------------------|
| `main.go`                | The Go-based greeter service code.                                            |
| `.choreo/component.yaml` | Choreo-specific configuration that provides information about how Choreo exposes the service. |
| `openapi.yaml`           | The OpenAPI contract of the greeter service. This is required to publish the service as a managed API. This `openapi.yaml` file is referenced by the `.choreo/component.yaml` file. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints. To run the greeter service on port 9090 and securely expose it through Choreo, you must provide the port and other required information in the `component.yaml` file. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

In the greeter sample, the `component.yaml` file is located in the `greeting-service-go/.choreo/` directory.

## Step 1: Create a service component

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Public Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Under **Connect a Git Repository**, enter the following details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **GitHub Repository**  | choreo-samples     |
    | **Branch**             | main               |
    | **Component Directory** | `/greeting-service-go` |

6. Select **Go** as the buildpack.
7. Enter the following details:

    | **Field**                | **Value**              |
    |--------------------------|------------------------|
    | **Language Version**     | 1.x                    |

8. Provide component display name, name and description:

    !!! info
        The **Component Name** field must be unique and cannot be changed after creation.

    | **Field**                 | **Value**          |
    |---------------------------|--------------------|
    | **Component Display Name**| Greetings          |
    | **Component Name**        | greetings          |
    | **Description**           | Send greetings     |

9. Click **Create**. This creates the component and lists it under **Component Listing** on the project home page.

You have successfully created the service. The next step is to build and deploy it.

## Step 2: Build and deploy

Now that you have connected the source repository and configured the endpoint details, it's time to build and deploy the greeter service.

### Step 2.1: Build

1. On the project home page, click on the `Greetings` component you created. This takes you to the component overview page.
2. In the left navigation menu, click **Build**.
3. On the **Build** page, click **Build Latest**.

    !!! note
        The build process may take some time. You can track progress in the **Build Details** pane. Once complete, the build status changes to **Success**.

### Step 2.2: Deploy

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take some time. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

Once you have successfully deployed the service, you can [test](../../testing/test-rest-endpoints-via-the-openapi-console.md), [manage](../../api-management/lifecycle-management.md), and [observe](../../monitoring-and-insights/observability-overview.md) it like any other component type in Choreo.


# Expose a Ballerina GraphQL Endpoint via a Service

Choreo offers the flexibility to develop and deploy applications in a language of your preference. This guide shows you how to deploy a service component that exposes a GraphQL API using the Ballerina language in Choreo. No prior knowledge of the Ballerina language is required to follow this guide. 

GraphQL API is a query language and runtime that provides a single endpoint for retrieving flexible and efficient data in a strongly-typed and self-documenting way. By following this guide, you will build a service component in Ballerina and deploy it on Choreo for any GraphQL client application to utilize it.

This guide shows how to build a simple reading list service and deploy it in Choreo using Ballerina. The GraphQL endpoint you create in this guide has two operations: **Query** and **Mutation**. The Query type operations read the data in the data source, and the Mutation operations update the data in the data source. The reading list service has two queries and three mutations as follows:

### Queries

**Retrieve the reading list**

This resource accepts an optional filter, `status`, which filters the reading list by reading status. Accepted values for status are `reading`, `read`, and `to_read`.

**Sample request**:
```
$ curl -X POST -H "Content-Type: application/json" -d '{"query": "query {allBooks (status: \"reading\") { id title author status }}"}' http://localhost:8090
```

**Sample response**
```
$ {
  "data": {
    "allBooks": [
      {
        "id": 1,
        "title": "Sample Book",
        "author": "Test Author",
        "status": "to_read"
      }
    ]
  }
}
```

**Retrieve a book item from the reading list**

This resource accepts a filter, `id`, which will select the book item from the reading list by book id.  The id is an Integer value. 

**Sample request**
```
$ curl -X POST -H "Content-Type: application/json" -d '{"query": "query {book (id: 1) { id title author status }}"}' http://localhost:8090
```

**Sample response**
```
$ {
  "data": {
    "book": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "to_read"
    }
  }
}
```

### Mutations

**Add a book item to the reading list**

This remote function accepts a book record as the input and consists of the title and the author. When you add a new book to the reading list, the method updates the reading status of the newly added book to `to_read`. This method returns the added book item upon successful execution.


**Sample request**

```
$ curl -X POST -H "Content-type: application/json" -d '{ "query": "mutation { addBook(book: {title: \"Sample Book\", author: \"Test Author\"}) { id title author status } }" }' 'http://localhost:8090'
```

**Sample response**

```
$ {
  "data": {
    "addBook": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "to_read"
    }
  }
}
```

**Update the reading status of a book**

This remote function requires `id` and `status` as inputs to update the reading status of the selected book. The `id` refers to the id of the book. It is an integer.  The `status` refers to the reading status that needs to be updated. This method returns the updated book item upon successful execution.

**Sample request**

```
$ curl -X POST -H "Content-type: application/json" -d '{ "query": "mutation { setStatus(id: 1, status: \"reading\") { id title author status } }" }' 'http://localhost:8090'
```

**Sample response**

```
$ {
  "data": {
    "setStatus": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "reading"
    }
  }
}
```

**Delete a book item from the reading list**

This remote function requires the `id` as the input to delete the book item from the reading list. This method returns the removed book item upon successful execution.

**Sample request**

```
$ curl -X POST -H "Content-type: application/json" -d '{ "query": "mutation { deleteBook(id: 1) { id title author status } }" }' 'http://localhost:8090'
```

**Sample response**
```
$ {
  "data": {
    "deleteBook": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "reading"
    }
  }
}
```

Our next step is to set up the resources that you will require to follow the guide, including the sample reading list application and the Choreo GitHub app.

## Prerequisites

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample GraphQL service](https://github.com/wso2/choreo-samples/tree/main/reading-list-graphql) implementation for this guide.

Let's get started!

## Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the reading list service.

!!! note
    The following file paths are relative to the path `<sample-repository-dir>/reading-list-graphql`.

|Filepath                 | Description                                                     |
|-------------------------|-----------------------------------------------------------------|
| `service.bal`           | The reading list service code written in the Ballerina language.|
| `Ballerina.toml`        | The Ballerina configuration file.                               |
| `.choreo/component.yaml`| The configuration file with endpoint details.                   |

## Step 1: Create a service component 

To create a Ballerina service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**| `reading-list-graphql`    |.

6. Select **Ballerina** as the buildpack.

7. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Ballerina Reading List`|
    | **Component Name**        | `ballerina-reading-list`|
    | **Description**           | Manage a reading list   |

8. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service component that exposes a GraphQL API written in the Ballerina language. Next, let's build and deploy the service.

## Step 2: Build and deploy

Now that we have connected the source repository, it's time to build and deploy the reading list service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Configurations** pane that opens, click **Next** to skip the configuration.
4. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.
To build and deploy the service, follow the steps below:

Once you have successfully deployed your service, you can test, manage, and observe it like any other component type in Choreo.

For detailed instructions, see the following sections:

- [Step 3: Test](https://wso2.com/choreo/docs/testing/test-graphql-endpoints-via-the-graphql-console/)
- [Step 4: Manage](https://wso2.com/choreo/docs/manage/api-management/)


# Expose a gRPC Endpoint via a Service

Choreo allows you to create and deploy applications in your preferred programming language. One powerful option is gRPC, a high-performance and language-agnostic remote procedure call (RPC) framework. It utilizes [Protocol Buffers](https://github.com/protocolbuffers/protobuf) to define services and generate client/server code.

In this guide, you will learn to use Choreo to create a service component that exposes a gRPC server implemented in [Go](https://go.dev/), enabling efficient and scalable communication with any gRPC client application. No prior knowledge of the Go language is necessary to follow this guide.

By following this guide, you will:

- Create a simple gRPC server using a Service component.
- Link the containerized gRPC service to the Choreo component using the Dockerfile. 
    The greeter service has a single RPC method named `sayHello`. Following is the proto file the server and the client application are using:

    ```proto
    syntax = "proto3";
    option go_package = "github.com/wso2/choreo-samples/go-grpc/pkg";

    service greeter {
      rpc SayHello (HelloRequest) returns (HelloReply) {}
    }

    message HelloRequest {
      string name = 1;
    }

    message HelloReply {
      string message = 1;
    }
    ```

- Deploy the gRPC server component in Choreo. 
- Create a gRPC client using a Manual Trigger component. 
- Deploy the gRPC client.
- Invoke the gRPC server using a gRPC client and check the response through the Choreo log view.


## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample service](https://github.com/wso2/choreo-samples/tree/main/go-grpc) implementation for this guide.

Let's get started!

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the greeter service.

!!! note 
    The following file paths are relative to the path `<sample-repository-dir>/go-grpc`.

|File Path                |Description                                                                                   |
|-------------------------|----------------------------------------------------------------------------------------------|
| `main.go`               | The greeter service code written in the Go language.                                         |
| `greeter_client/main.go`| The greeter client application written in the Go language.                                   |
| `Dockerfile.server`     | The Dockerfile to build the container image of the server application.                       |
| `Dockerfile.client`     | The Dockerfile to build the container image of the client application.                       |
| `.choreo/component.yaml`| The Choreo-specific configuration that provides information about how Choreo exposes the service.|
| `pkg/greeter.proto`     | The interface definition of the gRPC service. This is used to generate the server and client stubs for the Go application.|

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints.

Let's run the gRPC server service component on port 8080. To securely expose the service through Choreo, you must provide the port and other required information to Choreo. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

Choreo looks for an `component.yaml` file inside the `.choreo` directory to configure the endpoint details of the containerized component. Ensure the `.choreo` directory is at the root of the Docker build context path.

In the gRPC server sample, the `component.yaml` file is at `go-grpc/.choreo/component.yaml`, where the build context path is `go-grpc`.

## Step 1: Create a service component with a gRPC endpoint

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
6. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

7. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory** | `go-grpc`                  |

8. Select **Docker** as the buildpack.
9. Enter the following information:
    
    | **Field**                | **Value**                  |
    |--------------------------|----------------------------|
    | **Dockerfile**           | `go-grpc/Dockerfile.server`|

    !!! info
        1.  To successfully build your container with Choreo, it is essential to explicitly define a User ID (UID) under the USER instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-samples/blob/main/go-grpc/Dockerfile.server).
        To ensure that the defined USER instruction is valid, it must conform to the following conditions:
            - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
            - Usernames are considered invalid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

        2. The Dockerfile utilized in this guide is a multi-stage Dockerfile, which is designed to keep the final image size small and provides the ability to build the application with a specific version of tools and libraries.

4. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go gRPC Server`        |
    | **Component Name**        | `go-grpc-server`        |
    | **Description**           | Send greetings          |
    
10. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you have connected the source repository, and configured the endpoint details, it's time to build the service and create an image. Then you can deploy the image and test the greeter service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

    You can access the following scans under **Build**. 

      - **The Dockerfile scan**: Choreo performs a scan to check if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
      - **Container (Trivy) vulnerability scan**: This detects vulnerabilities in the final docker image. 
      - **Container (Trivy) vulnerability scan**: The details of the vulnerabilities open in a separate pane. If this scan detects critical vulnerabilities, the build will fail.
     
        !!! info
            If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Environment Configurations** pane that opens, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

6. Once you have successfully deployed your service, navigate to the component overview page and copy the gRPC service URL. You need to provide that URL when setting up the client application later in this guide.

You have successfully deployed the gRPC server. Currently, the gRPC service is only accessible by the components deployed within the same project.

## Step 3: Invoke the gRPC service

Let's invoke the gRPC service that you created above, using a gRPC client. 

### Step 3.1: Create a manual task for the gRPC client

To create a manual task component, follow these steps:

1. On the Choreo Console header, click the **Project** list and select the project where you created the gRPC service component. This opens the project home page.
2. Go to the **Component Listing** section and click **+ Create**.
3. Click the **Manual Task** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**       | `go/grpc`                  |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                  |
    |--------------------------|----------------------------|
    | **Dockerfile**           | `go/grpc/Dockerfile.client`|

8. Enter a display name, a unique name, and a description for the component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go gRPC Client`        |
    | **Component Name**        | `go-grpc-client`        |
    | **Description**           | `Receive greetings`     |


9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

### Step 3.2: Build the gRPC client component

To build the component, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 3.3: Setup environment variables and deploy the gRPC client

The client application, in this case, the gRPC client, requires the server URL of the gRPC server service. This is read from the client application as an environment variable. Follow the steps below to configure the environment variable for the client application:

1. On the Choreo Console left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane that opens, click **+ Add**.
4. Specify the following name and value to configure the environment variable for the client application:

    | **Field**       | **Value**               |
    |-----------------|-------------------------|
    | **Name**        | `GREETER_SERVICE`       |
    | **Value**       | Paste the URL value copied after deploying the gRPC service via [step 2.2](#step-22-deploy) above.  Make sure to **drop the `http://` or `grpc://` part and the trailing `/` from the URL when copying**. For example, if the URL is `http://go-grpc-server-3192360657:8080/`, add only `go-grpc-server-3192360657:8080`.|

5.  Click **Add** and then click **Next**.
6.  Click **Deploy**.

### Step 3.4: Execute the gRPC client component

To execute the gRPC client, follow these steps:

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the gRPC client and generates logs.
   You can trigger multiple runs to generate multiple logs.

For details on what you can monitor via the execute page, see [Monitor executions](../develop-integrations/develop-a-manual-task.md#step-7-monitor-executions). 


# Expose a Prism-Based Mock Server Using an OpenAPI Specification

Choreo supports deploying [Prism-based](https://docs.stoplight.io/docs/prism/674b27b261c3c-prism-overview) mock servers using OpenAPI specifications. With the Choreo Prism mock service component, you can serve multiple mock servers, each based on a different OpenAPI specification, as separate endpoints.

By default, these mock servers serve static content generated from the examples in the configured OpenAPI Specification (OAS). 

## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [Prism mock service](https://github.com/wso2/choreo-samples/tree/main/prism-mock-service) artifacts for this guide.

## Step 1: Create a Prism mock service component

To create a Prism mock service component, follow these steps:
    
1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, you can paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    |**Component Directory**  | `prism-mock-service`    |

6. Select **Prism Mock** as the buildpack.
7. Enter a display name, a unique name, and a description for the service component.
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

8. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

## Step 2: Build and deploy the component

Now that you have successfully created the Prism mock service, it's time to build and deploy it.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**. This builds the service from the latest commit.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

Once you have successfully deployed the service, you can [test](../../testing/test-rest-endpoints-via-the-openapi-console.md), [manage](../../api-management/lifecycle-management.md), and [observe](../../monitoring-and-insights/observability-overview.md) it like any other component type in Choreo.

## Serve dynamic content

The Prism mock service can serve dynamic content according to the schema definitions in the OpenAPI specification. To use the Prism mock service with dynamic content, clients must add the `prefer:dynamic=true` header in the request.

To generate meaningful dynamic responses, you can use the `x-faker` attribute in schema definitions of the OpenAPI specification. For more information on dynamically generated responses with the `x-faker` attribute, see the [Prism documentation](https://docs.stoplight.io/docs/prism/9528b5a8272c0-dynamic-response-generation-with-faker).


# Expose a TCP Server via a Service

Choreo offers the flexibility to design and deploy applications in the programming language of your choice. One viable choice for specific network communication needs is TCP (Transmission Control Protocol). TCP provides a reliable, stream-oriented communication mechanism that ensures data integrity and orderliness during transmission. It's the go-to option for scenarios where guaranteed data delivery and error recovery are paramount.

In this guide, you will learn to use Choreo to create a service component that exposes a TCP server implemented in [Go](https://go.dev/), enabling efficient and scalable communication with any TCP client application. No prior knowledge of the Go language is necessary to follow this guide.

By following this guide, you will:

- Setup a TCP server
    - Create a simple TCP server using a service component.
    - Link the containerized TCP service to the Choreo component using a Dockerfile. 
    - Deploy the TCP server component in Choreo. 
- Setup a TCP client
    - Create a TCP client using a manual task component. 
    - Link the containerized TCP client to the Choreo component using a Dockerfile. 
    - Deploy the TCP client component in Choreo.
- Invoke the TCP server using a TCP client and observe the response through the Choreo log view.

## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample service](https://github.com/wso2/choreo-samples/tree/main/docker-tcp-service) implementation for this guide.

Let's get started!

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the sample service.

!!! note 
    The following file paths are relative to the path `<sample-repository-dir>/docker-tcp-service`.

|File Path                 |Description                                                                                   |
|--------------------------|----------------------------------------------------------------------------------------------|
| `server/main.go`         | The greeter service code written in the Go language.                                         |
| `client/main.go`         | The greeter client application written in the Go language.                                   |
| `Dockerfile.server`      | The Dockerfile to build the container image of the server application.                       |
| `Dockerfile.client`      | The Dockerfile to build the container image of the client application.                       |
| `.choreo/component.yaml` | The Choreo-specific configuration provides information about how Choreo exposes the service. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints.

Let's run the TCP server service component on port 5050. To securely expose the service through Choreo, you must provide the port and other required information to Choreo. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

Choreo looks for an `component.yaml` file inside the `.choreo` directory to configure the endpoint details of a containerized component. Place the `.choreo` directory at the root of the Docker build context path.

In our TCP server sample, the `component.yaml` file is at `docker-tcp-service/.choreo/component.yaml`, where the build context path is `docker-tcp-service`.

## Step 1: Create a service component with a TCP endpoint

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory** | `docker-tcp-service`                  |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-tcp-service/Dockerfile.server`|

    !!! info
        1.  To successfully build your container with Choreo, it is essential to explicitly define a User ID (UID) under the USER instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-samples/blob/main/docker-tcp-service/Dockerfile.server).
        To ensure that the defined USER instruction is valid, it must conform to the following conditions:
            - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
            - Usernames are considered invalid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

        2. The Dockerfile utilized in this guide is a multi-stage Dockerfile, which is designed to keep the final image size small and provides the ability to build the application with a specific version of tools and libraries.

8. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go TCP Server`         |
    | **Component Name**        | `go-tcp-server`         |
    | **Description**           | Send greetings          |
    
9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you have connected the source repository, and configured the endpoint details, it's time to build the service and create an image. Then you can deploy the image and test the service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

    You can access the following scans under **Build**. 

      - **The Dockerfile scan**: Choreo performs a scan to check if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
      - **Container (Trivy) vulnerability scan**: This detects vulnerabilities in the final docker image. 
      - **Container (Trivy) vulnerability scan**: The details of the vulnerabilities open in a separate pane. If this scan detects critical vulnerabilities, the build will fail.
     
        !!! info
            If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Environment Configurations** pane that opens, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

6. Once you have successfully deployed your service, navigate to the component overview page and copy the TCP service address. You need to provide that address when setting up the client application later in this guide.

You have successfully deployed the TCP server. Currently, the TCP service is only accessible by the components deployed within the same project.

## Step 3: Invoke the TCP service

Now let's use a TCP client to invoke the TCP service that you created above. To do this, you can create a manual trigger component as the TCP client. This is the recommended approach because, in this example, it's more efficient to have a client that connects to the server, sends a request, and then stops. Here, a continuously executing task isn't required. Furthermore, if you use a manual trigger component, you won't need to expose an endpoint in the client for invocation, unlike with an API.

### Step 3.1: Create a manual trigger for the TCP client

To create a manual task component, follow these steps:

1. On the Choreo Console header, click the **Project** list and select the project where you created the TCP service component. This opens the project home page.
2. Go to the **Component Listing** section and click **+ Create**.
3. Click the **Manual Task** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Docker Context**      |`docker-tcp-service`     |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-tcp-service/Dockerfile.client`|

8. Enter a display name, a unique name, and a description for the component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**              |
    |---------------------------|------------------------|
    | **Component Display Name**| `Go TCP Client`        |
    | **Component Name**        | `go-tcp-client`        |
    | **Description**           | `Receive greetings`    |


9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

### Step 3.2: Build the TCP client component

To build the component, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 3.3: Setup environment variables and deploy the TCP client

The client application, in this case, the TCP client, requires the server URL of the TCP server service. This is read from the client application as an environment variable. Follow the steps below to configure the environment variable for the client application:

1. On the Choreo Console left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane that opens, click **+ Add**.
4. Specify the following name and value to configure the environment variable for the client application:

    | **Field**       | **Value**               |
    |-----------------|-------------------------|
    | **Name**        | `SERVER_ADDRESS`       |
    | **Value**       | Paste the URL value copied after deploying the TCP service via [step 2.2](#step-22-deploy) above.  Make sure to **drop the `tcp://` part and the trailing `/` from the URL when copying**. For example, add only `go-tcp-server-1097922445:8080`.|

5.  Click **Add** and then click **Next**.
6.  Click **Deploy**.

### Step 3.4: Execute the TCP client component

To execute the TCP client, follow these steps:

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the TCP client and generates logs.
   You can trigger multiple runs to generate multiple logs.

For details on what you can monitor via the execute page, see [Monitor executions](../develop-integrations/develop-a-manual-task.md#step-7-monitor-executions).


# Expose a UDP Server via a Service

Choreo offers the flexibility to design and deploy applications in the programming language of your choice. One compelling choice for certain network communication needs is UDP (User Datagram Protocol). UDP is a high-speed, connectionless protocol ideal for scenarios where lightweight, real-time data transmission is essential.

In this guide, you will learn to use Choreo to create a Service component that exposes a UDP server implemented in [Go](https://go.dev/), enabling efficient and scalable communication with any UDP client application. No prior knowledge of the Go language is necessary to follow this guide.

By following this guide, you will:

- Setup a UDP server
    - Create a simple UDP server using a Service component.
    - Link the containerized UDP service to the Choreo component using the Dockerfile. 
    - Deploy the UDP server component in Choreo. 
- Setup a UDP client
    - Create a UDP client using a manual task component. 
    - Link the containerized UDP client to the Choreo component using the Dockerfile. 
    - Deploy the UDP client component in Choreo.
- Invoke the UDP server using a UDP client and check the response through the Choreo log view.

## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample service](https://github.com/wso2/choreo-samples/tree/main/docker-udp-service) implementation for this guide.

Let's get started!

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the sample service.

!!! note 
    The following file paths are relative to the path `<sample-repository-dir>/docker-udp-service`.

|File Path                |Description                                                                                   |
|-------------------------|----------------------------------------------------------------------------------------------|
| `server/main.go`        | The greeter service code written in the Go language.                                         |
| `client/main.go`        | The greeter client application written in the Go language.                                   |
| `Dockerfile.server`     | The Dockerfile to build the container image of the server application.                       |
| `Dockerfile.client`     | The Dockerfile to build the container image of the client application.                       |
| `.choreo/component.yaml`| The Choreo-specific configuration provides information about how Choreo exposes the service. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints.

Let's run the UDP server service component on port 5050. To securely expose the service through Choreo, you must provide the port and other required information to Choreo. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

Choreo looks for an `component.yaml` file inside the `.choreo` directory to configure the endpoint details of a containerized component. Place the `.choreo` directory at the root of the Docker build context path.

In our gRPC server sample, the `component.yaml` file is at `docker-udp-service/.choreo/component.yaml`, where the build context path is `docker-udp-service`.

## Step 1: Create a service component with a UDP endpoint

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
6. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

7. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**   | `docker-udp-service`    |    

8. Select **Docker** as the buildpack.
9. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-udp-service/Dockerfile.server`|

    !!! info
        1.  To successfully build your container with Choreo, it is essential to explicitly define a User ID (UID) under the USER instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-samples/blob/main/docker-udp-service/Dockerfile.server).
        To ensure that the defined USER instruction is valid, it must conform to the following conditions:
            - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
            - Usernames are considered invalid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

        2. The Dockerfile utilized in this guide is a multi-stage Dockerfile, which is designed to keep the final image size small and provides the ability to build the application with a specific version of tools and libraries.

4. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go UDP Server`         |
    | **Component Name**        | `go-udp-server`         |
    | **Description**           | Send greetings          |

10. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you have connected the source repository, and configured the endpoint details, it's time to build the service and create an image. Then you can deploy the image and test the service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

    You can access the following scans under **Build**. 

      - **The Dockerfile scan**: Choreo performs a scan to check if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
      - **Container (Trivy) vulnerability scan**: This detects vulnerabilities in the final docker image. 
      - **Container (Trivy) vulnerability scan**: The details of the vulnerabilities open in a separate pane. If this scan detects critical vulnerabilities, the build will fail.
     
        !!! info
            If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Environment Configurations** pane that opens, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

6. Once you have successfully deployed your service, navigate to the component overview page and copy the UDP service address. You must provide that address when setting up the client application later in this guide.

You have successfully deployed the UDP server. Currently, the UDP service is only accessible by the components deployed within the same project.

## Step 3: Invoke the UDP service

Now let's use a UDP client to invoke the UDP service that you created above. To do this, you can create a manual trigger component as the UDP client. This is the recommended approach because, in this example, it's more efficient to have a client that connects to the server, sends a request, and then stops. Here, a continuously executing task isn't required. Furthermore, if you use a manual trigger component, you won't need to expose an endpoint in the client for invocation, unlike with an API.

### Step 3.1: Create a manual trigger for the UDP client

To create a manual task component, follow these steps:

1. On the Choreo Console header, click the **Project** list and select the project where you created the UDP service component. This opens the project home page.
2. Go to the **Component Listing** section and click **+ Create**.
3. Click the **Manual Task** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory** | `docker-udp-service`    |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-udp-service/Dockerfile.client`|

8. Enter a display name, a unique name, and a description for the component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**              |
    |---------------------------|------------------------|
    | **Component Display Name**| `Go UDP Client`        |
    | **Component Name**        | `go-udp-client`        |
    | **Description**           | `Receive greetings`    |


9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

### Step 3.2: Build the UDP client component

To build the component, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 3.3: Setup environment variables and deploy the UDP client

The client application, in this case, the UDP client, requires the server URL of the UDP server service. This is read from the client application as an environment variable. Follow the steps below to configure the environment variable for the client application:

1. On the Choreo Console left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane that opens, click **+ Add**.
4. Specify the following name and value to configure the environment variable for the client application:

    | **Field**       | **Value**               |
    |-----------------|-------------------------|
    | **Name**        | `SERVER_ADDRESS`       |
    | **Value**       | Paste the URL value copied after deploying the UDP service via [step 2.2](#step-22-deploy) above.  Make sure to **drop the `udp://` part and the trailing `/` from the URL when copying**. For example, add only `go-udp-server-1097922445:8080`.|

5.  Click **Add** and then click **Next**.
6.  Click **Deploy**.

### Step 3.4: Execute the UDP client component

To execute the UDP client, follow these steps:

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the UDP client and generates logs.
   You can trigger multiple runs to generate multiple logs.

For details on what you can monitor via the execute page, see [Monitor executions](../develop-integrations/develop-a-manual-task.md#step-7-monitor-executions).


# Expose a WebSocket Endpoint via a Service

Choreo allows you to create and deploy applications in your preferred programming language, offering a seamless platform for building dynamic and scalable solutions. This guide walks you through the steps to deploy a WebSocket service using the NodeJS buildpack.

WebSockets provide real-time, two-way communication between a client and server over a persistent TCP connection. This makes WebSocket APIs ideal for applications that require real-time updates.

In this guide, you will:

- Build a simple WebSocket service using a sample implementation in NodeJS.
- Deploy the service in Choreo, allowing any WebSocket client application to establish a connection and exchange real-time messages with your service.

## Prerequisites

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample WebSocket service](https://github.com/wso2/choreo-samples/tree/main/websocket-chat-app) implementation for this guide.

Let's get started!

## Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the NodeJS chat Application.

!!! note
    The following file paths are relative to the path `<sample-repository-dir>/websocket-chat-app/websocket-chat-service-nodejs`.

|Filepath                        | Description                                                     |
|--------------------------------|-----------------------------------------------------------------|
| `server.js`                    | The NodeJS chat service.                                        |
| `.choreo/component.yaml`       | The configuration file with endpoint details.                   |

!!! note
    Choreo currently supports defining WebSocket APIs using the AsyncAPI 2.0 specification.

## Step 1: Create a service component 

To create a NodeJS service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**   | `websocket-chat-app/websocket-chat-service-nodejs`  |

6. Select **NodeJS** as the buildpack and **18.x.x** as the Language Version

8. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:

    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `NodeJS Chat Service`   |
    | **Component Name**        | `nodejs-chat-service`   |
    | **Description**           | Manage a chat service   |

9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service component that provides a WebSocket API built with NodeJS. The next step is to proceed with building and deploying the service.

## Step 2: Build and deploy

Now that you have connected the source repository, it's time to build and deploy the chat service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane that opens, click **Next** to skip the configuration.
4. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

Once you have successfully deployed your service, you can [test](../../testing/test-websocket-endpoints-via-the-websocket-console.md), [manage](../../api-management/lifecycle-management.md), and observe it like any other component type in Choreo.

During testing, once the WebSocket connection is established, you can send {"type": "Connect", "username": "user1"} to the WebSocket endpoint to connect to the chat service. You can then send chat messages by using {"type": "Data", "message": "Hello, World!"}.

!!! note
     Some clients, such as certain browsers, may not support adding headers to the WebSocket handshake. In these cases, you can include the access token or test key required for WebSocket API invocation within the `sec-websocket-protocol` header, along with any specified subprotocols.

     For example: `sec-websocket-protocol: choreo-oauth2-token, {access token}, subprotocols`

     If you are using a test key, replace `choreo-oauth2-token` with `choreo-test-key`.


# Service Component Overview

Explore how to create, deploy, manage, and observe service components in Choreo.

## What is a service component?

A service component in Choreo lets you deploy and expose REST, GraphQL, gRPC, UDP, WS or TCP services. It is a fundamental building block for creating cloud-native applications in Choreo. They provide a simple and effective way to expose functionality as a service to other components within Choreo or to the outside world.

Service components encapsulate business logic and provide standardized interfaces, called endpoints, for communicating with other components or systems. You can deploy and scale services independently, which makes them highly flexible and adaptable to changing workloads.

With the help of the service component, developers can quickly create APIs and microservices, making it easier to implement and manage complex software systems. Service components can also be integrated with other Choreo components, that acts as message processors, connectors, and data sources, etc to create powerful end-to-end solutions.

You can expose a service to other components through endpoints. For details on configuring endpoints, see [Configure Endpoints](../configure-endpoints.md).


# Build and Deploy a Single-Page Web Application

A web application is an application program hosted on a server and serves ingress traffic through a browser. In Choreo, you can deploy a web application by creating a Web Application component and connecting it to a Git repository that contains the implementation of the web application. Web applications can fall into one of the following categories:

- **Single page applications (SPAs)**: Examples include React, Angular, Vue, Svelte, etc.
- **Web servers**: These serve static content or provide server-side rendering/static site generation (SSR/SSG).
- **Static content**: Examples include websites and other static resources that do not require a backend, usually comprising static HTML/JS/CSS files.

## Prerequisites

- To deploy a web application component, you must have a GitHub account with a repository containing the web application's implementation. For this guide, fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample web application implementation.

## Create a web application

You can create a web application in Choreo as follows:

### Build and deploy a SPA from source code

1. To create a web application component, connect a repository that includes the web application source code.
2. Select the relevant buildpack: Default buildpacks include **React**, **Angular**, and **Vue.js**. If you are using a different SPA framework, you can try one of these buildpacks because the configurations can be overridden to support most JavaScript-based SPAs.
3. Enter the build command: Based on your package manager (NPM, yarn, or pnpm). The relevant package manager is run based on the dependency lock file in your repository (defaults to NPM if no lock file is present).
4. Specify the build output directory.
5. Specify the NodeJS version: Choreo does not pick the Node.js version from the `package.json` engine property. The required Node version must be explicitly set in the build configuration.

Once you create the Web Application component, Choreo automatically generates a build pipeline for your single-page application and deploys it.

### Bring your Dockerfile

1. To create a web application component, connect a repository that contains the Dockerfile for your containerized web application.
2. Commit a Dockerfile to your connected Git repository to have full control over your build process.

This approach is recommended if you are deploying a web server and not just a single-page application (or a single-page application with a complex build process).

### Host static websites

1. Create a web application component and connect it to the GitHub repository that contains the required static assets.
2. Select the **Static Websites** buildpack: This buildpack does not trigger a build process. It only fetches the files from the path specified in the repository and serves them as-is.

## Build and deploy a SPA from source code

Follow the steps below to create a sample Web Application component and deploy it in Choreo:

1. Sign in to the Choreo Console at [https://console.choreo.dev/login/](https://console.choreo.dev/login/). This opens the **Project Home** page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Web Application** card.
6. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

7. Enter the following information:

    | **Field**                 | **Description**        |
    |---------------------------|------------------------|
    | **GitHub Account**        | Your account           |
    | **GitHub Repository**     | choreo-samples         |
    | **Branch**                | main                   |
    | **Component Directory**     | /react-single-page-app |

8. Select **React** as the **Buildpack**.
9. Enter the following information:

    | **Field**                 | **Description**        |
    |---------------------------|------------------------|
    | **Build Command**         | `npm run build`        |
    | **Build Path**            | `build`                |
    | **Node Version**          | `18`                   |

    !!! tip
        Managed authentication is enabled by default when you create a web application using **React**, **Angular**, or **Vue.js** buildpacks. To learn how to set up authentication for your web application with Choreo's managed authentication, see [Secure Web Applications with Managed Authentication](../../authentication-and-authorization/secure-web-applications-with-managed-authentication.md).

4. Specify a display name, a unique name and description for the component.
10. Click **Create**. Choreo initializes the component with the sample implementation and opens the **Overview** page of the component.

You have successfully created a Web Application component from the source code. Now let's build and deploy the web application.

## Build your web application

1. In the left navigation menu, click **Build**.
2. In the **Builds** pane, click **Build**. This opens the **Commits** pane, where you can see all the commits related to the component.
3. Select the latest commit and click **Build**. This triggers the build process and displays the progress in the **Build Logs** pane.

    You can access the following scans in the **Build Logs** pane:

    - **Dockerfile Scan**: Choreo checks if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
    - **Container (Trivy) Vulnerability Scan**: Detects vulnerabilities in the final Docker image. If critical vulnerabilities are detected, the build will fail.

    !!! info
        If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

    !!! note
        The build process may take some time. Once complete, the build status will be listed in the **Builds** pane. Here, you will see the build status as **Success**.

## Deploy and access your web application

1. In the left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure and Deploy**. This opens the **Configure & Deploy** pane. In this guide, you do not need to add a file mount.
3. Click **Next** to proceed to the **Authentication Settings** pane.
4. Keep the default settings and click **Deploy**.

    !!! note
        The deployment process may take a few minutes. Once complete, the **Deployment Status** will show as **Active** in the **Development** card.

5. To verify that the web application is hosted successfully, click the **Web App URL** in the **Development** card. This takes you to the web application.

## Create a short URL for your web application in production

!!! info
    This feature is only available on the Choreo cloud data plane.

When you promote your component to the Production environment, you can create a personalized short URL for your web application. The URL follows the `https://{your-short-prefix}.choreoapps.dev` structure, where you can select a name of your preference for `{your-short-prefix}`.

1. Click **Promote** in the **Development** card and promote your web application to production.
2. In the **Production** card, click **Create a short URL**.
3. Specify a **Short URL prefix** of your choice and click **Save**.

    !!! note
        Short URL names/prefixes are subject to availability, provided on a first-come-first-serve basis.

## Manage runtime configurations for web applications

For web applications with a backend server, Choreo allows you to mount runtime configurations and secrets as environment variables and/or file mounts for a specific environment. Alternatively, you can also inject them into the client application during server-side rendering or when serving static content.

For SPAs that run completely on the browser, Choreo does not support *baking-in* environment variables or other configurations. Instead, Choreo recommends the following approach (applicable to most SPA frameworks, including React):

!!! note
    - With SPAs, anything you mount as a runtime config will be available to your users in the browser.
    - **Do not include sensitive secrets that are not browser-safe**.

1. Go to your forked [Choreo samples repository](https://github.com/wso2/choreo-samples).
2. Open the `public` directory.
3. Create and commit a new file named `config.js` in the `public` directory of your React application. This file should contain the runtime configuration variables you want to expose to your application, such as API endpoints or feature flags. For example:

    ```javascript
    window.config = {
        apiUrl: 'https://api.example.com',
        featureFlags: {
            enableNewFeature: true,
            enableExperimentalFeature: false,
        },
    };
    ```

4. In your `index.html` file inside the `public` directory, add a script tag to include the `config.js` file inside the `<body>` tag:

    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>My React App</title>
    </head>
    <body>
        <div id="root"></div>
        <script src="%PUBLIC_URL%/config.js"></script>
    </body>
    </html>
    ```

5. In your React component, access the configuration variables by referencing the `window.config` object:

    ```javascript
    import React from 'react';

    function MyComponent() {
        const apiUrl = window.config.apiUrl;
        const enableNewFeature = window.config.featureFlags.enableNewFeature;
        const enableExperimentalFeature = window.config.featureFlags.enableExperimentalFeature;

        // ...
    }
    ```

6. When you deploy your component to Choreo, create a config file mount in the specified path for each environment (where your `index.html` expects the `config.js` file). For more details, see [Manage Configurations and Secrets](https://wso2.com/choreo/docs/devops-and-ci-cd/manage-configurations-and-secrets/#apply-a-file-mount-to-your-container).

## Limitations

The following limitations are specific to the Choreo cloud data plane:

- **Request size limit**: 256KB (including headers, cookies, and payloads).
- **Response body size limit**: 20MB.
- **Open ports**: Only one open port is permitted per web application. While you can have multiple ports open for project-level communication within a data plane, incoming traffic from the internet can only be directed to one port. This differs from Service-type components, which support multiple endpoints.

## Troubleshoot a web application

- **Blank page or 502 error after deployment**:
    If you encounter a blank page or a 502 error after deploying your web application, it typically indicates that the wrong directory is being served. To resolve this issue:
    1. Double-check the build output directory, especially if you are using a Dockerfile-less buildpack.
    2. Ensure that the specified output directory matches the actual output directory generated during the build process. For example, if you have erroneously entered `public/` as the output directory when it should have been `build/`.

By verifying and correcting the output directory alignment, you should be able to address the issue of encountering a blank page or experiencing a 502 error on deploying your web application.


# Develop Web Applications Locally with Choreo’s Managed Authentication

Choreo’s managed authentication capability provides a set of backend for frontend (BFF) endpoints to facilitate authentication and authorization for web applications. These endpoints are readily available for single-page web applications deployed on Choreo.

As a web application developer, you may need to run the application on your local workstation. Choreo’s local development capability ensures that authentication and authorization during local development work the same way as they do when the application is deployed to Choreo, eliminating the need for code changes.

This guide explains how to configure and use Choreo’s local development capability to streamline your workflow.

## How local development works in Choreo

Local development uses a proxy that sits in front of the locally running web application. This proxy intercepts all incoming requests:
- Requests to `/choreo-apis/*` and `/auth/*` are forwarded to Choreo.
- All other requests are forwarded to the locally running web application.

The proxy runs on HTTPS using a self-signed certificate, which is essential for secure, HTTP-only cookie-based managed authentication. Once the proxy is running, you can access the web application using the proxy's URL and start developing locally. The behavior of the web application, in terms of managed authentication, will mirror its behavior when deployed to Choreo.

## Configure local development

### Prerequisites

- Create a single-page application (SPA) with managed authentication enabled. For details, see [Secure Web Applications with Managed Authentication](../../authentication-and-authorization/secure-web-applications-with-managed-authentication.md#step-1-set-up-managed-authentication-for-your-web-application).
- Promote and deploy the application to the environment where you want to enable local development.

    !!! note
        - The locally running web application will use the same managed authentication configuration as the environment where local development is configured.
        - Local development is only allowed in non-critical environments.

### Apply configurations

1. Sign in to the Choreo Console.
2. In the **Component Listing** pane, click on the component you created and deployed.
3. In the left navigation menu, click **Deploy**.
4. Go to the respective environment card and click **Local Development**.
5. In the **Local Development** pane, toggle **Local Development** to enable it.
6. (Optional) To update the port on which the local development proxy server runs, expand **Advanced Configurations** and specify a value for **Proxy Port**.
7. Click **Apply**.

You have now configured local development. The next section explains how to access your web application for local development.

## Access your web application locally

### Prerequisites

- Ensure local development is enabled in the desired environment.
- Ensure your web application is running locally on `http://localhost` on a specific port.

### Access your web application locally

You can use either the Choreo built-in identity provider or an external identity provider to access your web application locally.

=== "Use the Choreo built-in identity provider"

    1. Sign in to the Choreo Console.
    2. In the **Component Listing** pane, click on the component you created and deployed.
    3. In the left navigation menu, click **Deploy**.
    4. Go to the respective environment card and click **Local Development**.
    5. In the **Local Development** pane, copy the command under **Step 1**.
    6. Paste the command in a terminal, replace `[APP_PORT]` with the port on which your application is running locally, and run the command.
    7. To access the application, go to the URL provided under **Step 2** in the **Local Development** pane.

        !!! note
            The local development proxy runs on HTTPS using a self-signed certificate. Your browser may warn that the certificate is not valid. Accept the risk and proceed.

=== "Use an external identity provider"

    1. Sign in to the Choreo Console.
    2. In the **Component Listing** pane, click on the component you created and deployed.
    3. In the left navigation menu, click **Deploy**.
    4. Go to the respective environment card and click **Local Development**.
    5. In the **Local Development** pane, copy the redirect URLs under **Step 1**.
    6. Go to the settings in the OAuth application in your identity provider and specify the copied URLs as allowed redirect URLs.
    7. In the **Local Development** pane, copy the command under **Step 2**.
    8. Paste the command in a terminal, replace `[APP_PORT]` with the port on which your application is running locally, and run the command.
    9. To access the application, go to the URL provided under **Step 3** in the **Local Development** pane.

        !!! note
            The local development proxy runs on HTTPS using a self-signed certificate. Your browser may warn that the certificate is not valid. Accept the risk and proceed.


# Create a Connection

Connections in Choreo provide a simple and uniform approach to seamlessly integrate components with services or resources.

Choreo allows you to create connections to services deployed in Choreo or registered as external services. It also allows you to create connections to any Choreo-managed database.

To create a connection to a service or a database, follow the step-by-step instructions in the respective tab:

=== "Create a connection to a service"

    <h2>Create a connection to a Choreo service</h2>

    Follow these steps to create a connection to a service deployed in Choreo:

    1. In the Choreo Console, go to the top navigation menu and set the visibility level as [project](../../choreo-concepts/connections.md#project-connections) or [component](../../choreo-concepts/connections.md#component-connections) as follows: 

        - **Project Connection**: Select an organization and a project in that organization. 
        - **Component Connection**: Select an organization, a project in that organization, and a component in the selected project. 

    2. In the left navigation menu, click **Dependencies**  and then **Connections**. This page lists all the existing connections.
    3. Click **+Create**. This opens the Marketplace view where you can browse and search for services or databases.
    4. Click the **Services** tab. You can search and apply filters to efficiently find a service.
    5. Click on the service you want to connect to. 
    6. Enter a name and a description for the connection.
    7. Select an **Access Mode** and **Authentication Scheme** for the connection.
    8. Click **Create**.
   
    This creates the connection and displays its details for each environment, along with an inline guide on how to use the connection in your component. 

    !!! note
        During connection creation, secret values for the lowest environment are visible, allowing you to copy them for local use if necessary. Secret values for higher environments remain hidden to ensure security
     
    <h2>Create a connection to an external service</h2>

    Follow these steps to create a connection to an external service:

    1. Follow steps 1–5 from the previous section.
    2. Expand the **Environment to Endpoint** section and verify the service endpoints assigned to the Choreo environments.
    3. Click **Create**.

      For step-by-step instructions on using a connection in your service, see [Use a Connection in Your Service](./use-a-connection-in-your-service.md).

      For step-by-step instructions on using a connection in your web application, see [Use a Connection in Your Web Application](./use-a-connection-in-your-web-application.md).


=== "Create a connection to a database"

    Prerequisites:

     - Create a Choreo-managed database. For details, see [Choreo-Managed Databases and Caches](../../manage-databases-and-caches/choreo-managed-databases-and-caches.md).
     - Add the database to the Marketplace. For details, see [Add Choreo-Managed Databases and Caches to the Marketplace](../../manage-databases-and-caches/add-choreo-managed-databases-and-caches-to-the-marketplace.md).

    Follow these steps to create a connection to a Choreo-managed database:

    1. In the Choreo Console, go to the top navigation menu and set the visibility level as [project](../../choreo-concepts/connections.md#project-connections) or [component](../../choreo-concepts/connections.md#component-connections) as follows: 

        - **Project Connection**: Select an organization and a project in that organization. 
        - **Component Connection**: Select an organization, a project in that organization, and a component in the selected project. 

    2. In the left navigation menu, click **Dependencies**  and then **Connections**. This page lists all the existing connections.
    3. Click **+Create**. This opens the Marketplace view where you can browse and search for services or databases.
    4. Click the **Databases** tab. You can search and apply filters to efficiently find a database.
    5. Click on the database you want to connect to. 
    6. To create the connection, follow these steps:

        1. Enter a name and description.
        2. Under **Environment Configuration**, select credentials for each environment.

            !!! note
                 By default, the selected database is applied to all environments. To use different databases for specific environments, select the appropriate database and provide the corresponding credentials for each environment.

        3. Click **Create**.  
    
    This creates the connection and displays the database connection details for each environment, along with an inline guide on how to use the connection in your component. 

    !!! note
        During connection creation, secret values for the lowest environment are visible, allowing you to copy them for local use if necessary. Secret values for higher environments remain hidden to ensure security
    
    For step-by-step instructions on using a database in your component, see [Use a Database Connection in Your Component](./use-a-database-connection-in-your-component.md).


# Use a Connection in Your Service

Choreo allows you to share and reuse your services, accelerating development and enhancing efficiency in building integrated applications through connections.

For step-by-step on instruction on creating a connection, see [Create a Connection](create-a-connection.md).

To learn more about Choreo Connections, see the documentation on [Connections](../../choreo-concepts/connections.md).

## Consume a service through a connection

You can consume a Choreo-deployed service within another service. Consuming connections from within Choreo services is seamless and straightforward. Follow the steps below to consume a Choreo service:

### Step 1: Add connection configurations

To integrate another service into your application, click the appropriate tab below based on your current configuration file and follow the step-by-step instructions:

=== "Component.yaml file (v1.1)"

    1. Copy and paste the snippet from the in-line developer guide into the `component.yaml` file.

        The following is a sample snippet: 

        ``` yaml

        dependencies:
            connectionReferences:
            - name: <CONNECTION_NAME>
              resourceRef: <RESOURCE_IDENTIFIER>

        ```

          | Field            | Description                                                         |
          |------------------|---------------------------------------------------------------------|
          | name             | The name given to the connection.                                   |
          | resourceRef      | A unique, readable identifier of the service being connected to.    |


    2. If you've previously added a `connectionReferences` section under `dependencies`, append this as another item under `connectionReferences`. Upon deploying the component, Choreo automatically creates a subscription if applicable and the necessary configurations to establish the connection will be injected into the Choreo-defined environment variables.
      
          The following table details the Choreo-defined environment variables:

          | Configuration Key       | Choreo-Defined Environment Variable Name                       |
          |-------------------------|----------------------------------------------------------------|
          | ServiceURL              | CHOREO_<CONNECTION_NAME\>_SERVICEURL                           |
          | ConsumerKey             | CHOREO_<CONNECTION_NAME\>_CONSUMERKEY                          |
          | ConsumerSecret          | CHOREO_<CONNECTION_NAME\>_CONSUMERSECRET                       |
          | TokenURL                | CHOREO_<CONNECTION_NAME\>_TOKENURL                             |
          | ChoreoAPIKey            | CHOREO_<CONNECTION_NAME\>CHOREOAPIKEY                          |


          If you want to use custom environment variable names instead of the Choreo-defined ones, you must define the environment configurations under the `configuration` section in the same file.
          The following is a sample snippet: 

          ``` yaml
          configuration:
            env:
              - name: HR_SERVICE_URL
                valueFrom:
                  connectionRef:
                    name: hr-connection
                    key: ServiceURL
          ```

          The following table provides details on the configuration keys associated with the connection. These keys can be referenced as `env[i].valueFrom.connectionRef.key`.

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | ServiceURL     | string     | Service URL of the Choreo service     | false         | false        |
          | ConsumerKey    | string     | Consumer key of the Choreo service    | false         | false        |
          | ConsumerSecret | string     | Consumer secret of the Choreo service | false         | true         |
          | TokenURL       | string     | Token URL of the STS                  | false         | false        |
          | ChoreoAPIKey   | string     | API key of the Choreo service         | false         | true         |

          For more details, see the instructions under the **component.yaml file (v1.1)** tab.

    ### Step 2: Read configurations within the application

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const serviceURL = process.env.CHOREO_<CONNECTION_NAME>_SERVICEURL;
    ```

=== "Component.yaml file (v1.0)"

    !!! note
        This `component.yaml v1.0` is a legacy configuration format. For new projects, we recommend using the latest version (v1.1) of `component.yaml` for improved usability and features.
  
    1. Copy and paste the snippet from the in-line developer guide into the `component.yaml` file.
      
        The following is a sample snippet:

        ``` yaml

        dependencies:
            serviceReferences:
            - name: <SERVICE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: ServiceURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerSecret
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: TokenURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ChoreoAPIKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>

        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the service you are connecting to.              |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added a service reference section under `dependencies`, append this as another item under `serviceReferences`. 

          Upon deploying the component, Choreo automatically creates a subscription if applicable and populates the specified environment variables with actual values.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | ServiceURL     | string     | Service URL of the Choreo service     | false         | false        |
          | ConsumerKey    | string     | Consumer key of the Choreo service    | false         | false        |
          | ConsumerSecret | string     | Consumer secret of the Choreo service | false         | true         |
          | TokenURL       | string     | Token URL of the STS                  | false         | false        |
          | ChoreoAPIKey   | string     | API key of the Choreo service         | false         | true         |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const serviceURL = process.env.SVC_URL;
    ```

=== "Component-config.yaml file"

    !!! note
        This `component-config.yaml` is a legacy configuration format. For new projects, we recommend using the latest version (v1.1) of `component.yaml` for improved usability and features.

    1. Copy and paste the snippet from the in-line developer guide into the `component-config` file under the `spec` section.

        The following is a sample snippet:

        ``` yaml

        outbound:
            serviceReferences:
            - name: <SERVICE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: ServiceURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerSecret
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: TokenURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ChoreoAPIKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>

        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the service you are connecting to.              |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added an outbound service reference, append this as another item under `serviceReferences`. 

          Upon deploying the component, Choreo automatically creates a subscription if applicable and populates the specified environment variables with actual values.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | ServiceURL     | string     | Service URL of the Choreo service     | false         | false        |
          | ConsumerKey    | string     | Consumer key of the Choreo service    | false         | false        |
          | ConsumerSecret | string     | Consumer secret of the Choreo service | false         | true         |
          | TokenURL       | string     | Token URL of the STS                  | false         | false        |
          | ChoreoAPIKey   | string     | API key of the Choreo service         | false         | true         |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const serviceURL = process.env.SVC_URL;
    ```

If you're using the API key security scheme for the connection, skip Step 3 and follow the instructions in [Step 4: API key security scheme](#step-4-invoke-the-service) tab.

### Step 3: Acquire an OAuth 2.0 access token

To consume a Choreo service with the visibility level set to organization or public and secured by the OAuth 2.0 security scheme, you must obtain an OAuth 2.0 token from the token endpoint. Subsequently, you can use the token to invoke the service.

- For languages with OAuth 2.0-aware HTTP clients, you must pass the OAuth 2.0-related configurations such as client id, client secret and so on, obtained when creating the connection to your HTTP client configuration. The HTTP client autonomously manages token retrieval and refreshing.

- For languages without OAuth 2.0-aware HTTP clients, you must manually initiate a call to the token endpoint. This includes fetching the token and managing token expiration and refresh directly within your application code. The following is a sample curl command to obtain a token:


    ```bash
    CONSUMER_KEY="your_consumer_key"
    CONSUMER_SECRET="your_consumer_secret"
    TOKEN_URL="your_token_url"

    # Encode client credentials as Base64
    CLIENT_CREDENTIALS=$(echo -n "$CLIENT_ID:$CLIENT_SECRET" | base64)

    curl -X POST $TOKEN_URL \
      -H "Content-Type: application/x-www-form-urlencoded" \
      -H "Authorization: Basic $CLIENT_CREDENTIALS" \
      --data-urlencode "grant_type=client_credentials"

    ```

### Step 4: Invoke the service

Click the tab that matches the security scheme of your service and follow the instructions below:

=== "API key security scheme"

     To invoke the API, use the `choreo-api-key` header with the API key value retrieved from the corresponding environment variable as described in [step 2](#step-2-read-configurations-within-the-application).

     The following is a sample code snippet in NodeJS:

     ``` java
       const response = await axios.get(serviceURL/{RESOURCE_PATH}, {
           headers: {
             'Choreo-API-Key': `${choreoApiKey}`
           }
       });
     ```

=== "OAuth 2.0 security scheme"

     To invoke the service, use the following instructions based on your programming language:

      - For languages with OAuth 2.0-aware HTTP clients, use the service URL resolved in [Step 2](#step-2-read-configurations-within-the-application). The OAuth-aware client manages authentication automatically. For sample requests and responses, see the API definition provided via the Choreo marketplace for the service.

      - For languages without OAuth 2.0-aware HTTP clients, use the token obtained in [step 3](#step-3-acquire-an-oauth-20-access-token) to make calls to the dependent service. Subsequently, add the obtained token to the HTTP authorization header with the bearer prefix. As the service URL, use the URL resolved in [step 2](#step-2-read-configurations-within-the-application). For sample requests and responses, see the API definition of the service provided via the Choreo marketplace.

       The following is a sample code snippet in NodeJS:

       ``` java
       const response = await axios.get(serviceURL/{RESOURCE_PATH}, {
           headers: {
             'Authorization': `Bearer ${accessToken}`
             'Choreo-API-Key': `${choreoApiKey}`
           }
       });
       ```

    !!! note
        If you want to consume a Choreo service at the project visibility level, you don't need to obtain a token. You can directly invoke the service using the resolved URL.


# Use a Connection in Your Web Application

Choreo simplifies the process of integrating services into your web application. The approach to connect to a service can vary based on your web application. 

To connect to a selected service, follow the step-by-step instructions given below depending on the authentication mechanism used in your web application.

=== "Managed authentication"
    
    Choreo-managed authentication allows you to seamlessly handle authentication for your web application. You can configure your web application to work with the built-in identity provider of Choreo or any external identity provider that supports OIDC/OAuth2.0

    !!! note 
         Choreo's managed authentication is currently available only for web applications created with **React**, **Angular**, or **Vue.js** buildpacks.

    Follow the steps below to use an existing connection within your web application: 

    <h2> Step 1: Add the connection configuration</h2>

    To integrate a service into your application, you must first add the connection configuration as follows: 

    1. For single page applications (SPAs), you must add the connection configuration as a file mount. You can mount a file via the **Configurations** pane on the **Deploy** page. You must mount a file (for example, `config.js`) and add the configuration provided in the inline developer documentation into it. 

        The following is a sample configuration:

        ``` yaml
             window.configs = {
                 apiUrl: '<SERVICE_URL>',        
             };

        ```

    2.  To ensure accessibility of the `config.js` file via JavaScript at runtime, add a script tag as follows in the `index.html` file to reference the `config.js` file:

        ``` html
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="utf-8" />
            <title>My React App</title>
        </head>
        <body>
            <div id="root"></div>
            <script src="/public/config.js"></script>
        </body>
        </html>
        ``` 

        !!! note
             If you use an external IdP, you must add the IdP's configuration to the same file.
    
             For more information on working with IdPs, see [Configure Asgardeo as an External Identity Provider](https://wso2.com/choreo/docs/administer/configure-an-external-idp/configure-asgardeo-as-an-external-idp/).


    <h2> Step 2: Read the configuration</h2>

    Once you add the connection configuration, you can proceed to read the configuration from your application. The steps to read depend on the programming language you use.

    The following is a sample code snippet in NodeJS:

    ``` java
         const serviceURL = window?.configs?.apiUrl ? window.configs.apiUrl : "/";
    ```

    <h2> Step 3: Invoke the service</h2>

    If you use Choreo-managed authentication, Choreo handles the security handshaking for the application during deployment. The connected service will be accessible under the same domain as your application. Therefore, you can call the configured path directly using your preferred HTTP client.

    The following is a sample code snippet in NodeJS:

    ``` java
         const response = await axios.get(serviceURL/{RESOURCE_PATH});
    ```

    !!! note
         If you are using an external IdP provider instead of Choreo-managed authentication, you must obtain an access token from your IdP and add it to the HTTP authorization header with the bearer prefix.


=== "Custom authentication or no authentication"

    If you are not using Choreo-managed authentication or your web application lacks authentication, follow the steps below to connect to a service from your web application:

    <h2> Step 1: Add the connection configuration</h2>

    1. For single-page applications (SPAs), you must add the connection configuration as a file mount. You can mount a file via the **Configurations** pane on the **Deploy** page. You must mount a file (for example, `config.js`) and add the configuration provided in the inline developer documentation into it.
 
        The following is a sample configuration:

        ``` yaml
             window.configs = {
                 apiUrl: '<SERVICE_URL>',
                 consumerKey: '<CONSUMER_KEY>',
                 consumerSecret: '<CONSUMER_SECRET>',
                 tokenUrl: '<TOKEN_URL>',
             };
        ```

    2.  To ensure accessibility of the `config.js` file via JavaScript at runtime, add a script tag as follows in the `index.html` file to reference the `config.js` file:

        ``` html
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="utf-8" />
            <title>My React App</title>
        </head>
        <body>
            <div id="root"></div>
            <script src="/public/config.js"></script>
        </body>
        </html>
        ``` 

    For other types of web applications, you must add the respective configuration into your application.

    <h2> Step 2: Read the configuration</h2>

    Once you have added the connection configuration, you can proceed to read the configuration from your application. The steps to read depend on the programming language you use.

    The following is a sample code snippet in NodeJS:

    ``` java
         const serviceURL = window?.configs?.apiUrl ? window.configs.apiUrl : "/";
    ```

    <h2> Step 3: Acquire an OAuth 2.0 access token</h2>

    - For languages with OAuth 2.0-aware HTTP clients, you must pass the OAuth 2.0-related configurations such as client id, client secret and so on, obtained when creating the connection to your HTTP client configuration. The HTTP client autonomously manages token retrieval and refreshing.
  
    - For languages without OAuth 2.0-aware HTTP clients, you must manually initiate a call to the token endpoint. This includes fetching the token and managing token expiration and refresh directly within your application code. The following is a sample curl command to obtain a token:


        ```bash
        CONSUMER_KEY="your_consumer_key"
        CONSUMER_SECRET="your_consumer_secret"
        TOKEN_URL="your_token_url"

        # Encode client credentials as Base64
        CLIENT_CREDENTIALS=$(echo -n "$CLIENT_ID:$CLIENT_SECRET" | base64)

        curl -X POST $TOKEN_URL \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -H "Authorization: Basic $CLIENT_CREDENTIALS" \
        --data-urlencode "grant_type=client_credentials"

        ```

    <h2> Step 4: Invoke the service</h2>

    You can invoke the service as follows:

    - For languages with OAuth 2.0-aware HTTP clients, you can invoke the service in a straightforward manner. The HTTP client seamlessly manages OAuth 2.0 authentication without requiring additional intervention.

        As the service URL you can use the URL that you resolved in step 2 above. For sample requests and responses, see the API definition provided via the Choreo marketplace for the service.

    - For languages without OAuth 2.0-aware HTTP clients, you can use the token obtained in step 3 above to make calls to the dependent service. Subsequently, add the obtained token to the HTTP authorization header with the bearer prefix.

        As the service URL you can use the URL that you resolved in step 2 above. For sample requests and responses, see the API definition of the service provided via the Choreo marketplace.

        The following is a sample code snippet in NodeJS:

        ```java 
            const response = await axios.get(serviceURL/{RESOURCE_PATH}, {
                headers: {
                'Authorization': `Bearer ${accessToken}`
                }
            })
        ```


# Use a Database Connection in Your Component

Choreo allows you to share and reuse Choreo-managed databases, accelerating development and enhancing efficiency in building integrated applications through connections.

For step-by-step instructions on creating a database connection, see [Create a Connection](create-a-connection.md).

To learn more about Choreo Connections, see the documentation on [Connections](../../choreo-concepts/connections.md).

## Consume a database through a connection

To consume a Choreo-managed database via a connection, follow these steps:

### Step 1: Add connection configurations

To integrate a database into your application, click the appropriate tab below based on your current configuration file and follow the step-by-step instructions:

=== "Component.yaml file (v1.1)"

    1. Copy and paste the snippet from the  developer guide into the `component.yaml` file.

        The following is a sample snippet:

        ``` yaml

        dependencies:
            connectionReferences:
            - name: <CONNECTION_NAME>
              resourceRef: <RESOURCE_IDENTIFIER>

        ```

          | Field            | Description                                                         |
          |------------------|---------------------------------------------------------------------|
          | name             | The name given to the connection.                                   |
          | resourceRef      | A unique, readable identifier of the database being connected to.    |


    2. If you've previously added a `connectionReferences` section under `dependencies`, append this as another item under `connectionReferences`. Upon deploying the component, the necessary configurations to establish the connection will be injected into Choreo-defined environment variables.

          The following table details the Choreo-defined environment variables:

          | Configuration Key       | Choreo-Defined Environment Variable Name                       |
          |-------------------------|----------------------------------------------------------------|
          | HostName                | CHOREO_<CONNECTION_NAME\>_HOSTNAME                             |
          | Port                    | CHOREO_<CONNECTION_NAME\>_PORT                                 |
          | Username                | CHOREO_<CONNECTION_NAME\>_USERNAME                             |
          | Password                | CHOREO_<CONNECTION_NAME\>_PASSWORD                             |
          | DatabaseName            | CHOREO_<CONNECTION_NAME\>DATABASENAME                          |


          If you'd like to use custom environment variable names instead of the Choreo-defined ones, add the dependency as a service reference under `dependencies` in the same file. For more details, refer to the instructions under the `component.yaml file (v1.0)` tab.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | HostName       | string     | Hostname of the database server       | false         | false        |
          | Port           | string     | Port of the database server           | false         | false        |
          | Username | string           | Username of the database server       | false         | false        |
          | Password       | string     | Password of the database server       | false         | true         |
          | DatabaseName   | string     | Name of the database                  | false         | false        |
    ### Step 2: Read configurations within the application

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const hostName = process.env.CHOREO_<CONNECTION_NAME>_HOSTNAME;
    ```

=== "Component.yaml file (v1.0)"

    !!! note
        The `component.yaml v1.0` file is considered legacy. For new components, we recommend using the latest version, `component.yaml v1.1`, which offers enhanced usability and features.

    1. Copy and paste the snippet from the  developer guide into the `component.yaml` file.

        The following is a sample snippet:

        ``` yaml

        dependencies:
            serviceReferences:
            - name: database:<DATABASE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: HostName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Port
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Username
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Password
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: DatabaseName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>


        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the database you are connecting to.             |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added a service reference section under `dependencies`, append this as another item under `serviceReferences`.

          Upon deploying the component, Choreo automatically populates the specified environment variables with actual values.

          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | HostName       | string     | Hostname of the database server       | false         | false        |
          | Port           | string     | Port of the database server           | false         | false        |
          | Username | string           | Username of the database server       | false         | false        |
          | Password       | string     | Password of the database server       | false         | true         |
          | DatabaseName   | string     | Name of the database                  | false         | false        |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const hostName = process.env.HOSTNAME;
    ```

=== "Component-config.yaml file"

    !!! note
        The `component-config.yaml` file is considered legacy. For new components, we recommend using the latest version, `component.yaml v1.1`, which offers enhanced usability and features.

    1. Copy and paste the snippet from the  developer guide into the `component-config` file under the `spec` section.

        The following is a sample snippet:

        ``` yaml

        outbound:
            serviceReferences:
            - name: database:<DATABASE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: HostName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Port
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Username
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Password
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: DatabaseName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>

        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the database you are connecting to.              |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added an outbound service reference, append this as another item under `serviceReferences`.

          Upon deploying the component, Choreo automatically populates the specified environment variables with actual values.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | HostName       | string     | Hostname of the database server       | false         | false        |
          | Port           | string     | Port of the database server           | false         | false        |
          | Username | string           | Username of the database server       | false         | false        |
          | Password       | string     | Password of the database server       | false         | true         |
          | DatabaseName   | string     | Name of the database                  | false         | false        |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const hostName = process.env.HOSTNAME;
    ```

### Step 3: Initiate a database connection

To initiate a connection to the database, follow these steps:

In this example, you will connect to a MySQL database.

#### Step 3.1: Install the required packages

For the MySQL database, install the `mysql2` package using npm:

```bash
// Install the mysql2 package
npm install mysql2

```

#### Step 3.2: Import required packages

```java

const client = require('mysql2')

```

#### Step 3.3: Establish a connection

To establish the connection, use the environment variables for `hostName`, `username`, `password`, `databaseName`, and `port` as follows:

```java

var connection = client.createConnection({
      host: hostName,
      user: username,
      password: password,
      database: databaseName,
      port: port
});

connection.connect((err) => {
      if (err) {
          return;
      }
      // Connection is successful
});

```

By following these steps, your component can interact with the Choreo-managed database seamlessly.




 # Bring Your Own Image (BYOI)

Choreo allows you to deploy and manage prebuilt container images from external container registries as Choreo components. This enables you to deploy and effectively manage your container images within the Choreo environment.

!!! info
    This feature is currently only available on [private data planes (PDPs)](../choreo-concepts/data-planes.md#private-data-planes) for the following component types:

    - Service
    - Web Application
    - Scheduled Task
    - Manual Task


## Prerequisites

Before you try out this guide, ensure you have the following:

- **A container registry**: Ensure you have a container registry containing the images you want to deploy. Choreo is compatible with various container registries, including but not limited to GCR (Google Container Registry), ACR (Azure Container Registry), GitHub Container Registry, and Docker Hub.

- **An image in the registry**: You need an image ready for deployment.

- **(Optional) An external build/CI pipeline**:  This is to initiate automatic deployments during the build process outside of Choreo.

When using a container registry to deploy a component, Choreo cannot create an image from the source code (Git) or initiate a new deployment when a new image is ready. However, you can use your existing build process to trigger a deployment on Choreo by sending an HTTP POST request to a webhook with the new image details.

This feature is currently only available on private data planes (PDPs). You can find this option under **Deploy an image from a container registry** in the **Select Source** step during component creation for service components, web applications, scheduled tasks, and manual tasks.

## Step 1: Register a container registry

To get started, establish a connection between your container registry and Choreo. 

!!! Info
    When you use your Choreo credentials, Choreo does not *pull* your images into its control plane. Instead, it functions as an orchestrator, facilitating your data plane's ability to retrieve images from an external container registry. Choreo passes on these credentials to the data plane for authentication and access.

To register your container registry, follow these steps:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the Choreo Console header, go to the **Organization** list and select your organization. 
3. In the left navigation menu, click **Settings**. This opens the organization settings page. 
4. Click the **Credentials** tab and then click the **Container Registries** tab. 
5. Click **+Add Registry** to configure the Git repository connection.
6. Specify a **Registry Display Name**.
7. Select the **Authentication Type**. Fill in the required information depending on your authentication type. For details on each authentication type, see [Authentication types](#authentication-types).
8. Click **Save**.

### Authentication types

Choreo provides the following authentication options:  

#### Public (anonymous) access
    
You can use this option to establish a connection with a container registry that permits unrestricted public or anonymous access (for example, Public Docker Hub). In this case, only the registry host information is necessary.

For example, the following are the Docker Hub registry hosts for reference:

| Vendor                           | Registry host                |
|----------------------------------|------------------------------|
|Docker Hub (public repositories)  | `registry.hub.docker.com`    |
|Docker Hub (private repositories) | `registry.docker.com`        |

\* If necessary, you can use other mirrors instead of the above.

#### Basic authentication

To use basic authentication to authenticate to the container registry, you must provide the username and password.

#### Docker config

You can provide a Docker config in JSON format to authenticate to the container registry. This option only allows you to register one container registry. That is, it **only allows a single registry under `auths`**.

You must provide the credentials directly within the configuration. Choreo cannot utilize references to executable authentication plugins.

Sample Docker config format:

```json
    {
    "auths": {
        "index.docker.io/v1/": {
        "auth": "c3R...zE2"
        }
    }
    }
```

#### Vendor-specific authentication

This option is specifically for private data planes, where your cloud provider manages authentication at the Kubernetes level. Choreo requires knowledge of the registry host because the data plane already possesses implicit (preconfigured) access to the registry.

Follow the guidelines below based on your container registry:

=== "ACR"
    **Azure Container Registry** 

    Recommended authentication options:

    * [**Service principal-based basic authentication**](https://learn.microsoft.com/en-us/azure/container-registry/container-registry-auth-service-principal)

    * **Vendor-specific authentication on Azure private data planes**
        
        Contact Choreo support to enable infrastructure-level private access to your registry from your Azure private data plane on AKS. If you are on a self-managed PDP on Azure, follow [this guide](https://learn.microsoft.com/en-us/azure/aks/cluster-container-registry-integration?toc=%2Fazure%2Fcontainer-registry%2Ftoc.json&bc=%2Fazure%2Fcontainer-registry%2Fbreadcrumb%2Ftoc.json&tabs=azure-cli).

=== "GAR"
    **Google Artifact Registry**

    Recommended authentication options:

    * [**Service account-based basic authentication**](https://cloud.google.com/artifact-registry/docs/docker/pushing-and-pulling#key)

        Use the service account key in JSON format ([`_json_key`](https://cloud.google.com/artifact-registry/docs/docker/authentication#:~:text=of%20the%20following%3A-,_json_key,-if%20you%20are)) as the username and specify the minified JSON contents of the service account key as the password.

         You can use `jq` as follows to minify the service account JSON key file:

         `jq -c . <service-account.json>`

    * **Vendor-specific authentication on GCP private data planes**

        Contact Choreo support to enable infrastructure-level private access to your registry from your GCP private data plane on GKE. If you are on a self-managed PDP on GCP, see [https://cloud.google.com/artifact-registry/docs/access-control#grant-project](https://cloud.google.com/artifact-registry/docs/access-control#grant-project).

=== "AWS ECR"
    **Elastic Container Registry**

    ECR does not allow the creation of static access passwords for basic authentication. The passwords (that is, access tokens) provided by AWS are only valid for 10 hours and must be manually regenerated. However, when an ECR is attached to an EKS cluster at an infrastructure level, this limitation does not apply because the authentication is handled by AWS internally. For details, see [https://docs.aws.amazon.com/AmazonECR/latest/userguide/registry_auth.html](https://docs.aws.amazon.com/AmazonECR/latest/userguide/registry_auth.html).

    Choreo recommends using ECR when you are exclusively on an AWS private data plane using the vendor-specific authentication option. Contact Choreo support to enable a private connection between your ECR and the underlying EKS clusters on your data plane. If you are on a self-managed PDP, you can follow [this guide](https://docs.aws.amazon.com/AmazonECR/latest/userguide/ECR_on_EKS.html).    

=== "Docker Hub (Private)"

    Recommended authentication options:

    * **Basic authentication**

          Use your Docker Hub username/password or an access token. You can generate an access token from your Docker Hub account settings and use it in place of the password. For details, see [https://docs.docker.com/docker-hub/access-tokens/](https://docs.docker.com/docker-hub/access-tokens/).

    * **Docker config**

          Sign in to the Docker CLI and copy the contents of the docker config JSON. Note that external credential stores and multiple repositories within the same config object are not supported. For more information, see [https://docs.docker.com/engine/reference/commandline/login/](https://docs.docker.com/engine/reference/commandline/login/).

=== "GHCR"
    **GitHub Container Registry**

    Recommended authentication option:

    * **Basic authentication using a PAT token**

          Create a personal access token (PAT) and use it in place of the password. You cannot use your own GitHub password. You must provide a [PAT token](https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry#authenticating-with-a-personal-access-token-classicn).
  
## Step 2: Create a component in Choreo

1. In the left navigation, click **Overview** and select your project. Alternatively, select your project from the **Project** list in the Choreo Console header. 
2. Under **Component Listing** click **+ Create**.
3. Select your component type (BYOI is only available for Service, Web Application, Scheduled Task, or Manual Task components). 
4. From the Create Component pane, select the **Container Registry** under the **Connect a Docker Image** section.
5. Under **Deploy an image from Container Registry/Docker Hub**, select the container registry you have registered in [Step 1](#step-1-register-a-container-registry).
6. Enter the full image URL. The image URL format in general is as follows:
   `[container-registry-host]/[repository-name]/[image-name]:[tag]`

    !!! tip
        When a public image from Docker Hub lacks a specified repository name, it typically defaults to `/library/`. For example, you can access the public Nginx image `https://hub.docker.com/_/nginx` as `registry.hub.docker.com/library/nginx:1.25`.

7. Enter a display name, a unique name, and a description for the component.
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.


## Step 3: Deploy the component in Choreo

To deploy the component and bring your image to Choreo, follow the steps given below: 

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Update Image & Deploy**. 
3. In the **Endpoint** pane that opens, you can see the endpoint ready to be deployed. Click the edit icon next to the endpoint name. Optionally, you can define the endpoints for your service when you manually deploy the service. For more information, see [Expose service endpoints](#step-4-expose-service-endpoints).
4. Change the **Network Visibility** to **Public**. This setting securely exposes the endpoint for consumption.
5. Click **Update**.

    !!! info
         In this example, you deploy a Ballerina service as a REST endpoint. Therefore, Choreo generated the REST endpoint automatically. If you deploy a non-Ballerina service, you must manually add the REST endpoint and set the network visibility to **Public**.

6. Select your update image option. Refer to the update options listed below.

    You have the capability of updating the image when you are deploying the component in Choreo in one of the following three ways:

    | Option                   |Description                                                                                             |
    |--------------------------|--------------------------------------------------------------------------------------------------------|
    | **Update Image Tag**     | This option allows you to update the tag of the image.                                                 |
    | **Update Image URL**     | With this option, you can change the image name, tag, and the image repository of the image URL.|
    | **Previous Images**      | This option allows you to select a previous image and redeploy the image.                               |

7. Click **Deploy**. This deploys the service to the development environment.

## Step 4: Expose service endpoints 

!!! info
    This section only applies to service components.

After creating a service component in Choreo, you have the option to define the endpoints for your service when manually deploying a new image.

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Update Image & Deploy**. 
3. In the **Endpoint** pane that opens, optionally, you can define the endpoints for your service when you manually deploy the service. 
4. Click  **Create/Update Endpoints**.
5. Under the **Edit endpoints.yaml** section, you can edit the endpoints YAML file in the provided editor. 
   Alternatively, you can upload the associated API specification/schema files (OpenAPI/GraphQL schemas). Instead of specifying the file path, you can also reference this file in the `endpoints.yaml` file by its file name, similar to the Git-based Choreo components. The endpoints template follows the standard definitions for defining endpoints in Choreo. For more details, see [Configure Endpoints](../develop-components/configure-endpoints.md).

## Auto-deploy images in Choreo with an external CI/build pipeline

Choreo does not have automatic detection and deployment for newly added images or tags in the linked container registry. To overcome this limitation, Choreo allows you to integrate your own CI pipelines and initiate deployments manually. This approach enables you to use your existing CI setup or build a pipeline for image creation and pushing. You can then trigger automatic deployments using a webhook.

Follow the steps below to configure your CI/build pipeline:

1. Build and push the container image associated with a Choreo component to your container registry.
2. In the left navigation menu, click **DevOps** and then click **External CI**.
3. Generate a token for your CI pipeline from the **Manage Tokens** section. 

    !!! note
        - The tokens are bound to a specific component.
        - It is recommended to reference the token from a secure location available to your CI pipeline. For example, use a GitHub secret if you are using GitHub Actions.

4. To trigger an automatic deployment to your development environment, you can initiate an HTTP POST request to the Choreo webhook endpoint with the updated image details. Alternatively, you can use the provided Webhook snippets. This action will seamlessly deploy the image to the development environment.



Services and integrations are exposed to other services, integrations, or applications through endpoints. A service or an integration can expose multiple endpoints, each representing a unique entry point into the service. For example, a service may expose a REST API endpoint and a GraphQL endpoint, each providing different ways to interact with the service. Endpoints provide specific details for how the service or the integration can be consumed. For instance, the port number, protocol, and the schema such as open API specification (OAS) or GraphQL schema. By defining these details, endpoints make it possible for other services, integrations, and applications to discover and interact with the service in a standardized way.

Choreo defines endpoints by combining port binding, protocol, endpoint name, network visibility, endpoint schema, and additional protocol-related fields. The following table describes each attribute of an endpoint.

| Field | Description |
| ----- | ----------- |
| Name | A unique identifier for the endpoint within the service component. |
| Port | The network port on which the endpoint is accessible. |
| Type | The endpoint protocol. Supported protocols: REST, GraphQL, gRPC, WS, UDP, and TCP. |
| Network Visibility | Determines the level of visibility of an endpoint. Possible values are: <ul><li>Project: Allows components within the same project to access the endpoint.</li><li>Organization: Allows any component within the same organization to access the endpoint but restricts access to components outside the organization.</li><li>Public: Allows any client to access the endpoint, regardless of location or organization.</li></ul> |
| Schema | Specifies the structure and format of the data exchanged through the endpoint. |
| Context (HTTP and GraphQL only) | A context path that you add to the endpoint's URL for routing purposes. |

## Configure endpoints
The method of defining endpoints depends on the buildpack.

* For `Ballerina` and `WSO2 MI` buildpacks, Choreo automatically detects the endpoint details for REST APIs.
* For all other buildpacks (Java, Python, NodeJS, Ruby, PHP, Go, Dockerfile, etc.), you can configure endpoints in one of the following ways:
  
    * **Using the Choreo Console**: If a `component.yaml` file is not present, you can define a basic endpoint configuration during component creation.
    * **Using the component.yaml file**: You can manually configure endpoint details by defining them in a `component.yaml` file, placing it inside the `.choreo` directory at the build context path, and committing it to the source repository.

You can override UI-defined and auto-generated endpoints by providing a `component.yaml` file in the `.choreo` directory, which will take priority over other configurations.

To learn about the `component.yaml` file, see [Overview of the component.yaml file](../develop-components/manage-component-source-configurations.md#overview-of-the-componentyaml-file).
!!! note
    Automatic endpoint generation is not supported for dynamic endpoint parameters such as variable ports. Therefore, you must use an `component.yaml` file to define dynamic endpoint parameters.

To learn about the `component.yaml` file, see [Overview of the component.yaml file](../develop-components/manage-component-source-configurations.md#overview-of-the-componentyaml-file).

## Expose endpoints as managed APIs

Exposing endpoints as managed APIs is crucial to ensure secure and controlled access to the services being exposed. When a user wants to expose their written service to the outside world or to the organization at large, there is an inherent security risk involved. To mitigate this risk, the Choreo platform is built with an internal (access within the organization only) or external (publicly accessible) gateway that is protected with Choreo API management making the services secure by design.

!!! note
    This feature is not available for gRPC, UDP, and TCP endpoints.

If you want to expose an endpoint as a managed API in Choreo, you need to set the network visibility to either Organization or Public. This allows the endpoint to be exposed through the Choreo API Gateway, which provides a number of benefits, including:

* Expose APIs to external and internal consumers
* Full lifecycle API Management
* API throttling
* Secure APIs with industry-standard authorization flows
* API analytics and monitoring

Once you deploy the service component, Choreo will expose the endpoint as a managed API through the Choreo API Gateway. You can then use the full lifecycle API management features provided by Choreo to test, deploy, maintain, monitor, and manage your API using the API management features.

## Understand the default component URL

The default URL of a component corresponds to the default endpoint of the component and is structured as follows:

`<domain>/<project-name>/<component-name>`

This URL does not include the default endpoint name. For all other endpoints, the URL structure includes the endpoint name, as follows:

`<domain>/<project-name>/<component-name>/<endpoint-name>`

If a component has multiple endpoints, Choreo allows you to change the endpoint corresponding to the default component URL. For a component with a single endpoint, the default URL automatically corresponds to that endpoint.

### Change the default endpoint of a component

To change the default endpoint of a component, follow the steps given below:

!!! note
     - You cannot change the default endpoint if it has associated published APIs. You must go to the **Lifecycle** page and unpublish the relevant APIs before updating the default endpoint. For instructions on unpublishing an API, see [Lifecycle Management](https://wso2.com/choreo/docs/api-management/lifecycle-management/).
     - Choreo does not allow you to change the default endpoint of a component if you create multiple deployment tracks within its current major version, or promote the component beyond its initial environment.

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to change the default endpoint.
3. In the left navigation menu, click **Deploy**.
4. On the **Deploy** page, go to the **Set Up** card and click **Configure & Deploy**.
5. In the **Environment Configurations** pane that opens, click **Next**.
6. In the **File Mount** pane that opens, click **Next**.
7. In the **Endpoint Details** pane that opens, click the **Default Endpoint** list, select the endpoint you want to set as the default endpoint, and then click **Update**.
8. Click **Deploy**. This deploys the component with the selected endpoint as the default, and the default URL will now correspond to this endpoint.  

### Edit a UI-Defined Endpoint
If you defined an endpoint during component creation, you can edit it later by following these steps:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to update the endpoint.
3. In the left navigation menu, click **Deploy**.
4. On the **Deploy** page, go to the **Set Up** card and click **Configure & Deploy**.
5. In the **Environment Configurations** pane that opens, click **Next**.
6. In the **File Mount** pane that opens, click **Next**.
7. In the **Endpoint Details** pane that opens, locate the endpoint you want to edit.
8. Click the **Edit** icon next to the endpoint, modify the editable fields, and click **Update**.
9. Click **Deploy** to apply the changes.

!!! note
     If you commit a `component.yaml` file, build the component, and proceed with deployment, the endpoints will be generated from the `component.yaml` file and will take priority. In this case, the endpoint cannot be edited through the UI. To modify the endpoint, you must update the`component.yaml` file.


# Configure Endpoints
{% include "configure-endpoints-body.md" %}

# Deploy a Containerized Application 

Using Choreo, you can easily deploy applications written in different language frameworks (such as Java, Go, NodeJS, Python, etc.) on shared or private data planes using containers.

Choreo supports deploying containerized applications for the following component types:

- Service
- Web Application
- Scheduled Task
- Manual Task
- Event Handler
- Test Runner

## Connect your repository to Choreo

To connect your GitHub repository to Choreo, you should authorize the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application to access your account or organization. When you attempt to connect your GitHub repository via the Component creation page, the Choreo Apps authorization prompt will appear.

* Connect GitHub Repository
    
    ![Connect GitHub Repository](../assets/img/develop-components/deploy/create-component-authz-github-page.png){.cInlineImage-threeQuarter}

* Authorize GitHub Application
    
    ![Authorize GitHub Application](../assets/img/develop-components/deploy/authz-choreo-github-app.png){.cInlineImage-half}

* Grant Repository Access

    ![Grant Repository Access](../assets/img/develop-components/deploy/github-repo-access.png){.cInlineImage-full}


    The **Choreo Apps** requires the following permission:
    
    - Read access to issues and metadata
    - Read and write access to code, pull requests, and repository hooks

!!! note
    You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. Choreo needs write access only to send pull requests to a user repository. Choreo does not directly push any changes to a repository.

Alternatively, you can connect a public repository without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. Select the **Third-Party GitHub Repository** and paste a public repository URL in the **Public Repository URL** field at the time of component creation.

!!! tip
     Authorizing the repository with the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application becomes essential if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component. If you own the repository, you can subsequently authorize it with the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application to enable **Auto Deploy**.

After granting access to the required repositories, you can choose a repository and an associated branch to connect to the Choreo component.
For the containerized application deployments, you should select the [**Component Directory**](https://docs.docker.com/build/building/context/#path-context), **Dockerfile** as the **Buildpack** and provide **Dockerfile Path** for the Docker build.

![Connected Dockerfile Repository](../assets/img/develop-components/deploy/create-component-connected-repo.png){.cInlineImage-full}

The following table describes the individual fields in the **Create Component** pane.

| **Field**               | **Description**                                                                                                                                                                      |
|-------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **GitHub Account**      | Your GitHub account or organization. If you want to add another GitHub account, you can expand the list and click **+ Add**.                                                            |
| **GitHub Repository**   | Depending on the repository access you provided, the list will show available repositories to be connected.                                                                                  |
| **Branch**              | The branch of the repository.                                                                                                                                                         |
| **Buildpack**        | Determines the implementation of the component: Any language or other language as a Docker container.                                                                                |
| **Dockerfile Path**     | The path to your Dockerfile. This path is defined relative to the repository root.<br/>For example, if the Dockerfile is at the repository root, the value for this field is `/Dockerfile`. |
| **Component Directory** | The component directory path. To include the repository root, leave the default `/` value.                                                                                          |
| **Port***               | The port at which your service is running.                                                                                                                                           |
| **OpenAPI Filepath***   | The path to an OpenAPI specification (in YAML/JSON) relative to the repository root. If you don't provide a path, the system automatically generates a default allow-all specification.    |

   
!!! note
 
    - Fields marked with **\*** are not visible for all component types.

    - To successfully build your container with Choreo, it is essential to explicitly define a User ID (`UID`) under the `USER` instruction in your Dockerfile. You can refer to the [sample Dockerfile](https://github.com/wso2/choreo-sample-apps/blob/main/go/rest-api/Dockerfile) for guidance.

    - To ensure that the defined USER instruction is valid, it must conform to the following conditions:
        
        - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
        - Usernames are not considered valid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

## Deploy the containerized component

Choreo will automatically apply deployment configurations and settings based on the component type you select during creation.
For example, if you select the **Service** component type, Choreo will deploy it as a Kubernetes deployment with appropriate scaling configurations.

You can run unit tests in the build pipeline by adding the relevant command to the Dockerfile.  For example: 

- [Go-based sample](https://github.com/wso2/choreo-sample-apps/blob/8c18c82db604adb43b89f669888a07cd6e31d7b7/go/rest-api/Dockerfile#L37)
- [Python-based sample](https://github.com/wso2/choreo-sample-apps/blob/8c18c82db604adb43b89f669888a07cd6e31d7b7/python/rest-api/Dockerfile#L15)

### Application configurations

You must provide any required configurations for running the application in the **Configs & Secrets** section of the component's **DevOps** page. Alternatively, you can also review the configurations when you manually deploy via the **Deploy** page.

After clicking the **Create** button, you can select the confidentiality of the configuration and specify how to mount it to the container.

![Application Configuration Page](../assets/img/develop-components/deploy/deploy-app-config-page.png){.cInlineImage-full}

![Create Configuration Mount Page](../assets/img/develop-components/deploy/deploy-app-config-type-mount-page.png){.cInlineImage-full}

#### Configuration types

* **ConfigMap**: Stores non-confidential data as key-value pairs.
* **Secret**: Stores and manages sensitive information, such as passwords, OAuth tokens, and ssh keys as key-value pairs.

#### Mount types

* **Environment Variables**: Mounts the selected ConfigMap or Secret as an environment variable in the container.
* **File Mount**: Mounts the selected ConfigMap or Secret as a file in the container. Here, the key is the file name, and the value is the file content.

The following image shows adding a **ConfigMap** with **File Mount** mount type to be read by the application.

![Configuration File Mount Page](../assets/img/develop-components/deploy/deploy-app-config-file-mount.png){.cInlineImage-full}

!!! note
    The JSON file includes ${DB_PASS} as an environment variable defined in a Secret. The application reads the JSON file and substitutes the placeholders with the corresponding environment variables.

### Deployment configurations

Choreo lets you configure deployment settings such as scaling, resource limits, and health checks based on your selected component type.

For more information about these configurations, see Choreo's [DevOps capabilities](../devops-and-ci-cd/view-runtime-details.md).

You can configure the **Endpoints** to expose your service using the **Service** Component in Choreo. See [Service Component Overview](../develop-components/develop-services/service-component-overview.md) for more information. 

### Build, deploy, and promote

After adding the application configuration, you can build and deploy it by clicking the **Deploy Manually** button. Choreo will start the build process with the selected commit in the **Build Area**. 

!!! note
    The **Auto Deploy on Commit** feature, which automatically builds and deploys the application upon pushing a code change to the repository, is enabled by default. To turn off this feature, navigate to the **Build Area** of the **Deploy** page.

Choreo scans your Dockerfile for security vulnerabilities during the build phase, and if there are no issues found, it proceeds with the build process. After building the image, it scans it again for vulnerabilities before deployment to the environment. You can view the build logs from the right-side panel, as shown in the image below.

![Build Logs Panel](../assets/img/develop-components/deploy/build-deploy-page-logs.png){.cInlineImage-full}

Once the build process is complete, Choreo will deploy the application automatically to the Development environment. To promote the build to higher environments, you can click the **Promote** button. The number of environment cards visible on the page may vary depending on your environment configurations.

### Troubleshoot security vulnerability scan failures (Trivy)

By default, Choreo utilizes the Aqua Trivy (OSS) image vulnerability scanner to detect security vulnerabilities in all Dockerfile-based build pipelines. The scanner will fail the pipeline if any **CRITICAL** CVEs (Common Vulnerabilities and Exposures) are detected. CVEs of other severity levels are recorded but does not fail the pipeline.

If you cannot fix a critical CVE immediately, you can opt to ignore it. To ignore a critical CVE, add a `trivyignore` (`<docker-build-context-path>/.trivyignore`) file to your build context path. In the file, add the CVEs you need the pipeline to ignore, one entry per line as follows:

```
CVE-2023-xxxx
CVE-2023-yyyy
```

You can add comments in the file by using `#` in front of the comment as follows: 

```
# comments can be added like this
CVE-2023-xxxx
```


# Deploy an Application with Buildpacks

Using Choreo, you can easily deploy applications written in different language frameworks (such as Java, Go, NodeJS, Python, Ruby, PHP, etc.) on shared or private data planes.

Choreo supports deploying applications with buildpacks for the following component types:

- Service
- Web Application
- Scheduled Task
- Manual Task
- Webhook
- Event Handler
- Test Runner

## Buildpacks
Buildpacks are a fundamental building block in modern application development. They convert your source code into a secure, efficient, production-ready container image without a Dockerfile. With Choreo, developers can take advantage of this powerful tool to effortlessly deploy their applications without the hassle of manual configuration.

Choreo uses [Google Buildpacks](https://cloud.google.com/docs/buildpacks/overview) as default buildpacks for Java, Go, NodeJS, Python, PHP, and Ruby. Choreo uses its own buildpacks for Ballerina and WSO2 MI.

## Develop a component

To develop a service component that exposes a Service in Go, you can follow the [Develop a Service ](develop-services/develop-a-service.md) guide.

Follow the guidelines below based on your language:

=== "Python"
    Supported Versions - 3.10.x, 3.11.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Reading Books List Service](https://github.com/wso2/choreo-samples/tree/main/reading-books-list-service-python)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-python-task)|

    ### Procfile
    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    
    !!! info 
        In **Python** projects, it is mandatory to have a `Procfile` with the `web` process type in the project root directory.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: python main.py` <br>
    `web: gunicorn --bind :8080 --workers 1 --threads 8 --timeout 0 main:app` <br>
    `web: flask run --host=0.0.0.0`

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Ballerina"

    Supported Versions - 2201.3.5, 2201.4.1, 2201.5.0, 2201.5.1, 201.6.0,  2201.7.0

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Echo Service](https://github.com/wso2/choreo-samples/tree/main/echo-service)|
    | Manual Task | [Covid19 Statistics To Email](https://github.com/wso2/choreo-samples/tree/main//covid19-statistics-to-email)|
    | Webhook | [Salesforce New Case To Google Sheet](https://github.com/wso2/choreo-samples/tree/main/sfdc-new-case-to-gsheet)|
    | Scheduled Task | [Shopify New Customers to HubSpot Create/Update Contact](https://github.com/wso2/choreo-samples/tree/main/shopify-new-customers-to-hubspot-contact)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Go"

    Supported Versions - 1.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Greeting Service](https://github.com/wso2/choreo-samples/tree/main/greeting-service-go)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-go-task)|
    | Web Application | [Hello World Web Application](https://github.com/wso2/choreo-samples/tree/main/hello-world-go-webapp)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== ".NET"
    Supported Versions - 6.x, 7.x, 8.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service | [Greeting Service](https://github.com/wso2/choreo-samples/tree/main/dotnet-greeter)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Java"
    Supported Versions
        - 8, 11, 17, 18 (OpenJDK Runtime Environment Temurin)

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Product Management Service](https://github.com/wso2/choreo-samples/tree/main/product-management-service)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-java-task)|

    !!! info

         When working on Java projects:

           - The `Main` class should be defined in the manifest file.
           - If Maven files such as `mvn.cmd` exist in the project without the `.mvn` directory, the build will fail. To ensure a successful build, you must either commit the `.mvn` directory along with any Maven files or not include any Maven files in the project if you choose not to commit the `.mvn` directory.
    
    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **Java** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: java -jar target/sample.jar` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "NodeJS"
    Supported Versions - 12.x.x, 14.x.x, 16.x.x, 18.x.x, 20.x.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Reading Books List Service](https://github.com/wso2/choreo-samples/tree/main/reading-books-list-service-nodejs)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-nodejs-task)|

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **NodeJS** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: node app.js` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "PHP"
    Supported Versions - 8.1.x, 8.2.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Hello World Service](https://github.com/wso2/choreo-samples/tree/main/hello-world-php-service)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-php-task)|
    | Web Application | [Hello World Web Application](https://github.com/wso2/choreo-samples/tree/main/hello-world-php-webapp)|

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **PHP** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web:php -S 0.0.0.0:8000 index.php` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Ruby"
    Supported Versions - 3.1.x, 3.2.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service | [Hello World Service](https://github.com/wso2/choreo-samples/tree/main/hello-world-ruby-service)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-ruby-task)|
    | Web Application | [Hello World Web Application](https://github.com/wso2/choreo-samples/tree/main/hello-world-ruby-webapp)|

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **Ruby** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: ruby app.rb` <br>
    `web:bundle exec ruby app.rb -p 8080` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "WSO2 MI"
    Supported Versions - 4.1.0.x, 4.2.0.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service |[Hello World Service](https://github.com/wso2/choreo-samples/tree/main/hello-world-mi)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Spring Boot"
    Supported Java Versions
        - 8, 11, 17, 18 (OpenJDK Runtime Environment Temurin)

    !!! info
         You can use this buildpack only with web applications. For other component types, use the **Java** buildpack. Additionally, if the generated artifact is a `WAR` file, it is necessary to include a **Procfile**.

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **Java** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: java -jar target/sample.war` <br>

### Configure build-time environment variables

You can configure the environment variables necessary to build the component using the **Build Configurations Editor** on the component **Build** page. 

!!! info
    The capability to configure build-time environment variables is not available for components created using **Ballerina** or **WSO2 MI** buildpacks.

During the build process, the build-time environment variables and their values are passed to the buildpack. Therefore, you can configure both buildpack-specific environment variables and those required for the component build.

For example, if you want to override the Maven command of the **Java** buildpack, you can use `GOOGLE_MAVEN_BUILD_ARGS` as the environment key and `clean install` as the value. 

For more examples, see [Google Cloud's buildpacks documentation](https://cloud.google.com/docs/buildpacks/service-specific-configs).


# Develop a Webhook

Choreo allows developers to design high-quality webhooks. To explore this capability, let's consider a scenario where a team of software engineers in an organization should be notified via email whenever someone creates a GitHub issue with the `bug` label in a specific repository.

In this tutorial, you will address the requirement by doing the following:

- Create a webhook by connecting to a forked GitHub repository where you have the webhook implementation that addresses the described requirement.
- Deploy the webhook to the development environment.
- Modify the webhook implementation to connect the webhook to GitHub, enabling it to act in response to selected GitHub-related events.
- Test the webhook.
- Promote the webhook to the production environment.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

## Step 1: Create a webhook component

To create a Webhook component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Webhook** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following information:

    | **Field**                     | **Description**    |
    |-------------------------------|--------------------|
    | **GitHub Account**            | Your account       |
    | **GitHub Repository**         | choreo-samples     |
    | **Branch**                    | main               |
    | **Component Path**              | `github-event-to-email-webhook` |

6. Select **Ballerina** as the build pack.
7. Provide a display name, a unique name and description for the component.
8. Click **Create**.

Choreo creates the Webhook component with the sample implementation and opens the component **Overview** page.

## Step 2: Deploy

To deploy the webhook to the development environment, follow these steps:

1. In the Choreo Console left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**.
3. In the **Configurations** pane, enter the following information:
    1. In the **webhookSecret** field, enter any value.

        !!! note
            Save this value for later use.

    2. In the **toEmail** field, enter the email address to send notification emails.
    3. Click **Deploy**.

    You can monitor the deployment progress in the **Console** pane that opens on the right of the page.

Once Choreo completes the deployment, the **Development** card indicates the **Deployment Status** as **Active**.

!!! note
    In the deployment card, you can click the icon corresponding to configurables to open the **Configurations** pane and edit configurations.

## Step 3: Connect the webhook to the GitHub repository

To allow the webhook to read the labels of issues in a specific GitHub repository, connect the webhook to the GitHub repository:

1. In the Choreo Console left navigation menu, click **Overview**.
2. On the **Overview** page, copy the invoke URL by clicking the copy icon within the **URL** field.
3. Go to your GitHub account and open the repository for which you want to generate notification emails.
4. In the top menu, click the **Settings** tab.
5. In the left navigation menu, click **Webhooks**.
6. Click **Add webhook** and enter the following information:

    | **Field**        | **Value**                                                          |
    |------------------|--------------------------------------------------------------------|
    | **Payload URL**  | The invoke URL you copied in Step 3, sub-step 1.                   |
    | **Content Type** | Select `application/json`                                          |
    | **Secret**       | The last webhook secret you configured in [Step 2](#step-2-deploy).| 

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Project Path** specifies the location of the project to build the component.

7. Under **Which events would you like to trigger this webhook?**, select **Let me select individual events**.
8. Select the **Issues** checkbox in the list of events displayed. This ensures that GitHub issues trigger the webhook.
9. Clear the **Pushes** checkbox to ensure that GitHub does not trigger your webhook when the team pushes changes to the selected GitHub repository.
10. Click **Add webhook** to save the configuration.

Now you have integrated Choreo with GitHub via the webhook you created and deployed. You can proceed to test the webhook.

## Step 4: Test

To test your webhook, create a GitHub issue with the `Bug` label in the repository that you connected to the webhook. You will receive an email similar to the following at the email address you provided in [Step 2](#step-2-deploy).

## Step 5: Promote

To promote the webhook to the Production environment, follow these steps:

1. On the **Deploy** page, go to the **Development** card and click **Promote**.
2. In the **Configuration Types** pane, leave the default selection (i.e., **Use default configuration values**) unchanged.

    !!! note
        If you have configured any default values for the configurable variables, selecting **Use default configuration values** allows you to proceed with those values. If not, specify values for the configurable variables.

3. Click **Next**.
4. In the **webhookSecret** field, enter any value.

    !!! note
        Save this value for later use.

5. In the **toEmail** field, enter the email address to send notification emails.
6. Click **Promote**.

    Once the component is promoted to production, the **Production** card displays the deployment status as **Active**.

Now you have successfully created, deployed, and tested a Webhook component and promoted it to production.


# Develop an External Consumer

An external consumer in Choreo is any client that can interact with services deployed in Choreo, as an entity hosted outside of the Choreo infrastructure. It is a generic component type that allows you to represent and manage any client, such as a mobile application, web application, server-to-server integration, bot, microservices, etc.

In this guide, you will:

 - Create an external consumer component.
 - Manage authentication for the external consumer.
 - Connect the external consumer to a service deployed in Choreo.
 
## Prerequisites

Before you try out this guide, complete the following steps:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

## Step 1: Create an external consumer component
 
To create an external consumer component, follow the steps given below:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **External Consumer** card. 
4. In the **Create an External Consumer** pane that opens, enter a display name, a unique name, and a description for the component.
5. Click **Create**. This creates the component and takes you to its **Overview** page.
   
## Step 2: Manage authentication for the external consumer

You can configure the external consumer to work with the Choreo built-in identity provider or any external identity provider that supports OIDC/OAuth 2.0.

Click the respective tab for details depending on the identity provider you want to configure: 

=== "Choreo built-in identity provider"

     Follow the steps given below to configure the built-in identity provider by generating authentication keys:

    !!! note
         Choreo built-in identity provider is configured by default. Therefore, this step is optional.

     1. In the **Overview** page of the component, under **Authentication Configurations**, click **Configure** corresponding to the environment for which you want to configure an identity provider.
     2. In the **Identity Provider** list, select **Choreo Built-In Identity Provider**.
     3. Click **Generate Keys**. 

        !!! Note
             If you see **Regenerate Secret** instead of **Generate Keys**, it indicates that OAuth keys are already generated for the component in the selected environment.

=== "An external identity provider"

     **Step 2.1: Create and configure an OIDC/OAuth 2.0 application in the external identity provider**

     1. Create an OIDC/OAuth 2.0 application in your external identity provider.
     2. Configure the OIDC/OAuth 2.0 application accordingly. (The access token type should be configured as JWT)

     **Step 2.2: Link the OIDC/OAuth 2.0 application to the Choreo component**

     3. In the **Overview** page of the component, under **Authentication Configurations**, click **Configure** corresponding to the environment for which you want to configure an identity provider.
     4. In the **Identity Provider** list, select your identity provider.
     5. Paste the **Client ID** of the OIDC/OAuth 2.0 application you created in your external identity provider.
     6. Click **Add Keys**.

## Step 3: Connect the external consumer to a service deployed in Choreo 

To establish connections from the external consumer to services deployed in Choreo, you can create connections. For step-by-step instructions on creating a connection, see [Create a Connection](./sharing-and-reusing/create-a-connection.md).


# Develop Components Using VS Code

The [Choreo VS Code extension](https://marketplace.visualstudio.com/items?itemName=WSO2.choreo) provides comprehensive component management capabilities to streamline local development within Choreo.

## Prerequisites

To ensure a smooth development experience with the Choreo extension, make sure you have the following:

1. [Visual Studio Code](https://code.visualstudio.com/download) installed with the [Choreo extension](https://marketplace.visualstudio.com/items?itemName=WSO2.choreo) version **2.0.0** or later.

2. A locally cloned GitHub repository to create new components or link to existing Choreo components.

3. [Git](https://git-scm.com) version 2.0.0 or later.

## Get started

To use the capabilities of the Choreo extension in the VS Code editor, you need an active [Choreo account](https://wso2.com/choreo/pricing/). If you already have an account, follow these steps to set up the extension:

1. Install the [Choreo VS Code extension](https://marketplace.visualstudio.com/items?itemName=WSO2.choreo) and wait for activation. On successful activation, the Choreo extension opens in the VS Code editor. 
2. Sign in to Choreo using one of the following methods:
    - In the Choreo activity pane, click **Sign In**.
       ![Sign in](../assets/img/develop-components/develop-using-vs-code/sign-in.png)
    - Use the `Sign In` command provided by the Choreo extension.

    This redirects you to an external URI to complete the authentication process. On successful sign-in, the Choreo activity pane displays your account details along with any components detected within the VS Code workspace.

## Create a new component

1. Open the source code directory where you want to build, deploy, and manage components using Choreo.
2. Create a new component using one of the following methods:
    - In the Choreo activity pane, click **Create Component**.
       ![Create Component Button](../assets/img/develop-components/develop-using-vs-code/create-component-btn.png)
    - Use the `Create New Component` command provided by the Choreo extension.

3. If the Choreo extension cannot determine the project context of the opened workspace, it prompts you to select the organization and the project to which the new component belongs.
4. Specify component details such as the name, type, buildpack, etc.

    ![Component Form](../assets/img/develop-components/develop-using-vs-code/component-form.png)
            
    On successful creation, the component details view opens, and the Choreo activity pane displays the new component.

    ![Component Details](../assets/img/develop-components/develop-using-vs-code/component-details-view.png)
     
    !!! tip
        Once the component is created, a `.choreo/context.yaml` file is generated in the root of the Git repository. For more details, see [Understand the project context](#understand-the-project-context).

The component details view allows you to manage your component by performing various actions such as the following:

 - Triggering builds for selected commits.
 - Viewing lists of builds and statuses.
 - Diagnosing build failures with build logs.
 - Deploying builds in available environments.
 - Accessing runtime logs and deployed component URLs.
 - Invoking deployed service endpoints.

## Understand the project context

Context files contain metadata related to the project, allowing the extension to establish an association between local directories and Choreo projects. These files, such as the `context.yaml`file, resides in the `/.choreo` directory within the root of the Git repository.

The Choreo extension scans the root of the opened Git repository to find the `context.yaml` file and lists the components of the associated project. This allows you to easily open and manage the components they are developing within the VS Code workspace.

A `context.yaml` file can contain multiple projects, whereas, a workspace opened via VS Code can have multiple `context.yaml` files with different project associations. In such cases, VS Code allows you to switch between these projects, add new project associations, or remove existing ones, allowing you as a developer to focus on components of a particular project at a time.

You can decide whether to commit the `context.yaml` file to the Git repository. Committing this file enables other team members working on the same repository to have a seamless developer experience with Choreo.

If the `context.yaml` file for a particular project is not committed to the Git repository or is unavailable for other reasons, you can easily regenerate it using one of the following methods:

 - In the Choreo activity pane, click **Link Directory**.
    ![Link Directory](../assets/img/develop-components/develop-using-vs-code/link-dir-btn.png)
 - Use the `Link Directory` command provided by the Choreo extension.

## Discover additional features

To access a range of functionalities provided by the Choreo extension, open the VS Code command palette and type `Choreo`.

## Troubleshoot issues

To troubleshoot Choreo extension issues, follow these steps:

1. To open the **OUTPUT** pane, go to the VS Code editor main menu, click **View**, and then click **Output**.

2. Select **Choreo** from the drop-down menu on the right-hand side to view the Choreo output for troubleshooting.

## Get help

For assistance with the Choreo VS Code extension, create [GitHub issues](https://github.com/wso2/choreo-vscode/issues).


# Develop Components With Git

Choreo enables you to develop components by connecting your GitHub, Bitbucket, or GitLab repository. You have the flexibility to either connect an existing repository or start with an empty repository and commit the source code later. By integrating your repositories with Choreo, you can automate tasks and optimize workflows across multiple systems, all within the Choreo platform.  Choreo currently supports GitHub, Bitbucket, and GitLab as Git providers. 

!!! tip
    Choreo supports both Bitbucket Server and Bitbucket Cloud. The currently supported Bitbucket Server version is 8.9.2.

In Choreo, you can connect a Git repository that contains Ballerina source code or a Docker project. To connect a Git repository to Choreo as a Docker project, your Git repository must include the following:

 - A Dockerfile: Specifies the instructions to build the Docker image. 
 - A build context: A set of files in the specified path used to build the image.

Once you connect your Git repository to Choreo, you can build, deploy, and manage your application easily. 

## Connect a Git repository to Choreo

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the Choreo Console header, go to the **Organization** list and select your organization. 
3. In the left navigation menu, click **Settings**. This opens the organization-level settings page. 
4. Click the **Credentials** tab. 
5. Click **+Add Credentials** to configure the Git repository connection.
6. Enter a **Credential Name**, select the Git provider, and enter the **Personal Access Token** you obtained from the Git provider.
7. Click **Save**.  

## Authorize GitHub with Choreo 

Authorizing Choreo as a GitHub application grants Choreo the following permissions to perform the respective actions on your behalf within the repository:

|Permission   | Read| Write| Description                                                           |
|-------------|-----|------|-----------------------------------------------------------------------|
|Issues       | Y   | N    | Read component ID label to filter the pull requests                   |
|Metadata     | Y   | N    | List repositories                                                     |
|Contents     | Y   | Y    | List branches and create a branch to commit sample code               |
|Pull Request | Y   | Y    | Create a pull request if you start with a Choreo sample               |
|Webhooks     | Y   | Y    | Trigger automatic deployment and configuration generation             |

### Add Git submodules to a project

Choreo provides [Git submodule](https://git-scm.com/book/en/v2/Git-Tools-Submodules) support when you connect your GitHub repository to Choreo. This allows you to manage and include external repositories effectively within Choreo build pipelines. Key benefits of this capability include:

  - **Code sharing without duplication**: Use submodules to maintain shared libraries across multiple projects, ensuring a single source of truth.
  - **Efficient third-party library management**: Manage third-party libraries as submodules to update them independently and track changes easily, avoiding direct code integration.

For example, when you [work with the Micro Integrator (MI) runtime in Choreo](./work-with-the-micro-integrator-runtime-in-choreo.md), you can use Git submodules to reuse MI templates and sequences across components without duplication.

!!! info "Note" 
    If you encounter an error stating that you cannot clone a submodule due to insufficient permissions, follow the instructions below to grant the necessary permissions:

      - For a personal account:

         1. Sign in to your personal GitHub account.
         2. In the upper-right corner, click your profile picture, and then click **Settings**.
         3. In the left navigation menu, go to the **Integrations** section and click **Applications**.
         4. Under the **Installed GitHub Apps** tab, click **Configure** corresponding to **choreo.dev**.
         5. Under **Repository Access**, grant access to the necessary repositories.

      - For an organization account:

         1. Sign in to your organization's GitHub account.
         2. In the upper-right corner, click your profile picture, and then click **Settings**.
         3. In the left navigation menu, go to the **Third-Party Access** section and click **GitHub Apps**.
         4. Click **Configure** corresponding to **choreo.dev**.
         5. Under **Repository Access**, grant access to the necessary repositories.

            !!! note
                Choreo currently does not support accessing private repositories in other organizations.

#### Automatically pull latest versions of Git submodules

Choreo lets you automatically pull the latest versions of Git submodules from their respective repositories. To enable this feature, follow these steps:

!!! note 
    Choreo currently supports this feature only for components where the buildpack is **WSO2 MI**.

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click the component for which you want to pull the latest versions of Git submodules.
3. In the left navigation menu, click **Build**.
4. On the **Build** page, click to edit **Build Configurations**.
5. Turn on the **Pull Latest Submodules** toggle.

    !!! info "Note"
        If you rebuild a previously built commit and it doesn’t reflect the latest changes, follow these steps to ensure the changes are applied to the deployed environment:

         1. In the Choreo Console left navigation menu, click **DevOps**, then click **Containers**.
         2. Click **Edit** to update the container settings.
         3. Select **Always** as the **Image Pull Policy**.
         4. Click **Save Changes**.

## Authorize Bitbucket with Choreo

Authorizing using a personal access token (PAT) from Bitbucket grants Choreo the following permissions to perform the respective actions on your behalf within the repository.

|Permission    | Read| Write| Description                                                        |
|--------------|-----|------|--------------------------------------------------------------------|
|Account       | Y   | N    | Get user information and workspace details                         |
|Repositories  | Y   | Y    | List branches and create a branch to commit sample code            |
|Pull Requests | Y   | Y    | Create a pull request if you start with a Choreo sample            |
|Webhooks      | Y   | Y    | Trigger automatic deployment and configuration generation          |

## Authorize self-managed GitLab with Choreo

Authorizing using a personal access token (PAT) obtained from your GitLab self-managed server grants Choreo the following permissions to perform the respective actions on your behalf within the repository.

|Permission    | Description                                                                         |
|--------------|-------------------------------------------------------------------------------------|
|API           | Grants full read/write access to the API, covering all groups and projects, as well as read/write access to the repository.|


 # Bring Your Own Image (BYOI)

Choreo allows you to deploy and manage prebuilt container images from external container registries as Choreo components. This enables you to deploy and effectively manage your container images within the Choreo environment.

!!! info
    This feature is currently only available on [private data planes (PDPs)](../choreo-concepts/data-planes.md#private-data-planes) for the following component types:

    - Service
    - Web Application
    - Scheduled Task
    - Manual Task


## Prerequisites

Before you try out this guide, ensure you have the following:

- **A container registry**: Ensure you have a container registry containing the images you want to deploy. Choreo is compatible with various container registries, including but not limited to GCR (Google Container Registry), ACR (Azure Container Registry), GitHub Container Registry, and Docker Hub.

- **An image in the registry**: You need an image ready for deployment.

- **(Optional) An external build/CI pipeline**:  This is to initiate automatic deployments during the build process outside of Choreo.

When using a container registry to deploy a component, Choreo cannot create an image from the source code (Git) or initiate a new deployment when a new image is ready. However, you can use your existing build process to trigger a deployment on Choreo by sending an HTTP POST request to a webhook with the new image details.

This feature is currently only available on private data planes (PDPs). You can find this option under **Deploy an image from a container registry** in the **Select Source** step during component creation for service components, web applications, scheduled tasks, and manual tasks.

## Step 1: Register a container registry

To get started, establish a connection between your container registry and Choreo. 

!!! Info
    When you use your Choreo credentials, Choreo does not *pull* your images into its control plane. Instead, it functions as an orchestrator, facilitating your data plane's ability to retrieve images from an external container registry. Choreo passes on these credentials to the data plane for authentication and access.

To register your container registry, follow these steps:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the Choreo Console header, go to the **Organization** list and select your organization. 
3. In the left navigation menu, click **Settings**. This opens the organization settings page. 
4. Click the **Credentials** tab and then click the **Container Registries** tab. 
5. Click **+Add Registry** to configure the Git repository connection.
6. Specify a **Registry Display Name**.
7. Select the **Authentication Type**. Fill in the required information depending on your authentication type. For details on each authentication type, see [Authentication types](#authentication-types).
8. Click **Save**.

### Authentication types

Choreo provides the following authentication options:  

#### Public (anonymous) access
    
You can use this option to establish a connection with a container registry that permits unrestricted public or anonymous access (for example, Public Docker Hub). In this case, only the registry host information is necessary.

For example, the following are the Docker Hub registry hosts for reference:

| Vendor                           | Registry host                |
|----------------------------------|------------------------------|
|Docker Hub (public repositories)  | `registry.hub.docker.com`    |
|Docker Hub (private repositories) | `registry.docker.com`        |

\* If necessary, you can use other mirrors instead of the above.

#### Basic authentication

To use basic authentication to authenticate to the container registry, you must provide the username and password.

#### Docker config

You can provide a Docker config in JSON format to authenticate to the container registry. This option only allows you to register one container registry. That is, it **only allows a single registry under `auths`**.

You must provide the credentials directly within the configuration. Choreo cannot utilize references to executable authentication plugins.

Sample Docker config format:

```json
    {
    "auths": {
        "index.docker.io/v1/": {
        "auth": "c3R...zE2"
        }
    }
    }
```

#### Vendor-specific authentication

This option is specifically for private data planes, where your cloud provider manages authentication at the Kubernetes level. Choreo requires knowledge of the registry host because the data plane already possesses implicit (preconfigured) access to the registry.

Follow the guidelines below based on your container registry:

=== "ACR"
    **Azure Container Registry** 

    Recommended authentication options:

    * [**Service principal-based basic authentication**](https://learn.microsoft.com/en-us/azure/container-registry/container-registry-auth-service-principal)

    * **Vendor-specific authentication on Azure private data planes**
        
        Contact Choreo support to enable infrastructure-level private access to your registry from your Azure private data plane on AKS. If you are on a self-managed PDP on Azure, follow [this guide](https://learn.microsoft.com/en-us/azure/aks/cluster-container-registry-integration?toc=%2Fazure%2Fcontainer-registry%2Ftoc.json&bc=%2Fazure%2Fcontainer-registry%2Fbreadcrumb%2Ftoc.json&tabs=azure-cli).

=== "GAR"
    **Google Artifact Registry**

    Recommended authentication options:

    * [**Service account-based basic authentication**](https://cloud.google.com/artifact-registry/docs/docker/pushing-and-pulling#key)

        Use the service account key in JSON format ([`_json_key`](https://cloud.google.com/artifact-registry/docs/docker/authentication#:~:text=of%20the%20following%3A-,_json_key,-if%20you%20are)) as the username and specify the minified JSON contents of the service account key as the password.

         You can use `jq` as follows to minify the service account JSON key file:

         `jq -c . <service-account.json>`

    * **Vendor-specific authentication on GCP private data planes**

        Contact Choreo support to enable infrastructure-level private access to your registry from your GCP private data plane on GKE. If you are on a self-managed PDP on GCP, see [https://cloud.google.com/artifact-registry/docs/access-control#grant-project](https://cloud.google.com/artifact-registry/docs/access-control#grant-project).

=== "AWS ECR"
    **Elastic Container Registry**

    ECR does not allow the creation of static access passwords for basic authentication. The passwords (that is, access tokens) provided by AWS are only valid for 10 hours and must be manually regenerated. However, when an ECR is attached to an EKS cluster at an infrastructure level, this limitation does not apply because the authentication is handled by AWS internally. For details, see [https://docs.aws.amazon.com/AmazonECR/latest/userguide/registry_auth.html](https://docs.aws.amazon.com/AmazonECR/latest/userguide/registry_auth.html).

    Choreo recommends using ECR when you are exclusively on an AWS private data plane using the vendor-specific authentication option. Contact Choreo support to enable a private connection between your ECR and the underlying EKS clusters on your data plane. If you are on a self-managed PDP, you can follow [this guide](https://docs.aws.amazon.com/AmazonECR/latest/userguide/ECR_on_EKS.html).    

=== "Docker Hub (Private)"

    Recommended authentication options:

    * **Basic authentication**

          Use your Docker Hub username/password or an access token. You can generate an access token from your Docker Hub account settings and use it in place of the password. For details, see [https://docs.docker.com/docker-hub/access-tokens/](https://docs.docker.com/docker-hub/access-tokens/).

    * **Docker config**

          Sign in to the Docker CLI and copy the contents of the docker config JSON. Note that external credential stores and multiple repositories within the same config object are not supported. For more information, see [https://docs.docker.com/engine/reference/commandline/login/](https://docs.docker.com/engine/reference/commandline/login/).

=== "GHCR"
    **GitHub Container Registry**

    Recommended authentication option:

    * **Basic authentication using a PAT token**

          Create a personal access token (PAT) and use it in place of the password. You cannot use your own GitHub password. You must provide a [PAT token](https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry#authenticating-with-a-personal-access-token-classicn).
  
## Step 2: Create a component in Choreo

1. In the left navigation, click **Overview** and select your project. Alternatively, select your project from the **Project** list in the Choreo Console header. 
2. Under **Component Listing** click **+ Create**.
3. Select your component type (BYOI is only available for Service, Web Application, Scheduled Task, or Manual Task components). 
4. From the Create Component pane, select the **Container Registry** under the **Connect a Docker Image** section.
5. Under **Deploy an image from Container Registry/Docker Hub**, select the container registry you have registered in [Step 1](#step-1-register-a-container-registry).
6. Enter the full image URL. The image URL format in general is as follows:
   `[container-registry-host]/[repository-name]/[image-name]:[tag]`

    !!! tip
        When a public image from Docker Hub lacks a specified repository name, it typically defaults to `/library/`. For example, you can access the public Nginx image `https://hub.docker.com/_/nginx` as `registry.hub.docker.com/library/nginx:1.25`.

7. Enter a display name, a unique name, and a description for the component.
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.


## Step 3: Deploy the component in Choreo

To deploy the component and bring your image to Choreo, follow the steps given below: 

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Update Image & Deploy**. 
3. In the **Endpoint** pane that opens, you can see the endpoint ready to be deployed. Click the edit icon next to the endpoint name. Optionally, you can define the endpoints for your service when you manually deploy the service. For more information, see [Expose service endpoints](#step-4-expose-service-endpoints).
4. Change the **Network Visibility** to **Public**. This setting securely exposes the endpoint for consumption.
5. Click **Update**.

    !!! info
         In this example, you deploy a Ballerina service as a REST endpoint. Therefore, Choreo generated the REST endpoint automatically. If you deploy a non-Ballerina service, you must manually add the REST endpoint and set the network visibility to **Public**.

6. Select your update image option. Refer to the update options listed below.

    You have the capability of updating the image when you are deploying the component in Choreo in one of the following three ways:

    | Option                   |Description                                                                                             |
    |--------------------------|--------------------------------------------------------------------------------------------------------|
    | **Update Image Tag**     | This option allows you to update the tag of the image.                                                 |
    | **Update Image URL**     | With this option, you can change the image name, tag, and the image repository of the image URL.|
    | **Previous Images**      | This option allows you to select a previous image and redeploy the image.                               |

7. Click **Deploy**. This deploys the service to the development environment.

## Step 4: Expose service endpoints 

!!! info
    This section only applies to service components.

After creating a service component in Choreo, you have the option to define the endpoints for your service when manually deploying a new image.

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Update Image & Deploy**. 
3. In the **Endpoint** pane that opens, optionally, you can define the endpoints for your service when you manually deploy the service. 
4. Click  **Create/Update Endpoints**.
5. Under the **Edit endpoints.yaml** section, you can edit the endpoints YAML file in the provided editor. 
   Alternatively, you can upload the associated API specification/schema files (OpenAPI/GraphQL schemas). Instead of specifying the file path, you can also reference this file in the `endpoints.yaml` file by its file name, similar to the Git-based Choreo components. The endpoints template follows the standard definitions for defining endpoints in Choreo. For more details, see [Configure Endpoints](../develop-components/configure-endpoints.md).

## Auto-deploy images in Choreo with an external CI/build pipeline

Choreo does not have automatic detection and deployment for newly added images or tags in the linked container registry. To overcome this limitation, Choreo allows you to integrate your own CI pipelines and initiate deployments manually. This approach enables you to use your existing CI setup or build a pipeline for image creation and pushing. You can then trigger automatic deployments using a webhook.

Follow the steps below to configure your CI/build pipeline:

1. Build and push the container image associated with a Choreo component to your container registry.
2. In the left navigation menu, click **DevOps** and then click **External CI**.
3. Generate a token for your CI pipeline from the **Manage Tokens** section. 

    !!! note
        - The tokens are bound to a specific component.
        - It is recommended to reference the token from a secure location available to your CI pipeline. For example, use a GitHub secret if you are using GitHub Actions.

4. To trigger an automatic deployment to your development environment, you can initiate an HTTP POST request to the Choreo webhook endpoint with the updated image details. Alternatively, you can use the provided Webhook snippets. This action will seamlessly deploy the image to the development environment.



Services and integrations are exposed to other services, integrations, or applications through endpoints. A service or an integration can expose multiple endpoints, each representing a unique entry point into the service. For example, a service may expose a REST API endpoint and a GraphQL endpoint, each providing different ways to interact with the service. Endpoints provide specific details for how the service or the integration can be consumed. For instance, the port number, protocol, and the schema such as open API specification (OAS) or GraphQL schema. By defining these details, endpoints make it possible for other services, integrations, and applications to discover and interact with the service in a standardized way.

Choreo defines endpoints by combining port binding, protocol, endpoint name, network visibility, endpoint schema, and additional protocol-related fields. The following table describes each attribute of an endpoint.

| Field | Description |
| ----- | ----------- |
| Name | A unique identifier for the endpoint within the service component. |
| Port | The network port on which the endpoint is accessible. |
| Type | The endpoint protocol. Supported protocols: REST, GraphQL, gRPC, WS, UDP, and TCP. |
| Network Visibility | Determines the level of visibility of an endpoint. Possible values are: <ul><li>Project: Allows components within the same project to access the endpoint.</li><li>Organization: Allows any component within the same organization to access the endpoint but restricts access to components outside the organization.</li><li>Public: Allows any client to access the endpoint, regardless of location or organization.</li></ul> |
| Schema | Specifies the structure and format of the data exchanged through the endpoint. |
| Context (HTTP and GraphQL only) | A context path that you add to the endpoint's URL for routing purposes. |

## Configure endpoints
The method of defining endpoints depends on the buildpack.

* For `Ballerina` and `WSO2 MI` buildpacks, Choreo automatically detects the endpoint details for REST APIs.
* For all other buildpacks (Java, Python, NodeJS, Ruby, PHP, Go, Dockerfile, etc.), you can configure endpoints in one of the following ways:
  
    * **Using the Choreo Console**: If a `component.yaml` file is not present, you can define a basic endpoint configuration during component creation.
    * **Using the component.yaml file**: You can manually configure endpoint details by defining them in a `component.yaml` file, placing it inside the `.choreo` directory at the build context path, and committing it to the source repository.

You can override UI-defined and auto-generated endpoints by providing a `component.yaml` file in the `.choreo` directory, which will take priority over other configurations.

To learn about the `component.yaml` file, see [Overview of the component.yaml file](../develop-components/manage-component-source-configurations.md#overview-of-the-componentyaml-file).
!!! note
    Automatic endpoint generation is not supported for dynamic endpoint parameters such as variable ports. Therefore, you must use an `component.yaml` file to define dynamic endpoint parameters.

To learn about the `component.yaml` file, see [Overview of the component.yaml file](../develop-components/manage-component-source-configurations.md#overview-of-the-componentyaml-file).

## Expose endpoints as managed APIs

Exposing endpoints as managed APIs is crucial to ensure secure and controlled access to the services being exposed. When a user wants to expose their written service to the outside world or to the organization at large, there is an inherent security risk involved. To mitigate this risk, the Choreo platform is built with an internal (access within the organization only) or external (publicly accessible) gateway that is protected with Choreo API management making the services secure by design.

!!! note
    This feature is not available for gRPC, UDP, and TCP endpoints.

If you want to expose an endpoint as a managed API in Choreo, you need to set the network visibility to either Organization or Public. This allows the endpoint to be exposed through the Choreo API Gateway, which provides a number of benefits, including:

* Expose APIs to external and internal consumers
* Full lifecycle API Management
* API throttling
* Secure APIs with industry-standard authorization flows
* API analytics and monitoring

Once you deploy the service component, Choreo will expose the endpoint as a managed API through the Choreo API Gateway. You can then use the full lifecycle API management features provided by Choreo to test, deploy, maintain, monitor, and manage your API using the API management features.

## Understand the default component URL

The default URL of a component corresponds to the default endpoint of the component and is structured as follows:

`<domain>/<project-name>/<component-name>`

This URL does not include the default endpoint name. For all other endpoints, the URL structure includes the endpoint name, as follows:

`<domain>/<project-name>/<component-name>/<endpoint-name>`

If a component has multiple endpoints, Choreo allows you to change the endpoint corresponding to the default component URL. For a component with a single endpoint, the default URL automatically corresponds to that endpoint.

### Change the default endpoint of a component

To change the default endpoint of a component, follow the steps given below:

!!! note
     - You cannot change the default endpoint if it has associated published APIs. You must go to the **Lifecycle** page and unpublish the relevant APIs before updating the default endpoint. For instructions on unpublishing an API, see [Lifecycle Management](https://wso2.com/choreo/docs/api-management/lifecycle-management/).
     - Choreo does not allow you to change the default endpoint of a component if you create multiple deployment tracks within its current major version, or promote the component beyond its initial environment.

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to change the default endpoint.
3. In the left navigation menu, click **Deploy**.
4. On the **Deploy** page, go to the **Set Up** card and click **Configure & Deploy**.
5. In the **Environment Configurations** pane that opens, click **Next**.
6. In the **File Mount** pane that opens, click **Next**.
7. In the **Endpoint Details** pane that opens, click the **Default Endpoint** list, select the endpoint you want to set as the default endpoint, and then click **Update**.
8. Click **Deploy**. This deploys the component with the selected endpoint as the default, and the default URL will now correspond to this endpoint.  

### Edit a UI-Defined Endpoint
If you defined an endpoint during component creation, you can edit it later by following these steps:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to update the endpoint.
3. In the left navigation menu, click **Deploy**.
4. On the **Deploy** page, go to the **Set Up** card and click **Configure & Deploy**.
5. In the **Environment Configurations** pane that opens, click **Next**.
6. In the **File Mount** pane that opens, click **Next**.
7. In the **Endpoint Details** pane that opens, locate the endpoint you want to edit.
8. Click the **Edit** icon next to the endpoint, modify the editable fields, and click **Update**.
9. Click **Deploy** to apply the changes.

!!! note
     If you commit a `component.yaml` file, build the component, and proceed with deployment, the endpoints will be generated from the `component.yaml` file and will take priority. In this case, the endpoint cannot be edited through the UI. To modify the endpoint, you must update the`component.yaml` file.


# Configure Endpoints
{% include "configure-endpoints-body.md" %}

# Deploy a Containerized Application 

Using Choreo, you can easily deploy applications written in different language frameworks (such as Java, Go, NodeJS, Python, etc.) on shared or private data planes using containers.

Choreo supports deploying containerized applications for the following component types:

- Service
- Web Application
- Scheduled Task
- Manual Task
- Event Handler
- Test Runner

## Connect your repository to Choreo

To connect your GitHub repository to Choreo, you should authorize the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application to access your account or organization. When you attempt to connect your GitHub repository via the Component creation page, the Choreo Apps authorization prompt will appear.

* Connect GitHub Repository
    
    ![Connect GitHub Repository](../assets/img/develop-components/deploy/create-component-authz-github-page.png){.cInlineImage-threeQuarter}

* Authorize GitHub Application
    
    ![Authorize GitHub Application](../assets/img/develop-components/deploy/authz-choreo-github-app.png){.cInlineImage-half}

* Grant Repository Access

    ![Grant Repository Access](../assets/img/develop-components/deploy/github-repo-access.png){.cInlineImage-full}


    The **Choreo Apps** requires the following permission:
    
    - Read access to issues and metadata
    - Read and write access to code, pull requests, and repository hooks

!!! note
    You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. Choreo needs write access only to send pull requests to a user repository. Choreo does not directly push any changes to a repository.

Alternatively, you can connect a public repository without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. Select the **Third-Party GitHub Repository** and paste a public repository URL in the **Public Repository URL** field at the time of component creation.

!!! tip
     Authorizing the repository with the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application becomes essential if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component. If you own the repository, you can subsequently authorize it with the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application to enable **Auto Deploy**.

After granting access to the required repositories, you can choose a repository and an associated branch to connect to the Choreo component.
For the containerized application deployments, you should select the [**Component Directory**](https://docs.docker.com/build/building/context/#path-context), **Dockerfile** as the **Buildpack** and provide **Dockerfile Path** for the Docker build.

![Connected Dockerfile Repository](../assets/img/develop-components/deploy/create-component-connected-repo.png){.cInlineImage-full}

The following table describes the individual fields in the **Create Component** pane.

| **Field**               | **Description**                                                                                                                                                                      |
|-------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **GitHub Account**      | Your GitHub account or organization. If you want to add another GitHub account, you can expand the list and click **+ Add**.                                                            |
| **GitHub Repository**   | Depending on the repository access you provided, the list will show available repositories to be connected.                                                                                  |
| **Branch**              | The branch of the repository.                                                                                                                                                         |
| **Buildpack**        | Determines the implementation of the component: Any language or other language as a Docker container.                                                                                |
| **Dockerfile Path**     | The path to your Dockerfile. This path is defined relative to the repository root.<br/>For example, if the Dockerfile is at the repository root, the value for this field is `/Dockerfile`. |
| **Component Directory** | The component directory path. To include the repository root, leave the default `/` value.                                                                                          |
| **Port***               | The port at which your service is running.                                                                                                                                           |
| **OpenAPI Filepath***   | The path to an OpenAPI specification (in YAML/JSON) relative to the repository root. If you don't provide a path, the system automatically generates a default allow-all specification.    |

   
!!! note
 
    - Fields marked with **\*** are not visible for all component types.

    - To successfully build your container with Choreo, it is essential to explicitly define a User ID (`UID`) under the `USER` instruction in your Dockerfile. You can refer to the [sample Dockerfile](https://github.com/wso2/choreo-sample-apps/blob/main/go/rest-api/Dockerfile) for guidance.

    - To ensure that the defined USER instruction is valid, it must conform to the following conditions:
        
        - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
        - Usernames are not considered valid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

## Deploy the containerized component

Choreo will automatically apply deployment configurations and settings based on the component type you select during creation.
For example, if you select the **Service** component type, Choreo will deploy it as a Kubernetes deployment with appropriate scaling configurations.

You can run unit tests in the build pipeline by adding the relevant command to the Dockerfile.  For example: 

- [Go-based sample](https://github.com/wso2/choreo-sample-apps/blob/8c18c82db604adb43b89f669888a07cd6e31d7b7/go/rest-api/Dockerfile#L37)
- [Python-based sample](https://github.com/wso2/choreo-sample-apps/blob/8c18c82db604adb43b89f669888a07cd6e31d7b7/python/rest-api/Dockerfile#L15)

### Application configurations

You must provide any required configurations for running the application in the **Configs & Secrets** section of the component's **DevOps** page. Alternatively, you can also review the configurations when you manually deploy via the **Deploy** page.

After clicking the **Create** button, you can select the confidentiality of the configuration and specify how to mount it to the container.

![Application Configuration Page](../assets/img/develop-components/deploy/deploy-app-config-page.png){.cInlineImage-full}

![Create Configuration Mount Page](../assets/img/develop-components/deploy/deploy-app-config-type-mount-page.png){.cInlineImage-full}

#### Configuration types

* **ConfigMap**: Stores non-confidential data as key-value pairs.
* **Secret**: Stores and manages sensitive information, such as passwords, OAuth tokens, and ssh keys as key-value pairs.

#### Mount types

* **Environment Variables**: Mounts the selected ConfigMap or Secret as an environment variable in the container.
* **File Mount**: Mounts the selected ConfigMap or Secret as a file in the container. Here, the key is the file name, and the value is the file content.

The following image shows adding a **ConfigMap** with **File Mount** mount type to be read by the application.

![Configuration File Mount Page](../assets/img/develop-components/deploy/deploy-app-config-file-mount.png){.cInlineImage-full}

!!! note
    The JSON file includes ${DB_PASS} as an environment variable defined in a Secret. The application reads the JSON file and substitutes the placeholders with the corresponding environment variables.

### Deployment configurations

Choreo lets you configure deployment settings such as scaling, resource limits, and health checks based on your selected component type.

For more information about these configurations, see Choreo's [DevOps capabilities](../devops-and-ci-cd/view-runtime-details.md).

You can configure the **Endpoints** to expose your service using the **Service** Component in Choreo. See [Service Component Overview](../develop-components/develop-services/service-component-overview.md) for more information. 

### Build, deploy, and promote

After adding the application configuration, you can build and deploy it by clicking the **Deploy Manually** button. Choreo will start the build process with the selected commit in the **Build Area**. 

!!! note
    The **Auto Deploy on Commit** feature, which automatically builds and deploys the application upon pushing a code change to the repository, is enabled by default. To turn off this feature, navigate to the **Build Area** of the **Deploy** page.

Choreo scans your Dockerfile for security vulnerabilities during the build phase, and if there are no issues found, it proceeds with the build process. After building the image, it scans it again for vulnerabilities before deployment to the environment. You can view the build logs from the right-side panel, as shown in the image below.

![Build Logs Panel](../assets/img/develop-components/deploy/build-deploy-page-logs.png){.cInlineImage-full}

Once the build process is complete, Choreo will deploy the application automatically to the Development environment. To promote the build to higher environments, you can click the **Promote** button. The number of environment cards visible on the page may vary depending on your environment configurations.

### Troubleshoot security vulnerability scan failures (Trivy)

By default, Choreo utilizes the Aqua Trivy (OSS) image vulnerability scanner to detect security vulnerabilities in all Dockerfile-based build pipelines. The scanner will fail the pipeline if any **CRITICAL** CVEs (Common Vulnerabilities and Exposures) are detected. CVEs of other severity levels are recorded but does not fail the pipeline.

If you cannot fix a critical CVE immediately, you can opt to ignore it. To ignore a critical CVE, add a `trivyignore` (`<docker-build-context-path>/.trivyignore`) file to your build context path. In the file, add the CVEs you need the pipeline to ignore, one entry per line as follows:

```
CVE-2023-xxxx
CVE-2023-yyyy
```

You can add comments in the file by using `#` in front of the comment as follows: 

```
# comments can be added like this
CVE-2023-xxxx
```


# Deploy an Application with Buildpacks

Using Choreo, you can easily deploy applications written in different language frameworks (such as Java, Go, NodeJS, Python, Ruby, PHP, etc.) on shared or private data planes.

Choreo supports deploying applications with buildpacks for the following component types:

- Service
- Web Application
- Scheduled Task
- Manual Task
- Webhook
- Event Handler
- Test Runner

## Buildpacks
Buildpacks are a fundamental building block in modern application development. They convert your source code into a secure, efficient, production-ready container image without a Dockerfile. With Choreo, developers can take advantage of this powerful tool to effortlessly deploy their applications without the hassle of manual configuration.

Choreo uses [Google Buildpacks](https://cloud.google.com/docs/buildpacks/overview) as default buildpacks for Java, Go, NodeJS, Python, PHP, and Ruby. Choreo uses its own buildpacks for Ballerina and WSO2 MI.

## Develop a component

To develop a service component that exposes a Service in Go, you can follow the [Develop a Service ](develop-services/develop-a-service.md) guide.

Follow the guidelines below based on your language:

=== "Python"
    Supported Versions - 3.10.x, 3.11.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Reading Books List Service](https://github.com/wso2/choreo-samples/tree/main/reading-books-list-service-python)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-python-task)|

    ### Procfile
    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    
    !!! info 
        In **Python** projects, it is mandatory to have a `Procfile` with the `web` process type in the project root directory.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: python main.py` <br>
    `web: gunicorn --bind :8080 --workers 1 --threads 8 --timeout 0 main:app` <br>
    `web: flask run --host=0.0.0.0`

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Ballerina"

    Supported Versions - 2201.3.5, 2201.4.1, 2201.5.0, 2201.5.1, 201.6.0,  2201.7.0

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Echo Service](https://github.com/wso2/choreo-samples/tree/main/echo-service)|
    | Manual Task | [Covid19 Statistics To Email](https://github.com/wso2/choreo-samples/tree/main//covid19-statistics-to-email)|
    | Webhook | [Salesforce New Case To Google Sheet](https://github.com/wso2/choreo-samples/tree/main/sfdc-new-case-to-gsheet)|
    | Scheduled Task | [Shopify New Customers to HubSpot Create/Update Contact](https://github.com/wso2/choreo-samples/tree/main/shopify-new-customers-to-hubspot-contact)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Go"

    Supported Versions - 1.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Greeting Service](https://github.com/wso2/choreo-samples/tree/main/greeting-service-go)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-go-task)|
    | Web Application | [Hello World Web Application](https://github.com/wso2/choreo-samples/tree/main/hello-world-go-webapp)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== ".NET"
    Supported Versions - 6.x, 7.x, 8.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service | [Greeting Service](https://github.com/wso2/choreo-samples/tree/main/dotnet-greeter)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Java"
    Supported Versions
        - 8, 11, 17, 18 (OpenJDK Runtime Environment Temurin)

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Product Management Service](https://github.com/wso2/choreo-samples/tree/main/product-management-service)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-java-task)|

    !!! info

         When working on Java projects:

           - The `Main` class should be defined in the manifest file.
           - If Maven files such as `mvn.cmd` exist in the project without the `.mvn` directory, the build will fail. To ensure a successful build, you must either commit the `.mvn` directory along with any Maven files or not include any Maven files in the project if you choose not to commit the `.mvn` directory.
    
    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **Java** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: java -jar target/sample.jar` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "NodeJS"
    Supported Versions - 12.x.x, 14.x.x, 16.x.x, 18.x.x, 20.x.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Reading Books List Service](https://github.com/wso2/choreo-samples/tree/main/reading-books-list-service-nodejs)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-nodejs-task)|

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **NodeJS** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: node app.js` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "PHP"
    Supported Versions - 8.1.x, 8.2.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Hello World Service](https://github.com/wso2/choreo-samples/tree/main/hello-world-php-service)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-php-task)|
    | Web Application | [Hello World Web Application](https://github.com/wso2/choreo-samples/tree/main/hello-world-php-webapp)|

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **PHP** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web:php -S 0.0.0.0:8000 index.php` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Ruby"
    Supported Versions - 3.1.x, 3.2.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service | [Hello World Service](https://github.com/wso2/choreo-samples/tree/main/hello-world-ruby-service)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-ruby-task)|
    | Web Application | [Hello World Web Application](https://github.com/wso2/choreo-samples/tree/main/hello-world-ruby-webapp)|

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **Ruby** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: ruby app.rb` <br>
    `web:bundle exec ruby app.rb -p 8080` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "WSO2 MI"
    Supported Versions - 4.1.0.x, 4.2.0.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service |[Hello World Service](https://github.com/wso2/choreo-samples/tree/main/hello-world-mi)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Spring Boot"
    Supported Java Versions
        - 8, 11, 17, 18 (OpenJDK Runtime Environment Temurin)

    !!! info
         You can use this buildpack only with web applications. For other component types, use the **Java** buildpack. Additionally, if the generated artifact is a `WAR` file, it is necessary to include a **Procfile**.

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **Java** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: java -jar target/sample.war` <br>

### Configure build-time environment variables

You can configure the environment variables necessary to build the component using the **Build Configurations Editor** on the component **Build** page. 

!!! info
    The capability to configure build-time environment variables is not available for components created using **Ballerina** or **WSO2 MI** buildpacks.

During the build process, the build-time environment variables and their values are passed to the buildpack. Therefore, you can configure both buildpack-specific environment variables and those required for the component build.

For example, if you want to override the Maven command of the **Java** buildpack, you can use `GOOGLE_MAVEN_BUILD_ARGS` as the environment key and `clean install` as the value. 

For more examples, see [Google Cloud's buildpacks documentation](https://cloud.google.com/docs/buildpacks/service-specific-configs).


# Develop a Webhook

Choreo allows developers to design high-quality webhooks. To explore this capability, let's consider a scenario where a team of software engineers in an organization should be notified via email whenever someone creates a GitHub issue with the `bug` label in a specific repository.

In this tutorial, you will address the requirement by doing the following:

- Create a webhook by connecting to a forked GitHub repository where you have the webhook implementation that addresses the described requirement.
- Deploy the webhook to the development environment.
- Modify the webhook implementation to connect the webhook to GitHub, enabling it to act in response to selected GitHub-related events.
- Test the webhook.
- Promote the webhook to the production environment.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

## Step 1: Create a webhook component

To create a Webhook component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Webhook** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following information:

    | **Field**                     | **Description**    |
    |-------------------------------|--------------------|
    | **GitHub Account**            | Your account       |
    | **GitHub Repository**         | choreo-samples     |
    | **Branch**                    | main               |
    | **Component Path**              | `github-event-to-email-webhook` |

6. Select **Ballerina** as the build pack.
7. Provide a display name, a unique name and description for the component.
8. Click **Create**.

Choreo creates the Webhook component with the sample implementation and opens the component **Overview** page.

## Step 2: Deploy

To deploy the webhook to the development environment, follow these steps:

1. In the Choreo Console left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**.
3. In the **Configurations** pane, enter the following information:
    1. In the **webhookSecret** field, enter any value.

        !!! note
            Save this value for later use.

    2. In the **toEmail** field, enter the email address to send notification emails.
    3. Click **Deploy**.

    You can monitor the deployment progress in the **Console** pane that opens on the right of the page.

Once Choreo completes the deployment, the **Development** card indicates the **Deployment Status** as **Active**.

!!! note
    In the deployment card, you can click the icon corresponding to configurables to open the **Configurations** pane and edit configurations.

## Step 3: Connect the webhook to the GitHub repository

To allow the webhook to read the labels of issues in a specific GitHub repository, connect the webhook to the GitHub repository:

1. In the Choreo Console left navigation menu, click **Overview**.
2. On the **Overview** page, copy the invoke URL by clicking the copy icon within the **URL** field.
3. Go to your GitHub account and open the repository for which you want to generate notification emails.
4. In the top menu, click the **Settings** tab.
5. In the left navigation menu, click **Webhooks**.
6. Click **Add webhook** and enter the following information:

    | **Field**        | **Value**                                                          |
    |------------------|--------------------------------------------------------------------|
    | **Payload URL**  | The invoke URL you copied in Step 3, sub-step 1.                   |
    | **Content Type** | Select `application/json`                                          |
    | **Secret**       | The last webhook secret you configured in [Step 2](#step-2-deploy).| 

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Project Path** specifies the location of the project to build the component.

7. Under **Which events would you like to trigger this webhook?**, select **Let me select individual events**.
8. Select the **Issues** checkbox in the list of events displayed. This ensures that GitHub issues trigger the webhook.
9. Clear the **Pushes** checkbox to ensure that GitHub does not trigger your webhook when the team pushes changes to the selected GitHub repository.
10. Click **Add webhook** to save the configuration.

Now you have integrated Choreo with GitHub via the webhook you created and deployed. You can proceed to test the webhook.

## Step 4: Test

To test your webhook, create a GitHub issue with the `Bug` label in the repository that you connected to the webhook. You will receive an email similar to the following at the email address you provided in [Step 2](#step-2-deploy).

## Step 5: Promote

To promote the webhook to the Production environment, follow these steps:

1. On the **Deploy** page, go to the **Development** card and click **Promote**.
2. In the **Configuration Types** pane, leave the default selection (i.e., **Use default configuration values**) unchanged.

    !!! note
        If you have configured any default values for the configurable variables, selecting **Use default configuration values** allows you to proceed with those values. If not, specify values for the configurable variables.

3. Click **Next**.
4. In the **webhookSecret** field, enter any value.

    !!! note
        Save this value for later use.

5. In the **toEmail** field, enter the email address to send notification emails.
6. Click **Promote**.

    Once the component is promoted to production, the **Production** card displays the deployment status as **Active**.

Now you have successfully created, deployed, and tested a Webhook component and promoted it to production.


# Develop an External Consumer

An external consumer in Choreo is any client that can interact with services deployed in Choreo, as an entity hosted outside of the Choreo infrastructure. It is a generic component type that allows you to represent and manage any client, such as a mobile application, web application, server-to-server integration, bot, microservices, etc.

In this guide, you will:

 - Create an external consumer component.
 - Manage authentication for the external consumer.
 - Connect the external consumer to a service deployed in Choreo.
 
## Prerequisites

Before you try out this guide, complete the following steps:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

## Step 1: Create an external consumer component
 
To create an external consumer component, follow the steps given below:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **External Consumer** card. 
4. In the **Create an External Consumer** pane that opens, enter a display name, a unique name, and a description for the component.
5. Click **Create**. This creates the component and takes you to its **Overview** page.
   
## Step 2: Manage authentication for the external consumer

You can configure the external consumer to work with the Choreo built-in identity provider or any external identity provider that supports OIDC/OAuth 2.0.

Click the respective tab for details depending on the identity provider you want to configure: 

=== "Choreo built-in identity provider"

     Follow the steps given below to configure the built-in identity provider by generating authentication keys:

    !!! note
         Choreo built-in identity provider is configured by default. Therefore, this step is optional.

     1. In the **Overview** page of the component, under **Authentication Configurations**, click **Configure** corresponding to the environment for which you want to configure an identity provider.
     2. In the **Identity Provider** list, select **Choreo Built-In Identity Provider**.
     3. Click **Generate Keys**. 

        !!! Note
             If you see **Regenerate Secret** instead of **Generate Keys**, it indicates that OAuth keys are already generated for the component in the selected environment.

=== "An external identity provider"

     **Step 2.1: Create and configure an OIDC/OAuth 2.0 application in the external identity provider**

     1. Create an OIDC/OAuth 2.0 application in your external identity provider.
     2. Configure the OIDC/OAuth 2.0 application accordingly. (The access token type should be configured as JWT)

     **Step 2.2: Link the OIDC/OAuth 2.0 application to the Choreo component**

     3. In the **Overview** page of the component, under **Authentication Configurations**, click **Configure** corresponding to the environment for which you want to configure an identity provider.
     4. In the **Identity Provider** list, select your identity provider.
     5. Paste the **Client ID** of the OIDC/OAuth 2.0 application you created in your external identity provider.
     6. Click **Add Keys**.

## Step 3: Connect the external consumer to a service deployed in Choreo 

To establish connections from the external consumer to services deployed in Choreo, you can create connections. For step-by-step instructions on creating a connection, see [Create a Connection](./sharing-and-reusing/create-a-connection.md).


# Develop Components Using VS Code

The [Choreo VS Code extension](https://marketplace.visualstudio.com/items?itemName=WSO2.choreo) provides comprehensive component management capabilities to streamline local development within Choreo.

## Prerequisites

To ensure a smooth development experience with the Choreo extension, make sure you have the following:

1. [Visual Studio Code](https://code.visualstudio.com/download) installed with the [Choreo extension](https://marketplace.visualstudio.com/items?itemName=WSO2.choreo) version **2.0.0** or later.

2. A locally cloned GitHub repository to create new components or link to existing Choreo components.

3. [Git](https://git-scm.com) version 2.0.0 or later.

## Get started

To use the capabilities of the Choreo extension in the VS Code editor, you need an active [Choreo account](https://wso2.com/choreo/pricing/). If you already have an account, follow these steps to set up the extension:

1. Install the [Choreo VS Code extension](https://marketplace.visualstudio.com/items?itemName=WSO2.choreo) and wait for activation. On successful activation, the Choreo extension opens in the VS Code editor. 
2. Sign in to Choreo using one of the following methods:
    - In the Choreo activity pane, click **Sign In**.
       ![Sign in](../assets/img/develop-components/develop-using-vs-code/sign-in.png)
    - Use the `Sign In` command provided by the Choreo extension.

    This redirects you to an external URI to complete the authentication process. On successful sign-in, the Choreo activity pane displays your account details along with any components detected within the VS Code workspace.

## Create a new component

1. Open the source code directory where you want to build, deploy, and manage components using Choreo.
2. Create a new component using one of the following methods:
    - In the Choreo activity pane, click **Create Component**.
       ![Create Component Button](../assets/img/develop-components/develop-using-vs-code/create-component-btn.png)
    - Use the `Create New Component` command provided by the Choreo extension.

3. If the Choreo extension cannot determine the project context of the opened workspace, it prompts you to select the organization and the project to which the new component belongs.
4. Specify component details such as the name, type, buildpack, etc.

    ![Component Form](../assets/img/develop-components/develop-using-vs-code/component-form.png)
            
    On successful creation, the component details view opens, and the Choreo activity pane displays the new component.

    ![Component Details](../assets/img/develop-components/develop-using-vs-code/component-details-view.png)
     
    !!! tip
        Once the component is created, a `.choreo/context.yaml` file is generated in the root of the Git repository. For more details, see [Understand the project context](#understand-the-project-context).

The component details view allows you to manage your component by performing various actions such as the following:

 - Triggering builds for selected commits.
 - Viewing lists of builds and statuses.
 - Diagnosing build failures with build logs.
 - Deploying builds in available environments.
 - Accessing runtime logs and deployed component URLs.
 - Invoking deployed service endpoints.

## Understand the project context

Context files contain metadata related to the project, allowing the extension to establish an association between local directories and Choreo projects. These files, such as the `context.yaml`file, resides in the `/.choreo` directory within the root of the Git repository.

The Choreo extension scans the root of the opened Git repository to find the `context.yaml` file and lists the components of the associated project. This allows you to easily open and manage the components they are developing within the VS Code workspace.

A `context.yaml` file can contain multiple projects, whereas, a workspace opened via VS Code can have multiple `context.yaml` files with different project associations. In such cases, VS Code allows you to switch between these projects, add new project associations, or remove existing ones, allowing you as a developer to focus on components of a particular project at a time.

You can decide whether to commit the `context.yaml` file to the Git repository. Committing this file enables other team members working on the same repository to have a seamless developer experience with Choreo.

If the `context.yaml` file for a particular project is not committed to the Git repository or is unavailable for other reasons, you can easily regenerate it using one of the following methods:

 - In the Choreo activity pane, click **Link Directory**.
    ![Link Directory](../assets/img/develop-components/develop-using-vs-code/link-dir-btn.png)
 - Use the `Link Directory` command provided by the Choreo extension.

## Discover additional features

To access a range of functionalities provided by the Choreo extension, open the VS Code command palette and type `Choreo`.

## Troubleshoot issues

To troubleshoot Choreo extension issues, follow these steps:

1. To open the **OUTPUT** pane, go to the VS Code editor main menu, click **View**, and then click **Output**.

2. Select **Choreo** from the drop-down menu on the right-hand side to view the Choreo output for troubleshooting.

## Get help

For assistance with the Choreo VS Code extension, create [GitHub issues](https://github.com/wso2/choreo-vscode/issues).


# Develop Components With Git

Choreo enables you to develop components by connecting your GitHub, Bitbucket, or GitLab repository. You have the flexibility to either connect an existing repository or start with an empty repository and commit the source code later. By integrating your repositories with Choreo, you can automate tasks and optimize workflows across multiple systems, all within the Choreo platform.  Choreo currently supports GitHub, Bitbucket, and GitLab as Git providers. 

!!! tip
    Choreo supports both Bitbucket Server and Bitbucket Cloud. The currently supported Bitbucket Server version is 8.9.2.

In Choreo, you can connect a Git repository that contains Ballerina source code or a Docker project. To connect a Git repository to Choreo as a Docker project, your Git repository must include the following:

 - A Dockerfile: Specifies the instructions to build the Docker image. 
 - A build context: A set of files in the specified path used to build the image.

Once you connect your Git repository to Choreo, you can build, deploy, and manage your application easily. 

## Connect a Git repository to Choreo

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the Choreo Console header, go to the **Organization** list and select your organization. 
3. In the left navigation menu, click **Settings**. This opens the organization-level settings page. 
4. Click the **Credentials** tab. 
5. Click **+Add Credentials** to configure the Git repository connection.
6. Enter a **Credential Name**, select the Git provider, and enter the **Personal Access Token** you obtained from the Git provider.
7. Click **Save**.  

## Authorize GitHub with Choreo 

Authorizing Choreo as a GitHub application grants Choreo the following permissions to perform the respective actions on your behalf within the repository:

|Permission   | Read| Write| Description                                                           |
|-------------|-----|------|-----------------------------------------------------------------------|
|Issues       | Y   | N    | Read component ID label to filter the pull requests                   |
|Metadata     | Y   | N    | List repositories                                                     |
|Contents     | Y   | Y    | List branches and create a branch to commit sample code               |
|Pull Request | Y   | Y    | Create a pull request if you start with a Choreo sample               |
|Webhooks     | Y   | Y    | Trigger automatic deployment and configuration generation             |

### Add Git submodules to a project

Choreo provides [Git submodule](https://git-scm.com/book/en/v2/Git-Tools-Submodules) support when you connect your GitHub repository to Choreo. This allows you to manage and include external repositories effectively within Choreo build pipelines. Key benefits of this capability include:

  - **Code sharing without duplication**: Use submodules to maintain shared libraries across multiple projects, ensuring a single source of truth.
  - **Efficient third-party library management**: Manage third-party libraries as submodules to update them independently and track changes easily, avoiding direct code integration.

For example, when you [work with the Micro Integrator (MI) runtime in Choreo](./work-with-the-micro-integrator-runtime-in-choreo.md), you can use Git submodules to reuse MI templates and sequences across components without duplication.

!!! info "Note" 
    If you encounter an error stating that you cannot clone a submodule due to insufficient permissions, follow the instructions below to grant the necessary permissions:

      - For a personal account:

         1. Sign in to your personal GitHub account.
         2. In the upper-right corner, click your profile picture, and then click **Settings**.
         3. In the left navigation menu, go to the **Integrations** section and click **Applications**.
         4. Under the **Installed GitHub Apps** tab, click **Configure** corresponding to **choreo.dev**.
         5. Under **Repository Access**, grant access to the necessary repositories.

      - For an organization account:

         1. Sign in to your organization's GitHub account.
         2. In the upper-right corner, click your profile picture, and then click **Settings**.
         3. In the left navigation menu, go to the **Third-Party Access** section and click **GitHub Apps**.
         4. Click **Configure** corresponding to **choreo.dev**.
         5. Under **Repository Access**, grant access to the necessary repositories.

            !!! note
                Choreo currently does not support accessing private repositories in other organizations.

#### Automatically pull latest versions of Git submodules

Choreo lets you automatically pull the latest versions of Git submodules from their respective repositories. To enable this feature, follow these steps:

!!! note 
    Choreo currently supports this feature only for components where the buildpack is **WSO2 MI**.

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click the component for which you want to pull the latest versions of Git submodules.
3. In the left navigation menu, click **Build**.
4. On the **Build** page, click to edit **Build Configurations**.
5. Turn on the **Pull Latest Submodules** toggle.

    !!! info "Note"
        If you rebuild a previously built commit and it doesn’t reflect the latest changes, follow these steps to ensure the changes are applied to the deployed environment:

         1. In the Choreo Console left navigation menu, click **DevOps**, then click **Containers**.
         2. Click **Edit** to update the container settings.
         3. Select **Always** as the **Image Pull Policy**.
         4. Click **Save Changes**.

## Authorize Bitbucket with Choreo

Authorizing using a personal access token (PAT) from Bitbucket grants Choreo the following permissions to perform the respective actions on your behalf within the repository.

|Permission    | Read| Write| Description                                                        |
|--------------|-----|------|--------------------------------------------------------------------|
|Account       | Y   | N    | Get user information and workspace details                         |
|Repositories  | Y   | Y    | List branches and create a branch to commit sample code            |
|Pull Requests | Y   | Y    | Create a pull request if you start with a Choreo sample            |
|Webhooks      | Y   | Y    | Trigger automatic deployment and configuration generation          |

## Authorize self-managed GitLab with Choreo

Authorizing using a personal access token (PAT) obtained from your GitLab self-managed server grants Choreo the following permissions to perform the respective actions on your behalf within the repository.

|Permission    | Description                                                                         |
|--------------|-------------------------------------------------------------------------------------|
|API           | Grants full read/write access to the API, covering all groups and projects, as well as read/write access to the repository.|


 # Bring Your Own Image (BYOI)

Choreo allows you to deploy and manage prebuilt container images from external container registries as Choreo components. This enables you to deploy and effectively manage your container images within the Choreo environment.

!!! info
    This feature is currently only available on [private data planes (PDPs)](../choreo-concepts/data-planes.md#private-data-planes) for the following component types:

    - Service
    - Web Application
    - Scheduled Task
    - Manual Task


## Prerequisites

Before you try out this guide, ensure you have the following:

- **A container registry**: Ensure you have a container registry containing the images you want to deploy. Choreo is compatible with various container registries, including but not limited to GCR (Google Container Registry), ACR (Azure Container Registry), GitHub Container Registry, and Docker Hub.

- **An image in the registry**: You need an image ready for deployment.

- **(Optional) An external build/CI pipeline**:  This is to initiate automatic deployments during the build process outside of Choreo.

When using a container registry to deploy a component, Choreo cannot create an image from the source code (Git) or initiate a new deployment when a new image is ready. However, you can use your existing build process to trigger a deployment on Choreo by sending an HTTP POST request to a webhook with the new image details.

This feature is currently only available on private data planes (PDPs). You can find this option under **Deploy an image from a container registry** in the **Select Source** step during component creation for service components, web applications, scheduled tasks, and manual tasks.

## Step 1: Register a container registry

To get started, establish a connection between your container registry and Choreo. 

!!! Info
    When you use your Choreo credentials, Choreo does not *pull* your images into its control plane. Instead, it functions as an orchestrator, facilitating your data plane's ability to retrieve images from an external container registry. Choreo passes on these credentials to the data plane for authentication and access.

To register your container registry, follow these steps:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the Choreo Console header, go to the **Organization** list and select your organization. 
3. In the left navigation menu, click **Settings**. This opens the organization settings page. 
4. Click the **Credentials** tab and then click the **Container Registries** tab. 
5. Click **+Add Registry** to configure the Git repository connection.
6. Specify a **Registry Display Name**.
7. Select the **Authentication Type**. Fill in the required information depending on your authentication type. For details on each authentication type, see [Authentication types](#authentication-types).
8. Click **Save**.

### Authentication types

Choreo provides the following authentication options:  

#### Public (anonymous) access
    
You can use this option to establish a connection with a container registry that permits unrestricted public or anonymous access (for example, Public Docker Hub). In this case, only the registry host information is necessary.

For example, the following are the Docker Hub registry hosts for reference:

| Vendor                           | Registry host                |
|----------------------------------|------------------------------|
|Docker Hub (public repositories)  | `registry.hub.docker.com`    |
|Docker Hub (private repositories) | `registry.docker.com`        |

\* If necessary, you can use other mirrors instead of the above.

#### Basic authentication

To use basic authentication to authenticate to the container registry, you must provide the username and password.

#### Docker config

You can provide a Docker config in JSON format to authenticate to the container registry. This option only allows you to register one container registry. That is, it **only allows a single registry under `auths`**.

You must provide the credentials directly within the configuration. Choreo cannot utilize references to executable authentication plugins.

Sample Docker config format:

```json
    {
    "auths": {
        "index.docker.io/v1/": {
        "auth": "c3R...zE2"
        }
    }
    }
```

#### Vendor-specific authentication

This option is specifically for private data planes, where your cloud provider manages authentication at the Kubernetes level. Choreo requires knowledge of the registry host because the data plane already possesses implicit (preconfigured) access to the registry.

Follow the guidelines below based on your container registry:

=== "ACR"
    **Azure Container Registry** 

    Recommended authentication options:

    * [**Service principal-based basic authentication**](https://learn.microsoft.com/en-us/azure/container-registry/container-registry-auth-service-principal)

    * **Vendor-specific authentication on Azure private data planes**
        
        Contact Choreo support to enable infrastructure-level private access to your registry from your Azure private data plane on AKS. If you are on a self-managed PDP on Azure, follow [this guide](https://learn.microsoft.com/en-us/azure/aks/cluster-container-registry-integration?toc=%2Fazure%2Fcontainer-registry%2Ftoc.json&bc=%2Fazure%2Fcontainer-registry%2Fbreadcrumb%2Ftoc.json&tabs=azure-cli).

=== "GAR"
    **Google Artifact Registry**

    Recommended authentication options:

    * [**Service account-based basic authentication**](https://cloud.google.com/artifact-registry/docs/docker/pushing-and-pulling#key)

        Use the service account key in JSON format ([`_json_key`](https://cloud.google.com/artifact-registry/docs/docker/authentication#:~:text=of%20the%20following%3A-,_json_key,-if%20you%20are)) as the username and specify the minified JSON contents of the service account key as the password.

         You can use `jq` as follows to minify the service account JSON key file:

         `jq -c . <service-account.json>`

    * **Vendor-specific authentication on GCP private data planes**

        Contact Choreo support to enable infrastructure-level private access to your registry from your GCP private data plane on GKE. If you are on a self-managed PDP on GCP, see [https://cloud.google.com/artifact-registry/docs/access-control#grant-project](https://cloud.google.com/artifact-registry/docs/access-control#grant-project).

=== "AWS ECR"
    **Elastic Container Registry**

    ECR does not allow the creation of static access passwords for basic authentication. The passwords (that is, access tokens) provided by AWS are only valid for 10 hours and must be manually regenerated. However, when an ECR is attached to an EKS cluster at an infrastructure level, this limitation does not apply because the authentication is handled by AWS internally. For details, see [https://docs.aws.amazon.com/AmazonECR/latest/userguide/registry_auth.html](https://docs.aws.amazon.com/AmazonECR/latest/userguide/registry_auth.html).

    Choreo recommends using ECR when you are exclusively on an AWS private data plane using the vendor-specific authentication option. Contact Choreo support to enable a private connection between your ECR and the underlying EKS clusters on your data plane. If you are on a self-managed PDP, you can follow [this guide](https://docs.aws.amazon.com/AmazonECR/latest/userguide/ECR_on_EKS.html).    

=== "Docker Hub (Private)"

    Recommended authentication options:

    * **Basic authentication**

          Use your Docker Hub username/password or an access token. You can generate an access token from your Docker Hub account settings and use it in place of the password. For details, see [https://docs.docker.com/docker-hub/access-tokens/](https://docs.docker.com/docker-hub/access-tokens/).

    * **Docker config**

          Sign in to the Docker CLI and copy the contents of the docker config JSON. Note that external credential stores and multiple repositories within the same config object are not supported. For more information, see [https://docs.docker.com/engine/reference/commandline/login/](https://docs.docker.com/engine/reference/commandline/login/).

=== "GHCR"
    **GitHub Container Registry**

    Recommended authentication option:

    * **Basic authentication using a PAT token**

          Create a personal access token (PAT) and use it in place of the password. You cannot use your own GitHub password. You must provide a [PAT token](https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry#authenticating-with-a-personal-access-token-classicn).
  
## Step 2: Create a component in Choreo

1. In the left navigation, click **Overview** and select your project. Alternatively, select your project from the **Project** list in the Choreo Console header. 
2. Under **Component Listing** click **+ Create**.
3. Select your component type (BYOI is only available for Service, Web Application, Scheduled Task, or Manual Task components). 
4. From the Create Component pane, select the **Container Registry** under the **Connect a Docker Image** section.
5. Under **Deploy an image from Container Registry/Docker Hub**, select the container registry you have registered in [Step 1](#step-1-register-a-container-registry).
6. Enter the full image URL. The image URL format in general is as follows:
   `[container-registry-host]/[repository-name]/[image-name]:[tag]`

    !!! tip
        When a public image from Docker Hub lacks a specified repository name, it typically defaults to `/library/`. For example, you can access the public Nginx image `https://hub.docker.com/_/nginx` as `registry.hub.docker.com/library/nginx:1.25`.

7. Enter a display name, a unique name, and a description for the component.
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.


## Step 3: Deploy the component in Choreo

To deploy the component and bring your image to Choreo, follow the steps given below: 

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Update Image & Deploy**. 
3. In the **Endpoint** pane that opens, you can see the endpoint ready to be deployed. Click the edit icon next to the endpoint name. Optionally, you can define the endpoints for your service when you manually deploy the service. For more information, see [Expose service endpoints](#step-4-expose-service-endpoints).
4. Change the **Network Visibility** to **Public**. This setting securely exposes the endpoint for consumption.
5. Click **Update**.

    !!! info
         In this example, you deploy a Ballerina service as a REST endpoint. Therefore, Choreo generated the REST endpoint automatically. If you deploy a non-Ballerina service, you must manually add the REST endpoint and set the network visibility to **Public**.

6. Select your update image option. Refer to the update options listed below.

    You have the capability of updating the image when you are deploying the component in Choreo in one of the following three ways:

    | Option                   |Description                                                                                             |
    |--------------------------|--------------------------------------------------------------------------------------------------------|
    | **Update Image Tag**     | This option allows you to update the tag of the image.                                                 |
    | **Update Image URL**     | With this option, you can change the image name, tag, and the image repository of the image URL.|
    | **Previous Images**      | This option allows you to select a previous image and redeploy the image.                               |

7. Click **Deploy**. This deploys the service to the development environment.

## Step 4: Expose service endpoints 

!!! info
    This section only applies to service components.

After creating a service component in Choreo, you have the option to define the endpoints for your service when manually deploying a new image.

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Update Image & Deploy**. 
3. In the **Endpoint** pane that opens, optionally, you can define the endpoints for your service when you manually deploy the service. 
4. Click  **Create/Update Endpoints**.
5. Under the **Edit endpoints.yaml** section, you can edit the endpoints YAML file in the provided editor. 
   Alternatively, you can upload the associated API specification/schema files (OpenAPI/GraphQL schemas). Instead of specifying the file path, you can also reference this file in the `endpoints.yaml` file by its file name, similar to the Git-based Choreo components. The endpoints template follows the standard definitions for defining endpoints in Choreo. For more details, see [Configure Endpoints](../develop-components/configure-endpoints.md).

## Auto-deploy images in Choreo with an external CI/build pipeline

Choreo does not have automatic detection and deployment for newly added images or tags in the linked container registry. To overcome this limitation, Choreo allows you to integrate your own CI pipelines and initiate deployments manually. This approach enables you to use your existing CI setup or build a pipeline for image creation and pushing. You can then trigger automatic deployments using a webhook.

Follow the steps below to configure your CI/build pipeline:

1. Build and push the container image associated with a Choreo component to your container registry.
2. In the left navigation menu, click **DevOps** and then click **External CI**.
3. Generate a token for your CI pipeline from the **Manage Tokens** section. 

    !!! note
        - The tokens are bound to a specific component.
        - It is recommended to reference the token from a secure location available to your CI pipeline. For example, use a GitHub secret if you are using GitHub Actions.

4. To trigger an automatic deployment to your development environment, you can initiate an HTTP POST request to the Choreo webhook endpoint with the updated image details. Alternatively, you can use the provided Webhook snippets. This action will seamlessly deploy the image to the development environment.



Services and integrations are exposed to other services, integrations, or applications through endpoints. A service or an integration can expose multiple endpoints, each representing a unique entry point into the service. For example, a service may expose a REST API endpoint and a GraphQL endpoint, each providing different ways to interact with the service. Endpoints provide specific details for how the service or the integration can be consumed. For instance, the port number, protocol, and the schema such as open API specification (OAS) or GraphQL schema. By defining these details, endpoints make it possible for other services, integrations, and applications to discover and interact with the service in a standardized way.

Choreo defines endpoints by combining port binding, protocol, endpoint name, network visibility, endpoint schema, and additional protocol-related fields. The following table describes each attribute of an endpoint.

| Field | Description |
| ----- | ----------- |
| Name | A unique identifier for the endpoint within the service component. |
| Port | The network port on which the endpoint is accessible. |
| Type | The endpoint protocol. Supported protocols: REST, GraphQL, gRPC, WS, UDP, and TCP. |
| Network Visibility | Determines the level of visibility of an endpoint. Possible values are: <ul><li>Project: Allows components within the same project to access the endpoint.</li><li>Organization: Allows any component within the same organization to access the endpoint but restricts access to components outside the organization.</li><li>Public: Allows any client to access the endpoint, regardless of location or organization.</li></ul> |
| Schema | Specifies the structure and format of the data exchanged through the endpoint. |
| Context (HTTP and GraphQL only) | A context path that you add to the endpoint's URL for routing purposes. |

## Configure endpoints
The method of defining endpoints depends on the buildpack.

* For `Ballerina` and `WSO2 MI` buildpacks, Choreo automatically detects the endpoint details for REST APIs.
* For all other buildpacks (Java, Python, NodeJS, Ruby, PHP, Go, Dockerfile, etc.), you can configure endpoints in one of the following ways:
  
    * **Using the Choreo Console**: If a `component.yaml` file is not present, you can define a basic endpoint configuration during component creation.
    * **Using the component.yaml file**: You can manually configure endpoint details by defining them in a `component.yaml` file, placing it inside the `.choreo` directory at the build context path, and committing it to the source repository.

You can override UI-defined and auto-generated endpoints by providing a `component.yaml` file in the `.choreo` directory, which will take priority over other configurations.

To learn about the `component.yaml` file, see [Overview of the component.yaml file](../develop-components/manage-component-source-configurations.md#overview-of-the-componentyaml-file).
!!! note
    Automatic endpoint generation is not supported for dynamic endpoint parameters such as variable ports. Therefore, you must use an `component.yaml` file to define dynamic endpoint parameters.

To learn about the `component.yaml` file, see [Overview of the component.yaml file](../develop-components/manage-component-source-configurations.md#overview-of-the-componentyaml-file).

## Expose endpoints as managed APIs

Exposing endpoints as managed APIs is crucial to ensure secure and controlled access to the services being exposed. When a user wants to expose their written service to the outside world or to the organization at large, there is an inherent security risk involved. To mitigate this risk, the Choreo platform is built with an internal (access within the organization only) or external (publicly accessible) gateway that is protected with Choreo API management making the services secure by design.

!!! note
    This feature is not available for gRPC, UDP, and TCP endpoints.

If you want to expose an endpoint as a managed API in Choreo, you need to set the network visibility to either Organization or Public. This allows the endpoint to be exposed through the Choreo API Gateway, which provides a number of benefits, including:

* Expose APIs to external and internal consumers
* Full lifecycle API Management
* API throttling
* Secure APIs with industry-standard authorization flows
* API analytics and monitoring

Once you deploy the service component, Choreo will expose the endpoint as a managed API through the Choreo API Gateway. You can then use the full lifecycle API management features provided by Choreo to test, deploy, maintain, monitor, and manage your API using the API management features.

## Understand the default component URL

The default URL of a component corresponds to the default endpoint of the component and is structured as follows:

`<domain>/<project-name>/<component-name>`

This URL does not include the default endpoint name. For all other endpoints, the URL structure includes the endpoint name, as follows:

`<domain>/<project-name>/<component-name>/<endpoint-name>`

If a component has multiple endpoints, Choreo allows you to change the endpoint corresponding to the default component URL. For a component with a single endpoint, the default URL automatically corresponds to that endpoint.

### Change the default endpoint of a component

To change the default endpoint of a component, follow the steps given below:

!!! note
     - You cannot change the default endpoint if it has associated published APIs. You must go to the **Lifecycle** page and unpublish the relevant APIs before updating the default endpoint. For instructions on unpublishing an API, see [Lifecycle Management](https://wso2.com/choreo/docs/api-management/lifecycle-management/).
     - Choreo does not allow you to change the default endpoint of a component if you create multiple deployment tracks within its current major version, or promote the component beyond its initial environment.

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to change the default endpoint.
3. In the left navigation menu, click **Deploy**.
4. On the **Deploy** page, go to the **Set Up** card and click **Configure & Deploy**.
5. In the **Environment Configurations** pane that opens, click **Next**.
6. In the **File Mount** pane that opens, click **Next**.
7. In the **Endpoint Details** pane that opens, click the **Default Endpoint** list, select the endpoint you want to set as the default endpoint, and then click **Update**.
8. Click **Deploy**. This deploys the component with the selected endpoint as the default, and the default URL will now correspond to this endpoint.  

### Edit a UI-Defined Endpoint
If you defined an endpoint during component creation, you can edit it later by following these steps:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to update the endpoint.
3. In the left navigation menu, click **Deploy**.
4. On the **Deploy** page, go to the **Set Up** card and click **Configure & Deploy**.
5. In the **Environment Configurations** pane that opens, click **Next**.
6. In the **File Mount** pane that opens, click **Next**.
7. In the **Endpoint Details** pane that opens, locate the endpoint you want to edit.
8. Click the **Edit** icon next to the endpoint, modify the editable fields, and click **Update**.
9. Click **Deploy** to apply the changes.

!!! note
     If you commit a `component.yaml` file, build the component, and proceed with deployment, the endpoints will be generated from the `component.yaml` file and will take priority. In this case, the endpoint cannot be edited through the UI. To modify the endpoint, you must update the`component.yaml` file.


# Configure Endpoints
{% include "configure-endpoints-body.md" %}

# Deploy a Containerized Application 

Using Choreo, you can easily deploy applications written in different language frameworks (such as Java, Go, NodeJS, Python, etc.) on shared or private data planes using containers.

Choreo supports deploying containerized applications for the following component types:

- Service
- Web Application
- Scheduled Task
- Manual Task
- Event Handler
- Test Runner

## Connect your repository to Choreo

To connect your GitHub repository to Choreo, you should authorize the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application to access your account or organization. When you attempt to connect your GitHub repository via the Component creation page, the Choreo Apps authorization prompt will appear.

* Connect GitHub Repository
    
    ![Connect GitHub Repository](../assets/img/develop-components/deploy/create-component-authz-github-page.png){.cInlineImage-threeQuarter}

* Authorize GitHub Application
    
    ![Authorize GitHub Application](../assets/img/develop-components/deploy/authz-choreo-github-app.png){.cInlineImage-half}

* Grant Repository Access

    ![Grant Repository Access](../assets/img/develop-components/deploy/github-repo-access.png){.cInlineImage-full}


    The **Choreo Apps** requires the following permission:
    
    - Read access to issues and metadata
    - Read and write access to code, pull requests, and repository hooks

!!! note
    You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. Choreo needs write access only to send pull requests to a user repository. Choreo does not directly push any changes to a repository.

Alternatively, you can connect a public repository without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. Select the **Third-Party GitHub Repository** and paste a public repository URL in the **Public Repository URL** field at the time of component creation.

!!! tip
     Authorizing the repository with the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application becomes essential if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component. If you own the repository, you can subsequently authorize it with the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application to enable **Auto Deploy**.

After granting access to the required repositories, you can choose a repository and an associated branch to connect to the Choreo component.
For the containerized application deployments, you should select the [**Component Directory**](https://docs.docker.com/build/building/context/#path-context), **Dockerfile** as the **Buildpack** and provide **Dockerfile Path** for the Docker build.

![Connected Dockerfile Repository](../assets/img/develop-components/deploy/create-component-connected-repo.png){.cInlineImage-full}

The following table describes the individual fields in the **Create Component** pane.

| **Field**               | **Description**                                                                                                                                                                      |
|-------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **GitHub Account**      | Your GitHub account or organization. If you want to add another GitHub account, you can expand the list and click **+ Add**.                                                            |
| **GitHub Repository**   | Depending on the repository access you provided, the list will show available repositories to be connected.                                                                                  |
| **Branch**              | The branch of the repository.                                                                                                                                                         |
| **Buildpack**        | Determines the implementation of the component: Any language or other language as a Docker container.                                                                                |
| **Dockerfile Path**     | The path to your Dockerfile. This path is defined relative to the repository root.<br/>For example, if the Dockerfile is at the repository root, the value for this field is `/Dockerfile`. |
| **Component Directory** | The component directory path. To include the repository root, leave the default `/` value.                                                                                          |
| **Port***               | The port at which your service is running.                                                                                                                                           |
| **OpenAPI Filepath***   | The path to an OpenAPI specification (in YAML/JSON) relative to the repository root. If you don't provide a path, the system automatically generates a default allow-all specification.    |

   
!!! note
 
    - Fields marked with **\*** are not visible for all component types.

    - To successfully build your container with Choreo, it is essential to explicitly define a User ID (`UID`) under the `USER` instruction in your Dockerfile. You can refer to the [sample Dockerfile](https://github.com/wso2/choreo-sample-apps/blob/main/go/rest-api/Dockerfile) for guidance.

    - To ensure that the defined USER instruction is valid, it must conform to the following conditions:
        
        - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
        - Usernames are not considered valid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

## Deploy the containerized component

Choreo will automatically apply deployment configurations and settings based on the component type you select during creation.
For example, if you select the **Service** component type, Choreo will deploy it as a Kubernetes deployment with appropriate scaling configurations.

You can run unit tests in the build pipeline by adding the relevant command to the Dockerfile.  For example: 

- [Go-based sample](https://github.com/wso2/choreo-sample-apps/blob/8c18c82db604adb43b89f669888a07cd6e31d7b7/go/rest-api/Dockerfile#L37)
- [Python-based sample](https://github.com/wso2/choreo-sample-apps/blob/8c18c82db604adb43b89f669888a07cd6e31d7b7/python/rest-api/Dockerfile#L15)

### Application configurations

You must provide any required configurations for running the application in the **Configs & Secrets** section of the component's **DevOps** page. Alternatively, you can also review the configurations when you manually deploy via the **Deploy** page.

After clicking the **Create** button, you can select the confidentiality of the configuration and specify how to mount it to the container.

![Application Configuration Page](../assets/img/develop-components/deploy/deploy-app-config-page.png){.cInlineImage-full}

![Create Configuration Mount Page](../assets/img/develop-components/deploy/deploy-app-config-type-mount-page.png){.cInlineImage-full}

#### Configuration types

* **ConfigMap**: Stores non-confidential data as key-value pairs.
* **Secret**: Stores and manages sensitive information, such as passwords, OAuth tokens, and ssh keys as key-value pairs.

#### Mount types

* **Environment Variables**: Mounts the selected ConfigMap or Secret as an environment variable in the container.
* **File Mount**: Mounts the selected ConfigMap or Secret as a file in the container. Here, the key is the file name, and the value is the file content.

The following image shows adding a **ConfigMap** with **File Mount** mount type to be read by the application.

![Configuration File Mount Page](../assets/img/develop-components/deploy/deploy-app-config-file-mount.png){.cInlineImage-full}

!!! note
    The JSON file includes ${DB_PASS} as an environment variable defined in a Secret. The application reads the JSON file and substitutes the placeholders with the corresponding environment variables.

### Deployment configurations

Choreo lets you configure deployment settings such as scaling, resource limits, and health checks based on your selected component type.

For more information about these configurations, see Choreo's [DevOps capabilities](../devops-and-ci-cd/view-runtime-details.md).

You can configure the **Endpoints** to expose your service using the **Service** Component in Choreo. See [Service Component Overview](../develop-components/develop-services/service-component-overview.md) for more information. 

### Build, deploy, and promote

After adding the application configuration, you can build and deploy it by clicking the **Deploy Manually** button. Choreo will start the build process with the selected commit in the **Build Area**. 

!!! note
    The **Auto Deploy on Commit** feature, which automatically builds and deploys the application upon pushing a code change to the repository, is enabled by default. To turn off this feature, navigate to the **Build Area** of the **Deploy** page.

Choreo scans your Dockerfile for security vulnerabilities during the build phase, and if there are no issues found, it proceeds with the build process. After building the image, it scans it again for vulnerabilities before deployment to the environment. You can view the build logs from the right-side panel, as shown in the image below.

![Build Logs Panel](../assets/img/develop-components/deploy/build-deploy-page-logs.png){.cInlineImage-full}

Once the build process is complete, Choreo will deploy the application automatically to the Development environment. To promote the build to higher environments, you can click the **Promote** button. The number of environment cards visible on the page may vary depending on your environment configurations.

### Troubleshoot security vulnerability scan failures (Trivy)

By default, Choreo utilizes the Aqua Trivy (OSS) image vulnerability scanner to detect security vulnerabilities in all Dockerfile-based build pipelines. The scanner will fail the pipeline if any **CRITICAL** CVEs (Common Vulnerabilities and Exposures) are detected. CVEs of other severity levels are recorded but does not fail the pipeline.

If you cannot fix a critical CVE immediately, you can opt to ignore it. To ignore a critical CVE, add a `trivyignore` (`<docker-build-context-path>/.trivyignore`) file to your build context path. In the file, add the CVEs you need the pipeline to ignore, one entry per line as follows:

```
CVE-2023-xxxx
CVE-2023-yyyy
```

You can add comments in the file by using `#` in front of the comment as follows: 

```
# comments can be added like this
CVE-2023-xxxx
```


# Deploy an Application with Buildpacks

Using Choreo, you can easily deploy applications written in different language frameworks (such as Java, Go, NodeJS, Python, Ruby, PHP, etc.) on shared or private data planes.

Choreo supports deploying applications with buildpacks for the following component types:

- Service
- Web Application
- Scheduled Task
- Manual Task
- Webhook
- Event Handler
- Test Runner

## Buildpacks
Buildpacks are a fundamental building block in modern application development. They convert your source code into a secure, efficient, production-ready container image without a Dockerfile. With Choreo, developers can take advantage of this powerful tool to effortlessly deploy their applications without the hassle of manual configuration.

Choreo uses [Google Buildpacks](https://cloud.google.com/docs/buildpacks/overview) as default buildpacks for Java, Go, NodeJS, Python, PHP, and Ruby. Choreo uses its own buildpacks for Ballerina and WSO2 MI.

## Develop a component

To develop a service component that exposes a Service in Go, you can follow the [Develop a Service ](develop-services/develop-a-service.md) guide.

Follow the guidelines below based on your language:

=== "Python"
    Supported Versions - 3.10.x, 3.11.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Reading Books List Service](https://github.com/wso2/choreo-samples/tree/main/reading-books-list-service-python)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-python-task)|

    ### Procfile
    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    
    !!! info 
        In **Python** projects, it is mandatory to have a `Procfile` with the `web` process type in the project root directory.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: python main.py` <br>
    `web: gunicorn --bind :8080 --workers 1 --threads 8 --timeout 0 main:app` <br>
    `web: flask run --host=0.0.0.0`

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Ballerina"

    Supported Versions - 2201.3.5, 2201.4.1, 2201.5.0, 2201.5.1, 201.6.0,  2201.7.0

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Echo Service](https://github.com/wso2/choreo-samples/tree/main/echo-service)|
    | Manual Task | [Covid19 Statistics To Email](https://github.com/wso2/choreo-samples/tree/main//covid19-statistics-to-email)|
    | Webhook | [Salesforce New Case To Google Sheet](https://github.com/wso2/choreo-samples/tree/main/sfdc-new-case-to-gsheet)|
    | Scheduled Task | [Shopify New Customers to HubSpot Create/Update Contact](https://github.com/wso2/choreo-samples/tree/main/shopify-new-customers-to-hubspot-contact)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Go"

    Supported Versions - 1.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Greeting Service](https://github.com/wso2/choreo-samples/tree/main/greeting-service-go)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-go-task)|
    | Web Application | [Hello World Web Application](https://github.com/wso2/choreo-samples/tree/main/hello-world-go-webapp)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== ".NET"
    Supported Versions - 6.x, 7.x, 8.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service | [Greeting Service](https://github.com/wso2/choreo-samples/tree/main/dotnet-greeter)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Java"
    Supported Versions
        - 8, 11, 17, 18 (OpenJDK Runtime Environment Temurin)

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Product Management Service](https://github.com/wso2/choreo-samples/tree/main/product-management-service)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-java-task)|

    !!! info

         When working on Java projects:

           - The `Main` class should be defined in the manifest file.
           - If Maven files such as `mvn.cmd` exist in the project without the `.mvn` directory, the build will fail. To ensure a successful build, you must either commit the `.mvn` directory along with any Maven files or not include any Maven files in the project if you choose not to commit the `.mvn` directory.
    
    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **Java** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: java -jar target/sample.jar` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "NodeJS"
    Supported Versions - 12.x.x, 14.x.x, 16.x.x, 18.x.x, 20.x.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Reading Books List Service](https://github.com/wso2/choreo-samples/tree/main/reading-books-list-service-nodejs)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-nodejs-task)|

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **NodeJS** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: node app.js` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "PHP"
    Supported Versions - 8.1.x, 8.2.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Hello World Service](https://github.com/wso2/choreo-samples/tree/main/hello-world-php-service)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-php-task)|
    | Web Application | [Hello World Web Application](https://github.com/wso2/choreo-samples/tree/main/hello-world-php-webapp)|

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **PHP** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web:php -S 0.0.0.0:8000 index.php` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Ruby"
    Supported Versions - 3.1.x, 3.2.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service | [Hello World Service](https://github.com/wso2/choreo-samples/tree/main/hello-world-ruby-service)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-ruby-task)|
    | Web Application | [Hello World Web Application](https://github.com/wso2/choreo-samples/tree/main/hello-world-ruby-webapp)|

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **Ruby** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: ruby app.rb` <br>
    `web:bundle exec ruby app.rb -p 8080` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "WSO2 MI"
    Supported Versions - 4.1.0.x, 4.2.0.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service |[Hello World Service](https://github.com/wso2/choreo-samples/tree/main/hello-world-mi)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Spring Boot"
    Supported Java Versions
        - 8, 11, 17, 18 (OpenJDK Runtime Environment Temurin)

    !!! info
         You can use this buildpack only with web applications. For other component types, use the **Java** buildpack. Additionally, if the generated artifact is a `WAR` file, it is necessary to include a **Procfile**.

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **Java** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: java -jar target/sample.war` <br>

### Configure build-time environment variables

You can configure the environment variables necessary to build the component using the **Build Configurations Editor** on the component **Build** page. 

!!! info
    The capability to configure build-time environment variables is not available for components created using **Ballerina** or **WSO2 MI** buildpacks.

During the build process, the build-time environment variables and their values are passed to the buildpack. Therefore, you can configure both buildpack-specific environment variables and those required for the component build.

For example, if you want to override the Maven command of the **Java** buildpack, you can use `GOOGLE_MAVEN_BUILD_ARGS` as the environment key and `clean install` as the value. 

For more examples, see [Google Cloud's buildpacks documentation](https://cloud.google.com/docs/buildpacks/service-specific-configs).


# Develop a Webhook

Choreo allows developers to design high-quality webhooks. To explore this capability, let's consider a scenario where a team of software engineers in an organization should be notified via email whenever someone creates a GitHub issue with the `bug` label in a specific repository.

In this tutorial, you will address the requirement by doing the following:

- Create a webhook by connecting to a forked GitHub repository where you have the webhook implementation that addresses the described requirement.
- Deploy the webhook to the development environment.
- Modify the webhook implementation to connect the webhook to GitHub, enabling it to act in response to selected GitHub-related events.
- Test the webhook.
- Promote the webhook to the production environment.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

## Step 1: Create a webhook component

To create a Webhook component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Webhook** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following information:

    | **Field**                     | **Description**    |
    |-------------------------------|--------------------|
    | **GitHub Account**            | Your account       |
    | **GitHub Repository**         | choreo-samples     |
    | **Branch**                    | main               |
    | **Component Path**              | `github-event-to-email-webhook` |

6. Select **Ballerina** as the build pack.
7. Provide a display name, a unique name and description for the component.
8. Click **Create**.

Choreo creates the Webhook component with the sample implementation and opens the component **Overview** page.

## Step 2: Deploy

To deploy the webhook to the development environment, follow these steps:

1. In the Choreo Console left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**.
3. In the **Configurations** pane, enter the following information:
    1. In the **webhookSecret** field, enter any value.

        !!! note
            Save this value for later use.

    2. In the **toEmail** field, enter the email address to send notification emails.
    3. Click **Deploy**.

    You can monitor the deployment progress in the **Console** pane that opens on the right of the page.

Once Choreo completes the deployment, the **Development** card indicates the **Deployment Status** as **Active**.

!!! note
    In the deployment card, you can click the icon corresponding to configurables to open the **Configurations** pane and edit configurations.

## Step 3: Connect the webhook to the GitHub repository

To allow the webhook to read the labels of issues in a specific GitHub repository, connect the webhook to the GitHub repository:

1. In the Choreo Console left navigation menu, click **Overview**.
2. On the **Overview** page, copy the invoke URL by clicking the copy icon within the **URL** field.
3. Go to your GitHub account and open the repository for which you want to generate notification emails.
4. In the top menu, click the **Settings** tab.
5. In the left navigation menu, click **Webhooks**.
6. Click **Add webhook** and enter the following information:

    | **Field**        | **Value**                                                          |
    |------------------|--------------------------------------------------------------------|
    | **Payload URL**  | The invoke URL you copied in Step 3, sub-step 1.                   |
    | **Content Type** | Select `application/json`                                          |
    | **Secret**       | The last webhook secret you configured in [Step 2](#step-2-deploy).| 

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Project Path** specifies the location of the project to build the component.

7. Under **Which events would you like to trigger this webhook?**, select **Let me select individual events**.
8. Select the **Issues** checkbox in the list of events displayed. This ensures that GitHub issues trigger the webhook.
9. Clear the **Pushes** checkbox to ensure that GitHub does not trigger your webhook when the team pushes changes to the selected GitHub repository.
10. Click **Add webhook** to save the configuration.

Now you have integrated Choreo with GitHub via the webhook you created and deployed. You can proceed to test the webhook.

## Step 4: Test

To test your webhook, create a GitHub issue with the `Bug` label in the repository that you connected to the webhook. You will receive an email similar to the following at the email address you provided in [Step 2](#step-2-deploy).

## Step 5: Promote

To promote the webhook to the Production environment, follow these steps:

1. On the **Deploy** page, go to the **Development** card and click **Promote**.
2. In the **Configuration Types** pane, leave the default selection (i.e., **Use default configuration values**) unchanged.

    !!! note
        If you have configured any default values for the configurable variables, selecting **Use default configuration values** allows you to proceed with those values. If not, specify values for the configurable variables.

3. Click **Next**.
4. In the **webhookSecret** field, enter any value.

    !!! note
        Save this value for later use.

5. In the **toEmail** field, enter the email address to send notification emails.
6. Click **Promote**.

    Once the component is promoted to production, the **Production** card displays the deployment status as **Active**.

Now you have successfully created, deployed, and tested a Webhook component and promoted it to production.


# Develop an External Consumer

An external consumer in Choreo is any client that can interact with services deployed in Choreo, as an entity hosted outside of the Choreo infrastructure. It is a generic component type that allows you to represent and manage any client, such as a mobile application, web application, server-to-server integration, bot, microservices, etc.

In this guide, you will:

 - Create an external consumer component.
 - Manage authentication for the external consumer.
 - Connect the external consumer to a service deployed in Choreo.
 
## Prerequisites

Before you try out this guide, complete the following steps:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

## Step 1: Create an external consumer component
 
To create an external consumer component, follow the steps given below:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **External Consumer** card. 
4. In the **Create an External Consumer** pane that opens, enter a display name, a unique name, and a description for the component.
5. Click **Create**. This creates the component and takes you to its **Overview** page.
   
## Step 2: Manage authentication for the external consumer

You can configure the external consumer to work with the Choreo built-in identity provider or any external identity provider that supports OIDC/OAuth 2.0.

Click the respective tab for details depending on the identity provider you want to configure: 

=== "Choreo built-in identity provider"

     Follow the steps given below to configure the built-in identity provider by generating authentication keys:

    !!! note
         Choreo built-in identity provider is configured by default. Therefore, this step is optional.

     1. In the **Overview** page of the component, under **Authentication Configurations**, click **Configure** corresponding to the environment for which you want to configure an identity provider.
     2. In the **Identity Provider** list, select **Choreo Built-In Identity Provider**.
     3. Click **Generate Keys**. 

        !!! Note
             If you see **Regenerate Secret** instead of **Generate Keys**, it indicates that OAuth keys are already generated for the component in the selected environment.

=== "An external identity provider"

     **Step 2.1: Create and configure an OIDC/OAuth 2.0 application in the external identity provider**

     1. Create an OIDC/OAuth 2.0 application in your external identity provider.
     2. Configure the OIDC/OAuth 2.0 application accordingly. (The access token type should be configured as JWT)

     **Step 2.2: Link the OIDC/OAuth 2.0 application to the Choreo component**

     3. In the **Overview** page of the component, under **Authentication Configurations**, click **Configure** corresponding to the environment for which you want to configure an identity provider.
     4. In the **Identity Provider** list, select your identity provider.
     5. Paste the **Client ID** of the OIDC/OAuth 2.0 application you created in your external identity provider.
     6. Click **Add Keys**.

## Step 3: Connect the external consumer to a service deployed in Choreo 

To establish connections from the external consumer to services deployed in Choreo, you can create connections. For step-by-step instructions on creating a connection, see [Create a Connection](./sharing-and-reusing/create-a-connection.md).


# Develop Components Using VS Code

The [Choreo VS Code extension](https://marketplace.visualstudio.com/items?itemName=WSO2.choreo) provides comprehensive component management capabilities to streamline local development within Choreo.

## Prerequisites

To ensure a smooth development experience with the Choreo extension, make sure you have the following:

1. [Visual Studio Code](https://code.visualstudio.com/download) installed with the [Choreo extension](https://marketplace.visualstudio.com/items?itemName=WSO2.choreo) version **2.0.0** or later.

2. A locally cloned GitHub repository to create new components or link to existing Choreo components.

3. [Git](https://git-scm.com) version 2.0.0 or later.

## Get started

To use the capabilities of the Choreo extension in the VS Code editor, you need an active [Choreo account](https://wso2.com/choreo/pricing/). If you already have an account, follow these steps to set up the extension:

1. Install the [Choreo VS Code extension](https://marketplace.visualstudio.com/items?itemName=WSO2.choreo) and wait for activation. On successful activation, the Choreo extension opens in the VS Code editor. 
2. Sign in to Choreo using one of the following methods:
    - In the Choreo activity pane, click **Sign In**.
       ![Sign in](../assets/img/develop-components/develop-using-vs-code/sign-in.png)
    - Use the `Sign In` command provided by the Choreo extension.

    This redirects you to an external URI to complete the authentication process. On successful sign-in, the Choreo activity pane displays your account details along with any components detected within the VS Code workspace.

## Create a new component

1. Open the source code directory where you want to build, deploy, and manage components using Choreo.
2. Create a new component using one of the following methods:
    - In the Choreo activity pane, click **Create Component**.
       ![Create Component Button](../assets/img/develop-components/develop-using-vs-code/create-component-btn.png)
    - Use the `Create New Component` command provided by the Choreo extension.

3. If the Choreo extension cannot determine the project context of the opened workspace, it prompts you to select the organization and the project to which the new component belongs.
4. Specify component details such as the name, type, buildpack, etc.

    ![Component Form](../assets/img/develop-components/develop-using-vs-code/component-form.png)
            
    On successful creation, the component details view opens, and the Choreo activity pane displays the new component.

    ![Component Details](../assets/img/develop-components/develop-using-vs-code/component-details-view.png)
     
    !!! tip
        Once the component is created, a `.choreo/context.yaml` file is generated in the root of the Git repository. For more details, see [Understand the project context](#understand-the-project-context).

The component details view allows you to manage your component by performing various actions such as the following:

 - Triggering builds for selected commits.
 - Viewing lists of builds and statuses.
 - Diagnosing build failures with build logs.
 - Deploying builds in available environments.
 - Accessing runtime logs and deployed component URLs.
 - Invoking deployed service endpoints.

## Understand the project context

Context files contain metadata related to the project, allowing the extension to establish an association between local directories and Choreo projects. These files, such as the `context.yaml`file, resides in the `/.choreo` directory within the root of the Git repository.

The Choreo extension scans the root of the opened Git repository to find the `context.yaml` file and lists the components of the associated project. This allows you to easily open and manage the components they are developing within the VS Code workspace.

A `context.yaml` file can contain multiple projects, whereas, a workspace opened via VS Code can have multiple `context.yaml` files with different project associations. In such cases, VS Code allows you to switch between these projects, add new project associations, or remove existing ones, allowing you as a developer to focus on components of a particular project at a time.

You can decide whether to commit the `context.yaml` file to the Git repository. Committing this file enables other team members working on the same repository to have a seamless developer experience with Choreo.

If the `context.yaml` file for a particular project is not committed to the Git repository or is unavailable for other reasons, you can easily regenerate it using one of the following methods:

 - In the Choreo activity pane, click **Link Directory**.
    ![Link Directory](../assets/img/develop-components/develop-using-vs-code/link-dir-btn.png)
 - Use the `Link Directory` command provided by the Choreo extension.

## Discover additional features

To access a range of functionalities provided by the Choreo extension, open the VS Code command palette and type `Choreo`.

## Troubleshoot issues

To troubleshoot Choreo extension issues, follow these steps:

1. To open the **OUTPUT** pane, go to the VS Code editor main menu, click **View**, and then click **Output**.

2. Select **Choreo** from the drop-down menu on the right-hand side to view the Choreo output for troubleshooting.

## Get help

For assistance with the Choreo VS Code extension, create [GitHub issues](https://github.com/wso2/choreo-vscode/issues).


# Develop Components With Git

Choreo enables you to develop components by connecting your GitHub, Bitbucket, or GitLab repository. You have the flexibility to either connect an existing repository or start with an empty repository and commit the source code later. By integrating your repositories with Choreo, you can automate tasks and optimize workflows across multiple systems, all within the Choreo platform.  Choreo currently supports GitHub, Bitbucket, and GitLab as Git providers. 

!!! tip
    Choreo supports both Bitbucket Server and Bitbucket Cloud. The currently supported Bitbucket Server version is 8.9.2.

In Choreo, you can connect a Git repository that contains Ballerina source code or a Docker project. To connect a Git repository to Choreo as a Docker project, your Git repository must include the following:

 - A Dockerfile: Specifies the instructions to build the Docker image. 
 - A build context: A set of files in the specified path used to build the image.

Once you connect your Git repository to Choreo, you can build, deploy, and manage your application easily. 

## Connect a Git repository to Choreo

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the Choreo Console header, go to the **Organization** list and select your organization. 
3. In the left navigation menu, click **Settings**. This opens the organization-level settings page. 
4. Click the **Credentials** tab. 
5. Click **+Add Credentials** to configure the Git repository connection.
6. Enter a **Credential Name**, select the Git provider, and enter the **Personal Access Token** you obtained from the Git provider.
7. Click **Save**.  

## Authorize GitHub with Choreo 

Authorizing Choreo as a GitHub application grants Choreo the following permissions to perform the respective actions on your behalf within the repository:

|Permission   | Read| Write| Description                                                           |
|-------------|-----|------|-----------------------------------------------------------------------|
|Issues       | Y   | N    | Read component ID label to filter the pull requests                   |
|Metadata     | Y   | N    | List repositories                                                     |
|Contents     | Y   | Y    | List branches and create a branch to commit sample code               |
|Pull Request | Y   | Y    | Create a pull request if you start with a Choreo sample               |
|Webhooks     | Y   | Y    | Trigger automatic deployment and configuration generation             |

### Add Git submodules to a project

Choreo provides [Git submodule](https://git-scm.com/book/en/v2/Git-Tools-Submodules) support when you connect your GitHub repository to Choreo. This allows you to manage and include external repositories effectively within Choreo build pipelines. Key benefits of this capability include:

  - **Code sharing without duplication**: Use submodules to maintain shared libraries across multiple projects, ensuring a single source of truth.
  - **Efficient third-party library management**: Manage third-party libraries as submodules to update them independently and track changes easily, avoiding direct code integration.

For example, when you [work with the Micro Integrator (MI) runtime in Choreo](./work-with-the-micro-integrator-runtime-in-choreo.md), you can use Git submodules to reuse MI templates and sequences across components without duplication.

!!! info "Note" 
    If you encounter an error stating that you cannot clone a submodule due to insufficient permissions, follow the instructions below to grant the necessary permissions:

      - For a personal account:

         1. Sign in to your personal GitHub account.
         2. In the upper-right corner, click your profile picture, and then click **Settings**.
         3. In the left navigation menu, go to the **Integrations** section and click **Applications**.
         4. Under the **Installed GitHub Apps** tab, click **Configure** corresponding to **choreo.dev**.
         5. Under **Repository Access**, grant access to the necessary repositories.

      - For an organization account:

         1. Sign in to your organization's GitHub account.
         2. In the upper-right corner, click your profile picture, and then click **Settings**.
         3. In the left navigation menu, go to the **Third-Party Access** section and click **GitHub Apps**.
         4. Click **Configure** corresponding to **choreo.dev**.
         5. Under **Repository Access**, grant access to the necessary repositories.

            !!! note
                Choreo currently does not support accessing private repositories in other organizations.

#### Automatically pull latest versions of Git submodules

Choreo lets you automatically pull the latest versions of Git submodules from their respective repositories. To enable this feature, follow these steps:

!!! note 
    Choreo currently supports this feature only for components where the buildpack is **WSO2 MI**.

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click the component for which you want to pull the latest versions of Git submodules.
3. In the left navigation menu, click **Build**.
4. On the **Build** page, click to edit **Build Configurations**.
5. Turn on the **Pull Latest Submodules** toggle.

    !!! info "Note"
        If you rebuild a previously built commit and it doesn’t reflect the latest changes, follow these steps to ensure the changes are applied to the deployed environment:

         1. In the Choreo Console left navigation menu, click **DevOps**, then click **Containers**.
         2. Click **Edit** to update the container settings.
         3. Select **Always** as the **Image Pull Policy**.
         4. Click **Save Changes**.

## Authorize Bitbucket with Choreo

Authorizing using a personal access token (PAT) from Bitbucket grants Choreo the following permissions to perform the respective actions on your behalf within the repository.

|Permission    | Read| Write| Description                                                        |
|--------------|-----|------|--------------------------------------------------------------------|
|Account       | Y   | N    | Get user information and workspace details                         |
|Repositories  | Y   | Y    | List branches and create a branch to commit sample code            |
|Pull Requests | Y   | Y    | Create a pull request if you start with a Choreo sample            |
|Webhooks      | Y   | Y    | Trigger automatic deployment and configuration generation          |

## Authorize self-managed GitLab with Choreo

Authorizing using a personal access token (PAT) obtained from your GitLab self-managed server grants Choreo the following permissions to perform the respective actions on your behalf within the repository.

|Permission    | Description                                                                         |
|--------------|-------------------------------------------------------------------------------------|
|API           | Grants full read/write access to the API, covering all groups and projects, as well as read/write access to the repository.|


 # Bring Your Own Image (BYOI)

Choreo allows you to deploy and manage prebuilt container images from external container registries as Choreo components. This enables you to deploy and effectively manage your container images within the Choreo environment.

!!! info
    This feature is currently only available on [private data planes (PDPs)](../choreo-concepts/data-planes.md#private-data-planes) for the following component types:

    - Service
    - Web Application
    - Scheduled Task
    - Manual Task


## Prerequisites

Before you try out this guide, ensure you have the following:

- **A container registry**: Ensure you have a container registry containing the images you want to deploy. Choreo is compatible with various container registries, including but not limited to GCR (Google Container Registry), ACR (Azure Container Registry), GitHub Container Registry, and Docker Hub.

- **An image in the registry**: You need an image ready for deployment.

- **(Optional) An external build/CI pipeline**:  This is to initiate automatic deployments during the build process outside of Choreo.

When using a container registry to deploy a component, Choreo cannot create an image from the source code (Git) or initiate a new deployment when a new image is ready. However, you can use your existing build process to trigger a deployment on Choreo by sending an HTTP POST request to a webhook with the new image details.

This feature is currently only available on private data planes (PDPs). You can find this option under **Deploy an image from a container registry** in the **Select Source** step during component creation for service components, web applications, scheduled tasks, and manual tasks.

## Step 1: Register a container registry

To get started, establish a connection between your container registry and Choreo. 

!!! Info
    When you use your Choreo credentials, Choreo does not *pull* your images into its control plane. Instead, it functions as an orchestrator, facilitating your data plane's ability to retrieve images from an external container registry. Choreo passes on these credentials to the data plane for authentication and access.

To register your container registry, follow these steps:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the Choreo Console header, go to the **Organization** list and select your organization. 
3. In the left navigation menu, click **Settings**. This opens the organization settings page. 
4. Click the **Credentials** tab and then click the **Container Registries** tab. 
5. Click **+Add Registry** to configure the Git repository connection.
6. Specify a **Registry Display Name**.
7. Select the **Authentication Type**. Fill in the required information depending on your authentication type. For details on each authentication type, see [Authentication types](#authentication-types).
8. Click **Save**.

### Authentication types

Choreo provides the following authentication options:  

#### Public (anonymous) access
    
You can use this option to establish a connection with a container registry that permits unrestricted public or anonymous access (for example, Public Docker Hub). In this case, only the registry host information is necessary.

For example, the following are the Docker Hub registry hosts for reference:

| Vendor                           | Registry host                |
|----------------------------------|------------------------------|
|Docker Hub (public repositories)  | `registry.hub.docker.com`    |
|Docker Hub (private repositories) | `registry.docker.com`        |

\* If necessary, you can use other mirrors instead of the above.

#### Basic authentication

To use basic authentication to authenticate to the container registry, you must provide the username and password.

#### Docker config

You can provide a Docker config in JSON format to authenticate to the container registry. This option only allows you to register one container registry. That is, it **only allows a single registry under `auths`**.

You must provide the credentials directly within the configuration. Choreo cannot utilize references to executable authentication plugins.

Sample Docker config format:

```json
    {
    "auths": {
        "index.docker.io/v1/": {
        "auth": "c3R...zE2"
        }
    }
    }
```

#### Vendor-specific authentication

This option is specifically for private data planes, where your cloud provider manages authentication at the Kubernetes level. Choreo requires knowledge of the registry host because the data plane already possesses implicit (preconfigured) access to the registry.

Follow the guidelines below based on your container registry:

=== "ACR"
    **Azure Container Registry** 

    Recommended authentication options:

    * [**Service principal-based basic authentication**](https://learn.microsoft.com/en-us/azure/container-registry/container-registry-auth-service-principal)

    * **Vendor-specific authentication on Azure private data planes**
        
        Contact Choreo support to enable infrastructure-level private access to your registry from your Azure private data plane on AKS. If you are on a self-managed PDP on Azure, follow [this guide](https://learn.microsoft.com/en-us/azure/aks/cluster-container-registry-integration?toc=%2Fazure%2Fcontainer-registry%2Ftoc.json&bc=%2Fazure%2Fcontainer-registry%2Fbreadcrumb%2Ftoc.json&tabs=azure-cli).

=== "GAR"
    **Google Artifact Registry**

    Recommended authentication options:

    * [**Service account-based basic authentication**](https://cloud.google.com/artifact-registry/docs/docker/pushing-and-pulling#key)

        Use the service account key in JSON format ([`_json_key`](https://cloud.google.com/artifact-registry/docs/docker/authentication#:~:text=of%20the%20following%3A-,_json_key,-if%20you%20are)) as the username and specify the minified JSON contents of the service account key as the password.

         You can use `jq` as follows to minify the service account JSON key file:

         `jq -c . <service-account.json>`

    * **Vendor-specific authentication on GCP private data planes**

        Contact Choreo support to enable infrastructure-level private access to your registry from your GCP private data plane on GKE. If you are on a self-managed PDP on GCP, see [https://cloud.google.com/artifact-registry/docs/access-control#grant-project](https://cloud.google.com/artifact-registry/docs/access-control#grant-project).

=== "AWS ECR"
    **Elastic Container Registry**

    ECR does not allow the creation of static access passwords for basic authentication. The passwords (that is, access tokens) provided by AWS are only valid for 10 hours and must be manually regenerated. However, when an ECR is attached to an EKS cluster at an infrastructure level, this limitation does not apply because the authentication is handled by AWS internally. For details, see [https://docs.aws.amazon.com/AmazonECR/latest/userguide/registry_auth.html](https://docs.aws.amazon.com/AmazonECR/latest/userguide/registry_auth.html).

    Choreo recommends using ECR when you are exclusively on an AWS private data plane using the vendor-specific authentication option. Contact Choreo support to enable a private connection between your ECR and the underlying EKS clusters on your data plane. If you are on a self-managed PDP, you can follow [this guide](https://docs.aws.amazon.com/AmazonECR/latest/userguide/ECR_on_EKS.html).    

=== "Docker Hub (Private)"

    Recommended authentication options:

    * **Basic authentication**

          Use your Docker Hub username/password or an access token. You can generate an access token from your Docker Hub account settings and use it in place of the password. For details, see [https://docs.docker.com/docker-hub/access-tokens/](https://docs.docker.com/docker-hub/access-tokens/).

    * **Docker config**

          Sign in to the Docker CLI and copy the contents of the docker config JSON. Note that external credential stores and multiple repositories within the same config object are not supported. For more information, see [https://docs.docker.com/engine/reference/commandline/login/](https://docs.docker.com/engine/reference/commandline/login/).

=== "GHCR"
    **GitHub Container Registry**

    Recommended authentication option:

    * **Basic authentication using a PAT token**

          Create a personal access token (PAT) and use it in place of the password. You cannot use your own GitHub password. You must provide a [PAT token](https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry#authenticating-with-a-personal-access-token-classicn).
  
## Step 2: Create a component in Choreo

1. In the left navigation, click **Overview** and select your project. Alternatively, select your project from the **Project** list in the Choreo Console header. 
2. Under **Component Listing** click **+ Create**.
3. Select your component type (BYOI is only available for Service, Web Application, Scheduled Task, or Manual Task components). 
4. From the Create Component pane, select the **Container Registry** under the **Connect a Docker Image** section.
5. Under **Deploy an image from Container Registry/Docker Hub**, select the container registry you have registered in [Step 1](#step-1-register-a-container-registry).
6. Enter the full image URL. The image URL format in general is as follows:
   `[container-registry-host]/[repository-name]/[image-name]:[tag]`

    !!! tip
        When a public image from Docker Hub lacks a specified repository name, it typically defaults to `/library/`. For example, you can access the public Nginx image `https://hub.docker.com/_/nginx` as `registry.hub.docker.com/library/nginx:1.25`.

7. Enter a display name, a unique name, and a description for the component.
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.


## Step 3: Deploy the component in Choreo

To deploy the component and bring your image to Choreo, follow the steps given below: 

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Update Image & Deploy**. 
3. In the **Endpoint** pane that opens, you can see the endpoint ready to be deployed. Click the edit icon next to the endpoint name. Optionally, you can define the endpoints for your service when you manually deploy the service. For more information, see [Expose service endpoints](#step-4-expose-service-endpoints).
4. Change the **Network Visibility** to **Public**. This setting securely exposes the endpoint for consumption.
5. Click **Update**.

    !!! info
         In this example, you deploy a Ballerina service as a REST endpoint. Therefore, Choreo generated the REST endpoint automatically. If you deploy a non-Ballerina service, you must manually add the REST endpoint and set the network visibility to **Public**.

6. Select your update image option. Refer to the update options listed below.

    You have the capability of updating the image when you are deploying the component in Choreo in one of the following three ways:

    | Option                   |Description                                                                                             |
    |--------------------------|--------------------------------------------------------------------------------------------------------|
    | **Update Image Tag**     | This option allows you to update the tag of the image.                                                 |
    | **Update Image URL**     | With this option, you can change the image name, tag, and the image repository of the image URL.|
    | **Previous Images**      | This option allows you to select a previous image and redeploy the image.                               |

7. Click **Deploy**. This deploys the service to the development environment.

## Step 4: Expose service endpoints 

!!! info
    This section only applies to service components.

After creating a service component in Choreo, you have the option to define the endpoints for your service when manually deploying a new image.

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Update Image & Deploy**. 
3. In the **Endpoint** pane that opens, optionally, you can define the endpoints for your service when you manually deploy the service. 
4. Click  **Create/Update Endpoints**.
5. Under the **Edit endpoints.yaml** section, you can edit the endpoints YAML file in the provided editor. 
   Alternatively, you can upload the associated API specification/schema files (OpenAPI/GraphQL schemas). Instead of specifying the file path, you can also reference this file in the `endpoints.yaml` file by its file name, similar to the Git-based Choreo components. The endpoints template follows the standard definitions for defining endpoints in Choreo. For more details, see [Configure Endpoints](../develop-components/configure-endpoints.md).

## Auto-deploy images in Choreo with an external CI/build pipeline

Choreo does not have automatic detection and deployment for newly added images or tags in the linked container registry. To overcome this limitation, Choreo allows you to integrate your own CI pipelines and initiate deployments manually. This approach enables you to use your existing CI setup or build a pipeline for image creation and pushing. You can then trigger automatic deployments using a webhook.

Follow the steps below to configure your CI/build pipeline:

1. Build and push the container image associated with a Choreo component to your container registry.
2. In the left navigation menu, click **DevOps** and then click **External CI**.
3. Generate a token for your CI pipeline from the **Manage Tokens** section. 

    !!! note
        - The tokens are bound to a specific component.
        - It is recommended to reference the token from a secure location available to your CI pipeline. For example, use a GitHub secret if you are using GitHub Actions.

4. To trigger an automatic deployment to your development environment, you can initiate an HTTP POST request to the Choreo webhook endpoint with the updated image details. Alternatively, you can use the provided Webhook snippets. This action will seamlessly deploy the image to the development environment.



Services and integrations are exposed to other services, integrations, or applications through endpoints. A service or an integration can expose multiple endpoints, each representing a unique entry point into the service. For example, a service may expose a REST API endpoint and a GraphQL endpoint, each providing different ways to interact with the service. Endpoints provide specific details for how the service or the integration can be consumed. For instance, the port number, protocol, and the schema such as open API specification (OAS) or GraphQL schema. By defining these details, endpoints make it possible for other services, integrations, and applications to discover and interact with the service in a standardized way.

Choreo defines endpoints by combining port binding, protocol, endpoint name, network visibility, endpoint schema, and additional protocol-related fields. The following table describes each attribute of an endpoint.

| Field | Description |
| ----- | ----------- |
| Name | A unique identifier for the endpoint within the service component. |
| Port | The network port on which the endpoint is accessible. |
| Type | The endpoint protocol. Supported protocols: REST, GraphQL, gRPC, WS, UDP, and TCP. |
| Network Visibility | Determines the level of visibility of an endpoint. Possible values are: <ul><li>Project: Allows components within the same project to access the endpoint.</li><li>Organization: Allows any component within the same organization to access the endpoint but restricts access to components outside the organization.</li><li>Public: Allows any client to access the endpoint, regardless of location or organization.</li></ul> |
| Schema | Specifies the structure and format of the data exchanged through the endpoint. |
| Context (HTTP and GraphQL only) | A context path that you add to the endpoint's URL for routing purposes. |

## Configure endpoints
The method of defining endpoints depends on the buildpack.

* For `Ballerina` and `WSO2 MI` buildpacks, Choreo automatically detects the endpoint details for REST APIs.
* For all other buildpacks (Java, Python, NodeJS, Ruby, PHP, Go, Dockerfile, etc.), you can configure endpoints in one of the following ways:
  
    * **Using the Choreo Console**: If a `component.yaml` file is not present, you can define a basic endpoint configuration during component creation.
    * **Using the component.yaml file**: You can manually configure endpoint details by defining them in a `component.yaml` file, placing it inside the `.choreo` directory at the build context path, and committing it to the source repository.

You can override UI-defined and auto-generated endpoints by providing a `component.yaml` file in the `.choreo` directory, which will take priority over other configurations.

To learn about the `component.yaml` file, see [Overview of the component.yaml file](../develop-components/manage-component-source-configurations.md#overview-of-the-componentyaml-file).
!!! note
    Automatic endpoint generation is not supported for dynamic endpoint parameters such as variable ports. Therefore, you must use an `component.yaml` file to define dynamic endpoint parameters.

To learn about the `component.yaml` file, see [Overview of the component.yaml file](../develop-components/manage-component-source-configurations.md#overview-of-the-componentyaml-file).

## Expose endpoints as managed APIs

Exposing endpoints as managed APIs is crucial to ensure secure and controlled access to the services being exposed. When a user wants to expose their written service to the outside world or to the organization at large, there is an inherent security risk involved. To mitigate this risk, the Choreo platform is built with an internal (access within the organization only) or external (publicly accessible) gateway that is protected with Choreo API management making the services secure by design.

!!! note
    This feature is not available for gRPC, UDP, and TCP endpoints.

If you want to expose an endpoint as a managed API in Choreo, you need to set the network visibility to either Organization or Public. This allows the endpoint to be exposed through the Choreo API Gateway, which provides a number of benefits, including:

* Expose APIs to external and internal consumers
* Full lifecycle API Management
* API throttling
* Secure APIs with industry-standard authorization flows
* API analytics and monitoring

Once you deploy the service component, Choreo will expose the endpoint as a managed API through the Choreo API Gateway. You can then use the full lifecycle API management features provided by Choreo to test, deploy, maintain, monitor, and manage your API using the API management features.

## Understand the default component URL

The default URL of a component corresponds to the default endpoint of the component and is structured as follows:

`<domain>/<project-name>/<component-name>`

This URL does not include the default endpoint name. For all other endpoints, the URL structure includes the endpoint name, as follows:

`<domain>/<project-name>/<component-name>/<endpoint-name>`

If a component has multiple endpoints, Choreo allows you to change the endpoint corresponding to the default component URL. For a component with a single endpoint, the default URL automatically corresponds to that endpoint.

### Change the default endpoint of a component

To change the default endpoint of a component, follow the steps given below:

!!! note
     - You cannot change the default endpoint if it has associated published APIs. You must go to the **Lifecycle** page and unpublish the relevant APIs before updating the default endpoint. For instructions on unpublishing an API, see [Lifecycle Management](https://wso2.com/choreo/docs/api-management/lifecycle-management/).
     - Choreo does not allow you to change the default endpoint of a component if you create multiple deployment tracks within its current major version, or promote the component beyond its initial environment.

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to change the default endpoint.
3. In the left navigation menu, click **Deploy**.
4. On the **Deploy** page, go to the **Set Up** card and click **Configure & Deploy**.
5. In the **Environment Configurations** pane that opens, click **Next**.
6. In the **File Mount** pane that opens, click **Next**.
7. In the **Endpoint Details** pane that opens, click the **Default Endpoint** list, select the endpoint you want to set as the default endpoint, and then click **Update**.
8. Click **Deploy**. This deploys the component with the selected endpoint as the default, and the default URL will now correspond to this endpoint.  

### Edit a UI-Defined Endpoint
If you defined an endpoint during component creation, you can edit it later by following these steps:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to update the endpoint.
3. In the left navigation menu, click **Deploy**.
4. On the **Deploy** page, go to the **Set Up** card and click **Configure & Deploy**.
5. In the **Environment Configurations** pane that opens, click **Next**.
6. In the **File Mount** pane that opens, click **Next**.
7. In the **Endpoint Details** pane that opens, locate the endpoint you want to edit.
8. Click the **Edit** icon next to the endpoint, modify the editable fields, and click **Update**.
9. Click **Deploy** to apply the changes.

!!! note
     If you commit a `component.yaml` file, build the component, and proceed with deployment, the endpoints will be generated from the `component.yaml` file and will take priority. In this case, the endpoint cannot be edited through the UI. To modify the endpoint, you must update the`component.yaml` file.


# Configure Endpoints
{% include "configure-endpoints-body.md" %}

# Deploy a Containerized Application 

Using Choreo, you can easily deploy applications written in different language frameworks (such as Java, Go, NodeJS, Python, etc.) on shared or private data planes using containers.

Choreo supports deploying containerized applications for the following component types:

- Service
- Web Application
- Scheduled Task
- Manual Task
- Event Handler
- Test Runner

## Connect your repository to Choreo

To connect your GitHub repository to Choreo, you should authorize the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application to access your account or organization. When you attempt to connect your GitHub repository via the Component creation page, the Choreo Apps authorization prompt will appear.

* Connect GitHub Repository
    
    ![Connect GitHub Repository](../assets/img/develop-components/deploy/create-component-authz-github-page.png){.cInlineImage-threeQuarter}

* Authorize GitHub Application
    
    ![Authorize GitHub Application](../assets/img/develop-components/deploy/authz-choreo-github-app.png){.cInlineImage-half}

* Grant Repository Access

    ![Grant Repository Access](../assets/img/develop-components/deploy/github-repo-access.png){.cInlineImage-full}


    The **Choreo Apps** requires the following permission:
    
    - Read access to issues and metadata
    - Read and write access to code, pull requests, and repository hooks

!!! note
    You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. Choreo needs write access only to send pull requests to a user repository. Choreo does not directly push any changes to a repository.

Alternatively, you can connect a public repository without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. Select the **Third-Party GitHub Repository** and paste a public repository URL in the **Public Repository URL** field at the time of component creation.

!!! tip
     Authorizing the repository with the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application becomes essential if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component. If you own the repository, you can subsequently authorize it with the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application to enable **Auto Deploy**.

After granting access to the required repositories, you can choose a repository and an associated branch to connect to the Choreo component.
For the containerized application deployments, you should select the [**Component Directory**](https://docs.docker.com/build/building/context/#path-context), **Dockerfile** as the **Buildpack** and provide **Dockerfile Path** for the Docker build.

![Connected Dockerfile Repository](../assets/img/develop-components/deploy/create-component-connected-repo.png){.cInlineImage-full}

The following table describes the individual fields in the **Create Component** pane.

| **Field**               | **Description**                                                                                                                                                                      |
|-------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **GitHub Account**      | Your GitHub account or organization. If you want to add another GitHub account, you can expand the list and click **+ Add**.                                                            |
| **GitHub Repository**   | Depending on the repository access you provided, the list will show available repositories to be connected.                                                                                  |
| **Branch**              | The branch of the repository.                                                                                                                                                         |
| **Buildpack**        | Determines the implementation of the component: Any language or other language as a Docker container.                                                                                |
| **Dockerfile Path**     | The path to your Dockerfile. This path is defined relative to the repository root.<br/>For example, if the Dockerfile is at the repository root, the value for this field is `/Dockerfile`. |
| **Component Directory** | The component directory path. To include the repository root, leave the default `/` value.                                                                                          |
| **Port***               | The port at which your service is running.                                                                                                                                           |
| **OpenAPI Filepath***   | The path to an OpenAPI specification (in YAML/JSON) relative to the repository root. If you don't provide a path, the system automatically generates a default allow-all specification.    |

   
!!! note
 
    - Fields marked with **\*** are not visible for all component types.

    - To successfully build your container with Choreo, it is essential to explicitly define a User ID (`UID`) under the `USER` instruction in your Dockerfile. You can refer to the [sample Dockerfile](https://github.com/wso2/choreo-sample-apps/blob/main/go/rest-api/Dockerfile) for guidance.

    - To ensure that the defined USER instruction is valid, it must conform to the following conditions:
        
        - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
        - Usernames are not considered valid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

## Deploy the containerized component

Choreo will automatically apply deployment configurations and settings based on the component type you select during creation.
For example, if you select the **Service** component type, Choreo will deploy it as a Kubernetes deployment with appropriate scaling configurations.

You can run unit tests in the build pipeline by adding the relevant command to the Dockerfile.  For example: 

- [Go-based sample](https://github.com/wso2/choreo-sample-apps/blob/8c18c82db604adb43b89f669888a07cd6e31d7b7/go/rest-api/Dockerfile#L37)
- [Python-based sample](https://github.com/wso2/choreo-sample-apps/blob/8c18c82db604adb43b89f669888a07cd6e31d7b7/python/rest-api/Dockerfile#L15)

### Application configurations

You must provide any required configurations for running the application in the **Configs & Secrets** section of the component's **DevOps** page. Alternatively, you can also review the configurations when you manually deploy via the **Deploy** page.

After clicking the **Create** button, you can select the confidentiality of the configuration and specify how to mount it to the container.

![Application Configuration Page](../assets/img/develop-components/deploy/deploy-app-config-page.png){.cInlineImage-full}

![Create Configuration Mount Page](../assets/img/develop-components/deploy/deploy-app-config-type-mount-page.png){.cInlineImage-full}

#### Configuration types

* **ConfigMap**: Stores non-confidential data as key-value pairs.
* **Secret**: Stores and manages sensitive information, such as passwords, OAuth tokens, and ssh keys as key-value pairs.

#### Mount types

* **Environment Variables**: Mounts the selected ConfigMap or Secret as an environment variable in the container.
* **File Mount**: Mounts the selected ConfigMap or Secret as a file in the container. Here, the key is the file name, and the value is the file content.

The following image shows adding a **ConfigMap** with **File Mount** mount type to be read by the application.

![Configuration File Mount Page](../assets/img/develop-components/deploy/deploy-app-config-file-mount.png){.cInlineImage-full}

!!! note
    The JSON file includes ${DB_PASS} as an environment variable defined in a Secret. The application reads the JSON file and substitutes the placeholders with the corresponding environment variables.

### Deployment configurations

Choreo lets you configure deployment settings such as scaling, resource limits, and health checks based on your selected component type.

For more information about these configurations, see Choreo's [DevOps capabilities](../devops-and-ci-cd/view-runtime-details.md).

You can configure the **Endpoints** to expose your service using the **Service** Component in Choreo. See [Service Component Overview](../develop-components/develop-services/service-component-overview.md) for more information. 

### Build, deploy, and promote

After adding the application configuration, you can build and deploy it by clicking the **Deploy Manually** button. Choreo will start the build process with the selected commit in the **Build Area**. 

!!! note
    The **Auto Deploy on Commit** feature, which automatically builds and deploys the application upon pushing a code change to the repository, is enabled by default. To turn off this feature, navigate to the **Build Area** of the **Deploy** page.

Choreo scans your Dockerfile for security vulnerabilities during the build phase, and if there are no issues found, it proceeds with the build process. After building the image, it scans it again for vulnerabilities before deployment to the environment. You can view the build logs from the right-side panel, as shown in the image below.

![Build Logs Panel](../assets/img/develop-components/deploy/build-deploy-page-logs.png){.cInlineImage-full}

Once the build process is complete, Choreo will deploy the application automatically to the Development environment. To promote the build to higher environments, you can click the **Promote** button. The number of environment cards visible on the page may vary depending on your environment configurations.

### Troubleshoot security vulnerability scan failures (Trivy)

By default, Choreo utilizes the Aqua Trivy (OSS) image vulnerability scanner to detect security vulnerabilities in all Dockerfile-based build pipelines. The scanner will fail the pipeline if any **CRITICAL** CVEs (Common Vulnerabilities and Exposures) are detected. CVEs of other severity levels are recorded but does not fail the pipeline.

If you cannot fix a critical CVE immediately, you can opt to ignore it. To ignore a critical CVE, add a `trivyignore` (`<docker-build-context-path>/.trivyignore`) file to your build context path. In the file, add the CVEs you need the pipeline to ignore, one entry per line as follows:

```
CVE-2023-xxxx
CVE-2023-yyyy
```

You can add comments in the file by using `#` in front of the comment as follows: 

```
# comments can be added like this
CVE-2023-xxxx
```


# Deploy an Application with Buildpacks

Using Choreo, you can easily deploy applications written in different language frameworks (such as Java, Go, NodeJS, Python, Ruby, PHP, etc.) on shared or private data planes.

Choreo supports deploying applications with buildpacks for the following component types:

- Service
- Web Application
- Scheduled Task
- Manual Task
- Webhook
- Event Handler
- Test Runner

## Buildpacks
Buildpacks are a fundamental building block in modern application development. They convert your source code into a secure, efficient, production-ready container image without a Dockerfile. With Choreo, developers can take advantage of this powerful tool to effortlessly deploy their applications without the hassle of manual configuration.

Choreo uses [Google Buildpacks](https://cloud.google.com/docs/buildpacks/overview) as default buildpacks for Java, Go, NodeJS, Python, PHP, and Ruby. Choreo uses its own buildpacks for Ballerina and WSO2 MI.

## Develop a component

To develop a service component that exposes a Service in Go, you can follow the [Develop a Service ](develop-services/develop-a-service.md) guide.

Follow the guidelines below based on your language:

=== "Python"
    Supported Versions - 3.10.x, 3.11.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Reading Books List Service](https://github.com/wso2/choreo-samples/tree/main/reading-books-list-service-python)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-python-task)|

    ### Procfile
    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    
    !!! info 
        In **Python** projects, it is mandatory to have a `Procfile` with the `web` process type in the project root directory.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: python main.py` <br>
    `web: gunicorn --bind :8080 --workers 1 --threads 8 --timeout 0 main:app` <br>
    `web: flask run --host=0.0.0.0`

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Ballerina"

    Supported Versions - 2201.3.5, 2201.4.1, 2201.5.0, 2201.5.1, 201.6.0,  2201.7.0

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Echo Service](https://github.com/wso2/choreo-samples/tree/main/echo-service)|
    | Manual Task | [Covid19 Statistics To Email](https://github.com/wso2/choreo-samples/tree/main//covid19-statistics-to-email)|
    | Webhook | [Salesforce New Case To Google Sheet](https://github.com/wso2/choreo-samples/tree/main/sfdc-new-case-to-gsheet)|
    | Scheduled Task | [Shopify New Customers to HubSpot Create/Update Contact](https://github.com/wso2/choreo-samples/tree/main/shopify-new-customers-to-hubspot-contact)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Go"

    Supported Versions - 1.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Greeting Service](https://github.com/wso2/choreo-samples/tree/main/greeting-service-go)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-go-task)|
    | Web Application | [Hello World Web Application](https://github.com/wso2/choreo-samples/tree/main/hello-world-go-webapp)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== ".NET"
    Supported Versions - 6.x, 7.x, 8.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service | [Greeting Service](https://github.com/wso2/choreo-samples/tree/main/dotnet-greeter)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Java"
    Supported Versions
        - 8, 11, 17, 18 (OpenJDK Runtime Environment Temurin)

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Product Management Service](https://github.com/wso2/choreo-samples/tree/main/product-management-service)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-java-task)|

    !!! info

         When working on Java projects:

           - The `Main` class should be defined in the manifest file.
           - If Maven files such as `mvn.cmd` exist in the project without the `.mvn` directory, the build will fail. To ensure a successful build, you must either commit the `.mvn` directory along with any Maven files or not include any Maven files in the project if you choose not to commit the `.mvn` directory.
    
    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **Java** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: java -jar target/sample.jar` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "NodeJS"
    Supported Versions - 12.x.x, 14.x.x, 16.x.x, 18.x.x, 20.x.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Reading Books List Service](https://github.com/wso2/choreo-samples/tree/main/reading-books-list-service-nodejs)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-nodejs-task)|

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **NodeJS** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: node app.js` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "PHP"
    Supported Versions - 8.1.x, 8.2.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Hello World Service](https://github.com/wso2/choreo-samples/tree/main/hello-world-php-service)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-php-task)|
    | Web Application | [Hello World Web Application](https://github.com/wso2/choreo-samples/tree/main/hello-world-php-webapp)|

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **PHP** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web:php -S 0.0.0.0:8000 index.php` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Ruby"
    Supported Versions - 3.1.x, 3.2.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service | [Hello World Service](https://github.com/wso2/choreo-samples/tree/main/hello-world-ruby-service)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-ruby-task)|
    | Web Application | [Hello World Web Application](https://github.com/wso2/choreo-samples/tree/main/hello-world-ruby-webapp)|

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **Ruby** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: ruby app.rb` <br>
    `web:bundle exec ruby app.rb -p 8080` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "WSO2 MI"
    Supported Versions - 4.1.0.x, 4.2.0.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service |[Hello World Service](https://github.com/wso2/choreo-samples/tree/main/hello-world-mi)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Spring Boot"
    Supported Java Versions
        - 8, 11, 17, 18 (OpenJDK Runtime Environment Temurin)

    !!! info
         You can use this buildpack only with web applications. For other component types, use the **Java** buildpack. Additionally, if the generated artifact is a `WAR` file, it is necessary to include a **Procfile**.

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **Java** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: java -jar target/sample.war` <br>

### Configure build-time environment variables

You can configure the environment variables necessary to build the component using the **Build Configurations Editor** on the component **Build** page. 

!!! info
    The capability to configure build-time environment variables is not available for components created using **Ballerina** or **WSO2 MI** buildpacks.

During the build process, the build-time environment variables and their values are passed to the buildpack. Therefore, you can configure both buildpack-specific environment variables and those required for the component build.

For example, if you want to override the Maven command of the **Java** buildpack, you can use `GOOGLE_MAVEN_BUILD_ARGS` as the environment key and `clean install` as the value. 

For more examples, see [Google Cloud's buildpacks documentation](https://cloud.google.com/docs/buildpacks/service-specific-configs).


# Develop a Webhook

Choreo allows developers to design high-quality webhooks. To explore this capability, let's consider a scenario where a team of software engineers in an organization should be notified via email whenever someone creates a GitHub issue with the `bug` label in a specific repository.

In this tutorial, you will address the requirement by doing the following:

- Create a webhook by connecting to a forked GitHub repository where you have the webhook implementation that addresses the described requirement.
- Deploy the webhook to the development environment.
- Modify the webhook implementation to connect the webhook to GitHub, enabling it to act in response to selected GitHub-related events.
- Test the webhook.
- Promote the webhook to the production environment.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

## Step 1: Create a webhook component

To create a Webhook component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Webhook** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following information:

    | **Field**                     | **Description**    |
    |-------------------------------|--------------------|
    | **GitHub Account**            | Your account       |
    | **GitHub Repository**         | choreo-samples     |
    | **Branch**                    | main               |
    | **Component Path**              | `github-event-to-email-webhook` |

6. Select **Ballerina** as the build pack.
7. Provide a display name, a unique name and description for the component.
8. Click **Create**.

Choreo creates the Webhook component with the sample implementation and opens the component **Overview** page.

## Step 2: Deploy

To deploy the webhook to the development environment, follow these steps:

1. In the Choreo Console left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**.
3. In the **Configurations** pane, enter the following information:
    1. In the **webhookSecret** field, enter any value.

        !!! note
            Save this value for later use.

    2. In the **toEmail** field, enter the email address to send notification emails.
    3. Click **Deploy**.

    You can monitor the deployment progress in the **Console** pane that opens on the right of the page.

Once Choreo completes the deployment, the **Development** card indicates the **Deployment Status** as **Active**.

!!! note
    In the deployment card, you can click the icon corresponding to configurables to open the **Configurations** pane and edit configurations.

## Step 3: Connect the webhook to the GitHub repository

To allow the webhook to read the labels of issues in a specific GitHub repository, connect the webhook to the GitHub repository:

1. In the Choreo Console left navigation menu, click **Overview**.
2. On the **Overview** page, copy the invoke URL by clicking the copy icon within the **URL** field.
3. Go to your GitHub account and open the repository for which you want to generate notification emails.
4. In the top menu, click the **Settings** tab.
5. In the left navigation menu, click **Webhooks**.
6. Click **Add webhook** and enter the following information:

    | **Field**        | **Value**                                                          |
    |------------------|--------------------------------------------------------------------|
    | **Payload URL**  | The invoke URL you copied in Step 3, sub-step 1.                   |
    | **Content Type** | Select `application/json`                                          |
    | **Secret**       | The last webhook secret you configured in [Step 2](#step-2-deploy).| 

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Project Path** specifies the location of the project to build the component.

7. Under **Which events would you like to trigger this webhook?**, select **Let me select individual events**.
8. Select the **Issues** checkbox in the list of events displayed. This ensures that GitHub issues trigger the webhook.
9. Clear the **Pushes** checkbox to ensure that GitHub does not trigger your webhook when the team pushes changes to the selected GitHub repository.
10. Click **Add webhook** to save the configuration.

Now you have integrated Choreo with GitHub via the webhook you created and deployed. You can proceed to test the webhook.

## Step 4: Test

To test your webhook, create a GitHub issue with the `Bug` label in the repository that you connected to the webhook. You will receive an email similar to the following at the email address you provided in [Step 2](#step-2-deploy).

## Step 5: Promote

To promote the webhook to the Production environment, follow these steps:

1. On the **Deploy** page, go to the **Development** card and click **Promote**.
2. In the **Configuration Types** pane, leave the default selection (i.e., **Use default configuration values**) unchanged.

    !!! note
        If you have configured any default values for the configurable variables, selecting **Use default configuration values** allows you to proceed with those values. If not, specify values for the configurable variables.

3. Click **Next**.
4. In the **webhookSecret** field, enter any value.

    !!! note
        Save this value for later use.

5. In the **toEmail** field, enter the email address to send notification emails.
6. Click **Promote**.

    Once the component is promoted to production, the **Production** card displays the deployment status as **Active**.

Now you have successfully created, deployed, and tested a Webhook component and promoted it to production.


# Develop an External Consumer

An external consumer in Choreo is any client that can interact with services deployed in Choreo, as an entity hosted outside of the Choreo infrastructure. It is a generic component type that allows you to represent and manage any client, such as a mobile application, web application, server-to-server integration, bot, microservices, etc.

In this guide, you will:

 - Create an external consumer component.
 - Manage authentication for the external consumer.
 - Connect the external consumer to a service deployed in Choreo.
 
## Prerequisites

Before you try out this guide, complete the following steps:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

## Step 1: Create an external consumer component
 
To create an external consumer component, follow the steps given below:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **External Consumer** card. 
4. In the **Create an External Consumer** pane that opens, enter a display name, a unique name, and a description for the component.
5. Click **Create**. This creates the component and takes you to its **Overview** page.
   
## Step 2: Manage authentication for the external consumer

You can configure the external consumer to work with the Choreo built-in identity provider or any external identity provider that supports OIDC/OAuth 2.0.

Click the respective tab for details depending on the identity provider you want to configure: 

=== "Choreo built-in identity provider"

     Follow the steps given below to configure the built-in identity provider by generating authentication keys:

    !!! note
         Choreo built-in identity provider is configured by default. Therefore, this step is optional.

     1. In the **Overview** page of the component, under **Authentication Configurations**, click **Configure** corresponding to the environment for which you want to configure an identity provider.
     2. In the **Identity Provider** list, select **Choreo Built-In Identity Provider**.
     3. Click **Generate Keys**. 

        !!! Note
             If you see **Regenerate Secret** instead of **Generate Keys**, it indicates that OAuth keys are already generated for the component in the selected environment.

=== "An external identity provider"

     **Step 2.1: Create and configure an OIDC/OAuth 2.0 application in the external identity provider**

     1. Create an OIDC/OAuth 2.0 application in your external identity provider.
     2. Configure the OIDC/OAuth 2.0 application accordingly. (The access token type should be configured as JWT)

     **Step 2.2: Link the OIDC/OAuth 2.0 application to the Choreo component**

     3. In the **Overview** page of the component, under **Authentication Configurations**, click **Configure** corresponding to the environment for which you want to configure an identity provider.
     4. In the **Identity Provider** list, select your identity provider.
     5. Paste the **Client ID** of the OIDC/OAuth 2.0 application you created in your external identity provider.
     6. Click **Add Keys**.

## Step 3: Connect the external consumer to a service deployed in Choreo 

To establish connections from the external consumer to services deployed in Choreo, you can create connections. For step-by-step instructions on creating a connection, see [Create a Connection](./sharing-and-reusing/create-a-connection.md).


# Develop Components Using VS Code

The [Choreo VS Code extension](https://marketplace.visualstudio.com/items?itemName=WSO2.choreo) provides comprehensive component management capabilities to streamline local development within Choreo.

## Prerequisites

To ensure a smooth development experience with the Choreo extension, make sure you have the following:

1. [Visual Studio Code](https://code.visualstudio.com/download) installed with the [Choreo extension](https://marketplace.visualstudio.com/items?itemName=WSO2.choreo) version **2.0.0** or later.

2. A locally cloned GitHub repository to create new components or link to existing Choreo components.

3. [Git](https://git-scm.com) version 2.0.0 or later.

## Get started

To use the capabilities of the Choreo extension in the VS Code editor, you need an active [Choreo account](https://wso2.com/choreo/pricing/). If you already have an account, follow these steps to set up the extension:

1. Install the [Choreo VS Code extension](https://marketplace.visualstudio.com/items?itemName=WSO2.choreo) and wait for activation. On successful activation, the Choreo extension opens in the VS Code editor. 
2. Sign in to Choreo using one of the following methods:
    - In the Choreo activity pane, click **Sign In**.
       ![Sign in](../assets/img/develop-components/develop-using-vs-code/sign-in.png)
    - Use the `Sign In` command provided by the Choreo extension.

    This redirects you to an external URI to complete the authentication process. On successful sign-in, the Choreo activity pane displays your account details along with any components detected within the VS Code workspace.

## Create a new component

1. Open the source code directory where you want to build, deploy, and manage components using Choreo.
2. Create a new component using one of the following methods:
    - In the Choreo activity pane, click **Create Component**.
       ![Create Component Button](../assets/img/develop-components/develop-using-vs-code/create-component-btn.png)
    - Use the `Create New Component` command provided by the Choreo extension.

3. If the Choreo extension cannot determine the project context of the opened workspace, it prompts you to select the organization and the project to which the new component belongs.
4. Specify component details such as the name, type, buildpack, etc.

    ![Component Form](../assets/img/develop-components/develop-using-vs-code/component-form.png)
            
    On successful creation, the component details view opens, and the Choreo activity pane displays the new component.

    ![Component Details](../assets/img/develop-components/develop-using-vs-code/component-details-view.png)
     
    !!! tip
        Once the component is created, a `.choreo/context.yaml` file is generated in the root of the Git repository. For more details, see [Understand the project context](#understand-the-project-context).

The component details view allows you to manage your component by performing various actions such as the following:

 - Triggering builds for selected commits.
 - Viewing lists of builds and statuses.
 - Diagnosing build failures with build logs.
 - Deploying builds in available environments.
 - Accessing runtime logs and deployed component URLs.
 - Invoking deployed service endpoints.

## Understand the project context

Context files contain metadata related to the project, allowing the extension to establish an association between local directories and Choreo projects. These files, such as the `context.yaml`file, resides in the `/.choreo` directory within the root of the Git repository.

The Choreo extension scans the root of the opened Git repository to find the `context.yaml` file and lists the components of the associated project. This allows you to easily open and manage the components they are developing within the VS Code workspace.

A `context.yaml` file can contain multiple projects, whereas, a workspace opened via VS Code can have multiple `context.yaml` files with different project associations. In such cases, VS Code allows you to switch between these projects, add new project associations, or remove existing ones, allowing you as a developer to focus on components of a particular project at a time.

You can decide whether to commit the `context.yaml` file to the Git repository. Committing this file enables other team members working on the same repository to have a seamless developer experience with Choreo.

If the `context.yaml` file for a particular project is not committed to the Git repository or is unavailable for other reasons, you can easily regenerate it using one of the following methods:

 - In the Choreo activity pane, click **Link Directory**.
    ![Link Directory](../assets/img/develop-components/develop-using-vs-code/link-dir-btn.png)
 - Use the `Link Directory` command provided by the Choreo extension.

## Discover additional features

To access a range of functionalities provided by the Choreo extension, open the VS Code command palette and type `Choreo`.

## Troubleshoot issues

To troubleshoot Choreo extension issues, follow these steps:

1. To open the **OUTPUT** pane, go to the VS Code editor main menu, click **View**, and then click **Output**.

2. Select **Choreo** from the drop-down menu on the right-hand side to view the Choreo output for troubleshooting.

## Get help

For assistance with the Choreo VS Code extension, create [GitHub issues](https://github.com/wso2/choreo-vscode/issues).


# Develop Components With Git

Choreo enables you to develop components by connecting your GitHub, Bitbucket, or GitLab repository. You have the flexibility to either connect an existing repository or start with an empty repository and commit the source code later. By integrating your repositories with Choreo, you can automate tasks and optimize workflows across multiple systems, all within the Choreo platform.  Choreo currently supports GitHub, Bitbucket, and GitLab as Git providers. 

!!! tip
    Choreo supports both Bitbucket Server and Bitbucket Cloud. The currently supported Bitbucket Server version is 8.9.2.

In Choreo, you can connect a Git repository that contains Ballerina source code or a Docker project. To connect a Git repository to Choreo as a Docker project, your Git repository must include the following:

 - A Dockerfile: Specifies the instructions to build the Docker image. 
 - A build context: A set of files in the specified path used to build the image.

Once you connect your Git repository to Choreo, you can build, deploy, and manage your application easily. 

## Connect a Git repository to Choreo

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the Choreo Console header, go to the **Organization** list and select your organization. 
3. In the left navigation menu, click **Settings**. This opens the organization-level settings page. 
4. Click the **Credentials** tab. 
5. Click **+Add Credentials** to configure the Git repository connection.
6. Enter a **Credential Name**, select the Git provider, and enter the **Personal Access Token** you obtained from the Git provider.
7. Click **Save**.  

## Authorize GitHub with Choreo 

Authorizing Choreo as a GitHub application grants Choreo the following permissions to perform the respective actions on your behalf within the repository:

|Permission   | Read| Write| Description                                                           |
|-------------|-----|------|-----------------------------------------------------------------------|
|Issues       | Y   | N    | Read component ID label to filter the pull requests                   |
|Metadata     | Y   | N    | List repositories                                                     |
|Contents     | Y   | Y    | List branches and create a branch to commit sample code               |
|Pull Request | Y   | Y    | Create a pull request if you start with a Choreo sample               |
|Webhooks     | Y   | Y    | Trigger automatic deployment and configuration generation             |

### Add Git submodules to a project

Choreo provides [Git submodule](https://git-scm.com/book/en/v2/Git-Tools-Submodules) support when you connect your GitHub repository to Choreo. This allows you to manage and include external repositories effectively within Choreo build pipelines. Key benefits of this capability include:

  - **Code sharing without duplication**: Use submodules to maintain shared libraries across multiple projects, ensuring a single source of truth.
  - **Efficient third-party library management**: Manage third-party libraries as submodules to update them independently and track changes easily, avoiding direct code integration.

For example, when you [work with the Micro Integrator (MI) runtime in Choreo](./work-with-the-micro-integrator-runtime-in-choreo.md), you can use Git submodules to reuse MI templates and sequences across components without duplication.

!!! info "Note" 
    If you encounter an error stating that you cannot clone a submodule due to insufficient permissions, follow the instructions below to grant the necessary permissions:

      - For a personal account:

         1. Sign in to your personal GitHub account.
         2. In the upper-right corner, click your profile picture, and then click **Settings**.
         3. In the left navigation menu, go to the **Integrations** section and click **Applications**.
         4. Under the **Installed GitHub Apps** tab, click **Configure** corresponding to **choreo.dev**.
         5. Under **Repository Access**, grant access to the necessary repositories.

      - For an organization account:

         1. Sign in to your organization's GitHub account.
         2. In the upper-right corner, click your profile picture, and then click **Settings**.
         3. In the left navigation menu, go to the **Third-Party Access** section and click **GitHub Apps**.
         4. Click **Configure** corresponding to **choreo.dev**.
         5. Under **Repository Access**, grant access to the necessary repositories.

            !!! note
                Choreo currently does not support accessing private repositories in other organizations.

#### Automatically pull latest versions of Git submodules

Choreo lets you automatically pull the latest versions of Git submodules from their respective repositories. To enable this feature, follow these steps:

!!! note 
    Choreo currently supports this feature only for components where the buildpack is **WSO2 MI**.

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click the component for which you want to pull the latest versions of Git submodules.
3. In the left navigation menu, click **Build**.
4. On the **Build** page, click to edit **Build Configurations**.
5. Turn on the **Pull Latest Submodules** toggle.

    !!! info "Note"
        If you rebuild a previously built commit and it doesn’t reflect the latest changes, follow these steps to ensure the changes are applied to the deployed environment:

         1. In the Choreo Console left navigation menu, click **DevOps**, then click **Containers**.
         2. Click **Edit** to update the container settings.
         3. Select **Always** as the **Image Pull Policy**.
         4. Click **Save Changes**.

## Authorize Bitbucket with Choreo

Authorizing using a personal access token (PAT) from Bitbucket grants Choreo the following permissions to perform the respective actions on your behalf within the repository.

|Permission    | Read| Write| Description                                                        |
|--------------|-----|------|--------------------------------------------------------------------|
|Account       | Y   | N    | Get user information and workspace details                         |
|Repositories  | Y   | Y    | List branches and create a branch to commit sample code            |
|Pull Requests | Y   | Y    | Create a pull request if you start with a Choreo sample            |
|Webhooks      | Y   | Y    | Trigger automatic deployment and configuration generation          |

## Authorize self-managed GitLab with Choreo

Authorizing using a personal access token (PAT) obtained from your GitLab self-managed server grants Choreo the following permissions to perform the respective actions on your behalf within the repository.

|Permission    | Description                                                                         |
|--------------|-------------------------------------------------------------------------------------|
|API           | Grants full read/write access to the API, covering all groups and projects, as well as read/write access to the repository.|


 # Bring Your Own Image (BYOI)

Choreo allows you to deploy and manage prebuilt container images from external container registries as Choreo components. This enables you to deploy and effectively manage your container images within the Choreo environment.

!!! info
    This feature is currently only available on [private data planes (PDPs)](../choreo-concepts/data-planes.md#private-data-planes) for the following component types:

    - Service
    - Web Application
    - Scheduled Task
    - Manual Task


## Prerequisites

Before you try out this guide, ensure you have the following:

- **A container registry**: Ensure you have a container registry containing the images you want to deploy. Choreo is compatible with various container registries, including but not limited to GCR (Google Container Registry), ACR (Azure Container Registry), GitHub Container Registry, and Docker Hub.

- **An image in the registry**: You need an image ready for deployment.

- **(Optional) An external build/CI pipeline**:  This is to initiate automatic deployments during the build process outside of Choreo.

When using a container registry to deploy a component, Choreo cannot create an image from the source code (Git) or initiate a new deployment when a new image is ready. However, you can use your existing build process to trigger a deployment on Choreo by sending an HTTP POST request to a webhook with the new image details.

This feature is currently only available on private data planes (PDPs). You can find this option under **Deploy an image from a container registry** in the **Select Source** step during component creation for service components, web applications, scheduled tasks, and manual tasks.

## Step 1: Register a container registry

To get started, establish a connection between your container registry and Choreo. 

!!! Info
    When you use your Choreo credentials, Choreo does not *pull* your images into its control plane. Instead, it functions as an orchestrator, facilitating your data plane's ability to retrieve images from an external container registry. Choreo passes on these credentials to the data plane for authentication and access.

To register your container registry, follow these steps:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the Choreo Console header, go to the **Organization** list and select your organization. 
3. In the left navigation menu, click **Settings**. This opens the organization settings page. 
4. Click the **Credentials** tab and then click the **Container Registries** tab. 
5. Click **+Add Registry** to configure the Git repository connection.
6. Specify a **Registry Display Name**.
7. Select the **Authentication Type**. Fill in the required information depending on your authentication type. For details on each authentication type, see [Authentication types](#authentication-types).
8. Click **Save**.

### Authentication types

Choreo provides the following authentication options:  

#### Public (anonymous) access
    
You can use this option to establish a connection with a container registry that permits unrestricted public or anonymous access (for example, Public Docker Hub). In this case, only the registry host information is necessary.

For example, the following are the Docker Hub registry hosts for reference:

| Vendor                           | Registry host                |
|----------------------------------|------------------------------|
|Docker Hub (public repositories)  | `registry.hub.docker.com`    |
|Docker Hub (private repositories) | `registry.docker.com`        |

\* If necessary, you can use other mirrors instead of the above.

#### Basic authentication

To use basic authentication to authenticate to the container registry, you must provide the username and password.

#### Docker config

You can provide a Docker config in JSON format to authenticate to the container registry. This option only allows you to register one container registry. That is, it **only allows a single registry under `auths`**.

You must provide the credentials directly within the configuration. Choreo cannot utilize references to executable authentication plugins.

Sample Docker config format:

```json
    {
    "auths": {
        "index.docker.io/v1/": {
        "auth": "c3R...zE2"
        }
    }
    }
```

#### Vendor-specific authentication

This option is specifically for private data planes, where your cloud provider manages authentication at the Kubernetes level. Choreo requires knowledge of the registry host because the data plane already possesses implicit (preconfigured) access to the registry.

Follow the guidelines below based on your container registry:

=== "ACR"
    **Azure Container Registry** 

    Recommended authentication options:

    * [**Service principal-based basic authentication**](https://learn.microsoft.com/en-us/azure/container-registry/container-registry-auth-service-principal)

    * **Vendor-specific authentication on Azure private data planes**
        
        Contact Choreo support to enable infrastructure-level private access to your registry from your Azure private data plane on AKS. If you are on a self-managed PDP on Azure, follow [this guide](https://learn.microsoft.com/en-us/azure/aks/cluster-container-registry-integration?toc=%2Fazure%2Fcontainer-registry%2Ftoc.json&bc=%2Fazure%2Fcontainer-registry%2Fbreadcrumb%2Ftoc.json&tabs=azure-cli).

=== "GAR"
    **Google Artifact Registry**

    Recommended authentication options:

    * [**Service account-based basic authentication**](https://cloud.google.com/artifact-registry/docs/docker/pushing-and-pulling#key)

        Use the service account key in JSON format ([`_json_key`](https://cloud.google.com/artifact-registry/docs/docker/authentication#:~:text=of%20the%20following%3A-,_json_key,-if%20you%20are)) as the username and specify the minified JSON contents of the service account key as the password.

         You can use `jq` as follows to minify the service account JSON key file:

         `jq -c . <service-account.json>`

    * **Vendor-specific authentication on GCP private data planes**

        Contact Choreo support to enable infrastructure-level private access to your registry from your GCP private data plane on GKE. If you are on a self-managed PDP on GCP, see [https://cloud.google.com/artifact-registry/docs/access-control#grant-project](https://cloud.google.com/artifact-registry/docs/access-control#grant-project).

=== "AWS ECR"
    **Elastic Container Registry**

    ECR does not allow the creation of static access passwords for basic authentication. The passwords (that is, access tokens) provided by AWS are only valid for 10 hours and must be manually regenerated. However, when an ECR is attached to an EKS cluster at an infrastructure level, this limitation does not apply because the authentication is handled by AWS internally. For details, see [https://docs.aws.amazon.com/AmazonECR/latest/userguide/registry_auth.html](https://docs.aws.amazon.com/AmazonECR/latest/userguide/registry_auth.html).

    Choreo recommends using ECR when you are exclusively on an AWS private data plane using the vendor-specific authentication option. Contact Choreo support to enable a private connection between your ECR and the underlying EKS clusters on your data plane. If you are on a self-managed PDP, you can follow [this guide](https://docs.aws.amazon.com/AmazonECR/latest/userguide/ECR_on_EKS.html).    

=== "Docker Hub (Private)"

    Recommended authentication options:

    * **Basic authentication**

          Use your Docker Hub username/password or an access token. You can generate an access token from your Docker Hub account settings and use it in place of the password. For details, see [https://docs.docker.com/docker-hub/access-tokens/](https://docs.docker.com/docker-hub/access-tokens/).

    * **Docker config**

          Sign in to the Docker CLI and copy the contents of the docker config JSON. Note that external credential stores and multiple repositories within the same config object are not supported. For more information, see [https://docs.docker.com/engine/reference/commandline/login/](https://docs.docker.com/engine/reference/commandline/login/).

=== "GHCR"
    **GitHub Container Registry**

    Recommended authentication option:

    * **Basic authentication using a PAT token**

          Create a personal access token (PAT) and use it in place of the password. You cannot use your own GitHub password. You must provide a [PAT token](https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry#authenticating-with-a-personal-access-token-classicn).
  
## Step 2: Create a component in Choreo

1. In the left navigation, click **Overview** and select your project. Alternatively, select your project from the **Project** list in the Choreo Console header. 
2. Under **Component Listing** click **+ Create**.
3. Select your component type (BYOI is only available for Service, Web Application, Scheduled Task, or Manual Task components). 
4. From the Create Component pane, select the **Container Registry** under the **Connect a Docker Image** section.
5. Under **Deploy an image from Container Registry/Docker Hub**, select the container registry you have registered in [Step 1](#step-1-register-a-container-registry).
6. Enter the full image URL. The image URL format in general is as follows:
   `[container-registry-host]/[repository-name]/[image-name]:[tag]`

    !!! tip
        When a public image from Docker Hub lacks a specified repository name, it typically defaults to `/library/`. For example, you can access the public Nginx image `https://hub.docker.com/_/nginx` as `registry.hub.docker.com/library/nginx:1.25`.

7. Enter a display name, a unique name, and a description for the component.
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.


## Step 3: Deploy the component in Choreo

To deploy the component and bring your image to Choreo, follow the steps given below: 

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Update Image & Deploy**. 
3. In the **Endpoint** pane that opens, you can see the endpoint ready to be deployed. Click the edit icon next to the endpoint name. Optionally, you can define the endpoints for your service when you manually deploy the service. For more information, see [Expose service endpoints](#step-4-expose-service-endpoints).
4. Change the **Network Visibility** to **Public**. This setting securely exposes the endpoint for consumption.
5. Click **Update**.

    !!! info
         In this example, you deploy a Ballerina service as a REST endpoint. Therefore, Choreo generated the REST endpoint automatically. If you deploy a non-Ballerina service, you must manually add the REST endpoint and set the network visibility to **Public**.

6. Select your update image option. Refer to the update options listed below.

    You have the capability of updating the image when you are deploying the component in Choreo in one of the following three ways:

    | Option                   |Description                                                                                             |
    |--------------------------|--------------------------------------------------------------------------------------------------------|
    | **Update Image Tag**     | This option allows you to update the tag of the image.                                                 |
    | **Update Image URL**     | With this option, you can change the image name, tag, and the image repository of the image URL.|
    | **Previous Images**      | This option allows you to select a previous image and redeploy the image.                               |

7. Click **Deploy**. This deploys the service to the development environment.

## Step 4: Expose service endpoints 

!!! info
    This section only applies to service components.

After creating a service component in Choreo, you have the option to define the endpoints for your service when manually deploying a new image.

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Update Image & Deploy**. 
3. In the **Endpoint** pane that opens, optionally, you can define the endpoints for your service when you manually deploy the service. 
4. Click  **Create/Update Endpoints**.
5. Under the **Edit endpoints.yaml** section, you can edit the endpoints YAML file in the provided editor. 
   Alternatively, you can upload the associated API specification/schema files (OpenAPI/GraphQL schemas). Instead of specifying the file path, you can also reference this file in the `endpoints.yaml` file by its file name, similar to the Git-based Choreo components. The endpoints template follows the standard definitions for defining endpoints in Choreo. For more details, see [Configure Endpoints](../develop-components/configure-endpoints.md).

## Auto-deploy images in Choreo with an external CI/build pipeline

Choreo does not have automatic detection and deployment for newly added images or tags in the linked container registry. To overcome this limitation, Choreo allows you to integrate your own CI pipelines and initiate deployments manually. This approach enables you to use your existing CI setup or build a pipeline for image creation and pushing. You can then trigger automatic deployments using a webhook.

Follow the steps below to configure your CI/build pipeline:

1. Build and push the container image associated with a Choreo component to your container registry.
2. In the left navigation menu, click **DevOps** and then click **External CI**.
3. Generate a token for your CI pipeline from the **Manage Tokens** section. 

    !!! note
        - The tokens are bound to a specific component.
        - It is recommended to reference the token from a secure location available to your CI pipeline. For example, use a GitHub secret if you are using GitHub Actions.

4. To trigger an automatic deployment to your development environment, you can initiate an HTTP POST request to the Choreo webhook endpoint with the updated image details. Alternatively, you can use the provided Webhook snippets. This action will seamlessly deploy the image to the development environment.



Services and integrations are exposed to other services, integrations, or applications through endpoints. A service or an integration can expose multiple endpoints, each representing a unique entry point into the service. For example, a service may expose a REST API endpoint and a GraphQL endpoint, each providing different ways to interact with the service. Endpoints provide specific details for how the service or the integration can be consumed. For instance, the port number, protocol, and the schema such as open API specification (OAS) or GraphQL schema. By defining these details, endpoints make it possible for other services, integrations, and applications to discover and interact with the service in a standardized way.

Choreo defines endpoints by combining port binding, protocol, endpoint name, network visibility, endpoint schema, and additional protocol-related fields. The following table describes each attribute of an endpoint.

| Field | Description |
| ----- | ----------- |
| Name | A unique identifier for the endpoint within the service component. |
| Port | The network port on which the endpoint is accessible. |
| Type | The endpoint protocol. Supported protocols: REST, GraphQL, gRPC, WS, UDP, and TCP. |
| Network Visibility | Determines the level of visibility of an endpoint. Possible values are: <ul><li>Project: Allows components within the same project to access the endpoint.</li><li>Organization: Allows any component within the same organization to access the endpoint but restricts access to components outside the organization.</li><li>Public: Allows any client to access the endpoint, regardless of location or organization.</li></ul> |
| Schema | Specifies the structure and format of the data exchanged through the endpoint. |
| Context (HTTP and GraphQL only) | A context path that you add to the endpoint's URL for routing purposes. |

## Configure endpoints
The method of defining endpoints depends on the buildpack.

* For `Ballerina` and `WSO2 MI` buildpacks, Choreo automatically detects the endpoint details for REST APIs.
* For all other buildpacks (Java, Python, NodeJS, Ruby, PHP, Go, Dockerfile, etc.), you can configure endpoints in one of the following ways:
  
    * **Using the Choreo Console**: If a `component.yaml` file is not present, you can define a basic endpoint configuration during component creation.
    * **Using the component.yaml file**: You can manually configure endpoint details by defining them in a `component.yaml` file, placing it inside the `.choreo` directory at the build context path, and committing it to the source repository.

You can override UI-defined and auto-generated endpoints by providing a `component.yaml` file in the `.choreo` directory, which will take priority over other configurations.

To learn about the `component.yaml` file, see [Overview of the component.yaml file](../develop-components/manage-component-source-configurations.md#overview-of-the-componentyaml-file).
!!! note
    Automatic endpoint generation is not supported for dynamic endpoint parameters such as variable ports. Therefore, you must use an `component.yaml` file to define dynamic endpoint parameters.

To learn about the `component.yaml` file, see [Overview of the component.yaml file](../develop-components/manage-component-source-configurations.md#overview-of-the-componentyaml-file).

## Expose endpoints as managed APIs

Exposing endpoints as managed APIs is crucial to ensure secure and controlled access to the services being exposed. When a user wants to expose their written service to the outside world or to the organization at large, there is an inherent security risk involved. To mitigate this risk, the Choreo platform is built with an internal (access within the organization only) or external (publicly accessible) gateway that is protected with Choreo API management making the services secure by design.

!!! note
    This feature is not available for gRPC, UDP, and TCP endpoints.

If you want to expose an endpoint as a managed API in Choreo, you need to set the network visibility to either Organization or Public. This allows the endpoint to be exposed through the Choreo API Gateway, which provides a number of benefits, including:

* Expose APIs to external and internal consumers
* Full lifecycle API Management
* API throttling
* Secure APIs with industry-standard authorization flows
* API analytics and monitoring

Once you deploy the service component, Choreo will expose the endpoint as a managed API through the Choreo API Gateway. You can then use the full lifecycle API management features provided by Choreo to test, deploy, maintain, monitor, and manage your API using the API management features.

## Understand the default component URL

The default URL of a component corresponds to the default endpoint of the component and is structured as follows:

`<domain>/<project-name>/<component-name>`

This URL does not include the default endpoint name. For all other endpoints, the URL structure includes the endpoint name, as follows:

`<domain>/<project-name>/<component-name>/<endpoint-name>`

If a component has multiple endpoints, Choreo allows you to change the endpoint corresponding to the default component URL. For a component with a single endpoint, the default URL automatically corresponds to that endpoint.

### Change the default endpoint of a component

To change the default endpoint of a component, follow the steps given below:

!!! note
     - You cannot change the default endpoint if it has associated published APIs. You must go to the **Lifecycle** page and unpublish the relevant APIs before updating the default endpoint. For instructions on unpublishing an API, see [Lifecycle Management](https://wso2.com/choreo/docs/api-management/lifecycle-management/).
     - Choreo does not allow you to change the default endpoint of a component if you create multiple deployment tracks within its current major version, or promote the component beyond its initial environment.

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to change the default endpoint.
3. In the left navigation menu, click **Deploy**.
4. On the **Deploy** page, go to the **Set Up** card and click **Configure & Deploy**.
5. In the **Environment Configurations** pane that opens, click **Next**.
6. In the **File Mount** pane that opens, click **Next**.
7. In the **Endpoint Details** pane that opens, click the **Default Endpoint** list, select the endpoint you want to set as the default endpoint, and then click **Update**.
8. Click **Deploy**. This deploys the component with the selected endpoint as the default, and the default URL will now correspond to this endpoint.  

### Edit a UI-Defined Endpoint
If you defined an endpoint during component creation, you can edit it later by following these steps:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to update the endpoint.
3. In the left navigation menu, click **Deploy**.
4. On the **Deploy** page, go to the **Set Up** card and click **Configure & Deploy**.
5. In the **Environment Configurations** pane that opens, click **Next**.
6. In the **File Mount** pane that opens, click **Next**.
7. In the **Endpoint Details** pane that opens, locate the endpoint you want to edit.
8. Click the **Edit** icon next to the endpoint, modify the editable fields, and click **Update**.
9. Click **Deploy** to apply the changes.

!!! note
     If you commit a `component.yaml` file, build the component, and proceed with deployment, the endpoints will be generated from the `component.yaml` file and will take priority. In this case, the endpoint cannot be edited through the UI. To modify the endpoint, you must update the`component.yaml` file.


# Configure Endpoints
{% include "configure-endpoints-body.md" %}

# Deploy a Containerized Application 

Using Choreo, you can easily deploy applications written in different language frameworks (such as Java, Go, NodeJS, Python, etc.) on shared or private data planes using containers.

Choreo supports deploying containerized applications for the following component types:

- Service
- Web Application
- Scheduled Task
- Manual Task
- Event Handler
- Test Runner

## Connect your repository to Choreo

To connect your GitHub repository to Choreo, you should authorize the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application to access your account or organization. When you attempt to connect your GitHub repository via the Component creation page, the Choreo Apps authorization prompt will appear.

* Connect GitHub Repository
    
    ![Connect GitHub Repository](../assets/img/develop-components/deploy/create-component-authz-github-page.png){.cInlineImage-threeQuarter}

* Authorize GitHub Application
    
    ![Authorize GitHub Application](../assets/img/develop-components/deploy/authz-choreo-github-app.png){.cInlineImage-half}

* Grant Repository Access

    ![Grant Repository Access](../assets/img/develop-components/deploy/github-repo-access.png){.cInlineImage-full}


    The **Choreo Apps** requires the following permission:
    
    - Read access to issues and metadata
    - Read and write access to code, pull requests, and repository hooks

!!! note
    You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. Choreo needs write access only to send pull requests to a user repository. Choreo does not directly push any changes to a repository.

Alternatively, you can connect a public repository without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. Select the **Third-Party GitHub Repository** and paste a public repository URL in the **Public Repository URL** field at the time of component creation.

!!! tip
     Authorizing the repository with the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application becomes essential if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component. If you own the repository, you can subsequently authorize it with the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application to enable **Auto Deploy**.

After granting access to the required repositories, you can choose a repository and an associated branch to connect to the Choreo component.
For the containerized application deployments, you should select the [**Component Directory**](https://docs.docker.com/build/building/context/#path-context), **Dockerfile** as the **Buildpack** and provide **Dockerfile Path** for the Docker build.

![Connected Dockerfile Repository](../assets/img/develop-components/deploy/create-component-connected-repo.png){.cInlineImage-full}

The following table describes the individual fields in the **Create Component** pane.

| **Field**               | **Description**                                                                                                                                                                      |
|-------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **GitHub Account**      | Your GitHub account or organization. If you want to add another GitHub account, you can expand the list and click **+ Add**.                                                            |
| **GitHub Repository**   | Depending on the repository access you provided, the list will show available repositories to be connected.                                                                                  |
| **Branch**              | The branch of the repository.                                                                                                                                                         |
| **Buildpack**        | Determines the implementation of the component: Any language or other language as a Docker container.                                                                                |
| **Dockerfile Path**     | The path to your Dockerfile. This path is defined relative to the repository root.<br/>For example, if the Dockerfile is at the repository root, the value for this field is `/Dockerfile`. |
| **Component Directory** | The component directory path. To include the repository root, leave the default `/` value.                                                                                          |
| **Port***               | The port at which your service is running.                                                                                                                                           |
| **OpenAPI Filepath***   | The path to an OpenAPI specification (in YAML/JSON) relative to the repository root. If you don't provide a path, the system automatically generates a default allow-all specification.    |

   
!!! note
 
    - Fields marked with **\*** are not visible for all component types.

    - To successfully build your container with Choreo, it is essential to explicitly define a User ID (`UID`) under the `USER` instruction in your Dockerfile. You can refer to the [sample Dockerfile](https://github.com/wso2/choreo-sample-apps/blob/main/go/rest-api/Dockerfile) for guidance.

    - To ensure that the defined USER instruction is valid, it must conform to the following conditions:
        
        - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
        - Usernames are not considered valid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

## Deploy the containerized component

Choreo will automatically apply deployment configurations and settings based on the component type you select during creation.
For example, if you select the **Service** component type, Choreo will deploy it as a Kubernetes deployment with appropriate scaling configurations.

You can run unit tests in the build pipeline by adding the relevant command to the Dockerfile.  For example: 

- [Go-based sample](https://github.com/wso2/choreo-sample-apps/blob/8c18c82db604adb43b89f669888a07cd6e31d7b7/go/rest-api/Dockerfile#L37)
- [Python-based sample](https://github.com/wso2/choreo-sample-apps/blob/8c18c82db604adb43b89f669888a07cd6e31d7b7/python/rest-api/Dockerfile#L15)

### Application configurations

You must provide any required configurations for running the application in the **Configs & Secrets** section of the component's **DevOps** page. Alternatively, you can also review the configurations when you manually deploy via the **Deploy** page.

After clicking the **Create** button, you can select the confidentiality of the configuration and specify how to mount it to the container.

![Application Configuration Page](../assets/img/develop-components/deploy/deploy-app-config-page.png){.cInlineImage-full}

![Create Configuration Mount Page](../assets/img/develop-components/deploy/deploy-app-config-type-mount-page.png){.cInlineImage-full}

#### Configuration types

* **ConfigMap**: Stores non-confidential data as key-value pairs.
* **Secret**: Stores and manages sensitive information, such as passwords, OAuth tokens, and ssh keys as key-value pairs.

#### Mount types

* **Environment Variables**: Mounts the selected ConfigMap or Secret as an environment variable in the container.
* **File Mount**: Mounts the selected ConfigMap or Secret as a file in the container. Here, the key is the file name, and the value is the file content.

The following image shows adding a **ConfigMap** with **File Mount** mount type to be read by the application.

![Configuration File Mount Page](../assets/img/develop-components/deploy/deploy-app-config-file-mount.png){.cInlineImage-full}

!!! note
    The JSON file includes ${DB_PASS} as an environment variable defined in a Secret. The application reads the JSON file and substitutes the placeholders with the corresponding environment variables.

### Deployment configurations

Choreo lets you configure deployment settings such as scaling, resource limits, and health checks based on your selected component type.

For more information about these configurations, see Choreo's [DevOps capabilities](../devops-and-ci-cd/view-runtime-details.md).

You can configure the **Endpoints** to expose your service using the **Service** Component in Choreo. See [Service Component Overview](../develop-components/develop-services/service-component-overview.md) for more information. 

### Build, deploy, and promote

After adding the application configuration, you can build and deploy it by clicking the **Deploy Manually** button. Choreo will start the build process with the selected commit in the **Build Area**. 

!!! note
    The **Auto Deploy on Commit** feature, which automatically builds and deploys the application upon pushing a code change to the repository, is enabled by default. To turn off this feature, navigate to the **Build Area** of the **Deploy** page.

Choreo scans your Dockerfile for security vulnerabilities during the build phase, and if there are no issues found, it proceeds with the build process. After building the image, it scans it again for vulnerabilities before deployment to the environment. You can view the build logs from the right-side panel, as shown in the image below.

![Build Logs Panel](../assets/img/develop-components/deploy/build-deploy-page-logs.png){.cInlineImage-full}

Once the build process is complete, Choreo will deploy the application automatically to the Development environment. To promote the build to higher environments, you can click the **Promote** button. The number of environment cards visible on the page may vary depending on your environment configurations.

### Troubleshoot security vulnerability scan failures (Trivy)

By default, Choreo utilizes the Aqua Trivy (OSS) image vulnerability scanner to detect security vulnerabilities in all Dockerfile-based build pipelines. The scanner will fail the pipeline if any **CRITICAL** CVEs (Common Vulnerabilities and Exposures) are detected. CVEs of other severity levels are recorded but does not fail the pipeline.

If you cannot fix a critical CVE immediately, you can opt to ignore it. To ignore a critical CVE, add a `trivyignore` (`<docker-build-context-path>/.trivyignore`) file to your build context path. In the file, add the CVEs you need the pipeline to ignore, one entry per line as follows:

```
CVE-2023-xxxx
CVE-2023-yyyy
```

You can add comments in the file by using `#` in front of the comment as follows: 

```
# comments can be added like this
CVE-2023-xxxx
```


# Deploy an Application with Buildpacks

Using Choreo, you can easily deploy applications written in different language frameworks (such as Java, Go, NodeJS, Python, Ruby, PHP, etc.) on shared or private data planes.

Choreo supports deploying applications with buildpacks for the following component types:

- Service
- Web Application
- Scheduled Task
- Manual Task
- Webhook
- Event Handler
- Test Runner

## Buildpacks
Buildpacks are a fundamental building block in modern application development. They convert your source code into a secure, efficient, production-ready container image without a Dockerfile. With Choreo, developers can take advantage of this powerful tool to effortlessly deploy their applications without the hassle of manual configuration.

Choreo uses [Google Buildpacks](https://cloud.google.com/docs/buildpacks/overview) as default buildpacks for Java, Go, NodeJS, Python, PHP, and Ruby. Choreo uses its own buildpacks for Ballerina and WSO2 MI.

## Develop a component

To develop a service component that exposes a Service in Go, you can follow the [Develop a Service ](develop-services/develop-a-service.md) guide.

Follow the guidelines below based on your language:

=== "Python"
    Supported Versions - 3.10.x, 3.11.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Reading Books List Service](https://github.com/wso2/choreo-samples/tree/main/reading-books-list-service-python)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-python-task)|

    ### Procfile
    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    
    !!! info 
        In **Python** projects, it is mandatory to have a `Procfile` with the `web` process type in the project root directory.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: python main.py` <br>
    `web: gunicorn --bind :8080 --workers 1 --threads 8 --timeout 0 main:app` <br>
    `web: flask run --host=0.0.0.0`

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Ballerina"

    Supported Versions - 2201.3.5, 2201.4.1, 2201.5.0, 2201.5.1, 201.6.0,  2201.7.0

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Echo Service](https://github.com/wso2/choreo-samples/tree/main/echo-service)|
    | Manual Task | [Covid19 Statistics To Email](https://github.com/wso2/choreo-samples/tree/main//covid19-statistics-to-email)|
    | Webhook | [Salesforce New Case To Google Sheet](https://github.com/wso2/choreo-samples/tree/main/sfdc-new-case-to-gsheet)|
    | Scheduled Task | [Shopify New Customers to HubSpot Create/Update Contact](https://github.com/wso2/choreo-samples/tree/main/shopify-new-customers-to-hubspot-contact)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Go"

    Supported Versions - 1.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Greeting Service](https://github.com/wso2/choreo-samples/tree/main/greeting-service-go)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-go-task)|
    | Web Application | [Hello World Web Application](https://github.com/wso2/choreo-samples/tree/main/hello-world-go-webapp)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== ".NET"
    Supported Versions - 6.x, 7.x, 8.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service | [Greeting Service](https://github.com/wso2/choreo-samples/tree/main/dotnet-greeter)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Java"
    Supported Versions
        - 8, 11, 17, 18 (OpenJDK Runtime Environment Temurin)

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Product Management Service](https://github.com/wso2/choreo-samples/tree/main/product-management-service)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-java-task)|

    !!! info

         When working on Java projects:

           - The `Main` class should be defined in the manifest file.
           - If Maven files such as `mvn.cmd` exist in the project without the `.mvn` directory, the build will fail. To ensure a successful build, you must either commit the `.mvn` directory along with any Maven files or not include any Maven files in the project if you choose not to commit the `.mvn` directory.
    
    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **Java** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: java -jar target/sample.jar` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "NodeJS"
    Supported Versions - 12.x.x, 14.x.x, 16.x.x, 18.x.x, 20.x.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Reading Books List Service](https://github.com/wso2/choreo-samples/tree/main/reading-books-list-service-nodejs)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-nodejs-task)|

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **NodeJS** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: node app.js` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "PHP"
    Supported Versions - 8.1.x, 8.2.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service| [Hello World Service](https://github.com/wso2/choreo-samples/tree/main/hello-world-php-service)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-php-task)|
    | Web Application | [Hello World Web Application](https://github.com/wso2/choreo-samples/tree/main/hello-world-php-webapp)|

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **PHP** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web:php -S 0.0.0.0:8000 index.php` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Ruby"
    Supported Versions - 3.1.x, 3.2.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service | [Hello World Service](https://github.com/wso2/choreo-samples/tree/main/hello-world-ruby-service)|
    | Manual Task | [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-ruby-task)|
    | Web Application | [Hello World Web Application](https://github.com/wso2/choreo-samples/tree/main/hello-world-ruby-webapp)|

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **Ruby** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: ruby app.rb` <br>
    `web:bundle exec ruby app.rb -p 8080` <br>

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "WSO2 MI"
    Supported Versions - 4.1.0.x, 4.2.0.x

    Refer below examples for different component types. Follow the `readme.md` inside the example.

    | Component Type  | Example            |
    |---------------- |--------------------|
    | Service |[Hello World Service](https://github.com/wso2/choreo-samples/tree/main/hello-world-mi)|

    For more examples, see [Choreo samples](https://github.com/wso2/choreo-samples).

=== "Spring Boot"
    Supported Java Versions
        - 8, 11, 17, 18 (OpenJDK Runtime Environment Temurin)

    !!! info
         You can use this buildpack only with web applications. For other component types, use the **Java** buildpack. Additionally, if the generated artifact is a `WAR` file, it is necessary to include a **Procfile**.

    #### Procfile 

    A `Procfile` is a configuration file used to declare the commands that are run by your application's containers. 
    If you want to customize the default entry point of the container, you can include a `Procfile` with the `web` process type in the project root directory. 
    In **Java** projects, it is optional to include a `Procfile`.

    Here's an example `Procfile` for an application:

    ```
    web: <command to start your application>
    ```

    e.g.,

    `web: java -jar target/sample.war` <br>

### Configure build-time environment variables

You can configure the environment variables necessary to build the component using the **Build Configurations Editor** on the component **Build** page. 

!!! info
    The capability to configure build-time environment variables is not available for components created using **Ballerina** or **WSO2 MI** buildpacks.

During the build process, the build-time environment variables and their values are passed to the buildpack. Therefore, you can configure both buildpack-specific environment variables and those required for the component build.

For example, if you want to override the Maven command of the **Java** buildpack, you can use `GOOGLE_MAVEN_BUILD_ARGS` as the environment key and `clean install` as the value. 

For more examples, see [Google Cloud's buildpacks documentation](https://cloud.google.com/docs/buildpacks/service-specific-configs).


# Develop a Webhook

Choreo allows developers to design high-quality webhooks. To explore this capability, let's consider a scenario where a team of software engineers in an organization should be notified via email whenever someone creates a GitHub issue with the `bug` label in a specific repository.

In this tutorial, you will address the requirement by doing the following:

- Create a webhook by connecting to a forked GitHub repository where you have the webhook implementation that addresses the described requirement.
- Deploy the webhook to the development environment.
- Modify the webhook implementation to connect the webhook to GitHub, enabling it to act in response to selected GitHub-related events.
- Test the webhook.
- Promote the webhook to the production environment.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

## Step 1: Create a webhook component

To create a Webhook component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Webhook** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following information:

    | **Field**                     | **Description**    |
    |-------------------------------|--------------------|
    | **GitHub Account**            | Your account       |
    | **GitHub Repository**         | choreo-samples     |
    | **Branch**                    | main               |
    | **Component Path**              | `github-event-to-email-webhook` |

6. Select **Ballerina** as the build pack.
7. Provide a display name, a unique name and description for the component.
8. Click **Create**.

Choreo creates the Webhook component with the sample implementation and opens the component **Overview** page.

## Step 2: Deploy

To deploy the webhook to the development environment, follow these steps:

1. In the Choreo Console left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**.
3. In the **Configurations** pane, enter the following information:
    1. In the **webhookSecret** field, enter any value.

        !!! note
            Save this value for later use.

    2. In the **toEmail** field, enter the email address to send notification emails.
    3. Click **Deploy**.

    You can monitor the deployment progress in the **Console** pane that opens on the right of the page.

Once Choreo completes the deployment, the **Development** card indicates the **Deployment Status** as **Active**.

!!! note
    In the deployment card, you can click the icon corresponding to configurables to open the **Configurations** pane and edit configurations.

## Step 3: Connect the webhook to the GitHub repository

To allow the webhook to read the labels of issues in a specific GitHub repository, connect the webhook to the GitHub repository:

1. In the Choreo Console left navigation menu, click **Overview**.
2. On the **Overview** page, copy the invoke URL by clicking the copy icon within the **URL** field.
3. Go to your GitHub account and open the repository for which you want to generate notification emails.
4. In the top menu, click the **Settings** tab.
5. In the left navigation menu, click **Webhooks**.
6. Click **Add webhook** and enter the following information:

    | **Field**        | **Value**                                                          |
    |------------------|--------------------------------------------------------------------|
    | **Payload URL**  | The invoke URL you copied in Step 3, sub-step 1.                   |
    | **Content Type** | Select `application/json`                                          |
    | **Secret**       | The last webhook secret you configured in [Step 2](#step-2-deploy).| 

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Project Path** specifies the location of the project to build the component.

7. Under **Which events would you like to trigger this webhook?**, select **Let me select individual events**.
8. Select the **Issues** checkbox in the list of events displayed. This ensures that GitHub issues trigger the webhook.
9. Clear the **Pushes** checkbox to ensure that GitHub does not trigger your webhook when the team pushes changes to the selected GitHub repository.
10. Click **Add webhook** to save the configuration.

Now you have integrated Choreo with GitHub via the webhook you created and deployed. You can proceed to test the webhook.

## Step 4: Test

To test your webhook, create a GitHub issue with the `Bug` label in the repository that you connected to the webhook. You will receive an email similar to the following at the email address you provided in [Step 2](#step-2-deploy).

## Step 5: Promote

To promote the webhook to the Production environment, follow these steps:

1. On the **Deploy** page, go to the **Development** card and click **Promote**.
2. In the **Configuration Types** pane, leave the default selection (i.e., **Use default configuration values**) unchanged.

    !!! note
        If you have configured any default values for the configurable variables, selecting **Use default configuration values** allows you to proceed with those values. If not, specify values for the configurable variables.

3. Click **Next**.
4. In the **webhookSecret** field, enter any value.

    !!! note
        Save this value for later use.

5. In the **toEmail** field, enter the email address to send notification emails.
6. Click **Promote**.

    Once the component is promoted to production, the **Production** card displays the deployment status as **Active**.

Now you have successfully created, deployed, and tested a Webhook component and promoted it to production.


# Develop an External Consumer

An external consumer in Choreo is any client that can interact with services deployed in Choreo, as an entity hosted outside of the Choreo infrastructure. It is a generic component type that allows you to represent and manage any client, such as a mobile application, web application, server-to-server integration, bot, microservices, etc.

In this guide, you will:

 - Create an external consumer component.
 - Manage authentication for the external consumer.
 - Connect the external consumer to a service deployed in Choreo.
 
## Prerequisites

Before you try out this guide, complete the following steps:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

## Step 1: Create an external consumer component
 
To create an external consumer component, follow the steps given below:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **External Consumer** card. 
4. In the **Create an External Consumer** pane that opens, enter a display name, a unique name, and a description for the component.
5. Click **Create**. This creates the component and takes you to its **Overview** page.
   
## Step 2: Manage authentication for the external consumer

You can configure the external consumer to work with the Choreo built-in identity provider or any external identity provider that supports OIDC/OAuth 2.0.

Click the respective tab for details depending on the identity provider you want to configure: 

=== "Choreo built-in identity provider"

     Follow the steps given below to configure the built-in identity provider by generating authentication keys:

    !!! note
         Choreo built-in identity provider is configured by default. Therefore, this step is optional.

     1. In the **Overview** page of the component, under **Authentication Configurations**, click **Configure** corresponding to the environment for which you want to configure an identity provider.
     2. In the **Identity Provider** list, select **Choreo Built-In Identity Provider**.
     3. Click **Generate Keys**. 

        !!! Note
             If you see **Regenerate Secret** instead of **Generate Keys**, it indicates that OAuth keys are already generated for the component in the selected environment.

=== "An external identity provider"

     **Step 2.1: Create and configure an OIDC/OAuth 2.0 application in the external identity provider**

     1. Create an OIDC/OAuth 2.0 application in your external identity provider.
     2. Configure the OIDC/OAuth 2.0 application accordingly. (The access token type should be configured as JWT)

     **Step 2.2: Link the OIDC/OAuth 2.0 application to the Choreo component**

     3. In the **Overview** page of the component, under **Authentication Configurations**, click **Configure** corresponding to the environment for which you want to configure an identity provider.
     4. In the **Identity Provider** list, select your identity provider.
     5. Paste the **Client ID** of the OIDC/OAuth 2.0 application you created in your external identity provider.
     6. Click **Add Keys**.

## Step 3: Connect the external consumer to a service deployed in Choreo 

To establish connections from the external consumer to services deployed in Choreo, you can create connections. For step-by-step instructions on creating a connection, see [Create a Connection](./sharing-and-reusing/create-a-connection.md).


# Develop Components Using VS Code

The [Choreo VS Code extension](https://marketplace.visualstudio.com/items?itemName=WSO2.choreo) provides comprehensive component management capabilities to streamline local development within Choreo.

## Prerequisites

To ensure a smooth development experience with the Choreo extension, make sure you have the following:

1. [Visual Studio Code](https://code.visualstudio.com/download) installed with the [Choreo extension](https://marketplace.visualstudio.com/items?itemName=WSO2.choreo) version **2.0.0** or later.

2. A locally cloned GitHub repository to create new components or link to existing Choreo components.

3. [Git](https://git-scm.com) version 2.0.0 or later.

## Get started

To use the capabilities of the Choreo extension in the VS Code editor, you need an active [Choreo account](https://wso2.com/choreo/pricing/). If you already have an account, follow these steps to set up the extension:

1. Install the [Choreo VS Code extension](https://marketplace.visualstudio.com/items?itemName=WSO2.choreo) and wait for activation. On successful activation, the Choreo extension opens in the VS Code editor. 
2. Sign in to Choreo using one of the following methods:
    - In the Choreo activity pane, click **Sign In**.
       ![Sign in](../assets/img/develop-components/develop-using-vs-code/sign-in.png)
    - Use the `Sign In` command provided by the Choreo extension.

    This redirects you to an external URI to complete the authentication process. On successful sign-in, the Choreo activity pane displays your account details along with any components detected within the VS Code workspace.

## Create a new component

1. Open the source code directory where you want to build, deploy, and manage components using Choreo.
2. Create a new component using one of the following methods:
    - In the Choreo activity pane, click **Create Component**.
       ![Create Component Button](../assets/img/develop-components/develop-using-vs-code/create-component-btn.png)
    - Use the `Create New Component` command provided by the Choreo extension.

3. If the Choreo extension cannot determine the project context of the opened workspace, it prompts you to select the organization and the project to which the new component belongs.
4. Specify component details such as the name, type, buildpack, etc.

    ![Component Form](../assets/img/develop-components/develop-using-vs-code/component-form.png)
            
    On successful creation, the component details view opens, and the Choreo activity pane displays the new component.

    ![Component Details](../assets/img/develop-components/develop-using-vs-code/component-details-view.png)
     
    !!! tip
        Once the component is created, a `.choreo/context.yaml` file is generated in the root of the Git repository. For more details, see [Understand the project context](#understand-the-project-context).

The component details view allows you to manage your component by performing various actions such as the following:

 - Triggering builds for selected commits.
 - Viewing lists of builds and statuses.
 - Diagnosing build failures with build logs.
 - Deploying builds in available environments.
 - Accessing runtime logs and deployed component URLs.
 - Invoking deployed service endpoints.

## Understand the project context

Context files contain metadata related to the project, allowing the extension to establish an association between local directories and Choreo projects. These files, such as the `context.yaml`file, resides in the `/.choreo` directory within the root of the Git repository.

The Choreo extension scans the root of the opened Git repository to find the `context.yaml` file and lists the components of the associated project. This allows you to easily open and manage the components they are developing within the VS Code workspace.

A `context.yaml` file can contain multiple projects, whereas, a workspace opened via VS Code can have multiple `context.yaml` files with different project associations. In such cases, VS Code allows you to switch between these projects, add new project associations, or remove existing ones, allowing you as a developer to focus on components of a particular project at a time.

You can decide whether to commit the `context.yaml` file to the Git repository. Committing this file enables other team members working on the same repository to have a seamless developer experience with Choreo.

If the `context.yaml` file for a particular project is not committed to the Git repository or is unavailable for other reasons, you can easily regenerate it using one of the following methods:

 - In the Choreo activity pane, click **Link Directory**.
    ![Link Directory](../assets/img/develop-components/develop-using-vs-code/link-dir-btn.png)
 - Use the `Link Directory` command provided by the Choreo extension.

## Discover additional features

To access a range of functionalities provided by the Choreo extension, open the VS Code command palette and type `Choreo`.

## Troubleshoot issues

To troubleshoot Choreo extension issues, follow these steps:

1. To open the **OUTPUT** pane, go to the VS Code editor main menu, click **View**, and then click **Output**.

2. Select **Choreo** from the drop-down menu on the right-hand side to view the Choreo output for troubleshooting.

## Get help

For assistance with the Choreo VS Code extension, create [GitHub issues](https://github.com/wso2/choreo-vscode/issues).


# Develop Components With Git

Choreo enables you to develop components by connecting your GitHub, Bitbucket, or GitLab repository. You have the flexibility to either connect an existing repository or start with an empty repository and commit the source code later. By integrating your repositories with Choreo, you can automate tasks and optimize workflows across multiple systems, all within the Choreo platform.  Choreo currently supports GitHub, Bitbucket, and GitLab as Git providers. 

!!! tip
    Choreo supports both Bitbucket Server and Bitbucket Cloud. The currently supported Bitbucket Server version is 8.9.2.

In Choreo, you can connect a Git repository that contains Ballerina source code or a Docker project. To connect a Git repository to Choreo as a Docker project, your Git repository must include the following:

 - A Dockerfile: Specifies the instructions to build the Docker image. 
 - A build context: A set of files in the specified path used to build the image.

Once you connect your Git repository to Choreo, you can build, deploy, and manage your application easily. 

## Connect a Git repository to Choreo

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the Choreo Console header, go to the **Organization** list and select your organization. 
3. In the left navigation menu, click **Settings**. This opens the organization-level settings page. 
4. Click the **Credentials** tab. 
5. Click **+Add Credentials** to configure the Git repository connection.
6. Enter a **Credential Name**, select the Git provider, and enter the **Personal Access Token** you obtained from the Git provider.
7. Click **Save**.  

## Authorize GitHub with Choreo 

Authorizing Choreo as a GitHub application grants Choreo the following permissions to perform the respective actions on your behalf within the repository:

|Permission   | Read| Write| Description                                                           |
|-------------|-----|------|-----------------------------------------------------------------------|
|Issues       | Y   | N    | Read component ID label to filter the pull requests                   |
|Metadata     | Y   | N    | List repositories                                                     |
|Contents     | Y   | Y    | List branches and create a branch to commit sample code               |
|Pull Request | Y   | Y    | Create a pull request if you start with a Choreo sample               |
|Webhooks     | Y   | Y    | Trigger automatic deployment and configuration generation             |

### Add Git submodules to a project

Choreo provides [Git submodule](https://git-scm.com/book/en/v2/Git-Tools-Submodules) support when you connect your GitHub repository to Choreo. This allows you to manage and include external repositories effectively within Choreo build pipelines. Key benefits of this capability include:

  - **Code sharing without duplication**: Use submodules to maintain shared libraries across multiple projects, ensuring a single source of truth.
  - **Efficient third-party library management**: Manage third-party libraries as submodules to update them independently and track changes easily, avoiding direct code integration.

For example, when you [work with the Micro Integrator (MI) runtime in Choreo](./work-with-the-micro-integrator-runtime-in-choreo.md), you can use Git submodules to reuse MI templates and sequences across components without duplication.

!!! info "Note" 
    If you encounter an error stating that you cannot clone a submodule due to insufficient permissions, follow the instructions below to grant the necessary permissions:

      - For a personal account:

         1. Sign in to your personal GitHub account.
         2. In the upper-right corner, click your profile picture, and then click **Settings**.
         3. In the left navigation menu, go to the **Integrations** section and click **Applications**.
         4. Under the **Installed GitHub Apps** tab, click **Configure** corresponding to **choreo.dev**.
         5. Under **Repository Access**, grant access to the necessary repositories.

      - For an organization account:

         1. Sign in to your organization's GitHub account.
         2. In the upper-right corner, click your profile picture, and then click **Settings**.
         3. In the left navigation menu, go to the **Third-Party Access** section and click **GitHub Apps**.
         4. Click **Configure** corresponding to **choreo.dev**.
         5. Under **Repository Access**, grant access to the necessary repositories.

            !!! note
                Choreo currently does not support accessing private repositories in other organizations.

#### Automatically pull latest versions of Git submodules

Choreo lets you automatically pull the latest versions of Git submodules from their respective repositories. To enable this feature, follow these steps:

!!! note 
    Choreo currently supports this feature only for components where the buildpack is **WSO2 MI**.

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click the component for which you want to pull the latest versions of Git submodules.
3. In the left navigation menu, click **Build**.
4. On the **Build** page, click to edit **Build Configurations**.
5. Turn on the **Pull Latest Submodules** toggle.

    !!! info "Note"
        If you rebuild a previously built commit and it doesn’t reflect the latest changes, follow these steps to ensure the changes are applied to the deployed environment:

         1. In the Choreo Console left navigation menu, click **DevOps**, then click **Containers**.
         2. Click **Edit** to update the container settings.
         3. Select **Always** as the **Image Pull Policy**.
         4. Click **Save Changes**.

## Authorize Bitbucket with Choreo

Authorizing using a personal access token (PAT) from Bitbucket grants Choreo the following permissions to perform the respective actions on your behalf within the repository.

|Permission    | Read| Write| Description                                                        |
|--------------|-----|------|--------------------------------------------------------------------|
|Account       | Y   | N    | Get user information and workspace details                         |
|Repositories  | Y   | Y    | List branches and create a branch to commit sample code            |
|Pull Requests | Y   | Y    | Create a pull request if you start with a Choreo sample            |
|Webhooks      | Y   | Y    | Trigger automatic deployment and configuration generation          |

## Authorize self-managed GitLab with Choreo

Authorizing using a personal access token (PAT) obtained from your GitLab self-managed server grants Choreo the following permissions to perform the respective actions on your behalf within the repository.

|Permission    | Description                                                                         |
|--------------|-------------------------------------------------------------------------------------|
|API           | Grants full read/write access to the API, covering all groups and projects, as well as read/write access to the repository.|


# Integrate Unit Tests into the Build Pipeline

Choreo allows you to integrate unit tests into the build pipeline, enabling code validation before deployment. This ensures early testing of code changes, reducing the risk of defects in production.

!!! note
        Currently, Choreo supports unit tests only for the `WSO2 MI` buildpack.

## How it works

### Step 1: Write tests

You can create unit tests in your source code using standard testing libraries. For step-by-step instructions on creating unit tests for WSO2 Micro Integrator projects, see [Creating a Unit Test Suite](https://mi.docs.wso2.com/en/latest/develop/creating-unit-test-suite/).

### Step 2: Enable unit tests

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click the component for which you want to enable unit tests.
3. In the left navigation menu, click **Build**.
4. On the **Build** page, click to edit **Build Configurations**.
5. Turn on the **Unit Test** toggle.
6. Click **Save**.

### Step 3: Trigger a new build

- On the **Build** page, click **Build Latest**.

This starts a new build with unit tests enabled. You can monitor its progress in the **Build Details** pane.

## View failed unit tests

If a unit test fails during the build, you can view its detailed logs for troubleshooting. Click **View Details** corresponding to the failed build, then expand the failed unit test step to view the logs.

## Explore a sample

To see unit tests in action within the build pipeline, try out the [WSO2 MI helloworld](https://github.com/wso2/choreo-samples/tree/main/hello-world-mi) sample. 


# Manage Component Source Configurations

In Choreo, you can configure service endpoints and connections via the `component.yaml` source configuration file. This file ensures that the configurations required to initialize endpoints and connections are defined, as they cannot be inferred from the source code. This guide provides an overview of how to configure and manage these settings effectively.

The source configuration file must be committed to your repository within the `.choreo` directory at the root of the project directory. This ensures the ability to version the configuration files alongside repository commits, enabling better tracking and management of configurations.

!!! note
    -  The `component-config.yaml` and `endpoints.yaml` files will eventually be deprecated and replaced by the `component.yaml` file. 
        - For details on how to seamlessly update to the latest `component.yaml` file`, see [Update to the latest source configuration file](#update-to-the-latest-source-configuration-file).
    - Choreo prioritizes configuration files in the following order: `component.yaml` takes the highest precedence, followed by `component-config.yaml`, and then `endpoints.yaml`.

## Overview of the `component.yaml` file 

**File location**:

```bash
<build-context-path>/.choreo/component.yaml
```

!!! note
    - For components built using **Buildpacks**, replace `build-context-path` with the `<project-directory>`. 
    For example, `<project-directory>/.choreo/component.yaml`.
    - For components built using **Docker**, replace `build-context-path` with the `<docker-context-path>`. 
    For example, `<docker-context-path>/.choreo/component.yaml`.

**Sample `component.yaml` file content**:

Click the respective tab to view the structure for your current configuration file version:

=== "Version 1.1"

    ``` yaml
    # +required The configuration file schema version
    schemaVersion: 1.1

    # +optional Incoming connection details for the component
    endpoints:
      # +required Unique name for the endpoint.
      # This name will be used when generating the managed API
      - name: greeter-sample
        # +optional Display name for the endpoint.
        displayName: Go Greeter Sample
        # +required Service section has the user service endpoint details
        service:
          # +optional Context (base path) of the API that gets exposed via the endpoint.
          basePath: /greeting-service
          # +required Numeric port value that gets exposed via the endpoint
          port: 9090
        # +required Type of traffic that the endpoint is accepting.
        # Allowed values: REST, GraphQL, WS, GRPC, TCP, UDP.
        type: REST
        # +optional Network level visibilities of the endpoint.
        # Accepted values: Project|Organization|Public(Default).
        networkVisibilities: 
          - Public
          - Organization
        # +optional Path to the schema definition file. Defaults to wild card route if not provided
        # This is only applicable to REST or WS endpoint types.
        # The path should be relative to the docker context.
        schemaFilePath: openapi.yaml
      
      # +optional Outgoing connection details for the component.
      dependencies:
        # +optional Defines the connection references from the Internal Marketplace.
        connectionReferences:
          # +required Name of the connection.
          - name: hr-connection
            # +required service identifer of the dependent component.
            resourceRef: service:/HRProject/UserComponent/v1/ad088/PUBLIC
      # +optional Defines runtime configurations
      configurations:
        # +optional List of environment variables to be injected into the component.
        env:
          # +required Name of the environment variable
          - name: HR_SERVICE_URL
            # +required value source
            # Allowed value sources: connectionRef
            valueFrom:
              # +required Choreo connection value source
              connectionRef:
                # +required Choreo connection name to refer the value from
                name: hr-connection
                # +required Choreo connection configuration key to refer the value from
                key: ServiceURL
    ```

    The descriptor-based approach of the `component.yaml` file simplifies and streamlines endpoint and connection configuration management. The use of versioned schemas ensures backward compatibility, providing a seamless transition with future updates.

    You can define the following root-level configurations via the `component.yaml` file:

    | Configuration        | Required     | Description                                                              |
    |----------------------|--------------|--------------------------------------------------------------------------|
    | **schemaVersion**    | Required     | The version of the `component.yaml` file. Defaults to the latest version.|
    | **endpoints**        | Optional     | The list of endpoint configurations.                                     |
    | **dependencies**     | Optional     | The list of dependency configurations.                                   |
    | **configurations**    | Optional     | The runtime configuration definitions.                                   |

    ### Endpoint configurations
    In the `endpoints` section of the `component.yaml` file, you can define multiple service endpoint configurations. Each endpoint must have a unique name and the required fields specified in the schema overview.

    !!! tip "Why have a unique name?"
          When you define multiple endpoints, the `endpoint.name` is appended to the Choreo-generated URL. A unique name ensures the endpoint is easily recognizable and readable within the URL.
          
    | Configuration        | Required     | Description                                                                                             |
    |----------------------|--------------|---------------------------------------------------------------------------------------------------------|
    | **name**             | Required     | A unique identifier for the endpoint within the service component. Avoid using excessively long names.  |
    | **displayName**      | Optional     | A display name for the endpoint.                                                                        |
    | **service**          | Required     | Service details for the endpoint.                                                                       |
    | **.basePath**        | Required     | The base path of the API exposed via this endpoint.                                                     |
    | **.port**            | Required     | The numeric port value exposed via this endpoint.                                                       |
    | **type**             | Required     | The type of traffic the endpoint accepts. For example, `REST`, `GraphQL`, `WS`, `gRPC`, `UDP`, or `TCP`.|
    | **networkVisibilities** | Required | The network-level visibility of the endpoint. For example, project, organization, or public.             |
    | **schemaFilePath** | Required | The file path to the swagger definition  or AsyncAPI 2.0 specification file. Defaults to the wildcard route if not specified. This field should be a relative path to the project path when using **Java**, **Python**, **NodeJS**, **Go**, **PHP**, **Ruby**, or **WSO2 MI** buildpacks. For REST or WebSocket endpoint types, when using the **Ballerina** or **Dockerfile** buildpack, the path should be relative to the component root or Docker context. |

    ### Dependency configurations

    In the `dependencies` section of the `component.yaml` file, you can define multiple connection configurations under `dependencies.connectionReferences`. You can use the connection reference generated in the inline developer guide when creating a connection. For instructions on copying [connection configurations](https://wso2.com/choreo/docs/develop-components/sharing-and-reusing/use-a-connection-in-your-service/), see the inline developer guide displayed during connection creation.

    You must include the following configurations in the `dependencies.connectionReferences` schema:

    | Configuration        | Required     | Description                                                                      |
    |----------------------|--------------|----------------------------------------------------------------------------------|
    | **name**             | Required     | The name given to the connection.                                                |
    | **resourceRef**      | Required     | A unique, human-readable identifier for the service you are connecting.          |


    !!! note
        Choreo automatically generates connection configurations when you create a connection. The properties such as **name** and **resourceRef** are automatically generated. The configurations required to establish the connection will be injected into Choreo-defined environment variables.

        To use custom environment variable names instead of Choreo's default ones, add the dependency as a `serviceReference` in your `component.yaml v1.1` file. You can copy the `serviceReference` section from the `component.yaml v1.0` tab and paste it under `dependencies` in your `component.yaml v1.1` file, which maintains backward compatibility with the v1.0 format.

    ### Runtime configurations
    In the `configurations` section of the `component.yaml` file, you can define runtime configurations for the component. These configurations currently support environment variable injection related to dependencies.
    
    | Configuration                 | Required     | Description                                                                       |
    |-------------------------------|--------------|-----------------------------------------------------------------------------------|
    | **env**                       | Optional     | An array of env variable configurations.                                          |
    | **name**                      | Required     | A unique name for the environment variable, starting with a letter or an underscore, and containing only letters, numbers, or underscores. |
    | **valueFrom**                 | Required     | The source of the environment variable value.                                     |
    | **connectionRef**             | Required     | Connection reference value source definition.                                     |
    | **name**                      | Required     | The name of the Choreo connection to reference the value from.                    |
    | **key**                       | Required     | The Choreo connection configuration key to reference the value from. For details on available keys, see [connection configurations](https://wso2.com/choreo/docs/develop-components/sharing-and-reusing/use-a-connection-in-your-service/) or the inline developer guide. |

    !!! note
        Runtime configurations are supported starting from `component.yaml v1.1`.

        When an environment variable value is specified using `connectionRef`, the connection's environment variable is renamed to the environment variable name defined in the `configurations` section. For example, in the sample `component.yaml` file given above, the `CHOREO_HR_CONNECTION_SERVICEURL` variable in the `hr-connection` is renamed to `HR_SERVICE_URL`.

=== "Version 1.0"

    ``` yaml
    # +required The configuration file schema version
    schemaVersion: 1.0

    # +optional Incoming connection details for the component
    endpoints:
      # +required Unique name for the endpoint.
      # This name will be used when generating the managed API
      - name: greeter-sample
        # +optional Display name for the endpoint.
        displayName: Go Greeter Sample
        # +required Service section has the user service endpoint details
        service:
          # +optional Context (base path) of the API that gets exposed via the endpoint.
          basePath: /greeting-service
          # +required Numeric port value that gets exposed via the endpoint
          port: 9090
        # +required Type of traffic that the endpoint is accepting.
        # Allowed values: REST, GraphQL, WS, GRPC, TCP, UDP.
        type: REST
        # +optional Network level visibilities of the endpoint.
        # Accepted values: Project|Organization|Public(Default).
        networkVisibilities: 
          - Public
          - Organization
        # +optional Path to the schema definition file. Defaults to wild card route if not provided
        # This is only applicable to REST or WS endpoint types.
        # The path should be relative to the docker context.
        schemaFilePath: openapi.yaml
      
    # +optional Outgoing connection details for the component.
    dependencies:
      # +optional Defines the service references from the Internal Marketplace.
      serviceReferences:
        # +required Name of the service reference.
        - name: choreo:///apifirst/HRProject/UserComponent/ad088/v1/PUBLIC
          # +required Name of the connection instance.
          connectionConfig: 19d2648b-d29c-4452-afdd-1b9311e81412
          # +required Environment variables injected into the component for connection configuration.
          env:
            # +required Key name of the connection configuration.
            - from: ServiceURL
              # +required Environment variable injected into the container.
              to: SERVICE_URL
    ```

    The descriptor-based approach of the `component.yaml` file simplifies and streamlines endpoint and connection configuration management. The use of versioned schemas ensures backward compatibility, providing a seamless transition with future updates.

    You can define the following root-level configurations via the `component.yaml` file:

    | Configuration        | Required     | Description                                                              |
    |----------------------|--------------|--------------------------------------------------------------------------|
    | **schemaVersion**    | Required     | The version of the `component.yaml` file. Defaults to the latest version.|
    | **endpoints**        | Optional     | The list of endpoint configurations.                                     |
    | **dependencies**     | Optional     | The list of dependency configurations.                                   |

    <h3> Endpoint configurations </h3>
    In the `endpoints` section of the `component.yaml` file, you can define multiple service endpoint configurations. Each endpoint must have a unique name and the required fields specified in the schema overview.

    !!! tip "Why have a unique name?"
          When you define multiple endpoints, the `endpoint.name` is appended to the Choreo-generated URL. A unique name ensures the endpoint is easily recognizable and readable within the URL.
          
    | Configuration           | Required     | Description                                                                                             |
    |-------------------------|--------------|---------------------------------------------------------------------------------------------------------|
    | **name**                | Required     | A unique identifier for the endpoint within the service component. Avoid using excessively long names.  |
    | **displayName**         | Optional     | A display name for the endpoint.                                                                        |
    | **service**             | Required     | Service details for the endpoint.                                                                       |
    | **.basePath**           | Required     | The base path of the API exposed via this endpoint.                                                     |
    | **.port**               | Required     | The numeric port value exposed via this endpoint.                                                       |
    | **type**                | Required     | The type of traffic the endpoint accepts. For example, `REST`, `GraphQL`, `gRPC`, `WS`, `UDP`, or `TCP`.|
    | **networkVisibilities** | Required     | The network-level visibility of the endpoint. For example, project, organization, or public.            |
    | **schemaFilePath**      | Required     | The file path to the swagger definition or AsyncAPI 2.0 specification file. Defaults to the wildcard route if not specified. This field should be a relative path to the project path when using **Java**, **Python**, **NodeJS**, **Go**, **PHP**, **Ruby**, or **WSO2 MI** buildpacks. For REST or WebSocket endpoint types, when using the **Ballerina** or **Dockerfile** buildpack, the path should be relative to the component root or Docker context. |

    <h3> Dependency configurations </h3>

    In the `dependencies` section of the `component.yaml` file, you can define multiple service connection configurations under `dependencies.serviceReferences`. You can use the service references generated in the inline developer guide when creating a service connection. For instructions on copying [connection configurations](https://wso2.com/choreo/docs/develop-components/sharing-and-reusing/use-a-connection-in-your-service/), see the inline developer guide displayed during connection creation.

    You must include the following configurations in the `dependencies.serviceReferences` schema:

    | Configuration        | Required     | Description                                                                      |
    |----------------------|--------------|----------------------------------------------------------------------------------|
    | **name**             | Required     | A unique name for the service reference.                                         |
    | **connectionConfig** | Required     | A unique name for the connection instance.                                       |
    | **env**              | Required     | The list of environment variable mappings to inject into the container.          |
    | **.from**            | Required     | The key name of the connection configuration.                                    |
    | **.to**              | Required     | The environment variable to inject into the container.                           |

    !!! note
        Choreo automatically generates connection configurations when you create a connection. The properties such as **name**, **connectionConfig**, and **env.from** are automatically generated. However, you must manually set the **env.to** value.

## Overview of the `component-config.yaml` file 

**File location**:

```bash
<build-context-path>/.choreo/component-config.yaml
```

**Sample `component-config.yaml` file content**:

```yaml
apiVersion: core.choreo.dev/v1beta1
kind: ComponentConfig
spec:
  # +optional Incoming connection details for the component (AKA endpoints).
  inbound:
    # +required Unique name for the endpoint.
    # This name will be used when generating the managed API
    - name: Greeting Service
      # +required Numeric port value that gets exposed via the endpoint
      port: 9090
      # +required Type of traffic that the endpoint is accepting.
      # Allowed values: REST, GraphQL, GRPC, TCP, UDP, WS.
      type: REST
      # +optional Network level visibility of the endpoint. Defaults to Public
      # Accepted values: Project|Organization|Public.
      networkVisibility: Public
      # +optional Context (base path) of the API that gets exposed via the endpoint.
      # This is mandatory if the endpoint type is set to REST, GraphQL or WS.
      context: /greeting
      # +optional The path to the schema definition file. Defaults to wildcard route if not specified.
      # This is only applicable to REST and WS endpoint types.
      # The path should be relative to the Docker context.
      schemaFilePath: greeting_openapi.yaml
  # +optional Outgoing connection details for the component.
  outbound:
    # +optional Defines the service references from the Internal Marketplace.
    serviceReferences:
      # +required Name of the service reference.
      - name: choreo:///apifirst/mttm/mmvhxd/ad088/v1.0/PUBLIC
        # +required Name of the connection instance.
        connectionConfig: 19d2648b-d29c-4452-afdd-1b9311e81412
        # +required Environment variables injected to the component for connection configuration.
        env:
          # +required Key name of the connection configuration.
          - from: ServiceURL
            # +required Environment variable injected to the container.
            to: SERVICE_URL
```

The `component-config.yaml` file complements and enhances the existing endpoint configuration process. It allows you to define how the endpoints (inbound connections) in your service are exposed and how your service connects to external services or components (outbound connections).

You can define the following root-level configurations via the `component-config.yaml` file:

| Configuration        | Required     | Description                                                                           |
|----------------------|--------------|---------------------------------------------------------------------------------------|
| **apiVersion**       | Required     | The version of the `component-config.yaml` file defaults to `core.choreo.dev/v1beta1`.|
| **kind**             | Required     | The resource type of the file defaults to `ComponentConfig`.                          |
| **spec.inbound**     | Optional     | The list of inbound connection configurations.                                        |
| **spec.outbound**    | Optional     | The list of outbound connection configurations.                                       |

#### Inbound connection configurations (`spec.inbound`)

In the `spec.inbound` configuration section, you can specify endpoints to set up inbound connections. To specify endpoints, you can follow the existing endpoints schema structure. For details on the endpoints schema structure, see the [endpoints schema documentation](#overview-of-the-endpointsyaml-file).

#### Outbound connection configurations (`spec.outbound`)

In the `spec.outbound` section, you can define `serviceReferences`. To define `serviceReferences`, you can use the service references generated in the Internal Marketplace when creating a service connection. To copy the [outbound connection configurations](../sharing-and-reusing/use-a-connection-in-your-service/#use-a-connection-in-your-service), see the inline developer guide displayed when you create a connection.

You must include the following configurations in the `serviceReferences` schema:

| Configuration        | Required     | Description                                                                      |
|----------------------|--------------|----------------------------------------------------------------------------------|
| **name**             | Required     | A unique name for the service reference.                                         |
| **connectionConfig** | Required     | A unique name for the connection instance.                                       |
| **env**              | Optional     | The list of environment variable mappings to inject into the container.          |
| **env.from**         | Required     | The key name of the connection configuration.                                    |
| **env.to**           | Required     | The environment variable to inject into the container.                           |

## Overview of the `endpoints.yaml` file

**File location**:

```bash
<build-context-path>/.choreo/endpoints.yaml
```

**Sample `endpoints.yaml` file content**:

```yaml
# +required Version of the endpoint configuration YAML
version: 0.1

# +required List of endpoints to create
endpoints:
  # +required Unique name for the endpoint.
  # This name will be used when generating the managed API
- name: Greeting Service
  # +required Numeric port value that gets exposed via this endpoint
  port: 9090
  # +required Type of the traffic this endpoint is accepting.
  # Allowed values: REST, GraphQL, GRPC, UDP, TCP, WS.
  type: REST
  # +optional Network level visibility of this endpoint. Defaults to Public
  # Accepted values: Project|Organization|Public.
  networkVisibility: Project
  # +optional Context (base path) of the API that is exposed via this endpoint.
  # This is mandatory if the endpoint type is set to REST, GraphQL or WS.
  context: /greeting
  # +optional Path to the schema definition file. Defaults to wild card route if not provided
  # This is only applicable to REST and WS endpoint types.
  # The path should be relative to the docker context.
  schemaFilePath: greeting_openapi.yaml
```

The `endpoints.yaml` configuration file allows you to define configurations for multiple endpoints necessary for Choreo service components. This schema is essential to identify the context, port binding, network exposure level, and other attributes required to generate a Choreo endpoint.

You can define the following root-level configurations via the `endpoints.yaml` file:

| Configuration        | Required     | Description                                                                       |
|----------------------|--------------|-----------------------------------------------------------------------------------|
| **version**          | Required     | The version of the `endpoints.yaml` file.                                         |
| **name**             | Required     | A unique name for the endpoint, which Choreo will use to generate the managed API.|
| **port**             | Required     | The numeric port value that gets exposed via this endpoint.                       |
| **type**             | Required     | The type of traffic this endpoint accepts, such as `REST`, `GraphQL`, `gRPC`, `WS`, `UDP`, or `TCP`. Currently, the MI preset supports only the `REST` type.                                         |
| **networkVisibility**| Required     | The network level visibility of this endpoint, which defaults to `Public` if not specified. Accepted values are `Project`, `Organization`, or `Public`.|
| **context**          | Required     | The context (base path) of the API that Choreo exposes via this endpoint.         |
| **schemaFilePath**   | Required     | The swagger definition file path. Defaults to the wildcard route if not provided. This field should be a relative path to the project path when using the **Java**, **Python**, **NodeJS**, **Go**, **PHP**, **Ruby**, and **WSO2 MI** buildpacks. For REST endpoint types, when using the **Ballerina** or **Dockerfile** buildpack, this field should be a relative path to the component root or Docker context.|

## Update to the latest source configuration file

With the upcoming deprecation of the `component-config.yaml` file and the `endpoints.yaml` file, Choreo provides a seamless process to move to the latest `component.yaml`  version of the `component.yaml` file. Follow these steps to transition seamlessly:

### Step 1: Identify whether your current source configuration file is outdated

You can determine whether you’re using an outdated configuration file in the following ways:

- **During a build:**
     - On the **Build** page, after triggering a build, a warning will appear if your source configuration file is outdated. Click **View Details** in the **Initialization** -> **Source Config Validation** step. You will see an information banner with an option to update the file.

- **In existing deployments:**
     - If an existing deployment uses a build with an outdated source configuration file, you will see a warning icon on the build card of the relevant environment card.


### Step 2: Generate the latest `component.yaml` file

- In either of the scenarios above, click **Update** to initiate the process of generating the latest `component.yaml` file. The updated file will retain your existing configurations to ensure a smooth update process.


### Step 3: Add the generated configuration file to your repository

1. Download the generated `component.yaml` file.
2. Replace the existing source configuration file in the `.choreo` folder within your source repository.
    - Ensure the file name is `component.yaml`.


### Step 4: Trigger a new build

1. Commit the new `component.yaml` file to your repository. Push changes to the remote Git repository.
2. Trigger a build using the latest commit.


### Step 5: Verify the update

Once the build is complete:

  - Deploy the build.
  - Confirm that the warning messages no longer appear.

You can benefit from the latest features and enhancements provided by the updated source configuration file.


# Manage Deployment Tracks for Choreo Components

Choreo allows you to create and manage dedicated [deployment tracks](../choreo-concepts/deployment-tracks.md) for components, facilitating independent version control and deployment. This capability also allows you to unlink deployment tracks from associated branches or relink them to different branches so that you can align with your preferred Git workflows, such as the feature branch workflow or GitFlow workflow.

!!! info
     Deployment track creation and management does not apply to API Proxy and [BYOI components](../develop-components/bring-your-own-image.md).

## Create a deployment track

**Prerequisites**:

 - Create a component in Choreo.

Follow the steps below to create a deployment track for a component:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to create a deployment track for.
3. On the header of the component overview page, click the **Deployment Track** drop-down list.
4. Click **+ Create New** to open the **Create Deployment Track** dialog.
5. In the **Create Deployment Track** dialog, do the following:
    1. Select a branch to associate with the deployment track.
    2. Optionally, specify a description for the deployment track. 
    3. To create a deployment track for a service component, specify a unique API version indicating the major and minor version numbers.
6. Click **Create**.

## Unlink a deployment track

If you want to detach a branch reference from a deployment track, you must unlink the branch.

!!! info
     When you unlink the branch of a deployment track, the active deployments are unaffected. However, while you can redeploy the existing deployment, you cannot perform a new deployment.

Follow the steps below to unlink a deployment track of a component:
  
1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to unlink a deployment track.
3. On the header of the component overview page, click the **Deployment Track** drop-down list and then click **View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
4. Click the edit icon corresponding to the deployment track you want to unlink.
5. In the **Edit Branch** dialog that opens, click the **Branch Name** list and select **None**.
6. Click **Save**.

## Link a deployment track

To associate a branch reference to an unlinked deployment track, you must link a branch.

!!! info
    To build and deploy the contents of the linked branch,  you must perform a manual build and deploy.

**Prerequisites**:

 - A minimum of two branches in your GitHub repository.

Follow the steps below to link a branch to an unlinked deployment track:
  
1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to associate a branch reference for.
3. On the header of the component overview page, click the **Deployment Track** drop-down list and then click **View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
4. Click **+ Link Branch** corresponding to the unlinked deployment track for which you want to associate a branch.
5. In the **Link Branch** dialog that opens, click the **Branch Name** list and select the branch you want to relink.
6. Click **Save**.

## Relink a deployment track

To switch the branch reference of a linked deployment track, you must relink to an appropriate branch.

!!! info
      If you unlink the existing branch of a deployment track and link a different branch, you must perform a manual build and deploy to build and deploy the contents of the recently linked branch.

**Prerequisites**:

 - A minimum of two branches in your GitHub repository.

Follow the steps below to switch the branch reference of a linked deployment track:
  
1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to relink a deployment track for.
3. On the header of the component overview page,  click the **Deployment Track** drop-down list and then click **View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
4. Click the **Edit Branch** icon corresponding to the deployment track you want to relink.
5. In the **Edit Branch** dialog that opens, click the **Branch Name** list and select the branch you want to relink.
6. Click **Save**.

Now that you understand how to create and manage deployment tracks for components, let’s explore a sample scenario to see how a developer can use deployment tracks to manage version releases in Choreo.

## Sample Scenario: Manage version releases with deployment tracks

Let’s consider the following version release scenario: 

- To initiate work on a new feature, a developer creates a new branch, named `feature-x` from either the `main` or `dev` branch.
- Once development is complete, the developer proceeds to merge the `feature-x` branch into the `dev` branch for testing.
- Upon successful testing in the `dev` branch, the developer proceeds to merge all the changes into the `main` branch for production deployment.

Following are the actions you need to take from a deployment track perspective to manage the version release:

1. To prepare for the new version release, unlink the `main` branch from the associated deployment track (let’s consider this as the deployment track 1).
2. Proceed to merge the `dev` branch containing the tested changes into the `main` branch.
3. Unlink the `dev` branch from the associated deployment track (let’s consider this as deployment track 2).
4. Link deployment track 2 containing the latest version of the service to the `main` branch for deployment.
5. To facilitate ongoing development and testing, create another deployment track (let’s consider this as deployment track 3) and link it to the `dev` branch.

!!! tip
     - As a developer, you can strategically unlink and relink deployment tracks to effectively manage different versions of your services within Choreo.
     - You can create new deployment tracks for ongoing development branches like `dev` to ensure a continuous development and release cycle.

## Delete a deployment track

If you no longer need a deployment track, you can delete it.

!!! note
    If the component exposes an endpoint or proxy and you want to delete the last version in the major version range, the recommended approach is to retire that version first. This allows consumers to transition to the next major version and prevents a sudden break in their experience.
    For example, if you have deployment tracks for v1.0 and v2.0, notify consumers to switch to v2.0 before deleting v1.0. Then, retire the APIs in v1.0 and proceed to delete the associated deployment track.




**Prerequisites**:

- At least 2 deployment tracks in a component.

Follow the steps below to delete a deployment track:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to delete a deployment track.
3. On the header of the component overview page, click the **Deployment Track** drop-down list.
4. Click **+ View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
5. Click the **Delete** icon corresponding to the deployment track you want to delete.
6. Click **Delete** to confirm the deletion.

# Manage the Micro Integrator Runtime Version in Your Integration Project

Choreo allows you to use a preferred WSO2 Micro Integrator (MI) runtime version in your integration project. Currently, Choreo supports MI product versions 4.1.0 and 4.2.0. You have the flexibility to deploy WSO2 updates within these specified versions. 

When you create an integration project, you can specify a required runtime version to gain control over the environment in which your integration runs. This version management capability empowers you to tailor your projects depending on your runtime requirements, enhancing the customization and adaptability of your integration workflows.

## Understand the version string

WSO2 Micro Integrator (MI) utilizes a versioning system consisting of three-digit numbers, such as `4.1.0` and `4.2.0`, following semantic versioning principles. The product remains committed to receiving updates from WSO2, including security fixes, bug resolutions, and enhancements. Within the Choreo platform, the MI runtime version is constructed by combining the product release version with its corresponding update level.

In Choreo, the MI runtime version is structured as a four-digit number, for example, `4.1.0.14` or `4.2.0.17`. The first three digits represent the product release version, while the last digit signifies the update level of the product. The fourth digit is optional and can be omitted.

![Version string](../assets/img/develop-components/micro-integrator/version-string.png)

## Version management in WSO2 Integration Studio

If you are using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/) to build and deploy integration artifacts in WSO2 Micro Integrator, you can create multiple runtime environments and execute projects on any selected environment. WSO2 Integration Studio also allows you to configure multiple Micro Integrator runtime environments, offering flexibility and customization in the execution of integration processes.

You can specify the Runtime version when you create an integration project in WSO2 Integration Studio. In the project creation wizard, specify the runtime version in the **Runtime version** field, as shown below.
![Specify Runtime version](../assets/img/develop-components/micro-integrator/specify_runtime_version.png)


An integration project is structured as a Maven project with multiple sub-modules. The root `pom.xml` file holds crucial information about the target runtime. The runtime version you configure when you create a new project is saved within the root `pom.xml` file. The version information is stored in the <project.runtime.version> element under the <properties> in the `pom.xml` file. If there is a need to update the runtime version, you have the flexibility to modify the value to a valid runtime version and ensure that the project runs in the required runtime environment.

![project runtime version](../assets/img/develop-components/micro-integrator/project-runtime-version.png)

You can establish multiple runtime environments by utilizing updated MI instances. With a valid WSO2 subscription, you can also access and download updates to set up an updated MI server locally. This update process allows you to select a preferred update level as the runtime version. Consequently, you can run your integration on a runtime with the latest updates, ensuring optimal performance and access to new features.

### Configure a Micro Integrator runtime environment in Integration Studio

If you are using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), follow these steps to set up a remote server instance with a Micro Integrator runtime environment to execute your integration project:

!!! info "Note"
    If you have not downloaded and installed WSO2 Integration Studio, you can follow the [installation instructions](https://apim.docs.wso2.com/en/latest/integrate/develop/installing-wso2-integration-studio/) in the WSO2 API Manager documentation.

1. Launch WSO2 Integration Studio and click **Add Server** in the **Getting Started** view.
   ![Add server](../assets/img/develop-components/micro-integrator/add-server.png)
2. In the **Define a New Server** dialog, click to expand the `WSO2` directory and select **WSO2 Remote Server**.
   ![Define a remote server instance](../assets/img/develop-components/micro-integrator/define-a-remote-server-instance.png)
3. Enter the WSO2 Micro Integrator Management API URL in the **Server URL** field and click **Test Connection**.

    !!! info "Note"
        The Management API of WSO2 Micro Integrator is an internal REST API introduced to substitute MI admin services. The default HTTPS port of the Management API of WSO2 Micro Integrator is `9164`. If you have not manually changed the default port, you must set the Management API URL as `https://localhost:9164/management`.  If you have changed the default HTTPS port, you must set the port number appropriately when specifying the **Server URL**. For more information on the default ports of WSO2 Micro Integrator, see [WSO2 Micro Integrator default ports](https://apim.docs.wso2.com/en/latest/install-and-setup/setup/reference/default-product-ports/#micro-integrator-ports) in the WSO2 API Manager documentation.

    ![Set server URL](../assets/img/develop-components/micro-integrator/set-server-url.png)
    
4. Click **Finish**.
5. In the **Add and Remove** dialog, select the integration components to move from the left side to the right side.
6. Click **Add >**.
7. Click **Finish**. 

Your integration project is now running in a remote server instance with the Micro Integrator runtime environment you require.
If you need to make changes to the integration project, expand the remote server instance, right-click on the deployed exporter project, and select **Redeploy** to apply the changes.

![Redeploy project](../assets/img/develop-components/micro-integrator/redeploy-project.png)

## Convention for version interpretation in Choreo deployments

You can use the following convention to indicate the required MI runtime version in your integration project:


| **Version format**           | **Example**       | **Description**   |
|------------------------------|-------------------|-------------------|
| Product version              | `4.1.0`, `4.2.0`  | Deploy on the latest update level of the mentioned product version.                 |
| Product version with update level  | `4.1.0.15`, `4.2.0.17` |  Deploy on the exact update level of the mentioned product version.    |
| GA version                   | `4.1.0.0`, `4.2.0.0` | Deploy on the exact GA version without any update.                  |
| Default version            | Empty value         | Deploy on the latest update level of the default product version.                  |


Choreo utilizes Alpine images for configuring and deploying the Micro Integrator runtime. This includes automated configuration of the JRE/JDK, customized to the compatibility of the chosen runtime version, simplifying the setup procedure.

## Migrate between runtime versions

Changing the runtime version in an integration project may become necessary during product version upgrades or when you want to apply updates. 

To change the runtime version of a MI Integration, follow the below steps.

### Update the runtime version in the integration project
    
To change the runtime version in the integration project, follow the steps below:
1. Open the project in Integration Studio.
2. Right-click on the project and select **Change Runtime MI Version**.
    ![Update Runtime version](../assets/img/develop-components/micro-integrator/click_change_runtime.png)
3.  Specify the new runtime version as shown below:
    ![Update Runtime version](../assets/img/develop-components/micro-integrator/update_runtime_version.png)
4. Alternatively, you can manually update the version by opening the root `pom.xml` file.  Open pom.xml and change the required runtime version in `<project.runtime.version>` element under `<properties>` section.

To test the changes locally, you must download and set up the runtime environment locally. Then, you must [configure the Integration Studio runtime environment](#configure-a-micro-integrator-runtime-environment-in-integration-studio) by directing it to the locally installed MI runtime. Once the setup is complete, you can deploy your integrations on the MI runtime environment and proceed to the testing phase.

After completing the tests to ensure everything works as expected, you can follow below steps to deploy the project in Choreo:

1. Commit and push the changes to your repository.
2. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
3. Select your project from the **Project** list in the header.
4. Select your MI integration component from the **Component** list in the header.
5. In the left navigation menu, click **Build**.
6. Select the latest commit and click **Build**.
7. In the left navigation menu, click **Deploy**.
8. Click on the **Configure and Deploy** and deploy the component.
9. Verify the Runtime version by checking the logs by selecting the **Runtime Logs** under the **Observability** section.

  You will see the runtime version in the logs as shown below:
  ![Runtime version in logs](../assets/img/develop-components/micro-integrator/runtime_version_in_logs.png)

Next, you must conduct additional testing in the development environment on Choreo before you promote the integration to production environments.

## Troubleshoot errors

The following error codes can help you troubleshoot errors that occur during the integration component build:

| **Error code** | **Description**            |
|----------------|----------------------------|
| 110 - 119      | Internal server error.     |
| 121            | Malformed runtime version. |
| 122            | The specified runtime version is not available. Either the product or update level is not available.    |
| 123            | Trivy security vulnerabilities found in the `libs` directory. |
| 124            | Trivy security vulnerabilities found in the `dropins` directory. |
| 125            | Trivy security vulnerabilities found in the `libs` or `dropins` directory. |
| 126            | Error building integration project. |


# Submit and Manage Workflow Approval Requests

In Choreo, if an administrator [configures a workflow to require approval](../administer/configure-approvals-for-choreo-workflows.md), you must submit a request to obtain approval to perform the task.

Upon submitting a workflow approval request, Choreo notifies all authorized assignees via email about the [review request](../administer/review-workflow-approval-requests.md). When an authorized assignee approves or rejects the request, you will receive an email with details of the decision.

The approach to request approval can vary depending on the workflow. 

## Request approval for environment promotion

**Prerequisites**:

- Ensure you have a component created, built, and deployed to the development environment.
- Ensure that an approval workflow is configured for environment promotion.
- Ensure you are promoting the component to a critical environment, such as production.

To request approval to promote a component from the development environment to production, follow these steps:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to deploy. This takes you to the **Overview** page of the component.
3. In the left navigation menu, click **Deploy**.
4. Go to the **Development** card and click **Request to Promote**.
5. In the **Request Approval** pane that opens, enter your request details and click **Submit**. This creates a request and notifies all authorized assignees via email about the request.

    !!! note
         When an environment promotion request for a specific component is pending review, Choreo restricts other developers from making the same request until the pending request is either approved or rejected.

When an authorized assignee approves the request, you will receive a confirmation email and can proceed to promote the component to production.

## Cancel a workflow approval request

If you want to cancel a workflow approval request that is already submitted, you can do so before the request is approved or rejected. 

When you submit a workflow approval request, the **Request to Promote** button changes to **Cancel Request**. To cancel an approval request, click **Cancel Request**. Upon confirming the cancellation, all configured approvers are notified immediately, and the request will no longer be pending.


# Work with the Micro Integrator Runtime in Choreo

WSO2 Micro Integrator (WSO2 MI) is a lightweight, high-performance integration runtime. It allows you to run integrations developed using WSO2 Integration Studio within Choreo. 

The topics on this page walk you through the key aspects you need to understand to use the WSO2 MI runtime effectively in Choreo.

## Integration types

Choreo supports the following WSO2 MI integrations that cater to different use cases and requirements. Each integration type serves a specific purpose. Therefore, it is essential to understand their differences to easily choose the most appropriate integration for your use case.

- **Service**: Exposes an integration as an API via HTTP, making it possible to create a RESTful interface for your integration services. This type is ideal for scenarios where you need to provide an API for external systems or clients to interact with your integration.
- **Event Handler**: Triggers an integration based on external events such as messages arriving on a queue or updates in a database. This type is well-suited for implementing event-driven architectures or responding to changes in your system's environment.
- **Scheduled Task**: Runs an integration automatically at predefined time intervals, ensuring that specific integration tasks occur at regular intervals. This type is ideal for batch processing, data synchronization, or periodic maintenance tasks.
- **Manual Task**: Initiates an integration via user action, giving you full control over when the integration executes. This type is useful for on-demand tasks, testing, or debugging purposes.

## Develop integrations with WSO2 Integration Studio

[WSO2 Integration Studio](https://wso2.com/integration/integration-studio/) is a powerful, Eclipse-based graphical development environment that enables you to build and deploy integration artifacts in WSO2 Micro Integrator. This comprehensive IDE offers a robust set of tools for designing and testing integration flows and crafting integration artifacts. By utilizing the visual, drag-and-drop capabilities of WSO2 Integration Studio, developers can significantly reduce the time and effort needed to construct and deploy integration flows.

In addition to streamlining the development process, Integration Studio offers features such as debugging, testing, and version control to ensure the quality and reliability of integration flows. By creating an Integration project and Composite Exporter project in WSO2 Integration Studio, developers can export their integration projects as a single deployment artifact, known as a composite application. This composite application encompasses all the components and configurations necessary for deploying the integration project to WSO2 Micro Integrator.

The Composite Exporter project simplifies the deployment process by allowing developers to package their integration projects as a single, self-contained artifact that can be easily deployed and managed. This approach enhances the consistency and reliability of integration projects while streamlining the overall deployment process.

To start developing integrations with WSO2 Micro Integrator, see [WSO2 Micro Integrator documentation - Developing Integration Solutions](https://mi.docs.wso2.com/en/latest/develop/intro-integration-development/).

## Integration project directory structure

An Integration Project in WSO2 Integration Studio is a multi-module Maven project that can contain multiple modules with WSO2 Synapse configurations and a composite application module to export all the configurations as a single deployable artifact.

An integration project directory structure includes the following key components:

 - WSO2 Synapse configurations: These modules contain the essential configurations for the integration project.
 - Composite Application module: This module is responsible for exporting all the Synapse configurations as a single deployable artifact.

Optionally, you can include the following components in your integration project:

 - OpenAPI definition file: You can add the OpenAPI definition file to any location within the project. When creating a component, you'll need to define the path to this file. Choreo will automatically generate an OpenAPI definition for you based on your integration project, if you don't provide one.
 - Java libraries: If your integration project requires additional Java libraries, you can add them to the libs directory located in the project root.
 - deployment.toml file: This optional configuration file allows you to customize the preconfigured settings of WSO2 MI instances running on Choreo. By including this file, you can tailor the behavior of your WSO2 MI instances to better suit your project's specific requirements.

Understanding the Integration Project directory structure is crucial for organizing your project and ensuring that all necessary components are included in the final deployable artifact.

## OpenAPI support

OpenAPI Support plays a crucial role in enhancing the functionality of integrations exposed as APIs. By providing an OpenAPI definition for your exposed integration, you can streamline testing and management processes, ensuring a more efficient and user-friendly experience. Choreo will automatically generate an OpenAPI definition for you based on your integration project, if you don't provide one, saving you time and effort.

To incorporate OpenAPI support, store the OpenAPI definition file within the repository hosting your Integration Studio project. When creating the project, simply point to the file's location in the repository. If needed, you can change the location of the OpenAPI definition file later via the deploy page.

![Open API file](../assets/img/develop-components/micro-integrator/openapi_file.png)

By leveraging OpenAPI Support, you can optimize the way you test and manage your integrations, resulting in a more efficient development process and a smoother user experience.

## Work with third-party libraries

The use of third-party libraries in your Micro Integrator project can offer several advantages, such as enhanced functionality, improved integration capabilities, optimized performance, and reduced development time.

Here are some of the benefits of adding third-party JARs to the Micro Integrator:

 - Increased functionality: Third-party libraries can extend the core Micro Integrator distribution, allowing for greater flexibility and customization of integration solutions.
 - Enhanced integration capabilities: Third-party libraries enable the Micro Integrator to interact with existing systems such as databases or other APIs, improving overall integration capabilities.
 - Optimized performance: By offering optimized implementations of common functions, third-party libraries can improve the performance of the Micro Integrator.
 - Efficient development: Developers can avoid re-implementing commonly used functions, reducing development time and increasing efficiency.

To incorporate third-party libraries into your Micro Integrator project, create a new directory called `libs` at the
root of your project. If your project root and GitHub repository root are not the same, place the `libs` directory in
the project root. After adding the required JAR files to the `libs` directory, the Micro Integrator runtime will
automatically include them when deploying the component. This process ensures that any dependencies needed by your
integration flow are available at runtime.

In addition to `jar` libraries, you may also need to incorporate OSGi bundle JARs into your project. To do this,
create another directory called `dropins` at the root of your project. Similarly, if the project root and GitHub
repository root differ, place the `dropins` directory in the project root. Within the `dropins` directory, add the OSGi
bundle JAR files. The OSGI runtime will pick up these bundles during deployment, enabling you to utilize their
functionality within your Micro Integrator project.

![Libs directory](../assets/img/develop-components/micro-integrator/libs_dir.png)

## Importing custom certificates to MI

The feature enables Choreo MI users to import certificates into the MI `client-truststore.jks` file. This functionality
proves valuable when users need to establish connections with servers or services utilizing SSL/TLS encryption and
possessing self-signed certificates or certificates issued by private certificate authorities (CAs) that are not
automatically trusted. Importing the certificate to the MI `client-truststore.jks` file enables MI clients to establish secure connections with
the server or service seamlessly, eliminating SSL/TLS errors or warnings.

Before importing the certificate, it is necessary to obtain the certificate file, which can be in PEM or DER format. You
can get the certificate from the server or service provider or export it from a web browser. Certificates should be
added to the `/wso2mi/certs/` folder. Users need to verify that the mount path for the certificate file aligns with this
specific path.

1. In the Choreo console, select the component you wish to add a certificate to.
2. From the left navigation click **Deploy**.
3. Click on the **Configs and Secrets** tab.
4. Click **Create**.
5. Select **ConfigMap** as the **Config Type** and **File Mount** as the **Mount Type**.
6. Click **Next**.
7. Specify the following values as mount configurations:

    | **Field**       | **Value**                                              |                                    
    |-----------------|--------------------------------------------------------|
    | **Config Name** | An appropriate name for the certificate.             |
    | **Mount path**  | `/wso2mi/certs/<filename>`. For example, `/wso2mi/certs/certificate.crt` |

8. Click **Upload File** and attach the certificate.
9. Click **Create**.

## Working with sensitive data using MI Secure Vault

MI Secure Vault is a feature that allows users to securely store sensitive data, such as passwords and tokens, and
provide access to that data to MI Integrations. This feature provides an added layer of security to your integrations by
reducing the risk of accidental exposure of sensitive data.

To use MI Secure Vault to work with sensitive data, follow these steps:

1. Select the component from the Choreo Console.
2. From the left navigation, click Deploy.
3. Click on the **Configure and Deploy**.
4. Click on the **Add Environment Configurations**
5. Specify the following values as configurations:

    | **Field**       | **Value**                                 |                                    
    |-------------------------------------------|--------------------------------------------------------|
    | **Name** | An appropriate name for the secret/alias. |
    | **Value**       | Value for the secret                      |

6. Select **Mark as a Secret**.
7. Click **Add**.
8. Click **Deploy**.
9. Once the secret has been created, you can access it in your integration code using the following syntax:

```xml
<property name="secret_value_1" expression="wso2:vault-lookup('user_pass')" scope="default" type="STRING"/>
```
This code retrieves the secret named "user_pass" from the MI Secure Vault and stores it in the property named "
secret_value_1". You can then use this property in your integration code to access the secret value.

For more information on these features, see the [Accessing secrets](https://mi.docs.wso2.com/en/latest/install-and-setup/setup/security/encrypting-plain-text/#step-3-accessing-secrets) section of the MI Secure Vault documentation. By using MI
Secure Vault to store and access sensitive data in your integrations, you can ensure that your integrations
remain secure and protect sensitive data from unauthorized access.


## Scan third-party libraries to identify security vulnerabilities

Scanning third-party libraries for security vulnerabilities is essential for identifying potential weaknesses in an application that could be exploited by attackers. Taking a proactive approach to security helps organizations detect and mitigate risks before they can be exploited, preventing data breaches, system compromises, and other security incidents.

Choreo incorporates a security vulnerability scanning process during deployment. It uses Trivy to scan and detect critical vulnerabilities in third-party libraries added to the integration component. If the scan uncovers any critical vulnerabilities, the deployment process is halted. The deployment pane displays the Trivy scan status and any security failures in the Library (Trivy) vulnerable scan step, which can be accessed by clicking on it. Once the vulnerability has been addressed, you can redeploy the component.

## Customize WSO2 Micro Integrator preconfigured settings

Customizing WSO2 Micro Integrator Preconfigured Settings is essential for ensuring that the integration solution works optimally within the specific context of your organization. While WSO2 MI comes with preconfigured settings designed for general use, these settings may not be suitable for every organization's unique requirements. Customizing these settings can help optimize performance and ensure compatibility with your organization's systems and applications.

To customize the preconfigured settings of WSO2 MI instances running on Choreo, define a `deployment.toml` file in the GitHub repository subpath of your Micro Integrator project:

![deployment.toml](../assets/img/develop-components/micro-integrator/config_file.png)

!!! note
    If you change critical configuration parameters such as port offset and hostname, it can break internal communication.
    Therefore, the recommended approach is to update only the necessary configuration parameters.

Given below is a sample `deployment.toml` file that can be used to configure the JMS transport. For more information on WSO2 MI
configuration parameters, see the [MI Configuration Catalog](https://mi.docs.wso2.com/en/latest/reference/config-catalog-mi/).

```
[[transport.jms.sender]]
name = "myQueueSender"
parameter.initial_naming_factory = "org.apache.activemq.jndi.ActiveMQInitialContextFactory"
parameter.provider_url = "$env{JMS_PROVIDER_URL}"
parameter.connection_factory_name = "QueueConnectionFactory"
parameter.connection_factory_type = "queue"
parameter.cache_level = "producer"

[[transport.jms.listener]]
name = "myQueueListener"
parameter.initial_naming_factory = "org.apache.activemq.jndi.ActiveMQInitialContextFactory"
parameter.provider_url = "$env{JMS_PROVIDER_URL}"
parameter.connection_factory_name = "QueueConnectionFactory"
parameter.connection_factory_type = "queue"
parameter.cache_level = "consumer"
```

## Environment variables

Using environment variables is a recommended practice when developing integration artifacts with WSO2 Integration Studio, as it improves configuration management, security, portability, and manageability. By leveraging environment variables, organizations can streamline the management and maintenance of their integrations, ensuring that updates can be implemented quickly and efficiently.

The component's Deploy page provides a user-friendly interface to manage environment variables across different environments. For information on managing environment variables for complex use cases, see [Configurations and secrets](../devops-and-ci-cd/manage-configurations-and-secrets.md).

![Environment variables](../assets/img/develop-components/micro-integrator/env_variables.png)

Environment variables offer several benefits:

 - Configuration management: They simplify the process of managing and updating configuration settings, making it easier to maintain consistency across different environments.
 - Security: Environment variables help protect sensitive information by storing it securely and separating it from the main codebase.
 - Portability: By using environment variables, you can ensure that your integration artifacts can be easily migrated and deployed across various environments with minimal changes.
 - Manageability: Environment variables offer a centralized way to manage configuration settings, making it easier to update and maintain your integrations over time.

For a comprehensive list of parameters that can be configured as environment variables, see [WSO2 Micro Integrator documentation - Injecting Parameters - Supported parameters](https://mi.docs.wso2.com/en/latest/develop/injecting-parameters/#supported-parameters).

## Configure logging

Configuring logging is crucial when developing and maintaining a software system, as it can significantly improve efficiency during the development, testing, and maintenance phases of the software development process. Logging captures events and messages that occur during an application's execution, providing valuable insights for troubleshooting and debugging issues.

With Micro Integrator instances, you can configure and customize logging according to your requirements. Logging configurations can be added to each MI instance's environment, allowing you to fine-tune logging depending on the specific environment or deployment scenario.

To configure logging in MI instances, follow the steps given below: 

!!! tip
     You can use environment variables with specific naming conventions.

1. Start the variable name with `logging_level_` followed by the package or class name.
2. Replace the dot character in the package name with an underscore.
3. Set the variable value to the required logging level for the corresponding package or class.

    For example, to enable wire logs, change the logging level of the `org.apache.synapse.transport.http.wire` package to `debug`. 

To configure logging, set the environment variable as follows:

1. In the left navigation menu, click **Deploy** and then click **Configs & Secrets**. 
2. Click **+ Create**. 
3. Select **ConfigMap** as the **Config Type** and **Environment Variables** as the **Mount Type**. 
4. Click **Next**. 
5. Specify the following values as mount configurations:

    | **Field**       | **Value**                                              |                                    
    |-----------------|--------------------------------------------------------|
    | **Config Name** | An appropriate name for the configuration.             |
    | **Name**        | `logging_level_org_apache_synapse_transport_http_wire` |
    | **Value**       | `debug`                                                |

6. Click **Create**.

## Connectors

WSO2 Micro Integrator (MI) Connectors are prebuilt connectors designed to simplify integration between WSO2 MI and various other systems. They enable seamless connections to databases, message brokers, REST APIs, and more, allowing you to perform actions such as sending messages, executing queries, or retrieving data. These connectors are easy to use, making it straightforward to incorporate them into your WSO2 MI integration flows. Micro Integrator connectors are versatile and can be utilized in various integration scenarios, including data integration, service-oriented architecture (SOA) integration, and event-driven architecture (EDA) integration.

WSO2 Integration Studio is a comprehensive development environment that facilitates the creation of integration flows using WSO2 Micro Integrator Connectors. With Integration Studio, you can design and implement integration flows that connect diverse systems and execute various actions, such as sending messages, executing queries, or retrieving data. You can build integration flows using either prebuilt connectors provided by WSO2 MI or custom connectors developed using the Connector Development Toolkit. Integration Studio offers a graphical user interface that simplifies the process of building and testing integration flows while also providing a set of tools for managing and deploying these flows in a WSO2 MI runtime environment.

For more information, see the following topics in the WSO2 Micro Integrator documentation.

- [Connectors Overview](https://mi.docs.wso2.com/en/latest/reference/connectors/connectors-overview/)
- [Adding Connectors](https://mi.docs.wso2.com/en/latest/develop/creating-artifacts/adding-connectors/)

## Deploying integrations in Choreo 

WSO2 MI buildpack is where you can deploy integrations developed with WSO2 Micro Integrator as an API. In this preset, you have three different ways to define endpoints. Choreo gives priory to the definition of endpoints in the below-mentioned order. 

1. **Using component.yaml file**
This is the most flexible method to define endpoints. You can configure the endpoint details with the `component.yaml` configuration file. Place this file in the `.choreo` directory in the project path of the component. 
If the Micro Integrator project has inbound endpoints, you can expose them via different endpoints using the `component.yaml`file.

    To learn about the `component.yaml` file, see [Overview of the component.yaml file](../develop-components/manage-component-source-configurations.md#overview-of-the-componentyaml-file).

3. **Auto generating endpoints**
If `component.yaml` is not provided and if the source Micro Integrator project has APIs, Choreo scans the project and generates the API endpoints. If the project has few APIs, an endpoint will be generated for each API. The visibility of this auto-generated endpoint is set to `Public` by default. You can change the visibility in the deployment flow.

4. **Provide default endpoints**
If `component.yaml` is not provided and if the source Micro Integrator project doesn't have APIs, Choreo generates a default endpoint which will expose the default micro integrator port (8290) with `Public` visibility and wildcard context.

!!! note
    If you are currently using `component-config.yaml` or `endpoints.yaml` configuration files, see the respective [migration guide](../develop-components/manage-component-source-configurations.md#migration-guide) for instructions on migrating to the recommended `component.yaml` configuration file.

## Explore Choreo examples on GitHub

For a hands-on experience with MI-based integrations in Choreo, we recommend exploring our samples in Choreo Console. You can filter out the samples based on the buildpack `WSO2 MI`. This will point you to the samples in the [Choreo samples GitHub repository](https://github.com/wso2/choreo-samples)

### [Choreo samples - GitHub Repository](https://github.com/wso2/choreo-samples)

- **Fork the Repository**: Start by forking the repository to your account.

- **Explore & run**: Navigate through the different integration scenarios. Each example has a README.md with setup and execution instructions.



# Develop a Manual Task

This guide walks you through the steps to develop, deploy, test, and observe a manual task using Choreo.

In this guide, you will:

- Develop a manual task to fetch the weather forecast for a specified location for the next 24 hours from the [OpenWeatherMap](https://openweathermap.org) API.
- Process the weather data into a specific format.
- Send the formatted data to a specified email address.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

    !!! info "Repository File Structure"
        The sample code for this guide is in the `<sample-repository-dir>/weather-to-email-integration` directory. The following table describes the key files in the repository:

        | **File Path**         | **File Content**                                                     |
        | --------------------- | -------------------------------------------------------------------- |
        | **Ballerina.toml**    | Contains metadata about the project                                  |
        | **Dependencies.toml** | Lists the dependencies required for the project                      |
        | **main.bal**          | Contains the entry point of the project, including the main function |
        | **types.bal**         | Contains custom data types used in the project                       |
        | **utils.bal**         | Contains utility functions and helper functions used in the project  |

3. Go to [OpenWeatherMap](https://openweathermap.org/) and sign up to obtain an API key. For details, see the [OpenWeatherMap documentation](https://openweathermap.org/appid#signup).

## Step 1: Create a manual task component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Manual Task** card.
6. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:

        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

7. Enter the following information:

    | **Field**             | **Description**                                      |
    | ----------------------| -----------------------------------------------------|
    | **Organization**      | Your GitHub account                                  |
    | **Repository**        | `choreo-samples`                                     |
    | **Branch**            | `main`                                               |
    | **Component Directory** | `weather-to-email-integration`                       |

8. Select **Ballerina** as the **Build Pack**.

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Component Directory** specifies the location of the project to build the component.

4. Enter a unique name and description for the component. You can use the following values:

    | **Field**          | **Value**                        |
    | ------------------ | -------------------------------- |
    | **Component Name** | `WeatherToEmail`                 |
    | **Description**    | `My first manual task`           |


8. Click **Create**. Choreo initializes the component with the sample implementation and opens the **Overview** page of the component.

## Step 2: Build the manual task

1. In the left navigation menu, click **Build**.
2. In the **Builds** pane, click **Build**. This opens the **Commits** pane, where you can see all the commits related to the component.
3. Select the latest commit and click **Build**. This triggers the build process and displays the build progress in the **Build Logs** pane.

    !!! info
        The build process may take some time. Once complete, the build status will be listed in the **Builds** pane. Here, you will see the build status as **Success**.

## Step 3: Deploy the manual task

1. In the left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane, specify values for the configurable variables:

    !!! tip
        The configurable variables populated here are defined in the sample Ballerina project used in this guide. To learn how to declare configurable variables in Ballerina, see the [Ballerina documentation on declaring configurable variables](https://ballerina.io/learn/by-example/configurable-variables/).

    | **Field**     | **Value**                                                               |
    | ------------- | ----------------------------------------------------------------------- |
    | **apiKey**    | The API key you obtained in the prerequisites section                   |
    | **latitude**  | Latitude of the location to get the weather forecast                    |
    | **longitude** | Longitude of the location to get the weather forecast                   |
    | **email**     | The email address to receive the formatted weather forecast information |

    !!! note
        If you use **Ballerina** as the buildpack and want to set a configurable variable as a secret, click the lock icon corresponding to the configurable variable. This marks it as a secret and conceals the input value.

        For example, if you set the **apiKey** as a secret, its input value will be concealed. To update the input value later, click **Update Secret Content** and specify a new value.

4. Click **Deploy**.

## Step 4: Execute the manual task

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the task.

    !!! info "Inject Dynamic Values into Your Application as Command-Line Arguments"
        If you want to inject dynamic values into your application as command-line arguments when you run a manual task, follow these steps:
        1. Click the drop-down icon next to **Run Now** and then click **Run with Arguments**.
        2. In the **Runtime Arguments** pane, enter the arguments you want to pass to your application.
        3. Click **Execute**. This triggers the task with the specified arguments.

        The capability to run a manual task with arguments is supported for the following buildpacks:

        === "Dockerfile"
            To explore a Dockerfile-based manual task with arguments, try out the [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/docker-hello-world-manual-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on Docker projects, the **Run with Arguments** capability is not supported if the Dockerfile contains `CMD`. In such scenarios, use `ENTRYPOINT` to define your default commands.

        === "Go"
            To explore a Go-based manual task with arguments, try out the [Hello World Go Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-go-task) sample. For instructions, see the `readme.md` file in the sample repository.

        === "Java"
            To explore a Java-based manual task with arguments, try out the [Hello World Java Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-java-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on Java projects:
                - The **Run with Arguments** capability is not supported if `Procfile` is available in the project.
                - The `Main` class should be defined in the `manifest` file.
                - If Maven files such as `mvn.cmd` exist in the project without the `.mvn` directory, the build will fail. To ensure a successful build, either commit the `.mvn` directory along with any Maven files or exclude Maven files if you choose not to commit the `.mvn` directory.

        === "NodeJS"
            To explore a NodeJS-based manual task with arguments, try out the [Hello World NodeJS Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-nodejs-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on NodeJS projects:
                - The **Run with Arguments** capability is not supported if `Procfile` is available in the project.
                - The project root must contain the `package.json` file with the `main` attribute defined.

        === "WSO2 MI"
            To explore a WSO2 MI-based manual task with arguments, try out the [Weather to Logs Task](https://github.com/wso2/choreo-samples/tree/main/weather-to-logs-mi-manual-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on WSO2 MI projects and deploying a WSO2 MI integration as a manual task in Choreo, use the WSO2 MI automation mode. For details, see [Running the Micro Integrator in Automation Mode](https://apim.docs.wso2.com/en/latest/install-and-setup/install/running-the-mi-in-automation-mode/).

        === "Ballerina"
            To explore a Ballerina manual task with arguments, try out the [Weather to Email Task](https://github.com/wso2/choreo-samples/tree/main/weather-to-email-integration) sample. For instructions, see the README.md file in the sample repository.

            !!! info
                If you want to pass arguments to Ballerina main functions, use the **Run with Arguments** capability. For details on the arguments you can pass, see the [Ballerina documentation](https://ballerina.io/learn/by-example/main-function/). You can also override configurable values in the same manner. For more information, see [Provide values to configurable variables](https://ballerina.io/learn/provide-values-to-configurable-variables/#provide-via-command-line-arguments).

## Step 5: Test the manual task

Once the task is triggered, an email with the subject `[WSO2 Choreo Demo] Next 24H Weather Forecast` is sent from `choreo.demo@gmail.com` to the email address specified as the **email** configurable variable value in [Step 3](#step-3-deploy-the-manual-task).

If the manual task ran successfully, you should receive an email similar to the following:

![Received email](../../assets/img/develop-components/develop-a-scheduled-integration/Received-email.png)

## Step 6: Observe the manual task

The observability view in Choreo displays graphs that depict details such as throughput, latency, diagnostic data, and logs to identify and troubleshoot anomalies in components you deploy.

1. In the left navigation menu, click **Observability**.
2. Observe the following:
    - The throughput and latencies of requests served over a given period.
    - The logs generated over a given period.
    - The flame graph (Diagnostics View) generated over a given period.
    - The low-code diagram.

To learn more about the observability details you can view via Choreo observability, see [Observability Overview](../../monitoring-and-insights/observability-overview.md).

## Step 7: Monitor executions

To track and monitor executions associated with the deployed manual task, go to the left navigation menu and click **Execute**.

!!! tip
    The **Execute** view is applicable to both scheduled and manual tasks.

You can view the following information:

- **Total executions**: The total number of executions within the past 30 days.

    ![Total Execution](../../assets/img/develop-components/develop-a-scheduled-integration/total_executions.png)

- **Execution history**: The currently active executions and those that are already complete. You can view information such as the execution ID, the revision of the execution, and the time it was triggered.

    ![Execution History](../../assets/img/develop-components/develop-a-scheduled-integration/execution_history.png)

- **Detailed execution logs**: Click on an execution to view detailed logs related to it.

    !!! info
        It may take a few minutes for the logs to appear. You may need to manually refresh to view the latest logs.

    ![Execution Logs](../../assets/img/develop-components/develop-a-scheduled-integration/execution_logs.png)


# Develop a Scheduled Task

Choreo is a versatile integration platform that allows you to create various types of integrations depending on your requirements. If you need to automatically run a specific integration at regular intervals, you can use Choreo to develop a scheduled task. This type of integration can automate the synchronization of data between different systems at specified intervals, reducing errors and improving productivity by eliminating the need for manual intervention.

This guide walks you through the steps to develop, deploy, test, and observe a scheduled task using Choreo.

In this guide, you will:

- Develop a scheduled task to fetch the weather forecast for a specified location for the next 24 hours from the [OpenWeatherMap](https://openweathermap.org) API.
- Process the weather data into a specific format.
- Send the formatted data to a specified email address at a specific time every day.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

    !!! info "Repository File Structure"
        The sample code for this guide is in the `<sample-repository-dir>/weather-to-email-scheduled-task` directory. The following table describes the key files in the repository:

        | **File Path**         | **File Content**                                                     |
        | --------------------- | -------------------------------------------------------------------- |
        | **Ballerina.toml**    | Contains metadata about the project                                  |
        | **Dependencies.toml** | Lists the dependencies required for the project                      |
        | **main.bal**          | Contains the entry point of the project, including the main function |
        | **types.bal**         | Contains custom data types used in the project                       |
        | **utils.bal**         | Contains utility functions and helper functions used in the project  |

3. Go to [OpenWeatherMap](https://openweathermap.org/) and sign up to obtain an API key. For details, see the [OpenWeatherMap documentation](https://openweathermap.org/appid#signup).

## Step 1: Create a scheduled task component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Scheduled Task** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following information:

    | **Field**             | **Description**                                |
    | --------------------- | ---------------------------------------------- |
    | **Organization**      | Your GitHub account                            |
    | **Repository**        | `choreo-samples`                               |
    | **Branch**            | `main`                                         |
    | **Component Directory** | `weather-to-email-scheduled-task`              |

6. Select **Ballerina** as the build pack.

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Component Directory** specifies the location of the project to build the component.

7. Enter a unique name and description for the component. You can use the following values:

    | **Field**          | **Value**                        |
    | ------------------ | -------------------------------- |
    | **Component Name** | `WeatherToEmail`                 |
    | **Description**    | `My first scheduled task`        |

8. Click **Create**. Choreo initializes the component with the sample implementation and opens the **Overview** page of the component.

Now you can proceed to build and deploy the scheduled task.

## Step 2: Build the scheduled task

1. In the left navigation menu, click **Build**.
2. In the **Builds** pane, click **Build**. This opens the **Commits** pane, where you can see all the commits related to the component.
3. Select the latest commit and click **Build**. This triggers the build process and displays the build progress in the **Build Logs** pane.

    !!! info
        The build process may take some time. Once complete, the build status will be listed in the **Builds** pane. Here, you will see the build status as **Success**.

## Step 3: Deploy the scheduled task

1. In the left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane, specify values for the configurable variables:

    !!! tip
        The configurable variables populated here are defined in the sample Ballerina project used in this guide. To learn how to declare configurable variables in Ballerina, see the [Ballerina documentation on declaring configurable variables](https://ballerina.io/learn/by-example/configurable-variables/).

    | **Field**     | **Value**                                                               |
    | ------------- | ----------------------------------------------------------------------- |
    | **apiKey**    | The API key you obtained in the prerequisites section                   |
    | **latitude**  | Latitude of the location to get the weather forecast                    |
    | **longitude** | Longitude of the location to get the weather forecast                   |
    | **email**     | The email address to receive the formatted weather forecast information |

    !!! note
        If you use **Ballerina** as the buildpack and want to set a configurable variable as a secret, click the lock icon corresponding to the configurable variable. This marks it as a secret and conceals the input value.

        For example, if you set the **apiKey** as a secret, its input value will be concealed. To update the input value later, click **Update Secret Content** and specify a new value.

4. Click **Next**.
5. Define a schedule to run the task. In this guide, set the schedule to receive the weather information daily at 8:00 AM UTC. Enter the following values:

    | **Field**            | **Value**                                             |
    | -------------------- | ----------------------------------------------------- |
    | **Select Time Zone** | Select a time zone to schedule the task               |
    | **Select Range**     | **Day**                                               |
    | **Every**            | `1`                                                   |
    | **At**               | `08:00`                                               |

    !!! tip
        To test and verify the task immediately, you can schedule the deployment to run in just a few minutes after you create it. However, to avoid unnecessary expenses, reschedule or stop the deployment once you test and verify.

6. Click **Deploy**. This deploys the scheduled task to the development environment and indicates the **Scheduled Status** as **Active** in the **Development** card.

You can test the scheduled task when it runs at the configured time.

## Step 4: Test the scheduled task

When the scheduled task runs at the configured time, an email with the subject `[WSO2 Choreo Demo] Next 24H Weather Forecast` is sent from `choreo.demo@gmail.com` to the email address specified as the **email** configurable variable value in [Step 3](#step-3-deploy-the-scheduled-task).

If the scheduled task ran successfully, you should receive an email similar to the following:

![Received email](../../assets/img/develop-components/develop-a-scheduled-integration/Received-email.png)

## Step 5: Observe the scheduled task

The observability view in Choreo displays graphs that depict details such as throughput, latency, diagnostic data, and logs to identify and troubleshoot anomalies in components you deploy.

1. In the left navigation menu, click **Observability**.
2. Observe the following:
    - The throughput and latencies of requests served over a given period.
    - The logs generated over a given period.
    - The flame graph (Diagnostics View) generated over a given period.
    - The low-code diagram.

To learn more about the observability details you can view via Choreo observability, see [Observability Overview](../../monitoring-and-insights/observability-overview.md).

## Step 6: Monitor executions

To track and monitor executions associated with the deployed scheduled task, go to the left navigation menu and click **Execute**.

!!! tip
    The **Execute** view is applicable to both scheduled and manual tasks.

You can view the following information:

- **Total executions**: The total number of executions within the past 30 days.

    ![Total Execution](../../assets/img/develop-components/develop-a-scheduled-integration/total_executions.png)

- **Execution history**: The currently active executions and those that are already complete. You can view information such as the execution ID, the revision of the execution, and the time it was triggered.

    ![Execution History](../../assets/img/develop-components/develop-a-scheduled-integration/execution_history.png)

- **Detailed execution logs**: Click on an execution to view detailed logs related to it.

    !!! info
        It may take a few minutes for the logs to appear. You may need to manually refresh to view the latest logs.

    ![Execution Logs](../../assets/img/develop-components/develop-a-scheduled-integration/execution_logs.png)


# Develop an Event Handler

An event handler executes predefined actions in response to specific events. Choreo simplifies the process of creating and deploying such integrations.

This guide walks you through the steps to create and deploy an Event Handler using WSO2 MI and Choreo.

In this guide, you will build a simple event handler that monitors RabbitMQ for new messages and displays them once they become available.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Set up RabbitMQ:
    - Use an existing RabbitMQ instance or start a new [RabbitMQ](https://www.rabbitmq.com/download.html) instance on a server that can be accessed via the internet.
    - Obtain the `username`, `hostname`, `password`, and `vhost` from the RabbitMQ instance to use later as environment variables.

3. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

## Step 1: Create an event handler component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Event Handler** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following information:

    | **Field**             | **Description**              |
    |-----------------------|----------------------------- |
    | **Organization**      | Your GitHub account          |
    | **Repository**        | `choreo-samples`             |
    | **Branch**            | `main`                       |
    | **Component Directory** | `mi-rabbitmq-listener`       |

6. Select **WSO2 MI** as the build pack. (since you are creating the REST API from a [WSO2 Integration Studio](https://wso2.com/micro-integrator/) project)

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Component Directory** specifies the location of the project to build the component.

7. Enter a unique name and description for the component. You can use the following values:

    | **Field**          | **Value**              |
    |--------------------|------------------------|
    | **Component Name** | `SalesOrderListener`   |
    | **Description**    | `RabbitMQ integration` |

8. Click **Create**.

## Step 2: Deploy the integration

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**.
3. In the **Configurations** pane, click **+ Add** corresponding to **Environment Variables** and add the following environment variables:

    !!! tip
        Use the values from your RabbitMQ instance as per the [Prerequisites](#prerequisites) section for the environment variables.

    | **Name**     | **Value**                                         |
    | ------------- |--------------------------------------------------|
    | **HOSTNAME**  | Hostname of your RabbitMQ server                 |
    | **VHOST**     | Virtual hostname of your RabbitMQ server         |
    | **USERNAME**  | Username for connecting to RabbitMQ              |
    | **PASSWORD**  | Password associated with the RabbitMQ username   |

4. Click **Deploy**. This deploys the event handler to the development environment and indicates the **Deployment Status** as **Active** in the **Development** card.

## Step 3: Test the integration

1. Send a sales order message to the **SalesOrderQueue** on the RabbitMQ server. You can send a sample sales order message similar to the following:

    ```json
    {
        "order_id": "12345",
        "customer_name": "John Doe",
        "product": "Widget",
        "quantity": 10,
        "total_amount": 100.00
    }
    ```

2. Observe the logs:
    - In the left navigation menu, click **Logs** and then click **Runtime Logs**. You will see the order message in the logs.

Now you have gained hands-on experience in creating, configuring, and deploying an event handler.


# Develop an Integration with Integration Studio

Choreo simplifies the process of building, deploying, and managing integration components, making it easy to expose integrations as APIs. This guide walks you through the steps to expose an integration created in WSO2 Integration Studio as an API in Choreo.

In this guide, you will:
- Create a component to expose a sample integration from the [Choreo samples repository](https://github.com/wso2/choreo-samples) as an API.
- Deploy, test, and observe the integration component.
- Publish the integration component as an API to the Choreo Developer Portal.

!!! note
    - To develop integrations for **Manual Task** and **Schedule Task** components in Choreo, use the **automation mode** in the WSO2 Micro Integrator. See [Running MI in Automation Mode](https://apim.docs.wso2.com/en/4.2.0/install-and-setup/install/running-the-mi-in-automation-mode/).
    - For other component types (Service, webhook, event-handler, etc.), use the **server mode**.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    - Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    - Enter a unique organization name. For example, `Stark Industries`.
    - Read and accept the privacy policy and terms of use.
    - Click **Create**. This creates the organization and opens the **Project Home** page.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

## Step 1: Create the integration component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the **Project Home** page.

2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following repository details:

    | **Field**             | **Description**              |
    |-----------------------|----------------------------- |
    | **Organization**      | Your GitHub account          |
    | **Repository**        | `choreo-samples`            |
    | **Branch**            | **`main`**                   |
    | **Component Directory** | `hello-world-mi`             |

6. Select WSO2 MI as the build pack (since you're creating the REST API from a [WSO2 Integration Studio](https://wso2.com/micro-integrator/) project).

7. Provide a unique name and description for the component:

    | **Field**          | **Value**              |
    |--------------------|------------------------|
    | **Component Name** | `Hello World`          |
    | **Description**    | `Hello World REST API` |

8. Click **Create**. Choreo initializes the component with the sample integration.

## Step 2: Deploy the integration component

1. In the Choreo Console left navigation menu, click **Deploy**.

2. Configure and deploy:
   - In the **Build Area** card, click **Configure & Deploy**.
   - In the **Configurations** pane, click **Next**. This displays the endpoint details ready for deployment.
   - Click **Deploy**. This deploys the integration component to the development environment.

    !!! tip
        - Choreo uses [endpoints](../../choreo-concepts/endpoint.md) to expose **Service** components to the network. Learn more about configuring endpoints in [Configure Endpoints](../configure-endpoints.md).
        - Automatic deployment is enabled by default, so only the first deployment needs to be done manually.

   The **Development** card shows the **Deployment Status** as **Active** when the integration is successfully deployed.

## Step 3: Test the integration

1. In the Choreo Console left navigation menu, click **Test** and then click **Console**.
2. In the OpenAPI Console, select **Development** from the environment drop-down list.
3. Expand the **GET /integration** operation.
4. Click **Try it out**, then click **Execute**. This sends a request to your deployed integration.
5. Check the response:
    - In the **Response body** section, observe the response. If the integration works as expected, you should see:
     
     ```json
     {"Hello" : "Integration"}
     ```

## Step 4: Observe the integration

1. Click **Observability** in the left navigation menu to monitor the performance of the integration component.

2. View metrics:
   - Observe throughput and latencies of requests over time.
   - View logs generated during a specific period.
   - Analyze the flame graph (Diagnostics View) for performance insights.

   For more details, see [Observability Overview](../../monitoring-and-insights/observability-overview.md).

## Step 5: Publish the integration component

1. In the Choreo Console left navigation menu, click **Manage** and then click **Lifecycle**.
2. The **Lifecycle Management** pane shows the current lifecycle stage as **Created**.
3. Click **Publish**. This changes the lifecycle stage to **Published** and exposes the integration as an API in the Choreo Developer Portal.
   - To view the published API, click **Go to Devportal**. In the Developer Portal, you can manage subscriptions and generate access tokens for testing.

Now you have successfully exposed an integration designed in WSO2 Integration Studio as a REST API in Choreo!


# Develop an API Proxy from a GitHub Repository Source

An API proxy acts as an intermediary between an existing API and Choreo, intercepting all requests made to the API. It also functions as a managed API, allowing you to apply essential API management features such as security policies and rate limiting.

In this guide, you will:

- Create an API proxy component to expose an existing API.
- Deploy the API proxy.
- Test the API proxy to verify its functionality.
- Manage the API.
- Consume the API.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample proxy source](https://github.com/wso2/choreo-samples/tree/main/department-api-proxy-from-github).  

## Step 1: Create an API proxy

You can create an API proxy either by selecting the source from a GitHub repository, uploading an OpenAPI specification file, or providing an OpenAPI specification URL. This guide demonstrates how to create an API proxy using a GitHub repository as the source.

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **API Proxy** card. This opens the **Create an API Proxy** pane.

4. Click on **Authorize With GitHub** card under **Connect a Git Repository** section to connect your GitHub account.
    - If you haven’t connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
         - Read and write access to code and pull requests.
         - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.    

5. Enter the following repository details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **Repository**         | choreo-samples     |
    | **Branch**             | **`main`**         |
    | **API Directory**      | /department-api-proxy-from-github |

    !!! note
        To select the relevant directory, click on the **Edit** action next to the **API Directory** input field. Then, enter `department-api-proxy-from-github` as the directory name to quickly search and locate the correct directory.

6. Specify the following values as Proxy Metadata:

    !!! info
        The **Context** field must be unique and cannot be changed after creation.**Version** and **Target** are mandatory fields. **Target** can be changed at any time after the creation.

    | **Field**       | **Value**                                  |
    |-----------------|--------------------------------------------|
    | **Context**     | `department-service`                                   |
    | **Version**     | `v1.0`                                      |
    | **Target**      | `https://samples.choreoapps.dev/company/hr`|

7. Specify the following values as Component Details:

    !!! info
        The **Component Name** field must be unique and cannot be changed after creation. This value is automatically generated, but you can edit it if necessary.
        **Component Display Name** is a required field.

    | **Field**       | **Value**                                  |
    |-----------------|--------------------------------------------|
    | **Component Display Name**| `Department Service`                    |
    | **Component Name**        | `department-service`                    |
    | **Description**           | `This is a sample proxy for department service`     |    

8. Click **Create**. This creates the API proxy component and takes you to the **Build** page.

!!! note
    When you create an API proxy from a GitHub repository source, the GitHub source serves as the single source of truth. Therefore, any modifications, such as adding or deleting resources, must be made through the GitHub repository.

## Step 2: Build

!!! info
    The initial build starts automatically when you create the API proxy, and you will be redirected to the **Build** page. In this case, you can skip the steps below. If you need to manually trigger a build later, follow these steps.

1. On the project home page, click on the `Department Service` component you created. This takes you to the component overview page.
2. In the left navigation menu, click **Build**.
3. On the **Build** page, click **Build Latest**.

!!! note
    The build process may take some time. You can track progress in the **Build Details** pane. Once complete, the build status changes to **Success**.

## Step 3: Deploy the API proxy

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**. This opens the **Configure & Deploy** pane.
3. Select **External** as the **API Access Mode** and click **Deploy**. The **Development** card indicates the **Deployment Status** as **Active** when the API proxy is successfully deployed.

Now you are ready to test the API proxy.

## Step 4: Test the API proxy

Choreo allows you to test your API proxy using either the [integrated OpenAPI Console](../../testing/test-rest-endpoints-via-the-openapi-console.md) or [cURL](../../testing/test-apis-with-curl.md). In this guide, you will use the OpenAPI Console.

!!! tip
    Choreo enables OAuth 2.0 to secure APIs by default. Therefore, you need an access token to invoke an API.

    - Choreo automatically generates a key to test the API via the OpenAPI Console. To view the key, click the show key icon in the **Security Header** field.
    - To disable security for the entire API or a specific resource:
        1. In the left navigation menu, click **Deploy**.
        2. Go to the **Build Area** card and click **Security Settings**.
        3. In the **Security Settings** pane:
            - To disable security for the entire API, clear the **OAuth2** checkbox.
            - To disable security for a specific resource, expand the relevant resource and turn off the **Security** toggle.
        4. Click **Apply**.

1. In the left navigation menu, click **Test** and then click **OpenAPI Console**.
2. Select **Development** from the environment drop-down list.
3. Expand the `GET /department/{departmentId}` resource and click **Try it Out**.
4. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

    ![API proxy response](../../assets/img/develop-components/develop-a-rest-api-proxy/rest-api-proxy-response.png){.cInlineImage-full}

    This indicates that your API proxy is working as expected.

## Step 5: Manage the API proxy

Now that you have a tested API proxy, you can publish it and make it available for application developers to consume. In this guide, you will apply rate limiting to the API and publish it.

### Step 5.1: Apply rate limiting to the API proxy

1. In the left navigation menu, click **Deploy**.
2. Go to the required environment card and click the settings icon corresponding to **API Configuration**.
3. In the **CORS, Rate Limiting and Resiliency** pane, click **Rate Limiting** to expand the section.
4. Select **API Level** as the **Rate Limiting Level**.
5. Specify appropriate values for the **Request Limit** and **Time Unit** fields. You can proceed with the default values.
6. Click **Apply**. This applies the rate limiting level to the API proxy and redeploys it.

### Step 5.2: Publish the API proxy

1. In the left navigation menu, click **Lifecycle** under **Manage**. This takes you to the **Lifecycle** page.
2. Click **Publish**.
3. In the **Publish API** dialog, click **Confirm** to proceed with publishing the API. If you want to change the display name, make the necessary changes and then click **Confirm**. This changes the API lifecycle state to **Published**.

## Step 6: Invoke the API

To generate credentials for the published API and invoke it via the Choreo Developer Portal, follow these steps:

1. In the **Lifecycle** page, click **Go to Devportal**. This takes you to the `Department Service` in the Choreo Developer Portal.

2. **Invoke the API**:
    1. In the Developer Portal left navigation menu, click **Try Out**.
    2. In the **Endpoint** list, select **Development** as the environment to try out the API.
    3. Click **Get Test Key** to generate an access token.
    4. Expand the `GET /department/{departmentId}` resource and click **Try it out**.
    5. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

        ![Try out response](../../assets/img/develop-components/develop-a-rest-api-proxy/try-out-response.png){.cInlineImage-full}

Now, you have gained hands-on experience creating, deploying, testing, and publishing an API proxy using Choreo.


# Develop an API Proxy from Scratch

An API proxy acts as an intermediary between an existing API and Choreo, intercepting all requests made to the API. It also functions as a managed API, allowing you to apply essential API management features such as security policies and rate limiting.

In this guide, you will:

- Create an API proxy component to expose an existing API.
- Deploy the API proxy.
- Test the API proxy to verify its functionality.
- Manage the API.
- Consume the API.

## Prerequisites

- If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

## Step 1: Create an API proxy

To create an API proxy, you can either upload an OpenAPI specification or provide an OpenAPI specification URL. In this guide, you will specify a URL to an OpenAPI definition of a sample API.

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **API Proxy** card. This opens the **Create an API Proxy** pane.
4. Select **Creare from Scratch** option. 
5. Specify the following values as Proxy Metadata:

    | **Field**       | **Value**                                  |
    |-----------------|--------------------------------------------|
    | **Context**     | `department-service`                                   |
    | **Version**     | `v1.0`                                      |
    | **Target**      | `https://samples.choreoapps.dev/company/hr` |

6. Enter following details for the Component Details:

    !!! info
        The **Component Name** field must be unique and cannot be changed after creation.

    | **Field**                 | **Value**          |
    |---------------------------|--------------------|
    | **Component Display Name**| `Department Service`          |
    | **Component Name**        | `department-service`          |
    | **Description**           | `Sample proxy for department service`     |

7. Click **Create**. This creates the API proxy component and takes you to the **Deploy** page.

## Step 2: Define resources for the API proxy

To add a new resource that retrieves a department by the department ID, follow these steps:

1. In the left navigation menu, click **Develop** and then click **Resources**.
2. Select **GET** as the **HTTP Verb** and enter `/department/{departmentId}` as the **URI Pattern**.
3. Click **+** to add the resource.
4. Expand the added resource and specify the following values:

    | **Field**        | **Value**                            |
    |------------------|--------------------------------------|
    | **Operation ID** | `findDepartment`                     |
    | **Description**  | `Find a department by department ID` |

5. Remove the five default resources that start with `/*` by clicking the delete icon corresponding to each resource.
6. Click **Save**.

## Step 3: Deploy the API proxy

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**. This opens the **Configure & Deploy** pane.
3. Select **External** as the API access mode and click **Deploy**. The **Development** card indicates the **Deployment Status** as **Active** when the API proxy is successfully deployed.

Now you are ready to test the API proxy.

## Step 4: Test the API proxy

Choreo allows you to test your API proxy using either the [integrated OpenAPI Console](../../testing/test-rest-endpoints-via-the-openapi-console.md) or [cURL](../testing/test-apis-with-curl.md). In this guide, you will use the OpenAPI Console.

!!! tip
    Choreo enables OAuth 2.0 to secure APIs by default. Therefore, you need an access token to invoke an API.

    - Choreo automatically generates a key to test the API via the OpenAPI Console. To view the key, click the show key icon in the **Security Header** field.
    - To disable security for the entire API or a specific resource:
        1. In the left navigation menu, click **Deploy**.
        2. Go to the **Build Area** card and click **Security Settings**.
        3. In the **Security Settings** pane:
            - To disable security for the entire API, clear the **OAuth2** checkbox.
            - To disable security for a specific resource, expand the relevant resource and turn off the **Security** toggle.
        4. Click **Apply**.

1. In the left navigation menu, click **Test** and then click **OpenAPI Console**.
2. Select **Development** from the environment drop-down list.
3. Expand the `GET /department/{departmentId}` resource and click **Try it Out**.
4. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

    ![API proxy response](../../assets/img/develop-components/develop-a-rest-api-proxy/rest-api-proxy-response.png){.cInlineImage-full}

    This indicates that your API proxy is working as expected.

## Step 5: Manage the API proxy

Now that you have a tested API proxy, you can publish it and make it available for application developers to consume. In this guide, you will apply rate limiting to the API and publish it.

### Step 5.1: Apply rate limiting to the API proxy

1. In the left navigation menu, click **Deploy**.
2. Go to the required environment card and click the settings icon corresponding to **CORS, Rate Limiting and Resiliency**.
3. In the **CORS, Rate Limiting and Resiliency** pane, click **Rate Limiting** to expand the section.
4. Select **API Level** as the **Rate Limiting Level**.
5. Specify appropriate values for the **Request Limit** and **Time Unit** fields. You can proceed with the default values.
6. Click **Apply**. This applies the rate limiting level to the API proxy and redeploys it.

### Step 5.2: Publish the API proxy

1. In the left navigation menu, click **Lifecycle** under **Manage**. This takes you to the **Lifecycle** page.
2. Click **Publish**.
3. In the **Publish API** dialog, click **Confirm** to proceed with publishing the API. If you want to change the display name, make the necessary changes and then click **Confirm**. This changes the API lifecycle state to **Published**.

## Step 6: Invoke the API

To generate credentials for the published API and invoke it via the Choreo Developer Portal, follow these steps:

1. In the **Lifecycle** page, click **Go to Devportal**. This takes you to the `Department Service` in the Choreo Developer Portal.

2. **Invoke the API**:
    1. In the Developer Portal left navigation menu, click **Try Out**.
    2. In the **Endpoint** list, select **Development** as the environment to try out the API.
    3. Click **Get Test Key** to generate an access token.
    4. Expand the `GET /department/{departmentId}` resource and click **Try it out**.
    5. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

        ![Try out response](../../assets/img/develop-components/develop-a-rest-api-proxy/try-out-response.png){.cInlineImage-full}

Now, you have gained hands-on experience creating, deploying, testing, and publishing an API proxy using Choreo.

# Develop a Ballerina Service

Choreo allows you to develop and deploy applications using your preferred programming language. This guide demonstrates how to deploy a service component that exposes a REST API using the [Ballerina language](https://ballerina.io/). No prior knowledge of Ballerina is required to follow this guide.

A REST API is a web service that adheres to Representational State Transfer (REST) principles, using HTTP methods to access and manage resources. This guide walks you through building a Ballerina service component, deploying it on Choreo, and testing it with an HTTP client application.

In this guide, you will:

 - Build a simple greeting service using a sample implementation. The service has a single resource named `greet` that accepts a query parameter as input.
 - Deploy the service in Choreo.
 - Test the service.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    - Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    - Enter a unique organization name. For example, `Stark Industries`.
    - Read and accept the privacy policy and terms of use.
    - Click **Create**. This creates the organization and opens the **Project Home** page.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample greetings service](https://github.com/wso2/choreo-samples/tree/main/greeting-service) implementation in Ballerina.

### Learn the repository file structure

It’s important to understand the purpose of key files in the sample service. The table below provides an overview of each file in the greeter service:

!!! note
    The file paths are relative to `<sample-repository-dir>/greeting-service`.

| **Filepath**              | **Description**                                                |
|---------------------------|---------------------------------------------------------------|
| `service.bal`             | The greetings service code written in Ballerina.               |
| `tests/service_test.bal`  | Test files related to the `service.bal` file.                  |
| `Ballerina.toml`          | The Ballerina configuration file.                              |

Let’s get started!

## Step 1: Create a service component

To create a Ballerina service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the **Project Home** page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect your GitHub account. If you haven’t connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Provide the following repository details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **Repository**         | choreo-samples     |
    | **Branch**             | **`main`**         |
    |**Component Directory** | `/greeting-service` |

6. Select **Ballerina** as the buildpack.

7. Provide a display name, a unique name, and a description for the service component:

    !!! info
        The **Component Name** field specifies a unique identifier for the component. This name cannot be changed after creation.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Ballerina Greetings`   |
    | **Component Name**        | `ballerina-greetings`   |
    | **Description**           | Send greetings          |

8. Click **Create**. This creates the component and takes you to the **Overview** page.

You have successfully created a service that exposes a REST API written in Ballerina. Next, let’s build and deploy the service.

## Step 2: Build and deploy

Now that you’ve connected the source repository and configured the endpoint details, it’s time to build and deploy the service.

!!! note
    If you’re rebuilding the Ballerina service component after changing the Ballerina version, ensure that the version in the `Ballerina.toml` file matches the version in the `Dependencies.toml` file.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service may take a while. Track the progress via the logs in the **Build Details** pane. Once complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps:

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane, click **Next** to skip the configuration.
4. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service may take a while. Once deployed, the **Development** environment card shows the **Deployment Status** as **Active**.

Once deployed, you can test, manage, and observe the service like any other component in Choreo.

For detailed instructions, see the following sections:
- [Step 3: Test](../../testing/test-rest-endpoints-via-the-openapi-console.md)
- [Step 4: Manage](../../api-management/lifecycle-management.md)

## Manage the deployment

To view Kubernetes-level insights for detailed diagnosis of this Ballerina REST API, see Choreo’s [DevOps capabilities](../../devops-and-ci-cd/view-runtime-details.md).


# Develop a Service with Docker

Choreo allows you to create and deploy applications in any language. This guide demonstrates how to develop and deploy a containerized service component using a Dockerfile.

In this guide, you will:

 - Create a containerized service component using a sample service implementation. The sample service has a single resource named `greet` that accepts a query parameter as input.
 - Deploy the service in Choreo using a Dockerfile. The service will run on port 9090.
 - Test the service.

If you want to create a service component that exposes a Ballerina service, see [Develop a Ballerina Service](develop-a-ballerina-service.md).

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    - Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    - Enter a unique organization name. For example, `Stark Industries`.
    - Read and accept the privacy policy and terms of use.
    - Click **Create**. This creates the organization and opens the **Project Home** page.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample greetings service](https://github.com/wso2/choreo-samples/tree/main/greeting-service-go) implementation with the Dockerfile.

### Learn the repository file structure

It’s important to understand the purpose of key files in the sample service. The table below provides an overview of each file in the greeter service:

!!! note
    The file paths are relative to `<sample-repository-dir>/greeting-service-go`.

| **Filepath**               | **Description**                                                              |
|----------------------------|------------------------------------------------------------------------------|
| `main.go`                  | The Go-based greeter service code.                                           |
| `Dockerfile`               | The Dockerfile to build the container image of the application.              |
| `.choreo/component.yaml`   | Choreo-specific configuration that provides information about how Choreo exposes the service. |
| `openapi.yaml`             | The OpenAPI contract of the greeter service. This is required to publish the service as a managed API. This file is referenced by the `.choreo/component.yaml` file. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints. The greeter service runs on port 9090. To securely expose the service through Choreo, you must provide the port and other required information in the `component.yaml` file. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

In the greeter sample, the `component.yaml` file is located in the `greeting-service-go/.choreo/` directory.

## Step 1: Create a service component from a Dockerfile

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/cloud-native-app-developer) and sign in. This opens the **Project Home** page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect your GitHub account. If you haven’t connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
         - Read and write access to code and pull requests.
         - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following repository details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **Repository**         | choreo-samples     |
    | **Branch**             | `main`         |
    | **Component Directory** | `/greeting-service-go`         |

6. Select **Docker** as the buildpack.
7. Enter the following details:

    | **Field**                | **Value**                        |
    |--------------------------|----------------------------------|
    | **Dockerfile**           | `/greeting-service-go/Dockerfile`|

    !!! info
        1. To successfully build your container with Choreo, explicitly define a user ID (UID) under the `USER` instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-sample-apps/blob/main/go/greeter/Dockerfile).
           - A valid User ID is a numeric value between 10000-20000 (e.g., `10001` or `10500`).
           - Usernames are invalid and should not be used (e.g., `my-custom-user-12221` or `my-custom-user`).

        2. The Dockerfile used in this guide is a multi-stage Dockerfile, which keeps the final image size small and allows building the application with specific versions of tools and libraries.

8. Provide a display name, a unique name, and a description for the service component:

    !!! info
        The **Component Name** field specifies a unique identifier for the component. This name cannot be changed after creation.

    | **Field**                 | **Value**          |
    |---------------------------|--------------------|
    | **Component Display Name**| `Greetings`        |
    | **Component Name**        | `greetings`        |
    | **Description**           | Send greetings     |

9. Click **Create**. This creates the component and takes you to the **Overview** page.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you’ve connected the source repository and configured the endpoint details, it’s time to build the service and create an image. Then, you can deploy the image and test the greeter service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service may take a while. Track the progress via the logs in the **Build Details** pane. Once complete, the build status changes to **Success**.

    You can access the following scans under **Build**:
    - **Dockerfile Scan**: Choreo checks if a non-root user ID is assigned to the Docker container for security. If no non-root user is specified, the build will fail.
    - **Container (Trivy) Vulnerability Scan**: This detects vulnerabilities in the final Docker image. If critical vulnerabilities are found, the build will fail.

    !!! info
        If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps:

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service may take a while. Once deployed, the **Development** environment card shows the **Deployment Status** as **Active**.

Once deployed, you can [test](../../testing/test-rest-endpoints-via-the-openapi-console.md), [manage](../../api-management/lifecycle-management.md), and [observe](../../monitoring-and-insights/observability-overview.md) the service like any other component in Choreo.

To view Kubernetes-level insights for detailed diagnosis of this Dockerfile-based REST API, see [Choreo's DevOps capabilities](../../devops-and-ci-cd/view-runtime-details.md).


# Develop a Service

Choreo allows you to create and deploy applications in your preferred programming language. 

In this guide, you will:

- Build a simple greeting service using a sample service implementation. The sample implementation will have a single resource named `greet` that accepts a single query parameter as input.
- Deploy the service in Choreo using a `Go` buildpack. The service will run on port 9090.
- Test the service.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample greetings service](https://github.com/wso2/choreo-samples/tree/main/greeting-service-go) implementation in `Go`.

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the greeter service:

!!! note 
    The specified file paths are relative to `<sample-repository-dir>/greeting-service-go`.

| **Filepath**             | **Description**                                                               |
|--------------------------|-------------------------------------------------------------------------------|
| `main.go`                | The Go-based greeter service code.                                            |
| `.choreo/component.yaml` | Choreo-specific configuration that provides information about how Choreo exposes the service. |
| `openapi.yaml`           | The OpenAPI contract of the greeter service. This is required to publish the service as a managed API. This `openapi.yaml` file is referenced by the `.choreo/component.yaml` file. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints. To run the greeter service on port 9090 and securely expose it through Choreo, you must provide the port and other required information in the `component.yaml` file. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

In the greeter sample, the `component.yaml` file is located in the `greeting-service-go/.choreo/` directory.

## Step 1: Create a service component

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Public Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Under **Connect a Git Repository**, enter the following details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **GitHub Repository**  | choreo-samples     |
    | **Branch**             | main               |
    | **Component Directory** | `/greeting-service-go` |

6. Select **Go** as the buildpack.
7. Enter the following details:

    | **Field**                | **Value**              |
    |--------------------------|------------------------|
    | **Language Version**     | 1.x                    |

8. Provide component display name, name and description:

    !!! info
        The **Component Name** field must be unique and cannot be changed after creation.

    | **Field**                 | **Value**          |
    |---------------------------|--------------------|
    | **Component Display Name**| Greetings          |
    | **Component Name**        | greetings          |
    | **Description**           | Send greetings     |

9. Click **Create**. This creates the component and lists it under **Component Listing** on the project home page.

You have successfully created the service. The next step is to build and deploy it.

## Step 2: Build and deploy

Now that you have connected the source repository and configured the endpoint details, it's time to build and deploy the greeter service.

### Step 2.1: Build

1. On the project home page, click on the `Greetings` component you created. This takes you to the component overview page.
2. In the left navigation menu, click **Build**.
3. On the **Build** page, click **Build Latest**.

    !!! note
        The build process may take some time. You can track progress in the **Build Details** pane. Once complete, the build status changes to **Success**.

### Step 2.2: Deploy

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take some time. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

Once you have successfully deployed the service, you can [test](../../testing/test-rest-endpoints-via-the-openapi-console.md), [manage](../../api-management/lifecycle-management.md), and [observe](../../monitoring-and-insights/observability-overview.md) it like any other component type in Choreo.


# Expose a Ballerina GraphQL Endpoint via a Service

Choreo offers the flexibility to develop and deploy applications in a language of your preference. This guide shows you how to deploy a service component that exposes a GraphQL API using the Ballerina language in Choreo. No prior knowledge of the Ballerina language is required to follow this guide. 

GraphQL API is a query language and runtime that provides a single endpoint for retrieving flexible and efficient data in a strongly-typed and self-documenting way. By following this guide, you will build a service component in Ballerina and deploy it on Choreo for any GraphQL client application to utilize it.

This guide shows how to build a simple reading list service and deploy it in Choreo using Ballerina. The GraphQL endpoint you create in this guide has two operations: **Query** and **Mutation**. The Query type operations read the data in the data source, and the Mutation operations update the data in the data source. The reading list service has two queries and three mutations as follows:

### Queries

**Retrieve the reading list**

This resource accepts an optional filter, `status`, which filters the reading list by reading status. Accepted values for status are `reading`, `read`, and `to_read`.

**Sample request**:
```
$ curl -X POST -H "Content-Type: application/json" -d '{"query": "query {allBooks (status: \"reading\") { id title author status }}"}' http://localhost:8090
```

**Sample response**
```
$ {
  "data": {
    "allBooks": [
      {
        "id": 1,
        "title": "Sample Book",
        "author": "Test Author",
        "status": "to_read"
      }
    ]
  }
}
```

**Retrieve a book item from the reading list**

This resource accepts a filter, `id`, which will select the book item from the reading list by book id.  The id is an Integer value. 

**Sample request**
```
$ curl -X POST -H "Content-Type: application/json" -d '{"query": "query {book (id: 1) { id title author status }}"}' http://localhost:8090
```

**Sample response**
```
$ {
  "data": {
    "book": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "to_read"
    }
  }
}
```

### Mutations

**Add a book item to the reading list**

This remote function accepts a book record as the input and consists of the title and the author. When you add a new book to the reading list, the method updates the reading status of the newly added book to `to_read`. This method returns the added book item upon successful execution.


**Sample request**

```
$ curl -X POST -H "Content-type: application/json" -d '{ "query": "mutation { addBook(book: {title: \"Sample Book\", author: \"Test Author\"}) { id title author status } }" }' 'http://localhost:8090'
```

**Sample response**

```
$ {
  "data": {
    "addBook": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "to_read"
    }
  }
}
```

**Update the reading status of a book**

This remote function requires `id` and `status` as inputs to update the reading status of the selected book. The `id` refers to the id of the book. It is an integer.  The `status` refers to the reading status that needs to be updated. This method returns the updated book item upon successful execution.

**Sample request**

```
$ curl -X POST -H "Content-type: application/json" -d '{ "query": "mutation { setStatus(id: 1, status: \"reading\") { id title author status } }" }' 'http://localhost:8090'
```

**Sample response**

```
$ {
  "data": {
    "setStatus": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "reading"
    }
  }
}
```

**Delete a book item from the reading list**

This remote function requires the `id` as the input to delete the book item from the reading list. This method returns the removed book item upon successful execution.

**Sample request**

```
$ curl -X POST -H "Content-type: application/json" -d '{ "query": "mutation { deleteBook(id: 1) { id title author status } }" }' 'http://localhost:8090'
```

**Sample response**
```
$ {
  "data": {
    "deleteBook": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "reading"
    }
  }
}
```

Our next step is to set up the resources that you will require to follow the guide, including the sample reading list application and the Choreo GitHub app.

## Prerequisites

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample GraphQL service](https://github.com/wso2/choreo-samples/tree/main/reading-list-graphql) implementation for this guide.

Let's get started!

## Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the reading list service.

!!! note
    The following file paths are relative to the path `<sample-repository-dir>/reading-list-graphql`.

|Filepath                 | Description                                                     |
|-------------------------|-----------------------------------------------------------------|
| `service.bal`           | The reading list service code written in the Ballerina language.|
| `Ballerina.toml`        | The Ballerina configuration file.                               |
| `.choreo/component.yaml`| The configuration file with endpoint details.                   |

## Step 1: Create a service component 

To create a Ballerina service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**| `reading-list-graphql`    |.

6. Select **Ballerina** as the buildpack.

7. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Ballerina Reading List`|
    | **Component Name**        | `ballerina-reading-list`|
    | **Description**           | Manage a reading list   |

8. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service component that exposes a GraphQL API written in the Ballerina language. Next, let's build and deploy the service.

## Step 2: Build and deploy

Now that we have connected the source repository, it's time to build and deploy the reading list service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Configurations** pane that opens, click **Next** to skip the configuration.
4. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.
To build and deploy the service, follow the steps below:

Once you have successfully deployed your service, you can test, manage, and observe it like any other component type in Choreo.

For detailed instructions, see the following sections:

- [Step 3: Test](https://wso2.com/choreo/docs/testing/test-graphql-endpoints-via-the-graphql-console/)
- [Step 4: Manage](https://wso2.com/choreo/docs/manage/api-management/)


# Expose a gRPC Endpoint via a Service

Choreo allows you to create and deploy applications in your preferred programming language. One powerful option is gRPC, a high-performance and language-agnostic remote procedure call (RPC) framework. It utilizes [Protocol Buffers](https://github.com/protocolbuffers/protobuf) to define services and generate client/server code.

In this guide, you will learn to use Choreo to create a service component that exposes a gRPC server implemented in [Go](https://go.dev/), enabling efficient and scalable communication with any gRPC client application. No prior knowledge of the Go language is necessary to follow this guide.

By following this guide, you will:

- Create a simple gRPC server using a Service component.
- Link the containerized gRPC service to the Choreo component using the Dockerfile. 
    The greeter service has a single RPC method named `sayHello`. Following is the proto file the server and the client application are using:

    ```proto
    syntax = "proto3";
    option go_package = "github.com/wso2/choreo-samples/go-grpc/pkg";

    service greeter {
      rpc SayHello (HelloRequest) returns (HelloReply) {}
    }

    message HelloRequest {
      string name = 1;
    }

    message HelloReply {
      string message = 1;
    }
    ```

- Deploy the gRPC server component in Choreo. 
- Create a gRPC client using a Manual Trigger component. 
- Deploy the gRPC client.
- Invoke the gRPC server using a gRPC client and check the response through the Choreo log view.


## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample service](https://github.com/wso2/choreo-samples/tree/main/go-grpc) implementation for this guide.

Let's get started!

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the greeter service.

!!! note 
    The following file paths are relative to the path `<sample-repository-dir>/go-grpc`.

|File Path                |Description                                                                                   |
|-------------------------|----------------------------------------------------------------------------------------------|
| `main.go`               | The greeter service code written in the Go language.                                         |
| `greeter_client/main.go`| The greeter client application written in the Go language.                                   |
| `Dockerfile.server`     | The Dockerfile to build the container image of the server application.                       |
| `Dockerfile.client`     | The Dockerfile to build the container image of the client application.                       |
| `.choreo/component.yaml`| The Choreo-specific configuration that provides information about how Choreo exposes the service.|
| `pkg/greeter.proto`     | The interface definition of the gRPC service. This is used to generate the server and client stubs for the Go application.|

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints.

Let's run the gRPC server service component on port 8080. To securely expose the service through Choreo, you must provide the port and other required information to Choreo. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

Choreo looks for an `component.yaml` file inside the `.choreo` directory to configure the endpoint details of the containerized component. Ensure the `.choreo` directory is at the root of the Docker build context path.

In the gRPC server sample, the `component.yaml` file is at `go-grpc/.choreo/component.yaml`, where the build context path is `go-grpc`.

## Step 1: Create a service component with a gRPC endpoint

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
6. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

7. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory** | `go-grpc`                  |

8. Select **Docker** as the buildpack.
9. Enter the following information:
    
    | **Field**                | **Value**                  |
    |--------------------------|----------------------------|
    | **Dockerfile**           | `go-grpc/Dockerfile.server`|

    !!! info
        1.  To successfully build your container with Choreo, it is essential to explicitly define a User ID (UID) under the USER instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-samples/blob/main/go-grpc/Dockerfile.server).
        To ensure that the defined USER instruction is valid, it must conform to the following conditions:
            - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
            - Usernames are considered invalid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

        2. The Dockerfile utilized in this guide is a multi-stage Dockerfile, which is designed to keep the final image size small and provides the ability to build the application with a specific version of tools and libraries.

4. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go gRPC Server`        |
    | **Component Name**        | `go-grpc-server`        |
    | **Description**           | Send greetings          |
    
10. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you have connected the source repository, and configured the endpoint details, it's time to build the service and create an image. Then you can deploy the image and test the greeter service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

    You can access the following scans under **Build**. 

      - **The Dockerfile scan**: Choreo performs a scan to check if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
      - **Container (Trivy) vulnerability scan**: This detects vulnerabilities in the final docker image. 
      - **Container (Trivy) vulnerability scan**: The details of the vulnerabilities open in a separate pane. If this scan detects critical vulnerabilities, the build will fail.
     
        !!! info
            If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Environment Configurations** pane that opens, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

6. Once you have successfully deployed your service, navigate to the component overview page and copy the gRPC service URL. You need to provide that URL when setting up the client application later in this guide.

You have successfully deployed the gRPC server. Currently, the gRPC service is only accessible by the components deployed within the same project.

## Step 3: Invoke the gRPC service

Let's invoke the gRPC service that you created above, using a gRPC client. 

### Step 3.1: Create a manual task for the gRPC client

To create a manual task component, follow these steps:

1. On the Choreo Console header, click the **Project** list and select the project where you created the gRPC service component. This opens the project home page.
2. Go to the **Component Listing** section and click **+ Create**.
3. Click the **Manual Task** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**       | `go/grpc`                  |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                  |
    |--------------------------|----------------------------|
    | **Dockerfile**           | `go/grpc/Dockerfile.client`|

8. Enter a display name, a unique name, and a description for the component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go gRPC Client`        |
    | **Component Name**        | `go-grpc-client`        |
    | **Description**           | `Receive greetings`     |


9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

### Step 3.2: Build the gRPC client component

To build the component, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 3.3: Setup environment variables and deploy the gRPC client

The client application, in this case, the gRPC client, requires the server URL of the gRPC server service. This is read from the client application as an environment variable. Follow the steps below to configure the environment variable for the client application:

1. On the Choreo Console left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane that opens, click **+ Add**.
4. Specify the following name and value to configure the environment variable for the client application:

    | **Field**       | **Value**               |
    |-----------------|-------------------------|
    | **Name**        | `GREETER_SERVICE`       |
    | **Value**       | Paste the URL value copied after deploying the gRPC service via [step 2.2](#step-22-deploy) above.  Make sure to **drop the `http://` or `grpc://` part and the trailing `/` from the URL when copying**. For example, if the URL is `http://go-grpc-server-3192360657:8080/`, add only `go-grpc-server-3192360657:8080`.|

5.  Click **Add** and then click **Next**.
6.  Click **Deploy**.

### Step 3.4: Execute the gRPC client component

To execute the gRPC client, follow these steps:

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the gRPC client and generates logs.
   You can trigger multiple runs to generate multiple logs.

For details on what you can monitor via the execute page, see [Monitor executions](../develop-integrations/develop-a-manual-task.md#step-7-monitor-executions). 


# Expose a Prism-Based Mock Server Using an OpenAPI Specification

Choreo supports deploying [Prism-based](https://docs.stoplight.io/docs/prism/674b27b261c3c-prism-overview) mock servers using OpenAPI specifications. With the Choreo Prism mock service component, you can serve multiple mock servers, each based on a different OpenAPI specification, as separate endpoints.

By default, these mock servers serve static content generated from the examples in the configured OpenAPI Specification (OAS). 

## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [Prism mock service](https://github.com/wso2/choreo-samples/tree/main/prism-mock-service) artifacts for this guide.

## Step 1: Create a Prism mock service component

To create a Prism mock service component, follow these steps:
    
1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, you can paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    |**Component Directory**  | `prism-mock-service`    |

6. Select **Prism Mock** as the buildpack.
7. Enter a display name, a unique name, and a description for the service component.
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

8. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

## Step 2: Build and deploy the component

Now that you have successfully created the Prism mock service, it's time to build and deploy it.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**. This builds the service from the latest commit.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

Once you have successfully deployed the service, you can [test](../../testing/test-rest-endpoints-via-the-openapi-console.md), [manage](../../api-management/lifecycle-management.md), and [observe](../../monitoring-and-insights/observability-overview.md) it like any other component type in Choreo.

## Serve dynamic content

The Prism mock service can serve dynamic content according to the schema definitions in the OpenAPI specification. To use the Prism mock service with dynamic content, clients must add the `prefer:dynamic=true` header in the request.

To generate meaningful dynamic responses, you can use the `x-faker` attribute in schema definitions of the OpenAPI specification. For more information on dynamically generated responses with the `x-faker` attribute, see the [Prism documentation](https://docs.stoplight.io/docs/prism/9528b5a8272c0-dynamic-response-generation-with-faker).


# Expose a TCP Server via a Service

Choreo offers the flexibility to design and deploy applications in the programming language of your choice. One viable choice for specific network communication needs is TCP (Transmission Control Protocol). TCP provides a reliable, stream-oriented communication mechanism that ensures data integrity and orderliness during transmission. It's the go-to option for scenarios where guaranteed data delivery and error recovery are paramount.

In this guide, you will learn to use Choreo to create a service component that exposes a TCP server implemented in [Go](https://go.dev/), enabling efficient and scalable communication with any TCP client application. No prior knowledge of the Go language is necessary to follow this guide.

By following this guide, you will:

- Setup a TCP server
    - Create a simple TCP server using a service component.
    - Link the containerized TCP service to the Choreo component using a Dockerfile. 
    - Deploy the TCP server component in Choreo. 
- Setup a TCP client
    - Create a TCP client using a manual task component. 
    - Link the containerized TCP client to the Choreo component using a Dockerfile. 
    - Deploy the TCP client component in Choreo.
- Invoke the TCP server using a TCP client and observe the response through the Choreo log view.

## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample service](https://github.com/wso2/choreo-samples/tree/main/docker-tcp-service) implementation for this guide.

Let's get started!

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the sample service.

!!! note 
    The following file paths are relative to the path `<sample-repository-dir>/docker-tcp-service`.

|File Path                 |Description                                                                                   |
|--------------------------|----------------------------------------------------------------------------------------------|
| `server/main.go`         | The greeter service code written in the Go language.                                         |
| `client/main.go`         | The greeter client application written in the Go language.                                   |
| `Dockerfile.server`      | The Dockerfile to build the container image of the server application.                       |
| `Dockerfile.client`      | The Dockerfile to build the container image of the client application.                       |
| `.choreo/component.yaml` | The Choreo-specific configuration provides information about how Choreo exposes the service. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints.

Let's run the TCP server service component on port 5050. To securely expose the service through Choreo, you must provide the port and other required information to Choreo. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

Choreo looks for an `component.yaml` file inside the `.choreo` directory to configure the endpoint details of a containerized component. Place the `.choreo` directory at the root of the Docker build context path.

In our TCP server sample, the `component.yaml` file is at `docker-tcp-service/.choreo/component.yaml`, where the build context path is `docker-tcp-service`.

## Step 1: Create a service component with a TCP endpoint

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory** | `docker-tcp-service`                  |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-tcp-service/Dockerfile.server`|

    !!! info
        1.  To successfully build your container with Choreo, it is essential to explicitly define a User ID (UID) under the USER instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-samples/blob/main/docker-tcp-service/Dockerfile.server).
        To ensure that the defined USER instruction is valid, it must conform to the following conditions:
            - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
            - Usernames are considered invalid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

        2. The Dockerfile utilized in this guide is a multi-stage Dockerfile, which is designed to keep the final image size small and provides the ability to build the application with a specific version of tools and libraries.

8. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go TCP Server`         |
    | **Component Name**        | `go-tcp-server`         |
    | **Description**           | Send greetings          |
    
9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you have connected the source repository, and configured the endpoint details, it's time to build the service and create an image. Then you can deploy the image and test the service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

    You can access the following scans under **Build**. 

      - **The Dockerfile scan**: Choreo performs a scan to check if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
      - **Container (Trivy) vulnerability scan**: This detects vulnerabilities in the final docker image. 
      - **Container (Trivy) vulnerability scan**: The details of the vulnerabilities open in a separate pane. If this scan detects critical vulnerabilities, the build will fail.
     
        !!! info
            If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Environment Configurations** pane that opens, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

6. Once you have successfully deployed your service, navigate to the component overview page and copy the TCP service address. You need to provide that address when setting up the client application later in this guide.

You have successfully deployed the TCP server. Currently, the TCP service is only accessible by the components deployed within the same project.

## Step 3: Invoke the TCP service

Now let's use a TCP client to invoke the TCP service that you created above. To do this, you can create a manual trigger component as the TCP client. This is the recommended approach because, in this example, it's more efficient to have a client that connects to the server, sends a request, and then stops. Here, a continuously executing task isn't required. Furthermore, if you use a manual trigger component, you won't need to expose an endpoint in the client for invocation, unlike with an API.

### Step 3.1: Create a manual trigger for the TCP client

To create a manual task component, follow these steps:

1. On the Choreo Console header, click the **Project** list and select the project where you created the TCP service component. This opens the project home page.
2. Go to the **Component Listing** section and click **+ Create**.
3. Click the **Manual Task** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Docker Context**      |`docker-tcp-service`     |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-tcp-service/Dockerfile.client`|

8. Enter a display name, a unique name, and a description for the component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**              |
    |---------------------------|------------------------|
    | **Component Display Name**| `Go TCP Client`        |
    | **Component Name**        | `go-tcp-client`        |
    | **Description**           | `Receive greetings`    |


9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

### Step 3.2: Build the TCP client component

To build the component, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 3.3: Setup environment variables and deploy the TCP client

The client application, in this case, the TCP client, requires the server URL of the TCP server service. This is read from the client application as an environment variable. Follow the steps below to configure the environment variable for the client application:

1. On the Choreo Console left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane that opens, click **+ Add**.
4. Specify the following name and value to configure the environment variable for the client application:

    | **Field**       | **Value**               |
    |-----------------|-------------------------|
    | **Name**        | `SERVER_ADDRESS`       |
    | **Value**       | Paste the URL value copied after deploying the TCP service via [step 2.2](#step-22-deploy) above.  Make sure to **drop the `tcp://` part and the trailing `/` from the URL when copying**. For example, add only `go-tcp-server-1097922445:8080`.|

5.  Click **Add** and then click **Next**.
6.  Click **Deploy**.

### Step 3.4: Execute the TCP client component

To execute the TCP client, follow these steps:

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the TCP client and generates logs.
   You can trigger multiple runs to generate multiple logs.

For details on what you can monitor via the execute page, see [Monitor executions](../develop-integrations/develop-a-manual-task.md#step-7-monitor-executions).


# Expose a UDP Server via a Service

Choreo offers the flexibility to design and deploy applications in the programming language of your choice. One compelling choice for certain network communication needs is UDP (User Datagram Protocol). UDP is a high-speed, connectionless protocol ideal for scenarios where lightweight, real-time data transmission is essential.

In this guide, you will learn to use Choreo to create a Service component that exposes a UDP server implemented in [Go](https://go.dev/), enabling efficient and scalable communication with any UDP client application. No prior knowledge of the Go language is necessary to follow this guide.

By following this guide, you will:

- Setup a UDP server
    - Create a simple UDP server using a Service component.
    - Link the containerized UDP service to the Choreo component using the Dockerfile. 
    - Deploy the UDP server component in Choreo. 
- Setup a UDP client
    - Create a UDP client using a manual task component. 
    - Link the containerized UDP client to the Choreo component using the Dockerfile. 
    - Deploy the UDP client component in Choreo.
- Invoke the UDP server using a UDP client and check the response through the Choreo log view.

## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample service](https://github.com/wso2/choreo-samples/tree/main/docker-udp-service) implementation for this guide.

Let's get started!

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the sample service.

!!! note 
    The following file paths are relative to the path `<sample-repository-dir>/docker-udp-service`.

|File Path                |Description                                                                                   |
|-------------------------|----------------------------------------------------------------------------------------------|
| `server/main.go`        | The greeter service code written in the Go language.                                         |
| `client/main.go`        | The greeter client application written in the Go language.                                   |
| `Dockerfile.server`     | The Dockerfile to build the container image of the server application.                       |
| `Dockerfile.client`     | The Dockerfile to build the container image of the client application.                       |
| `.choreo/component.yaml`| The Choreo-specific configuration provides information about how Choreo exposes the service. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints.

Let's run the UDP server service component on port 5050. To securely expose the service through Choreo, you must provide the port and other required information to Choreo. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

Choreo looks for an `component.yaml` file inside the `.choreo` directory to configure the endpoint details of a containerized component. Place the `.choreo` directory at the root of the Docker build context path.

In our gRPC server sample, the `component.yaml` file is at `docker-udp-service/.choreo/component.yaml`, where the build context path is `docker-udp-service`.

## Step 1: Create a service component with a UDP endpoint

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
6. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

7. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**   | `docker-udp-service`    |    

8. Select **Docker** as the buildpack.
9. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-udp-service/Dockerfile.server`|

    !!! info
        1.  To successfully build your container with Choreo, it is essential to explicitly define a User ID (UID) under the USER instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-samples/blob/main/docker-udp-service/Dockerfile.server).
        To ensure that the defined USER instruction is valid, it must conform to the following conditions:
            - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
            - Usernames are considered invalid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

        2. The Dockerfile utilized in this guide is a multi-stage Dockerfile, which is designed to keep the final image size small and provides the ability to build the application with a specific version of tools and libraries.

4. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go UDP Server`         |
    | **Component Name**        | `go-udp-server`         |
    | **Description**           | Send greetings          |

10. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you have connected the source repository, and configured the endpoint details, it's time to build the service and create an image. Then you can deploy the image and test the service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

    You can access the following scans under **Build**. 

      - **The Dockerfile scan**: Choreo performs a scan to check if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
      - **Container (Trivy) vulnerability scan**: This detects vulnerabilities in the final docker image. 
      - **Container (Trivy) vulnerability scan**: The details of the vulnerabilities open in a separate pane. If this scan detects critical vulnerabilities, the build will fail.
     
        !!! info
            If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Environment Configurations** pane that opens, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

6. Once you have successfully deployed your service, navigate to the component overview page and copy the UDP service address. You must provide that address when setting up the client application later in this guide.

You have successfully deployed the UDP server. Currently, the UDP service is only accessible by the components deployed within the same project.

## Step 3: Invoke the UDP service

Now let's use a UDP client to invoke the UDP service that you created above. To do this, you can create a manual trigger component as the UDP client. This is the recommended approach because, in this example, it's more efficient to have a client that connects to the server, sends a request, and then stops. Here, a continuously executing task isn't required. Furthermore, if you use a manual trigger component, you won't need to expose an endpoint in the client for invocation, unlike with an API.

### Step 3.1: Create a manual trigger for the UDP client

To create a manual task component, follow these steps:

1. On the Choreo Console header, click the **Project** list and select the project where you created the UDP service component. This opens the project home page.
2. Go to the **Component Listing** section and click **+ Create**.
3. Click the **Manual Task** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory** | `docker-udp-service`    |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-udp-service/Dockerfile.client`|

8. Enter a display name, a unique name, and a description for the component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**              |
    |---------------------------|------------------------|
    | **Component Display Name**| `Go UDP Client`        |
    | **Component Name**        | `go-udp-client`        |
    | **Description**           | `Receive greetings`    |


9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

### Step 3.2: Build the UDP client component

To build the component, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 3.3: Setup environment variables and deploy the UDP client

The client application, in this case, the UDP client, requires the server URL of the UDP server service. This is read from the client application as an environment variable. Follow the steps below to configure the environment variable for the client application:

1. On the Choreo Console left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane that opens, click **+ Add**.
4. Specify the following name and value to configure the environment variable for the client application:

    | **Field**       | **Value**               |
    |-----------------|-------------------------|
    | **Name**        | `SERVER_ADDRESS`       |
    | **Value**       | Paste the URL value copied after deploying the UDP service via [step 2.2](#step-22-deploy) above.  Make sure to **drop the `udp://` part and the trailing `/` from the URL when copying**. For example, add only `go-udp-server-1097922445:8080`.|

5.  Click **Add** and then click **Next**.
6.  Click **Deploy**.

### Step 3.4: Execute the UDP client component

To execute the UDP client, follow these steps:

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the UDP client and generates logs.
   You can trigger multiple runs to generate multiple logs.

For details on what you can monitor via the execute page, see [Monitor executions](../develop-integrations/develop-a-manual-task.md#step-7-monitor-executions).


# Expose a WebSocket Endpoint via a Service

Choreo allows you to create and deploy applications in your preferred programming language, offering a seamless platform for building dynamic and scalable solutions. This guide walks you through the steps to deploy a WebSocket service using the NodeJS buildpack.

WebSockets provide real-time, two-way communication between a client and server over a persistent TCP connection. This makes WebSocket APIs ideal for applications that require real-time updates.

In this guide, you will:

- Build a simple WebSocket service using a sample implementation in NodeJS.
- Deploy the service in Choreo, allowing any WebSocket client application to establish a connection and exchange real-time messages with your service.

## Prerequisites

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample WebSocket service](https://github.com/wso2/choreo-samples/tree/main/websocket-chat-app) implementation for this guide.

Let's get started!

## Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the NodeJS chat Application.

!!! note
    The following file paths are relative to the path `<sample-repository-dir>/websocket-chat-app/websocket-chat-service-nodejs`.

|Filepath                        | Description                                                     |
|--------------------------------|-----------------------------------------------------------------|
| `server.js`                    | The NodeJS chat service.                                        |
| `.choreo/component.yaml`       | The configuration file with endpoint details.                   |

!!! note
    Choreo currently supports defining WebSocket APIs using the AsyncAPI 2.0 specification.

## Step 1: Create a service component 

To create a NodeJS service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**   | `websocket-chat-app/websocket-chat-service-nodejs`  |

6. Select **NodeJS** as the buildpack and **18.x.x** as the Language Version

8. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:

    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `NodeJS Chat Service`   |
    | **Component Name**        | `nodejs-chat-service`   |
    | **Description**           | Manage a chat service   |

9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service component that provides a WebSocket API built with NodeJS. The next step is to proceed with building and deploying the service.

## Step 2: Build and deploy

Now that you have connected the source repository, it's time to build and deploy the chat service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane that opens, click **Next** to skip the configuration.
4. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

Once you have successfully deployed your service, you can [test](../../testing/test-websocket-endpoints-via-the-websocket-console.md), [manage](../../api-management/lifecycle-management.md), and observe it like any other component type in Choreo.

During testing, once the WebSocket connection is established, you can send {"type": "Connect", "username": "user1"} to the WebSocket endpoint to connect to the chat service. You can then send chat messages by using {"type": "Data", "message": "Hello, World!"}.

!!! note
     Some clients, such as certain browsers, may not support adding headers to the WebSocket handshake. In these cases, you can include the access token or test key required for WebSocket API invocation within the `sec-websocket-protocol` header, along with any specified subprotocols.

     For example: `sec-websocket-protocol: choreo-oauth2-token, {access token}, subprotocols`

     If you are using a test key, replace `choreo-oauth2-token` with `choreo-test-key`.


# Service Component Overview

Explore how to create, deploy, manage, and observe service components in Choreo.

## What is a service component?

A service component in Choreo lets you deploy and expose REST, GraphQL, gRPC, UDP, WS or TCP services. It is a fundamental building block for creating cloud-native applications in Choreo. They provide a simple and effective way to expose functionality as a service to other components within Choreo or to the outside world.

Service components encapsulate business logic and provide standardized interfaces, called endpoints, for communicating with other components or systems. You can deploy and scale services independently, which makes them highly flexible and adaptable to changing workloads.

With the help of the service component, developers can quickly create APIs and microservices, making it easier to implement and manage complex software systems. Service components can also be integrated with other Choreo components, that acts as message processors, connectors, and data sources, etc to create powerful end-to-end solutions.

You can expose a service to other components through endpoints. For details on configuring endpoints, see [Configure Endpoints](../configure-endpoints.md).


# Build and Deploy a Single-Page Web Application

A web application is an application program hosted on a server and serves ingress traffic through a browser. In Choreo, you can deploy a web application by creating a Web Application component and connecting it to a Git repository that contains the implementation of the web application. Web applications can fall into one of the following categories:

- **Single page applications (SPAs)**: Examples include React, Angular, Vue, Svelte, etc.
- **Web servers**: These serve static content or provide server-side rendering/static site generation (SSR/SSG).
- **Static content**: Examples include websites and other static resources that do not require a backend, usually comprising static HTML/JS/CSS files.

## Prerequisites

- To deploy a web application component, you must have a GitHub account with a repository containing the web application's implementation. For this guide, fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample web application implementation.

## Create a web application

You can create a web application in Choreo as follows:

### Build and deploy a SPA from source code

1. To create a web application component, connect a repository that includes the web application source code.
2. Select the relevant buildpack: Default buildpacks include **React**, **Angular**, and **Vue.js**. If you are using a different SPA framework, you can try one of these buildpacks because the configurations can be overridden to support most JavaScript-based SPAs.
3. Enter the build command: Based on your package manager (NPM, yarn, or pnpm). The relevant package manager is run based on the dependency lock file in your repository (defaults to NPM if no lock file is present).
4. Specify the build output directory.
5. Specify the NodeJS version: Choreo does not pick the Node.js version from the `package.json` engine property. The required Node version must be explicitly set in the build configuration.

Once you create the Web Application component, Choreo automatically generates a build pipeline for your single-page application and deploys it.

### Bring your Dockerfile

1. To create a web application component, connect a repository that contains the Dockerfile for your containerized web application.
2. Commit a Dockerfile to your connected Git repository to have full control over your build process.

This approach is recommended if you are deploying a web server and not just a single-page application (or a single-page application with a complex build process).

### Host static websites

1. Create a web application component and connect it to the GitHub repository that contains the required static assets.
2. Select the **Static Websites** buildpack: This buildpack does not trigger a build process. It only fetches the files from the path specified in the repository and serves them as-is.

## Build and deploy a SPA from source code

Follow the steps below to create a sample Web Application component and deploy it in Choreo:

1. Sign in to the Choreo Console at [https://console.choreo.dev/login/](https://console.choreo.dev/login/). This opens the **Project Home** page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Web Application** card.
6. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

7. Enter the following information:

    | **Field**                 | **Description**        |
    |---------------------------|------------------------|
    | **GitHub Account**        | Your account           |
    | **GitHub Repository**     | choreo-samples         |
    | **Branch**                | main                   |
    | **Component Directory**     | /react-single-page-app |

8. Select **React** as the **Buildpack**.
9. Enter the following information:

    | **Field**                 | **Description**        |
    |---------------------------|------------------------|
    | **Build Command**         | `npm run build`        |
    | **Build Path**            | `build`                |
    | **Node Version**          | `18`                   |

    !!! tip
        Managed authentication is enabled by default when you create a web application using **React**, **Angular**, or **Vue.js** buildpacks. To learn how to set up authentication for your web application with Choreo's managed authentication, see [Secure Web Applications with Managed Authentication](../../authentication-and-authorization/secure-web-applications-with-managed-authentication.md).

4. Specify a display name, a unique name and description for the component.
10. Click **Create**. Choreo initializes the component with the sample implementation and opens the **Overview** page of the component.

You have successfully created a Web Application component from the source code. Now let's build and deploy the web application.

## Build your web application

1. In the left navigation menu, click **Build**.
2. In the **Builds** pane, click **Build**. This opens the **Commits** pane, where you can see all the commits related to the component.
3. Select the latest commit and click **Build**. This triggers the build process and displays the progress in the **Build Logs** pane.

    You can access the following scans in the **Build Logs** pane:

    - **Dockerfile Scan**: Choreo checks if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
    - **Container (Trivy) Vulnerability Scan**: Detects vulnerabilities in the final Docker image. If critical vulnerabilities are detected, the build will fail.

    !!! info
        If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

    !!! note
        The build process may take some time. Once complete, the build status will be listed in the **Builds** pane. Here, you will see the build status as **Success**.

## Deploy and access your web application

1. In the left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure and Deploy**. This opens the **Configure & Deploy** pane. In this guide, you do not need to add a file mount.
3. Click **Next** to proceed to the **Authentication Settings** pane.
4. Keep the default settings and click **Deploy**.

    !!! note
        The deployment process may take a few minutes. Once complete, the **Deployment Status** will show as **Active** in the **Development** card.

5. To verify that the web application is hosted successfully, click the **Web App URL** in the **Development** card. This takes you to the web application.

## Create a short URL for your web application in production

!!! info
    This feature is only available on the Choreo cloud data plane.

When you promote your component to the Production environment, you can create a personalized short URL for your web application. The URL follows the `https://{your-short-prefix}.choreoapps.dev` structure, where you can select a name of your preference for `{your-short-prefix}`.

1. Click **Promote** in the **Development** card and promote your web application to production.
2. In the **Production** card, click **Create a short URL**.
3. Specify a **Short URL prefix** of your choice and click **Save**.

    !!! note
        Short URL names/prefixes are subject to availability, provided on a first-come-first-serve basis.

## Manage runtime configurations for web applications

For web applications with a backend server, Choreo allows you to mount runtime configurations and secrets as environment variables and/or file mounts for a specific environment. Alternatively, you can also inject them into the client application during server-side rendering or when serving static content.

For SPAs that run completely on the browser, Choreo does not support *baking-in* environment variables or other configurations. Instead, Choreo recommends the following approach (applicable to most SPA frameworks, including React):

!!! note
    - With SPAs, anything you mount as a runtime config will be available to your users in the browser.
    - **Do not include sensitive secrets that are not browser-safe**.

1. Go to your forked [Choreo samples repository](https://github.com/wso2/choreo-samples).
2. Open the `public` directory.
3. Create and commit a new file named `config.js` in the `public` directory of your React application. This file should contain the runtime configuration variables you want to expose to your application, such as API endpoints or feature flags. For example:

    ```javascript
    window.config = {
        apiUrl: 'https://api.example.com',
        featureFlags: {
            enableNewFeature: true,
            enableExperimentalFeature: false,
        },
    };
    ```

4. In your `index.html` file inside the `public` directory, add a script tag to include the `config.js` file inside the `<body>` tag:

    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>My React App</title>
    </head>
    <body>
        <div id="root"></div>
        <script src="%PUBLIC_URL%/config.js"></script>
    </body>
    </html>
    ```

5. In your React component, access the configuration variables by referencing the `window.config` object:

    ```javascript
    import React from 'react';

    function MyComponent() {
        const apiUrl = window.config.apiUrl;
        const enableNewFeature = window.config.featureFlags.enableNewFeature;
        const enableExperimentalFeature = window.config.featureFlags.enableExperimentalFeature;

        // ...
    }
    ```

6. When you deploy your component to Choreo, create a config file mount in the specified path for each environment (where your `index.html` expects the `config.js` file). For more details, see [Manage Configurations and Secrets](https://wso2.com/choreo/docs/devops-and-ci-cd/manage-configurations-and-secrets/#apply-a-file-mount-to-your-container).

## Limitations

The following limitations are specific to the Choreo cloud data plane:

- **Request size limit**: 256KB (including headers, cookies, and payloads).
- **Response body size limit**: 20MB.
- **Open ports**: Only one open port is permitted per web application. While you can have multiple ports open for project-level communication within a data plane, incoming traffic from the internet can only be directed to one port. This differs from Service-type components, which support multiple endpoints.

## Troubleshoot a web application

- **Blank page or 502 error after deployment**:
    If you encounter a blank page or a 502 error after deploying your web application, it typically indicates that the wrong directory is being served. To resolve this issue:
    1. Double-check the build output directory, especially if you are using a Dockerfile-less buildpack.
    2. Ensure that the specified output directory matches the actual output directory generated during the build process. For example, if you have erroneously entered `public/` as the output directory when it should have been `build/`.

By verifying and correcting the output directory alignment, you should be able to address the issue of encountering a blank page or experiencing a 502 error on deploying your web application.


# Develop Web Applications Locally with Choreo’s Managed Authentication

Choreo’s managed authentication capability provides a set of backend for frontend (BFF) endpoints to facilitate authentication and authorization for web applications. These endpoints are readily available for single-page web applications deployed on Choreo.

As a web application developer, you may need to run the application on your local workstation. Choreo’s local development capability ensures that authentication and authorization during local development work the same way as they do when the application is deployed to Choreo, eliminating the need for code changes.

This guide explains how to configure and use Choreo’s local development capability to streamline your workflow.

## How local development works in Choreo

Local development uses a proxy that sits in front of the locally running web application. This proxy intercepts all incoming requests:
- Requests to `/choreo-apis/*` and `/auth/*` are forwarded to Choreo.
- All other requests are forwarded to the locally running web application.

The proxy runs on HTTPS using a self-signed certificate, which is essential for secure, HTTP-only cookie-based managed authentication. Once the proxy is running, you can access the web application using the proxy's URL and start developing locally. The behavior of the web application, in terms of managed authentication, will mirror its behavior when deployed to Choreo.

## Configure local development

### Prerequisites

- Create a single-page application (SPA) with managed authentication enabled. For details, see [Secure Web Applications with Managed Authentication](../../authentication-and-authorization/secure-web-applications-with-managed-authentication.md#step-1-set-up-managed-authentication-for-your-web-application).
- Promote and deploy the application to the environment where you want to enable local development.

    !!! note
        - The locally running web application will use the same managed authentication configuration as the environment where local development is configured.
        - Local development is only allowed in non-critical environments.

### Apply configurations

1. Sign in to the Choreo Console.
2. In the **Component Listing** pane, click on the component you created and deployed.
3. In the left navigation menu, click **Deploy**.
4. Go to the respective environment card and click **Local Development**.
5. In the **Local Development** pane, toggle **Local Development** to enable it.
6. (Optional) To update the port on which the local development proxy server runs, expand **Advanced Configurations** and specify a value for **Proxy Port**.
7. Click **Apply**.

You have now configured local development. The next section explains how to access your web application for local development.

## Access your web application locally

### Prerequisites

- Ensure local development is enabled in the desired environment.
- Ensure your web application is running locally on `http://localhost` on a specific port.

### Access your web application locally

You can use either the Choreo built-in identity provider or an external identity provider to access your web application locally.

=== "Use the Choreo built-in identity provider"

    1. Sign in to the Choreo Console.
    2. In the **Component Listing** pane, click on the component you created and deployed.
    3. In the left navigation menu, click **Deploy**.
    4. Go to the respective environment card and click **Local Development**.
    5. In the **Local Development** pane, copy the command under **Step 1**.
    6. Paste the command in a terminal, replace `[APP_PORT]` with the port on which your application is running locally, and run the command.
    7. To access the application, go to the URL provided under **Step 2** in the **Local Development** pane.

        !!! note
            The local development proxy runs on HTTPS using a self-signed certificate. Your browser may warn that the certificate is not valid. Accept the risk and proceed.

=== "Use an external identity provider"

    1. Sign in to the Choreo Console.
    2. In the **Component Listing** pane, click on the component you created and deployed.
    3. In the left navigation menu, click **Deploy**.
    4. Go to the respective environment card and click **Local Development**.
    5. In the **Local Development** pane, copy the redirect URLs under **Step 1**.
    6. Go to the settings in the OAuth application in your identity provider and specify the copied URLs as allowed redirect URLs.
    7. In the **Local Development** pane, copy the command under **Step 2**.
    8. Paste the command in a terminal, replace `[APP_PORT]` with the port on which your application is running locally, and run the command.
    9. To access the application, go to the URL provided under **Step 3** in the **Local Development** pane.

        !!! note
            The local development proxy runs on HTTPS using a self-signed certificate. Your browser may warn that the certificate is not valid. Accept the risk and proceed.


# Create a Connection

Connections in Choreo provide a simple and uniform approach to seamlessly integrate components with services or resources.

Choreo allows you to create connections to services deployed in Choreo or registered as external services. It also allows you to create connections to any Choreo-managed database.

To create a connection to a service or a database, follow the step-by-step instructions in the respective tab:

=== "Create a connection to a service"

    <h2>Create a connection to a Choreo service</h2>

    Follow these steps to create a connection to a service deployed in Choreo:

    1. In the Choreo Console, go to the top navigation menu and set the visibility level as [project](../../choreo-concepts/connections.md#project-connections) or [component](../../choreo-concepts/connections.md#component-connections) as follows: 

        - **Project Connection**: Select an organization and a project in that organization. 
        - **Component Connection**: Select an organization, a project in that organization, and a component in the selected project. 

    2. In the left navigation menu, click **Dependencies**  and then **Connections**. This page lists all the existing connections.
    3. Click **+Create**. This opens the Marketplace view where you can browse and search for services or databases.
    4. Click the **Services** tab. You can search and apply filters to efficiently find a service.
    5. Click on the service you want to connect to. 
    6. Enter a name and a description for the connection.
    7. Select an **Access Mode** and **Authentication Scheme** for the connection.
    8. Click **Create**.
   
    This creates the connection and displays its details for each environment, along with an inline guide on how to use the connection in your component. 

    !!! note
        During connection creation, secret values for the lowest environment are visible, allowing you to copy them for local use if necessary. Secret values for higher environments remain hidden to ensure security
     
    <h2>Create a connection to an external service</h2>

    Follow these steps to create a connection to an external service:

    1. Follow steps 1–5 from the previous section.
    2. Expand the **Environment to Endpoint** section and verify the service endpoints assigned to the Choreo environments.
    3. Click **Create**.

      For step-by-step instructions on using a connection in your service, see [Use a Connection in Your Service](./use-a-connection-in-your-service.md).

      For step-by-step instructions on using a connection in your web application, see [Use a Connection in Your Web Application](./use-a-connection-in-your-web-application.md).


=== "Create a connection to a database"

    Prerequisites:

     - Create a Choreo-managed database. For details, see [Choreo-Managed Databases and Caches](../../manage-databases-and-caches/choreo-managed-databases-and-caches.md).
     - Add the database to the Marketplace. For details, see [Add Choreo-Managed Databases and Caches to the Marketplace](../../manage-databases-and-caches/add-choreo-managed-databases-and-caches-to-the-marketplace.md).

    Follow these steps to create a connection to a Choreo-managed database:

    1. In the Choreo Console, go to the top navigation menu and set the visibility level as [project](../../choreo-concepts/connections.md#project-connections) or [component](../../choreo-concepts/connections.md#component-connections) as follows: 

        - **Project Connection**: Select an organization and a project in that organization. 
        - **Component Connection**: Select an organization, a project in that organization, and a component in the selected project. 

    2. In the left navigation menu, click **Dependencies**  and then **Connections**. This page lists all the existing connections.
    3. Click **+Create**. This opens the Marketplace view where you can browse and search for services or databases.
    4. Click the **Databases** tab. You can search and apply filters to efficiently find a database.
    5. Click on the database you want to connect to. 
    6. To create the connection, follow these steps:

        1. Enter a name and description.
        2. Under **Environment Configuration**, select credentials for each environment.

            !!! note
                 By default, the selected database is applied to all environments. To use different databases for specific environments, select the appropriate database and provide the corresponding credentials for each environment.

        3. Click **Create**.  
    
    This creates the connection and displays the database connection details for each environment, along with an inline guide on how to use the connection in your component. 

    !!! note
        During connection creation, secret values for the lowest environment are visible, allowing you to copy them for local use if necessary. Secret values for higher environments remain hidden to ensure security
    
    For step-by-step instructions on using a database in your component, see [Use a Database Connection in Your Component](./use-a-database-connection-in-your-component.md).


# Use a Connection in Your Service

Choreo allows you to share and reuse your services, accelerating development and enhancing efficiency in building integrated applications through connections.

For step-by-step on instruction on creating a connection, see [Create a Connection](create-a-connection.md).

To learn more about Choreo Connections, see the documentation on [Connections](../../choreo-concepts/connections.md).

## Consume a service through a connection

You can consume a Choreo-deployed service within another service. Consuming connections from within Choreo services is seamless and straightforward. Follow the steps below to consume a Choreo service:

### Step 1: Add connection configurations

To integrate another service into your application, click the appropriate tab below based on your current configuration file and follow the step-by-step instructions:

=== "Component.yaml file (v1.1)"

    1. Copy and paste the snippet from the in-line developer guide into the `component.yaml` file.

        The following is a sample snippet: 

        ``` yaml

        dependencies:
            connectionReferences:
            - name: <CONNECTION_NAME>
              resourceRef: <RESOURCE_IDENTIFIER>

        ```

          | Field            | Description                                                         |
          |------------------|---------------------------------------------------------------------|
          | name             | The name given to the connection.                                   |
          | resourceRef      | A unique, readable identifier of the service being connected to.    |


    2. If you've previously added a `connectionReferences` section under `dependencies`, append this as another item under `connectionReferences`. Upon deploying the component, Choreo automatically creates a subscription if applicable and the necessary configurations to establish the connection will be injected into the Choreo-defined environment variables.
      
          The following table details the Choreo-defined environment variables:

          | Configuration Key       | Choreo-Defined Environment Variable Name                       |
          |-------------------------|----------------------------------------------------------------|
          | ServiceURL              | CHOREO_<CONNECTION_NAME\>_SERVICEURL                           |
          | ConsumerKey             | CHOREO_<CONNECTION_NAME\>_CONSUMERKEY                          |
          | ConsumerSecret          | CHOREO_<CONNECTION_NAME\>_CONSUMERSECRET                       |
          | TokenURL                | CHOREO_<CONNECTION_NAME\>_TOKENURL                             |
          | ChoreoAPIKey            | CHOREO_<CONNECTION_NAME\>CHOREOAPIKEY                          |


          If you want to use custom environment variable names instead of the Choreo-defined ones, you must define the environment configurations under the `configuration` section in the same file.
          The following is a sample snippet: 

          ``` yaml
          configuration:
            env:
              - name: HR_SERVICE_URL
                valueFrom:
                  connectionRef:
                    name: hr-connection
                    key: ServiceURL
          ```

          The following table provides details on the configuration keys associated with the connection. These keys can be referenced as `env[i].valueFrom.connectionRef.key`.

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | ServiceURL     | string     | Service URL of the Choreo service     | false         | false        |
          | ConsumerKey    | string     | Consumer key of the Choreo service    | false         | false        |
          | ConsumerSecret | string     | Consumer secret of the Choreo service | false         | true         |
          | TokenURL       | string     | Token URL of the STS                  | false         | false        |
          | ChoreoAPIKey   | string     | API key of the Choreo service         | false         | true         |

          For more details, see the instructions under the **component.yaml file (v1.1)** tab.

    ### Step 2: Read configurations within the application

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const serviceURL = process.env.CHOREO_<CONNECTION_NAME>_SERVICEURL;
    ```

=== "Component.yaml file (v1.0)"

    !!! note
        This `component.yaml v1.0` is a legacy configuration format. For new projects, we recommend using the latest version (v1.1) of `component.yaml` for improved usability and features.
  
    1. Copy and paste the snippet from the in-line developer guide into the `component.yaml` file.
      
        The following is a sample snippet:

        ``` yaml

        dependencies:
            serviceReferences:
            - name: <SERVICE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: ServiceURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerSecret
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: TokenURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ChoreoAPIKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>

        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the service you are connecting to.              |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added a service reference section under `dependencies`, append this as another item under `serviceReferences`. 

          Upon deploying the component, Choreo automatically creates a subscription if applicable and populates the specified environment variables with actual values.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | ServiceURL     | string     | Service URL of the Choreo service     | false         | false        |
          | ConsumerKey    | string     | Consumer key of the Choreo service    | false         | false        |
          | ConsumerSecret | string     | Consumer secret of the Choreo service | false         | true         |
          | TokenURL       | string     | Token URL of the STS                  | false         | false        |
          | ChoreoAPIKey   | string     | API key of the Choreo service         | false         | true         |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const serviceURL = process.env.SVC_URL;
    ```

=== "Component-config.yaml file"

    !!! note
        This `component-config.yaml` is a legacy configuration format. For new projects, we recommend using the latest version (v1.1) of `component.yaml` for improved usability and features.

    1. Copy and paste the snippet from the in-line developer guide into the `component-config` file under the `spec` section.

        The following is a sample snippet:

        ``` yaml

        outbound:
            serviceReferences:
            - name: <SERVICE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: ServiceURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerSecret
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: TokenURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ChoreoAPIKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>

        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the service you are connecting to.              |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added an outbound service reference, append this as another item under `serviceReferences`. 

          Upon deploying the component, Choreo automatically creates a subscription if applicable and populates the specified environment variables with actual values.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | ServiceURL     | string     | Service URL of the Choreo service     | false         | false        |
          | ConsumerKey    | string     | Consumer key of the Choreo service    | false         | false        |
          | ConsumerSecret | string     | Consumer secret of the Choreo service | false         | true         |
          | TokenURL       | string     | Token URL of the STS                  | false         | false        |
          | ChoreoAPIKey   | string     | API key of the Choreo service         | false         | true         |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const serviceURL = process.env.SVC_URL;
    ```

If you're using the API key security scheme for the connection, skip Step 3 and follow the instructions in [Step 4: API key security scheme](#step-4-invoke-the-service) tab.

### Step 3: Acquire an OAuth 2.0 access token

To consume a Choreo service with the visibility level set to organization or public and secured by the OAuth 2.0 security scheme, you must obtain an OAuth 2.0 token from the token endpoint. Subsequently, you can use the token to invoke the service.

- For languages with OAuth 2.0-aware HTTP clients, you must pass the OAuth 2.0-related configurations such as client id, client secret and so on, obtained when creating the connection to your HTTP client configuration. The HTTP client autonomously manages token retrieval and refreshing.

- For languages without OAuth 2.0-aware HTTP clients, you must manually initiate a call to the token endpoint. This includes fetching the token and managing token expiration and refresh directly within your application code. The following is a sample curl command to obtain a token:


    ```bash
    CONSUMER_KEY="your_consumer_key"
    CONSUMER_SECRET="your_consumer_secret"
    TOKEN_URL="your_token_url"

    # Encode client credentials as Base64
    CLIENT_CREDENTIALS=$(echo -n "$CLIENT_ID:$CLIENT_SECRET" | base64)

    curl -X POST $TOKEN_URL \
      -H "Content-Type: application/x-www-form-urlencoded" \
      -H "Authorization: Basic $CLIENT_CREDENTIALS" \
      --data-urlencode "grant_type=client_credentials"

    ```

### Step 4: Invoke the service

Click the tab that matches the security scheme of your service and follow the instructions below:

=== "API key security scheme"

     To invoke the API, use the `choreo-api-key` header with the API key value retrieved from the corresponding environment variable as described in [step 2](#step-2-read-configurations-within-the-application).

     The following is a sample code snippet in NodeJS:

     ``` java
       const response = await axios.get(serviceURL/{RESOURCE_PATH}, {
           headers: {
             'Choreo-API-Key': `${choreoApiKey}`
           }
       });
     ```

=== "OAuth 2.0 security scheme"

     To invoke the service, use the following instructions based on your programming language:

      - For languages with OAuth 2.0-aware HTTP clients, use the service URL resolved in [Step 2](#step-2-read-configurations-within-the-application). The OAuth-aware client manages authentication automatically. For sample requests and responses, see the API definition provided via the Choreo marketplace for the service.

      - For languages without OAuth 2.0-aware HTTP clients, use the token obtained in [step 3](#step-3-acquire-an-oauth-20-access-token) to make calls to the dependent service. Subsequently, add the obtained token to the HTTP authorization header with the bearer prefix. As the service URL, use the URL resolved in [step 2](#step-2-read-configurations-within-the-application). For sample requests and responses, see the API definition of the service provided via the Choreo marketplace.

       The following is a sample code snippet in NodeJS:

       ``` java
       const response = await axios.get(serviceURL/{RESOURCE_PATH}, {
           headers: {
             'Authorization': `Bearer ${accessToken}`
             'Choreo-API-Key': `${choreoApiKey}`
           }
       });
       ```

    !!! note
        If you want to consume a Choreo service at the project visibility level, you don't need to obtain a token. You can directly invoke the service using the resolved URL.


# Use a Connection in Your Web Application

Choreo simplifies the process of integrating services into your web application. The approach to connect to a service can vary based on your web application. 

To connect to a selected service, follow the step-by-step instructions given below depending on the authentication mechanism used in your web application.

=== "Managed authentication"
    
    Choreo-managed authentication allows you to seamlessly handle authentication for your web application. You can configure your web application to work with the built-in identity provider of Choreo or any external identity provider that supports OIDC/OAuth2.0

    !!! note 
         Choreo's managed authentication is currently available only for web applications created with **React**, **Angular**, or **Vue.js** buildpacks.

    Follow the steps below to use an existing connection within your web application: 

    <h2> Step 1: Add the connection configuration</h2>

    To integrate a service into your application, you must first add the connection configuration as follows: 

    1. For single page applications (SPAs), you must add the connection configuration as a file mount. You can mount a file via the **Configurations** pane on the **Deploy** page. You must mount a file (for example, `config.js`) and add the configuration provided in the inline developer documentation into it. 

        The following is a sample configuration:

        ``` yaml
             window.configs = {
                 apiUrl: '<SERVICE_URL>',        
             };

        ```

    2.  To ensure accessibility of the `config.js` file via JavaScript at runtime, add a script tag as follows in the `index.html` file to reference the `config.js` file:

        ``` html
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="utf-8" />
            <title>My React App</title>
        </head>
        <body>
            <div id="root"></div>
            <script src="/public/config.js"></script>
        </body>
        </html>
        ``` 

        !!! note
             If you use an external IdP, you must add the IdP's configuration to the same file.
    
             For more information on working with IdPs, see [Configure Asgardeo as an External Identity Provider](https://wso2.com/choreo/docs/administer/configure-an-external-idp/configure-asgardeo-as-an-external-idp/).


    <h2> Step 2: Read the configuration</h2>

    Once you add the connection configuration, you can proceed to read the configuration from your application. The steps to read depend on the programming language you use.

    The following is a sample code snippet in NodeJS:

    ``` java
         const serviceURL = window?.configs?.apiUrl ? window.configs.apiUrl : "/";
    ```

    <h2> Step 3: Invoke the service</h2>

    If you use Choreo-managed authentication, Choreo handles the security handshaking for the application during deployment. The connected service will be accessible under the same domain as your application. Therefore, you can call the configured path directly using your preferred HTTP client.

    The following is a sample code snippet in NodeJS:

    ``` java
         const response = await axios.get(serviceURL/{RESOURCE_PATH});
    ```

    !!! note
         If you are using an external IdP provider instead of Choreo-managed authentication, you must obtain an access token from your IdP and add it to the HTTP authorization header with the bearer prefix.


=== "Custom authentication or no authentication"

    If you are not using Choreo-managed authentication or your web application lacks authentication, follow the steps below to connect to a service from your web application:

    <h2> Step 1: Add the connection configuration</h2>

    1. For single-page applications (SPAs), you must add the connection configuration as a file mount. You can mount a file via the **Configurations** pane on the **Deploy** page. You must mount a file (for example, `config.js`) and add the configuration provided in the inline developer documentation into it.
 
        The following is a sample configuration:

        ``` yaml
             window.configs = {
                 apiUrl: '<SERVICE_URL>',
                 consumerKey: '<CONSUMER_KEY>',
                 consumerSecret: '<CONSUMER_SECRET>',
                 tokenUrl: '<TOKEN_URL>',
             };
        ```

    2.  To ensure accessibility of the `config.js` file via JavaScript at runtime, add a script tag as follows in the `index.html` file to reference the `config.js` file:

        ``` html
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="utf-8" />
            <title>My React App</title>
        </head>
        <body>
            <div id="root"></div>
            <script src="/public/config.js"></script>
        </body>
        </html>
        ``` 

    For other types of web applications, you must add the respective configuration into your application.

    <h2> Step 2: Read the configuration</h2>

    Once you have added the connection configuration, you can proceed to read the configuration from your application. The steps to read depend on the programming language you use.

    The following is a sample code snippet in NodeJS:

    ``` java
         const serviceURL = window?.configs?.apiUrl ? window.configs.apiUrl : "/";
    ```

    <h2> Step 3: Acquire an OAuth 2.0 access token</h2>

    - For languages with OAuth 2.0-aware HTTP clients, you must pass the OAuth 2.0-related configurations such as client id, client secret and so on, obtained when creating the connection to your HTTP client configuration. The HTTP client autonomously manages token retrieval and refreshing.
  
    - For languages without OAuth 2.0-aware HTTP clients, you must manually initiate a call to the token endpoint. This includes fetching the token and managing token expiration and refresh directly within your application code. The following is a sample curl command to obtain a token:


        ```bash
        CONSUMER_KEY="your_consumer_key"
        CONSUMER_SECRET="your_consumer_secret"
        TOKEN_URL="your_token_url"

        # Encode client credentials as Base64
        CLIENT_CREDENTIALS=$(echo -n "$CLIENT_ID:$CLIENT_SECRET" | base64)

        curl -X POST $TOKEN_URL \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -H "Authorization: Basic $CLIENT_CREDENTIALS" \
        --data-urlencode "grant_type=client_credentials"

        ```

    <h2> Step 4: Invoke the service</h2>

    You can invoke the service as follows:

    - For languages with OAuth 2.0-aware HTTP clients, you can invoke the service in a straightforward manner. The HTTP client seamlessly manages OAuth 2.0 authentication without requiring additional intervention.

        As the service URL you can use the URL that you resolved in step 2 above. For sample requests and responses, see the API definition provided via the Choreo marketplace for the service.

    - For languages without OAuth 2.0-aware HTTP clients, you can use the token obtained in step 3 above to make calls to the dependent service. Subsequently, add the obtained token to the HTTP authorization header with the bearer prefix.

        As the service URL you can use the URL that you resolved in step 2 above. For sample requests and responses, see the API definition of the service provided via the Choreo marketplace.

        The following is a sample code snippet in NodeJS:

        ```java 
            const response = await axios.get(serviceURL/{RESOURCE_PATH}, {
                headers: {
                'Authorization': `Bearer ${accessToken}`
                }
            })
        ```


# Use a Database Connection in Your Component

Choreo allows you to share and reuse Choreo-managed databases, accelerating development and enhancing efficiency in building integrated applications through connections.

For step-by-step instructions on creating a database connection, see [Create a Connection](create-a-connection.md).

To learn more about Choreo Connections, see the documentation on [Connections](../../choreo-concepts/connections.md).

## Consume a database through a connection

To consume a Choreo-managed database via a connection, follow these steps:

### Step 1: Add connection configurations

To integrate a database into your application, click the appropriate tab below based on your current configuration file and follow the step-by-step instructions:

=== "Component.yaml file (v1.1)"

    1. Copy and paste the snippet from the  developer guide into the `component.yaml` file.

        The following is a sample snippet:

        ``` yaml

        dependencies:
            connectionReferences:
            - name: <CONNECTION_NAME>
              resourceRef: <RESOURCE_IDENTIFIER>

        ```

          | Field            | Description                                                         |
          |------------------|---------------------------------------------------------------------|
          | name             | The name given to the connection.                                   |
          | resourceRef      | A unique, readable identifier of the database being connected to.    |


    2. If you've previously added a `connectionReferences` section under `dependencies`, append this as another item under `connectionReferences`. Upon deploying the component, the necessary configurations to establish the connection will be injected into Choreo-defined environment variables.

          The following table details the Choreo-defined environment variables:

          | Configuration Key       | Choreo-Defined Environment Variable Name                       |
          |-------------------------|----------------------------------------------------------------|
          | HostName                | CHOREO_<CONNECTION_NAME\>_HOSTNAME                             |
          | Port                    | CHOREO_<CONNECTION_NAME\>_PORT                                 |
          | Username                | CHOREO_<CONNECTION_NAME\>_USERNAME                             |
          | Password                | CHOREO_<CONNECTION_NAME\>_PASSWORD                             |
          | DatabaseName            | CHOREO_<CONNECTION_NAME\>DATABASENAME                          |


          If you'd like to use custom environment variable names instead of the Choreo-defined ones, add the dependency as a service reference under `dependencies` in the same file. For more details, refer to the instructions under the `component.yaml file (v1.0)` tab.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | HostName       | string     | Hostname of the database server       | false         | false        |
          | Port           | string     | Port of the database server           | false         | false        |
          | Username | string           | Username of the database server       | false         | false        |
          | Password       | string     | Password of the database server       | false         | true         |
          | DatabaseName   | string     | Name of the database                  | false         | false        |
    ### Step 2: Read configurations within the application

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const hostName = process.env.CHOREO_<CONNECTION_NAME>_HOSTNAME;
    ```

=== "Component.yaml file (v1.0)"

    !!! note
        The `component.yaml v1.0` file is considered legacy. For new components, we recommend using the latest version, `component.yaml v1.1`, which offers enhanced usability and features.

    1. Copy and paste the snippet from the  developer guide into the `component.yaml` file.

        The following is a sample snippet:

        ``` yaml

        dependencies:
            serviceReferences:
            - name: database:<DATABASE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: HostName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Port
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Username
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Password
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: DatabaseName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>


        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the database you are connecting to.             |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added a service reference section under `dependencies`, append this as another item under `serviceReferences`.

          Upon deploying the component, Choreo automatically populates the specified environment variables with actual values.

          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | HostName       | string     | Hostname of the database server       | false         | false        |
          | Port           | string     | Port of the database server           | false         | false        |
          | Username | string           | Username of the database server       | false         | false        |
          | Password       | string     | Password of the database server       | false         | true         |
          | DatabaseName   | string     | Name of the database                  | false         | false        |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const hostName = process.env.HOSTNAME;
    ```

=== "Component-config.yaml file"

    !!! note
        The `component-config.yaml` file is considered legacy. For new components, we recommend using the latest version, `component.yaml v1.1`, which offers enhanced usability and features.

    1. Copy and paste the snippet from the  developer guide into the `component-config` file under the `spec` section.

        The following is a sample snippet:

        ``` yaml

        outbound:
            serviceReferences:
            - name: database:<DATABASE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: HostName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Port
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Username
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Password
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: DatabaseName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>

        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the database you are connecting to.              |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added an outbound service reference, append this as another item under `serviceReferences`.

          Upon deploying the component, Choreo automatically populates the specified environment variables with actual values.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | HostName       | string     | Hostname of the database server       | false         | false        |
          | Port           | string     | Port of the database server           | false         | false        |
          | Username | string           | Username of the database server       | false         | false        |
          | Password       | string     | Password of the database server       | false         | true         |
          | DatabaseName   | string     | Name of the database                  | false         | false        |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const hostName = process.env.HOSTNAME;
    ```

### Step 3: Initiate a database connection

To initiate a connection to the database, follow these steps:

In this example, you will connect to a MySQL database.

#### Step 3.1: Install the required packages

For the MySQL database, install the `mysql2` package using npm:

```bash
// Install the mysql2 package
npm install mysql2

```

#### Step 3.2: Import required packages

```java

const client = require('mysql2')

```

#### Step 3.3: Establish a connection

To establish the connection, use the environment variables for `hostName`, `username`, `password`, `databaseName`, and `port` as follows:

```java

var connection = client.createConnection({
      host: hostName,
      user: username,
      password: password,
      database: databaseName,
      port: port
});

connection.connect((err) => {
      if (err) {
          return;
      }
      // Connection is successful
});

```

By following these steps, your component can interact with the Choreo-managed database seamlessly.




# Integrate Unit Tests into the Build Pipeline

Choreo allows you to integrate unit tests into the build pipeline, enabling code validation before deployment. This ensures early testing of code changes, reducing the risk of defects in production.

!!! note
        Currently, Choreo supports unit tests only for the `WSO2 MI` buildpack.

## How it works

### Step 1: Write tests

You can create unit tests in your source code using standard testing libraries. For step-by-step instructions on creating unit tests for WSO2 Micro Integrator projects, see [Creating a Unit Test Suite](https://mi.docs.wso2.com/en/latest/develop/creating-unit-test-suite/).

### Step 2: Enable unit tests

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click the component for which you want to enable unit tests.
3. In the left navigation menu, click **Build**.
4. On the **Build** page, click to edit **Build Configurations**.
5. Turn on the **Unit Test** toggle.
6. Click **Save**.

### Step 3: Trigger a new build

- On the **Build** page, click **Build Latest**.

This starts a new build with unit tests enabled. You can monitor its progress in the **Build Details** pane.

## View failed unit tests

If a unit test fails during the build, you can view its detailed logs for troubleshooting. Click **View Details** corresponding to the failed build, then expand the failed unit test step to view the logs.

## Explore a sample

To see unit tests in action within the build pipeline, try out the [WSO2 MI helloworld](https://github.com/wso2/choreo-samples/tree/main/hello-world-mi) sample. 


# Manage Component Source Configurations

In Choreo, you can configure service endpoints and connections via the `component.yaml` source configuration file. This file ensures that the configurations required to initialize endpoints and connections are defined, as they cannot be inferred from the source code. This guide provides an overview of how to configure and manage these settings effectively.

The source configuration file must be committed to your repository within the `.choreo` directory at the root of the project directory. This ensures the ability to version the configuration files alongside repository commits, enabling better tracking and management of configurations.

!!! note
    -  The `component-config.yaml` and `endpoints.yaml` files will eventually be deprecated and replaced by the `component.yaml` file. 
        - For details on how to seamlessly update to the latest `component.yaml` file`, see [Update to the latest source configuration file](#update-to-the-latest-source-configuration-file).
    - Choreo prioritizes configuration files in the following order: `component.yaml` takes the highest precedence, followed by `component-config.yaml`, and then `endpoints.yaml`.

## Overview of the `component.yaml` file 

**File location**:

```bash
<build-context-path>/.choreo/component.yaml
```

!!! note
    - For components built using **Buildpacks**, replace `build-context-path` with the `<project-directory>`. 
    For example, `<project-directory>/.choreo/component.yaml`.
    - For components built using **Docker**, replace `build-context-path` with the `<docker-context-path>`. 
    For example, `<docker-context-path>/.choreo/component.yaml`.

**Sample `component.yaml` file content**:

Click the respective tab to view the structure for your current configuration file version:

=== "Version 1.1"

    ``` yaml
    # +required The configuration file schema version
    schemaVersion: 1.1

    # +optional Incoming connection details for the component
    endpoints:
      # +required Unique name for the endpoint.
      # This name will be used when generating the managed API
      - name: greeter-sample
        # +optional Display name for the endpoint.
        displayName: Go Greeter Sample
        # +required Service section has the user service endpoint details
        service:
          # +optional Context (base path) of the API that gets exposed via the endpoint.
          basePath: /greeting-service
          # +required Numeric port value that gets exposed via the endpoint
          port: 9090
        # +required Type of traffic that the endpoint is accepting.
        # Allowed values: REST, GraphQL, WS, GRPC, TCP, UDP.
        type: REST
        # +optional Network level visibilities of the endpoint.
        # Accepted values: Project|Organization|Public(Default).
        networkVisibilities: 
          - Public
          - Organization
        # +optional Path to the schema definition file. Defaults to wild card route if not provided
        # This is only applicable to REST or WS endpoint types.
        # The path should be relative to the docker context.
        schemaFilePath: openapi.yaml
      
      # +optional Outgoing connection details for the component.
      dependencies:
        # +optional Defines the connection references from the Internal Marketplace.
        connectionReferences:
          # +required Name of the connection.
          - name: hr-connection
            # +required service identifer of the dependent component.
            resourceRef: service:/HRProject/UserComponent/v1/ad088/PUBLIC
      # +optional Defines runtime configurations
      configurations:
        # +optional List of environment variables to be injected into the component.
        env:
          # +required Name of the environment variable
          - name: HR_SERVICE_URL
            # +required value source
            # Allowed value sources: connectionRef
            valueFrom:
              # +required Choreo connection value source
              connectionRef:
                # +required Choreo connection name to refer the value from
                name: hr-connection
                # +required Choreo connection configuration key to refer the value from
                key: ServiceURL
    ```

    The descriptor-based approach of the `component.yaml` file simplifies and streamlines endpoint and connection configuration management. The use of versioned schemas ensures backward compatibility, providing a seamless transition with future updates.

    You can define the following root-level configurations via the `component.yaml` file:

    | Configuration        | Required     | Description                                                              |
    |----------------------|--------------|--------------------------------------------------------------------------|
    | **schemaVersion**    | Required     | The version of the `component.yaml` file. Defaults to the latest version.|
    | **endpoints**        | Optional     | The list of endpoint configurations.                                     |
    | **dependencies**     | Optional     | The list of dependency configurations.                                   |
    | **configurations**    | Optional     | The runtime configuration definitions.                                   |

    ### Endpoint configurations
    In the `endpoints` section of the `component.yaml` file, you can define multiple service endpoint configurations. Each endpoint must have a unique name and the required fields specified in the schema overview.

    !!! tip "Why have a unique name?"
          When you define multiple endpoints, the `endpoint.name` is appended to the Choreo-generated URL. A unique name ensures the endpoint is easily recognizable and readable within the URL.
          
    | Configuration        | Required     | Description                                                                                             |
    |----------------------|--------------|---------------------------------------------------------------------------------------------------------|
    | **name**             | Required     | A unique identifier for the endpoint within the service component. Avoid using excessively long names.  |
    | **displayName**      | Optional     | A display name for the endpoint.                                                                        |
    | **service**          | Required     | Service details for the endpoint.                                                                       |
    | **.basePath**        | Required     | The base path of the API exposed via this endpoint.                                                     |
    | **.port**            | Required     | The numeric port value exposed via this endpoint.                                                       |
    | **type**             | Required     | The type of traffic the endpoint accepts. For example, `REST`, `GraphQL`, `WS`, `gRPC`, `UDP`, or `TCP`.|
    | **networkVisibilities** | Required | The network-level visibility of the endpoint. For example, project, organization, or public.             |
    | **schemaFilePath** | Required | The file path to the swagger definition  or AsyncAPI 2.0 specification file. Defaults to the wildcard route if not specified. This field should be a relative path to the project path when using **Java**, **Python**, **NodeJS**, **Go**, **PHP**, **Ruby**, or **WSO2 MI** buildpacks. For REST or WebSocket endpoint types, when using the **Ballerina** or **Dockerfile** buildpack, the path should be relative to the component root or Docker context. |

    ### Dependency configurations

    In the `dependencies` section of the `component.yaml` file, you can define multiple connection configurations under `dependencies.connectionReferences`. You can use the connection reference generated in the inline developer guide when creating a connection. For instructions on copying [connection configurations](https://wso2.com/choreo/docs/develop-components/sharing-and-reusing/use-a-connection-in-your-service/), see the inline developer guide displayed during connection creation.

    You must include the following configurations in the `dependencies.connectionReferences` schema:

    | Configuration        | Required     | Description                                                                      |
    |----------------------|--------------|----------------------------------------------------------------------------------|
    | **name**             | Required     | The name given to the connection.                                                |
    | **resourceRef**      | Required     | A unique, human-readable identifier for the service you are connecting.          |


    !!! note
        Choreo automatically generates connection configurations when you create a connection. The properties such as **name** and **resourceRef** are automatically generated. The configurations required to establish the connection will be injected into Choreo-defined environment variables.

        To use custom environment variable names instead of Choreo's default ones, add the dependency as a `serviceReference` in your `component.yaml v1.1` file. You can copy the `serviceReference` section from the `component.yaml v1.0` tab and paste it under `dependencies` in your `component.yaml v1.1` file, which maintains backward compatibility with the v1.0 format.

    ### Runtime configurations
    In the `configurations` section of the `component.yaml` file, you can define runtime configurations for the component. These configurations currently support environment variable injection related to dependencies.
    
    | Configuration                 | Required     | Description                                                                       |
    |-------------------------------|--------------|-----------------------------------------------------------------------------------|
    | **env**                       | Optional     | An array of env variable configurations.                                          |
    | **name**                      | Required     | A unique name for the environment variable, starting with a letter or an underscore, and containing only letters, numbers, or underscores. |
    | **valueFrom**                 | Required     | The source of the environment variable value.                                     |
    | **connectionRef**             | Required     | Connection reference value source definition.                                     |
    | **name**                      | Required     | The name of the Choreo connection to reference the value from.                    |
    | **key**                       | Required     | The Choreo connection configuration key to reference the value from. For details on available keys, see [connection configurations](https://wso2.com/choreo/docs/develop-components/sharing-and-reusing/use-a-connection-in-your-service/) or the inline developer guide. |

    !!! note
        Runtime configurations are supported starting from `component.yaml v1.1`.

        When an environment variable value is specified using `connectionRef`, the connection's environment variable is renamed to the environment variable name defined in the `configurations` section. For example, in the sample `component.yaml` file given above, the `CHOREO_HR_CONNECTION_SERVICEURL` variable in the `hr-connection` is renamed to `HR_SERVICE_URL`.

=== "Version 1.0"

    ``` yaml
    # +required The configuration file schema version
    schemaVersion: 1.0

    # +optional Incoming connection details for the component
    endpoints:
      # +required Unique name for the endpoint.
      # This name will be used when generating the managed API
      - name: greeter-sample
        # +optional Display name for the endpoint.
        displayName: Go Greeter Sample
        # +required Service section has the user service endpoint details
        service:
          # +optional Context (base path) of the API that gets exposed via the endpoint.
          basePath: /greeting-service
          # +required Numeric port value that gets exposed via the endpoint
          port: 9090
        # +required Type of traffic that the endpoint is accepting.
        # Allowed values: REST, GraphQL, WS, GRPC, TCP, UDP.
        type: REST
        # +optional Network level visibilities of the endpoint.
        # Accepted values: Project|Organization|Public(Default).
        networkVisibilities: 
          - Public
          - Organization
        # +optional Path to the schema definition file. Defaults to wild card route if not provided
        # This is only applicable to REST or WS endpoint types.
        # The path should be relative to the docker context.
        schemaFilePath: openapi.yaml
      
    # +optional Outgoing connection details for the component.
    dependencies:
      # +optional Defines the service references from the Internal Marketplace.
      serviceReferences:
        # +required Name of the service reference.
        - name: choreo:///apifirst/HRProject/UserComponent/ad088/v1/PUBLIC
          # +required Name of the connection instance.
          connectionConfig: 19d2648b-d29c-4452-afdd-1b9311e81412
          # +required Environment variables injected into the component for connection configuration.
          env:
            # +required Key name of the connection configuration.
            - from: ServiceURL
              # +required Environment variable injected into the container.
              to: SERVICE_URL
    ```

    The descriptor-based approach of the `component.yaml` file simplifies and streamlines endpoint and connection configuration management. The use of versioned schemas ensures backward compatibility, providing a seamless transition with future updates.

    You can define the following root-level configurations via the `component.yaml` file:

    | Configuration        | Required     | Description                                                              |
    |----------------------|--------------|--------------------------------------------------------------------------|
    | **schemaVersion**    | Required     | The version of the `component.yaml` file. Defaults to the latest version.|
    | **endpoints**        | Optional     | The list of endpoint configurations.                                     |
    | **dependencies**     | Optional     | The list of dependency configurations.                                   |

    <h3> Endpoint configurations </h3>
    In the `endpoints` section of the `component.yaml` file, you can define multiple service endpoint configurations. Each endpoint must have a unique name and the required fields specified in the schema overview.

    !!! tip "Why have a unique name?"
          When you define multiple endpoints, the `endpoint.name` is appended to the Choreo-generated URL. A unique name ensures the endpoint is easily recognizable and readable within the URL.
          
    | Configuration           | Required     | Description                                                                                             |
    |-------------------------|--------------|---------------------------------------------------------------------------------------------------------|
    | **name**                | Required     | A unique identifier for the endpoint within the service component. Avoid using excessively long names.  |
    | **displayName**         | Optional     | A display name for the endpoint.                                                                        |
    | **service**             | Required     | Service details for the endpoint.                                                                       |
    | **.basePath**           | Required     | The base path of the API exposed via this endpoint.                                                     |
    | **.port**               | Required     | The numeric port value exposed via this endpoint.                                                       |
    | **type**                | Required     | The type of traffic the endpoint accepts. For example, `REST`, `GraphQL`, `gRPC`, `WS`, `UDP`, or `TCP`.|
    | **networkVisibilities** | Required     | The network-level visibility of the endpoint. For example, project, organization, or public.            |
    | **schemaFilePath**      | Required     | The file path to the swagger definition or AsyncAPI 2.0 specification file. Defaults to the wildcard route if not specified. This field should be a relative path to the project path when using **Java**, **Python**, **NodeJS**, **Go**, **PHP**, **Ruby**, or **WSO2 MI** buildpacks. For REST or WebSocket endpoint types, when using the **Ballerina** or **Dockerfile** buildpack, the path should be relative to the component root or Docker context. |

    <h3> Dependency configurations </h3>

    In the `dependencies` section of the `component.yaml` file, you can define multiple service connection configurations under `dependencies.serviceReferences`. You can use the service references generated in the inline developer guide when creating a service connection. For instructions on copying [connection configurations](https://wso2.com/choreo/docs/develop-components/sharing-and-reusing/use-a-connection-in-your-service/), see the inline developer guide displayed during connection creation.

    You must include the following configurations in the `dependencies.serviceReferences` schema:

    | Configuration        | Required     | Description                                                                      |
    |----------------------|--------------|----------------------------------------------------------------------------------|
    | **name**             | Required     | A unique name for the service reference.                                         |
    | **connectionConfig** | Required     | A unique name for the connection instance.                                       |
    | **env**              | Required     | The list of environment variable mappings to inject into the container.          |
    | **.from**            | Required     | The key name of the connection configuration.                                    |
    | **.to**              | Required     | The environment variable to inject into the container.                           |

    !!! note
        Choreo automatically generates connection configurations when you create a connection. The properties such as **name**, **connectionConfig**, and **env.from** are automatically generated. However, you must manually set the **env.to** value.

## Overview of the `component-config.yaml` file 

**File location**:

```bash
<build-context-path>/.choreo/component-config.yaml
```

**Sample `component-config.yaml` file content**:

```yaml
apiVersion: core.choreo.dev/v1beta1
kind: ComponentConfig
spec:
  # +optional Incoming connection details for the component (AKA endpoints).
  inbound:
    # +required Unique name for the endpoint.
    # This name will be used when generating the managed API
    - name: Greeting Service
      # +required Numeric port value that gets exposed via the endpoint
      port: 9090
      # +required Type of traffic that the endpoint is accepting.
      # Allowed values: REST, GraphQL, GRPC, TCP, UDP, WS.
      type: REST
      # +optional Network level visibility of the endpoint. Defaults to Public
      # Accepted values: Project|Organization|Public.
      networkVisibility: Public
      # +optional Context (base path) of the API that gets exposed via the endpoint.
      # This is mandatory if the endpoint type is set to REST, GraphQL or WS.
      context: /greeting
      # +optional The path to the schema definition file. Defaults to wildcard route if not specified.
      # This is only applicable to REST and WS endpoint types.
      # The path should be relative to the Docker context.
      schemaFilePath: greeting_openapi.yaml
  # +optional Outgoing connection details for the component.
  outbound:
    # +optional Defines the service references from the Internal Marketplace.
    serviceReferences:
      # +required Name of the service reference.
      - name: choreo:///apifirst/mttm/mmvhxd/ad088/v1.0/PUBLIC
        # +required Name of the connection instance.
        connectionConfig: 19d2648b-d29c-4452-afdd-1b9311e81412
        # +required Environment variables injected to the component for connection configuration.
        env:
          # +required Key name of the connection configuration.
          - from: ServiceURL
            # +required Environment variable injected to the container.
            to: SERVICE_URL
```

The `component-config.yaml` file complements and enhances the existing endpoint configuration process. It allows you to define how the endpoints (inbound connections) in your service are exposed and how your service connects to external services or components (outbound connections).

You can define the following root-level configurations via the `component-config.yaml` file:

| Configuration        | Required     | Description                                                                           |
|----------------------|--------------|---------------------------------------------------------------------------------------|
| **apiVersion**       | Required     | The version of the `component-config.yaml` file defaults to `core.choreo.dev/v1beta1`.|
| **kind**             | Required     | The resource type of the file defaults to `ComponentConfig`.                          |
| **spec.inbound**     | Optional     | The list of inbound connection configurations.                                        |
| **spec.outbound**    | Optional     | The list of outbound connection configurations.                                       |

#### Inbound connection configurations (`spec.inbound`)

In the `spec.inbound` configuration section, you can specify endpoints to set up inbound connections. To specify endpoints, you can follow the existing endpoints schema structure. For details on the endpoints schema structure, see the [endpoints schema documentation](#overview-of-the-endpointsyaml-file).

#### Outbound connection configurations (`spec.outbound`)

In the `spec.outbound` section, you can define `serviceReferences`. To define `serviceReferences`, you can use the service references generated in the Internal Marketplace when creating a service connection. To copy the [outbound connection configurations](../sharing-and-reusing/use-a-connection-in-your-service/#use-a-connection-in-your-service), see the inline developer guide displayed when you create a connection.

You must include the following configurations in the `serviceReferences` schema:

| Configuration        | Required     | Description                                                                      |
|----------------------|--------------|----------------------------------------------------------------------------------|
| **name**             | Required     | A unique name for the service reference.                                         |
| **connectionConfig** | Required     | A unique name for the connection instance.                                       |
| **env**              | Optional     | The list of environment variable mappings to inject into the container.          |
| **env.from**         | Required     | The key name of the connection configuration.                                    |
| **env.to**           | Required     | The environment variable to inject into the container.                           |

## Overview of the `endpoints.yaml` file

**File location**:

```bash
<build-context-path>/.choreo/endpoints.yaml
```

**Sample `endpoints.yaml` file content**:

```yaml
# +required Version of the endpoint configuration YAML
version: 0.1

# +required List of endpoints to create
endpoints:
  # +required Unique name for the endpoint.
  # This name will be used when generating the managed API
- name: Greeting Service
  # +required Numeric port value that gets exposed via this endpoint
  port: 9090
  # +required Type of the traffic this endpoint is accepting.
  # Allowed values: REST, GraphQL, GRPC, UDP, TCP, WS.
  type: REST
  # +optional Network level visibility of this endpoint. Defaults to Public
  # Accepted values: Project|Organization|Public.
  networkVisibility: Project
  # +optional Context (base path) of the API that is exposed via this endpoint.
  # This is mandatory if the endpoint type is set to REST, GraphQL or WS.
  context: /greeting
  # +optional Path to the schema definition file. Defaults to wild card route if not provided
  # This is only applicable to REST and WS endpoint types.
  # The path should be relative to the docker context.
  schemaFilePath: greeting_openapi.yaml
```

The `endpoints.yaml` configuration file allows you to define configurations for multiple endpoints necessary for Choreo service components. This schema is essential to identify the context, port binding, network exposure level, and other attributes required to generate a Choreo endpoint.

You can define the following root-level configurations via the `endpoints.yaml` file:

| Configuration        | Required     | Description                                                                       |
|----------------------|--------------|-----------------------------------------------------------------------------------|
| **version**          | Required     | The version of the `endpoints.yaml` file.                                         |
| **name**             | Required     | A unique name for the endpoint, which Choreo will use to generate the managed API.|
| **port**             | Required     | The numeric port value that gets exposed via this endpoint.                       |
| **type**             | Required     | The type of traffic this endpoint accepts, such as `REST`, `GraphQL`, `gRPC`, `WS`, `UDP`, or `TCP`. Currently, the MI preset supports only the `REST` type.                                         |
| **networkVisibility**| Required     | The network level visibility of this endpoint, which defaults to `Public` if not specified. Accepted values are `Project`, `Organization`, or `Public`.|
| **context**          | Required     | The context (base path) of the API that Choreo exposes via this endpoint.         |
| **schemaFilePath**   | Required     | The swagger definition file path. Defaults to the wildcard route if not provided. This field should be a relative path to the project path when using the **Java**, **Python**, **NodeJS**, **Go**, **PHP**, **Ruby**, and **WSO2 MI** buildpacks. For REST endpoint types, when using the **Ballerina** or **Dockerfile** buildpack, this field should be a relative path to the component root or Docker context.|

## Update to the latest source configuration file

With the upcoming deprecation of the `component-config.yaml` file and the `endpoints.yaml` file, Choreo provides a seamless process to move to the latest `component.yaml`  version of the `component.yaml` file. Follow these steps to transition seamlessly:

### Step 1: Identify whether your current source configuration file is outdated

You can determine whether you’re using an outdated configuration file in the following ways:

- **During a build:**
     - On the **Build** page, after triggering a build, a warning will appear if your source configuration file is outdated. Click **View Details** in the **Initialization** -> **Source Config Validation** step. You will see an information banner with an option to update the file.

- **In existing deployments:**
     - If an existing deployment uses a build with an outdated source configuration file, you will see a warning icon on the build card of the relevant environment card.


### Step 2: Generate the latest `component.yaml` file

- In either of the scenarios above, click **Update** to initiate the process of generating the latest `component.yaml` file. The updated file will retain your existing configurations to ensure a smooth update process.


### Step 3: Add the generated configuration file to your repository

1. Download the generated `component.yaml` file.
2. Replace the existing source configuration file in the `.choreo` folder within your source repository.
    - Ensure the file name is `component.yaml`.


### Step 4: Trigger a new build

1. Commit the new `component.yaml` file to your repository. Push changes to the remote Git repository.
2. Trigger a build using the latest commit.


### Step 5: Verify the update

Once the build is complete:

  - Deploy the build.
  - Confirm that the warning messages no longer appear.

You can benefit from the latest features and enhancements provided by the updated source configuration file.


# Manage Deployment Tracks for Choreo Components

Choreo allows you to create and manage dedicated [deployment tracks](../choreo-concepts/deployment-tracks.md) for components, facilitating independent version control and deployment. This capability also allows you to unlink deployment tracks from associated branches or relink them to different branches so that you can align with your preferred Git workflows, such as the feature branch workflow or GitFlow workflow.

!!! info
     Deployment track creation and management does not apply to API Proxy and [BYOI components](../develop-components/bring-your-own-image.md).

## Create a deployment track

**Prerequisites**:

 - Create a component in Choreo.

Follow the steps below to create a deployment track for a component:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to create a deployment track for.
3. On the header of the component overview page, click the **Deployment Track** drop-down list.
4. Click **+ Create New** to open the **Create Deployment Track** dialog.
5. In the **Create Deployment Track** dialog, do the following:
    1. Select a branch to associate with the deployment track.
    2. Optionally, specify a description for the deployment track. 
    3. To create a deployment track for a service component, specify a unique API version indicating the major and minor version numbers.
6. Click **Create**.

## Unlink a deployment track

If you want to detach a branch reference from a deployment track, you must unlink the branch.

!!! info
     When you unlink the branch of a deployment track, the active deployments are unaffected. However, while you can redeploy the existing deployment, you cannot perform a new deployment.

Follow the steps below to unlink a deployment track of a component:
  
1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to unlink a deployment track.
3. On the header of the component overview page, click the **Deployment Track** drop-down list and then click **View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
4. Click the edit icon corresponding to the deployment track you want to unlink.
5. In the **Edit Branch** dialog that opens, click the **Branch Name** list and select **None**.
6. Click **Save**.

## Link a deployment track

To associate a branch reference to an unlinked deployment track, you must link a branch.

!!! info
    To build and deploy the contents of the linked branch,  you must perform a manual build and deploy.

**Prerequisites**:

 - A minimum of two branches in your GitHub repository.

Follow the steps below to link a branch to an unlinked deployment track:
  
1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to associate a branch reference for.
3. On the header of the component overview page, click the **Deployment Track** drop-down list and then click **View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
4. Click **+ Link Branch** corresponding to the unlinked deployment track for which you want to associate a branch.
5. In the **Link Branch** dialog that opens, click the **Branch Name** list and select the branch you want to relink.
6. Click **Save**.

## Relink a deployment track

To switch the branch reference of a linked deployment track, you must relink to an appropriate branch.

!!! info
      If you unlink the existing branch of a deployment track and link a different branch, you must perform a manual build and deploy to build and deploy the contents of the recently linked branch.

**Prerequisites**:

 - A minimum of two branches in your GitHub repository.

Follow the steps below to switch the branch reference of a linked deployment track:
  
1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to relink a deployment track for.
3. On the header of the component overview page,  click the **Deployment Track** drop-down list and then click **View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
4. Click the **Edit Branch** icon corresponding to the deployment track you want to relink.
5. In the **Edit Branch** dialog that opens, click the **Branch Name** list and select the branch you want to relink.
6. Click **Save**.

Now that you understand how to create and manage deployment tracks for components, let’s explore a sample scenario to see how a developer can use deployment tracks to manage version releases in Choreo.

## Sample Scenario: Manage version releases with deployment tracks

Let’s consider the following version release scenario: 

- To initiate work on a new feature, a developer creates a new branch, named `feature-x` from either the `main` or `dev` branch.
- Once development is complete, the developer proceeds to merge the `feature-x` branch into the `dev` branch for testing.
- Upon successful testing in the `dev` branch, the developer proceeds to merge all the changes into the `main` branch for production deployment.

Following are the actions you need to take from a deployment track perspective to manage the version release:

1. To prepare for the new version release, unlink the `main` branch from the associated deployment track (let’s consider this as the deployment track 1).
2. Proceed to merge the `dev` branch containing the tested changes into the `main` branch.
3. Unlink the `dev` branch from the associated deployment track (let’s consider this as deployment track 2).
4. Link deployment track 2 containing the latest version of the service to the `main` branch for deployment.
5. To facilitate ongoing development and testing, create another deployment track (let’s consider this as deployment track 3) and link it to the `dev` branch.

!!! tip
     - As a developer, you can strategically unlink and relink deployment tracks to effectively manage different versions of your services within Choreo.
     - You can create new deployment tracks for ongoing development branches like `dev` to ensure a continuous development and release cycle.

## Delete a deployment track

If you no longer need a deployment track, you can delete it.

!!! note
    If the component exposes an endpoint or proxy and you want to delete the last version in the major version range, the recommended approach is to retire that version first. This allows consumers to transition to the next major version and prevents a sudden break in their experience.
    For example, if you have deployment tracks for v1.0 and v2.0, notify consumers to switch to v2.0 before deleting v1.0. Then, retire the APIs in v1.0 and proceed to delete the associated deployment track.




**Prerequisites**:

- At least 2 deployment tracks in a component.

Follow the steps below to delete a deployment track:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to delete a deployment track.
3. On the header of the component overview page, click the **Deployment Track** drop-down list.
4. Click **+ View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
5. Click the **Delete** icon corresponding to the deployment track you want to delete.
6. Click **Delete** to confirm the deletion.

# Manage the Micro Integrator Runtime Version in Your Integration Project

Choreo allows you to use a preferred WSO2 Micro Integrator (MI) runtime version in your integration project. Currently, Choreo supports MI product versions 4.1.0 and 4.2.0. You have the flexibility to deploy WSO2 updates within these specified versions. 

When you create an integration project, you can specify a required runtime version to gain control over the environment in which your integration runs. This version management capability empowers you to tailor your projects depending on your runtime requirements, enhancing the customization and adaptability of your integration workflows.

## Understand the version string

WSO2 Micro Integrator (MI) utilizes a versioning system consisting of three-digit numbers, such as `4.1.0` and `4.2.0`, following semantic versioning principles. The product remains committed to receiving updates from WSO2, including security fixes, bug resolutions, and enhancements. Within the Choreo platform, the MI runtime version is constructed by combining the product release version with its corresponding update level.

In Choreo, the MI runtime version is structured as a four-digit number, for example, `4.1.0.14` or `4.2.0.17`. The first three digits represent the product release version, while the last digit signifies the update level of the product. The fourth digit is optional and can be omitted.

![Version string](../assets/img/develop-components/micro-integrator/version-string.png)

## Version management in WSO2 Integration Studio

If you are using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/) to build and deploy integration artifacts in WSO2 Micro Integrator, you can create multiple runtime environments and execute projects on any selected environment. WSO2 Integration Studio also allows you to configure multiple Micro Integrator runtime environments, offering flexibility and customization in the execution of integration processes.

You can specify the Runtime version when you create an integration project in WSO2 Integration Studio. In the project creation wizard, specify the runtime version in the **Runtime version** field, as shown below.
![Specify Runtime version](../assets/img/develop-components/micro-integrator/specify_runtime_version.png)


An integration project is structured as a Maven project with multiple sub-modules. The root `pom.xml` file holds crucial information about the target runtime. The runtime version you configure when you create a new project is saved within the root `pom.xml` file. The version information is stored in the <project.runtime.version> element under the <properties> in the `pom.xml` file. If there is a need to update the runtime version, you have the flexibility to modify the value to a valid runtime version and ensure that the project runs in the required runtime environment.

![project runtime version](../assets/img/develop-components/micro-integrator/project-runtime-version.png)

You can establish multiple runtime environments by utilizing updated MI instances. With a valid WSO2 subscription, you can also access and download updates to set up an updated MI server locally. This update process allows you to select a preferred update level as the runtime version. Consequently, you can run your integration on a runtime with the latest updates, ensuring optimal performance and access to new features.

### Configure a Micro Integrator runtime environment in Integration Studio

If you are using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), follow these steps to set up a remote server instance with a Micro Integrator runtime environment to execute your integration project:

!!! info "Note"
    If you have not downloaded and installed WSO2 Integration Studio, you can follow the [installation instructions](https://apim.docs.wso2.com/en/latest/integrate/develop/installing-wso2-integration-studio/) in the WSO2 API Manager documentation.

1. Launch WSO2 Integration Studio and click **Add Server** in the **Getting Started** view.
   ![Add server](../assets/img/develop-components/micro-integrator/add-server.png)
2. In the **Define a New Server** dialog, click to expand the `WSO2` directory and select **WSO2 Remote Server**.
   ![Define a remote server instance](../assets/img/develop-components/micro-integrator/define-a-remote-server-instance.png)
3. Enter the WSO2 Micro Integrator Management API URL in the **Server URL** field and click **Test Connection**.

    !!! info "Note"
        The Management API of WSO2 Micro Integrator is an internal REST API introduced to substitute MI admin services. The default HTTPS port of the Management API of WSO2 Micro Integrator is `9164`. If you have not manually changed the default port, you must set the Management API URL as `https://localhost:9164/management`.  If you have changed the default HTTPS port, you must set the port number appropriately when specifying the **Server URL**. For more information on the default ports of WSO2 Micro Integrator, see [WSO2 Micro Integrator default ports](https://apim.docs.wso2.com/en/latest/install-and-setup/setup/reference/default-product-ports/#micro-integrator-ports) in the WSO2 API Manager documentation.

    ![Set server URL](../assets/img/develop-components/micro-integrator/set-server-url.png)
    
4. Click **Finish**.
5. In the **Add and Remove** dialog, select the integration components to move from the left side to the right side.
6. Click **Add >**.
7. Click **Finish**. 

Your integration project is now running in a remote server instance with the Micro Integrator runtime environment you require.
If you need to make changes to the integration project, expand the remote server instance, right-click on the deployed exporter project, and select **Redeploy** to apply the changes.

![Redeploy project](../assets/img/develop-components/micro-integrator/redeploy-project.png)

## Convention for version interpretation in Choreo deployments

You can use the following convention to indicate the required MI runtime version in your integration project:


| **Version format**           | **Example**       | **Description**   |
|------------------------------|-------------------|-------------------|
| Product version              | `4.1.0`, `4.2.0`  | Deploy on the latest update level of the mentioned product version.                 |
| Product version with update level  | `4.1.0.15`, `4.2.0.17` |  Deploy on the exact update level of the mentioned product version.    |
| GA version                   | `4.1.0.0`, `4.2.0.0` | Deploy on the exact GA version without any update.                  |
| Default version            | Empty value         | Deploy on the latest update level of the default product version.                  |


Choreo utilizes Alpine images for configuring and deploying the Micro Integrator runtime. This includes automated configuration of the JRE/JDK, customized to the compatibility of the chosen runtime version, simplifying the setup procedure.

## Migrate between runtime versions

Changing the runtime version in an integration project may become necessary during product version upgrades or when you want to apply updates. 

To change the runtime version of a MI Integration, follow the below steps.

### Update the runtime version in the integration project
    
To change the runtime version in the integration project, follow the steps below:
1. Open the project in Integration Studio.
2. Right-click on the project and select **Change Runtime MI Version**.
    ![Update Runtime version](../assets/img/develop-components/micro-integrator/click_change_runtime.png)
3.  Specify the new runtime version as shown below:
    ![Update Runtime version](../assets/img/develop-components/micro-integrator/update_runtime_version.png)
4. Alternatively, you can manually update the version by opening the root `pom.xml` file.  Open pom.xml and change the required runtime version in `<project.runtime.version>` element under `<properties>` section.

To test the changes locally, you must download and set up the runtime environment locally. Then, you must [configure the Integration Studio runtime environment](#configure-a-micro-integrator-runtime-environment-in-integration-studio) by directing it to the locally installed MI runtime. Once the setup is complete, you can deploy your integrations on the MI runtime environment and proceed to the testing phase.

After completing the tests to ensure everything works as expected, you can follow below steps to deploy the project in Choreo:

1. Commit and push the changes to your repository.
2. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
3. Select your project from the **Project** list in the header.
4. Select your MI integration component from the **Component** list in the header.
5. In the left navigation menu, click **Build**.
6. Select the latest commit and click **Build**.
7. In the left navigation menu, click **Deploy**.
8. Click on the **Configure and Deploy** and deploy the component.
9. Verify the Runtime version by checking the logs by selecting the **Runtime Logs** under the **Observability** section.

  You will see the runtime version in the logs as shown below:
  ![Runtime version in logs](../assets/img/develop-components/micro-integrator/runtime_version_in_logs.png)

Next, you must conduct additional testing in the development environment on Choreo before you promote the integration to production environments.

## Troubleshoot errors

The following error codes can help you troubleshoot errors that occur during the integration component build:

| **Error code** | **Description**            |
|----------------|----------------------------|
| 110 - 119      | Internal server error.     |
| 121            | Malformed runtime version. |
| 122            | The specified runtime version is not available. Either the product or update level is not available.    |
| 123            | Trivy security vulnerabilities found in the `libs` directory. |
| 124            | Trivy security vulnerabilities found in the `dropins` directory. |
| 125            | Trivy security vulnerabilities found in the `libs` or `dropins` directory. |
| 126            | Error building integration project. |


# Submit and Manage Workflow Approval Requests

In Choreo, if an administrator [configures a workflow to require approval](../administer/configure-approvals-for-choreo-workflows.md), you must submit a request to obtain approval to perform the task.

Upon submitting a workflow approval request, Choreo notifies all authorized assignees via email about the [review request](../administer/review-workflow-approval-requests.md). When an authorized assignee approves or rejects the request, you will receive an email with details of the decision.

The approach to request approval can vary depending on the workflow. 

## Request approval for environment promotion

**Prerequisites**:

- Ensure you have a component created, built, and deployed to the development environment.
- Ensure that an approval workflow is configured for environment promotion.
- Ensure you are promoting the component to a critical environment, such as production.

To request approval to promote a component from the development environment to production, follow these steps:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to deploy. This takes you to the **Overview** page of the component.
3. In the left navigation menu, click **Deploy**.
4. Go to the **Development** card and click **Request to Promote**.
5. In the **Request Approval** pane that opens, enter your request details and click **Submit**. This creates a request and notifies all authorized assignees via email about the request.

    !!! note
         When an environment promotion request for a specific component is pending review, Choreo restricts other developers from making the same request until the pending request is either approved or rejected.

When an authorized assignee approves the request, you will receive a confirmation email and can proceed to promote the component to production.

## Cancel a workflow approval request

If you want to cancel a workflow approval request that is already submitted, you can do so before the request is approved or rejected. 

When you submit a workflow approval request, the **Request to Promote** button changes to **Cancel Request**. To cancel an approval request, click **Cancel Request**. Upon confirming the cancellation, all configured approvers are notified immediately, and the request will no longer be pending.


# Work with the Micro Integrator Runtime in Choreo

WSO2 Micro Integrator (WSO2 MI) is a lightweight, high-performance integration runtime. It allows you to run integrations developed using WSO2 Integration Studio within Choreo. 

The topics on this page walk you through the key aspects you need to understand to use the WSO2 MI runtime effectively in Choreo.

## Integration types

Choreo supports the following WSO2 MI integrations that cater to different use cases and requirements. Each integration type serves a specific purpose. Therefore, it is essential to understand their differences to easily choose the most appropriate integration for your use case.

- **Service**: Exposes an integration as an API via HTTP, making it possible to create a RESTful interface for your integration services. This type is ideal for scenarios where you need to provide an API for external systems or clients to interact with your integration.
- **Event Handler**: Triggers an integration based on external events such as messages arriving on a queue or updates in a database. This type is well-suited for implementing event-driven architectures or responding to changes in your system's environment.
- **Scheduled Task**: Runs an integration automatically at predefined time intervals, ensuring that specific integration tasks occur at regular intervals. This type is ideal for batch processing, data synchronization, or periodic maintenance tasks.
- **Manual Task**: Initiates an integration via user action, giving you full control over when the integration executes. This type is useful for on-demand tasks, testing, or debugging purposes.

## Develop integrations with WSO2 Integration Studio

[WSO2 Integration Studio](https://wso2.com/integration/integration-studio/) is a powerful, Eclipse-based graphical development environment that enables you to build and deploy integration artifacts in WSO2 Micro Integrator. This comprehensive IDE offers a robust set of tools for designing and testing integration flows and crafting integration artifacts. By utilizing the visual, drag-and-drop capabilities of WSO2 Integration Studio, developers can significantly reduce the time and effort needed to construct and deploy integration flows.

In addition to streamlining the development process, Integration Studio offers features such as debugging, testing, and version control to ensure the quality and reliability of integration flows. By creating an Integration project and Composite Exporter project in WSO2 Integration Studio, developers can export their integration projects as a single deployment artifact, known as a composite application. This composite application encompasses all the components and configurations necessary for deploying the integration project to WSO2 Micro Integrator.

The Composite Exporter project simplifies the deployment process by allowing developers to package their integration projects as a single, self-contained artifact that can be easily deployed and managed. This approach enhances the consistency and reliability of integration projects while streamlining the overall deployment process.

To start developing integrations with WSO2 Micro Integrator, see [WSO2 Micro Integrator documentation - Developing Integration Solutions](https://mi.docs.wso2.com/en/latest/develop/intro-integration-development/).

## Integration project directory structure

An Integration Project in WSO2 Integration Studio is a multi-module Maven project that can contain multiple modules with WSO2 Synapse configurations and a composite application module to export all the configurations as a single deployable artifact.

An integration project directory structure includes the following key components:

 - WSO2 Synapse configurations: These modules contain the essential configurations for the integration project.
 - Composite Application module: This module is responsible for exporting all the Synapse configurations as a single deployable artifact.

Optionally, you can include the following components in your integration project:

 - OpenAPI definition file: You can add the OpenAPI definition file to any location within the project. When creating a component, you'll need to define the path to this file. Choreo will automatically generate an OpenAPI definition for you based on your integration project, if you don't provide one.
 - Java libraries: If your integration project requires additional Java libraries, you can add them to the libs directory located in the project root.
 - deployment.toml file: This optional configuration file allows you to customize the preconfigured settings of WSO2 MI instances running on Choreo. By including this file, you can tailor the behavior of your WSO2 MI instances to better suit your project's specific requirements.

Understanding the Integration Project directory structure is crucial for organizing your project and ensuring that all necessary components are included in the final deployable artifact.

## OpenAPI support

OpenAPI Support plays a crucial role in enhancing the functionality of integrations exposed as APIs. By providing an OpenAPI definition for your exposed integration, you can streamline testing and management processes, ensuring a more efficient and user-friendly experience. Choreo will automatically generate an OpenAPI definition for you based on your integration project, if you don't provide one, saving you time and effort.

To incorporate OpenAPI support, store the OpenAPI definition file within the repository hosting your Integration Studio project. When creating the project, simply point to the file's location in the repository. If needed, you can change the location of the OpenAPI definition file later via the deploy page.

![Open API file](../assets/img/develop-components/micro-integrator/openapi_file.png)

By leveraging OpenAPI Support, you can optimize the way you test and manage your integrations, resulting in a more efficient development process and a smoother user experience.

## Work with third-party libraries

The use of third-party libraries in your Micro Integrator project can offer several advantages, such as enhanced functionality, improved integration capabilities, optimized performance, and reduced development time.

Here are some of the benefits of adding third-party JARs to the Micro Integrator:

 - Increased functionality: Third-party libraries can extend the core Micro Integrator distribution, allowing for greater flexibility and customization of integration solutions.
 - Enhanced integration capabilities: Third-party libraries enable the Micro Integrator to interact with existing systems such as databases or other APIs, improving overall integration capabilities.
 - Optimized performance: By offering optimized implementations of common functions, third-party libraries can improve the performance of the Micro Integrator.
 - Efficient development: Developers can avoid re-implementing commonly used functions, reducing development time and increasing efficiency.

To incorporate third-party libraries into your Micro Integrator project, create a new directory called `libs` at the
root of your project. If your project root and GitHub repository root are not the same, place the `libs` directory in
the project root. After adding the required JAR files to the `libs` directory, the Micro Integrator runtime will
automatically include them when deploying the component. This process ensures that any dependencies needed by your
integration flow are available at runtime.

In addition to `jar` libraries, you may also need to incorporate OSGi bundle JARs into your project. To do this,
create another directory called `dropins` at the root of your project. Similarly, if the project root and GitHub
repository root differ, place the `dropins` directory in the project root. Within the `dropins` directory, add the OSGi
bundle JAR files. The OSGI runtime will pick up these bundles during deployment, enabling you to utilize their
functionality within your Micro Integrator project.

![Libs directory](../assets/img/develop-components/micro-integrator/libs_dir.png)

## Importing custom certificates to MI

The feature enables Choreo MI users to import certificates into the MI `client-truststore.jks` file. This functionality
proves valuable when users need to establish connections with servers or services utilizing SSL/TLS encryption and
possessing self-signed certificates or certificates issued by private certificate authorities (CAs) that are not
automatically trusted. Importing the certificate to the MI `client-truststore.jks` file enables MI clients to establish secure connections with
the server or service seamlessly, eliminating SSL/TLS errors or warnings.

Before importing the certificate, it is necessary to obtain the certificate file, which can be in PEM or DER format. You
can get the certificate from the server or service provider or export it from a web browser. Certificates should be
added to the `/wso2mi/certs/` folder. Users need to verify that the mount path for the certificate file aligns with this
specific path.

1. In the Choreo console, select the component you wish to add a certificate to.
2. From the left navigation click **Deploy**.
3. Click on the **Configs and Secrets** tab.
4. Click **Create**.
5. Select **ConfigMap** as the **Config Type** and **File Mount** as the **Mount Type**.
6. Click **Next**.
7. Specify the following values as mount configurations:

    | **Field**       | **Value**                                              |                                    
    |-----------------|--------------------------------------------------------|
    | **Config Name** | An appropriate name for the certificate.             |
    | **Mount path**  | `/wso2mi/certs/<filename>`. For example, `/wso2mi/certs/certificate.crt` |

8. Click **Upload File** and attach the certificate.
9. Click **Create**.

## Working with sensitive data using MI Secure Vault

MI Secure Vault is a feature that allows users to securely store sensitive data, such as passwords and tokens, and
provide access to that data to MI Integrations. This feature provides an added layer of security to your integrations by
reducing the risk of accidental exposure of sensitive data.

To use MI Secure Vault to work with sensitive data, follow these steps:

1. Select the component from the Choreo Console.
2. From the left navigation, click Deploy.
3. Click on the **Configure and Deploy**.
4. Click on the **Add Environment Configurations**
5. Specify the following values as configurations:

    | **Field**       | **Value**                                 |                                    
    |-------------------------------------------|--------------------------------------------------------|
    | **Name** | An appropriate name for the secret/alias. |
    | **Value**       | Value for the secret                      |

6. Select **Mark as a Secret**.
7. Click **Add**.
8. Click **Deploy**.
9. Once the secret has been created, you can access it in your integration code using the following syntax:

```xml
<property name="secret_value_1" expression="wso2:vault-lookup('user_pass')" scope="default" type="STRING"/>
```
This code retrieves the secret named "user_pass" from the MI Secure Vault and stores it in the property named "
secret_value_1". You can then use this property in your integration code to access the secret value.

For more information on these features, see the [Accessing secrets](https://mi.docs.wso2.com/en/latest/install-and-setup/setup/security/encrypting-plain-text/#step-3-accessing-secrets) section of the MI Secure Vault documentation. By using MI
Secure Vault to store and access sensitive data in your integrations, you can ensure that your integrations
remain secure and protect sensitive data from unauthorized access.


## Scan third-party libraries to identify security vulnerabilities

Scanning third-party libraries for security vulnerabilities is essential for identifying potential weaknesses in an application that could be exploited by attackers. Taking a proactive approach to security helps organizations detect and mitigate risks before they can be exploited, preventing data breaches, system compromises, and other security incidents.

Choreo incorporates a security vulnerability scanning process during deployment. It uses Trivy to scan and detect critical vulnerabilities in third-party libraries added to the integration component. If the scan uncovers any critical vulnerabilities, the deployment process is halted. The deployment pane displays the Trivy scan status and any security failures in the Library (Trivy) vulnerable scan step, which can be accessed by clicking on it. Once the vulnerability has been addressed, you can redeploy the component.

## Customize WSO2 Micro Integrator preconfigured settings

Customizing WSO2 Micro Integrator Preconfigured Settings is essential for ensuring that the integration solution works optimally within the specific context of your organization. While WSO2 MI comes with preconfigured settings designed for general use, these settings may not be suitable for every organization's unique requirements. Customizing these settings can help optimize performance and ensure compatibility with your organization's systems and applications.

To customize the preconfigured settings of WSO2 MI instances running on Choreo, define a `deployment.toml` file in the GitHub repository subpath of your Micro Integrator project:

![deployment.toml](../assets/img/develop-components/micro-integrator/config_file.png)

!!! note
    If you change critical configuration parameters such as port offset and hostname, it can break internal communication.
    Therefore, the recommended approach is to update only the necessary configuration parameters.

Given below is a sample `deployment.toml` file that can be used to configure the JMS transport. For more information on WSO2 MI
configuration parameters, see the [MI Configuration Catalog](https://mi.docs.wso2.com/en/latest/reference/config-catalog-mi/).

```
[[transport.jms.sender]]
name = "myQueueSender"
parameter.initial_naming_factory = "org.apache.activemq.jndi.ActiveMQInitialContextFactory"
parameter.provider_url = "$env{JMS_PROVIDER_URL}"
parameter.connection_factory_name = "QueueConnectionFactory"
parameter.connection_factory_type = "queue"
parameter.cache_level = "producer"

[[transport.jms.listener]]
name = "myQueueListener"
parameter.initial_naming_factory = "org.apache.activemq.jndi.ActiveMQInitialContextFactory"
parameter.provider_url = "$env{JMS_PROVIDER_URL}"
parameter.connection_factory_name = "QueueConnectionFactory"
parameter.connection_factory_type = "queue"
parameter.cache_level = "consumer"
```

## Environment variables

Using environment variables is a recommended practice when developing integration artifacts with WSO2 Integration Studio, as it improves configuration management, security, portability, and manageability. By leveraging environment variables, organizations can streamline the management and maintenance of their integrations, ensuring that updates can be implemented quickly and efficiently.

The component's Deploy page provides a user-friendly interface to manage environment variables across different environments. For information on managing environment variables for complex use cases, see [Configurations and secrets](../devops-and-ci-cd/manage-configurations-and-secrets.md).

![Environment variables](../assets/img/develop-components/micro-integrator/env_variables.png)

Environment variables offer several benefits:

 - Configuration management: They simplify the process of managing and updating configuration settings, making it easier to maintain consistency across different environments.
 - Security: Environment variables help protect sensitive information by storing it securely and separating it from the main codebase.
 - Portability: By using environment variables, you can ensure that your integration artifacts can be easily migrated and deployed across various environments with minimal changes.
 - Manageability: Environment variables offer a centralized way to manage configuration settings, making it easier to update and maintain your integrations over time.

For a comprehensive list of parameters that can be configured as environment variables, see [WSO2 Micro Integrator documentation - Injecting Parameters - Supported parameters](https://mi.docs.wso2.com/en/latest/develop/injecting-parameters/#supported-parameters).

## Configure logging

Configuring logging is crucial when developing and maintaining a software system, as it can significantly improve efficiency during the development, testing, and maintenance phases of the software development process. Logging captures events and messages that occur during an application's execution, providing valuable insights for troubleshooting and debugging issues.

With Micro Integrator instances, you can configure and customize logging according to your requirements. Logging configurations can be added to each MI instance's environment, allowing you to fine-tune logging depending on the specific environment or deployment scenario.

To configure logging in MI instances, follow the steps given below: 

!!! tip
     You can use environment variables with specific naming conventions.

1. Start the variable name with `logging_level_` followed by the package or class name.
2. Replace the dot character in the package name with an underscore.
3. Set the variable value to the required logging level for the corresponding package or class.

    For example, to enable wire logs, change the logging level of the `org.apache.synapse.transport.http.wire` package to `debug`. 

To configure logging, set the environment variable as follows:

1. In the left navigation menu, click **Deploy** and then click **Configs & Secrets**. 
2. Click **+ Create**. 
3. Select **ConfigMap** as the **Config Type** and **Environment Variables** as the **Mount Type**. 
4. Click **Next**. 
5. Specify the following values as mount configurations:

    | **Field**       | **Value**                                              |                                    
    |-----------------|--------------------------------------------------------|
    | **Config Name** | An appropriate name for the configuration.             |
    | **Name**        | `logging_level_org_apache_synapse_transport_http_wire` |
    | **Value**       | `debug`                                                |

6. Click **Create**.

## Connectors

WSO2 Micro Integrator (MI) Connectors are prebuilt connectors designed to simplify integration between WSO2 MI and various other systems. They enable seamless connections to databases, message brokers, REST APIs, and more, allowing you to perform actions such as sending messages, executing queries, or retrieving data. These connectors are easy to use, making it straightforward to incorporate them into your WSO2 MI integration flows. Micro Integrator connectors are versatile and can be utilized in various integration scenarios, including data integration, service-oriented architecture (SOA) integration, and event-driven architecture (EDA) integration.

WSO2 Integration Studio is a comprehensive development environment that facilitates the creation of integration flows using WSO2 Micro Integrator Connectors. With Integration Studio, you can design and implement integration flows that connect diverse systems and execute various actions, such as sending messages, executing queries, or retrieving data. You can build integration flows using either prebuilt connectors provided by WSO2 MI or custom connectors developed using the Connector Development Toolkit. Integration Studio offers a graphical user interface that simplifies the process of building and testing integration flows while also providing a set of tools for managing and deploying these flows in a WSO2 MI runtime environment.

For more information, see the following topics in the WSO2 Micro Integrator documentation.

- [Connectors Overview](https://mi.docs.wso2.com/en/latest/reference/connectors/connectors-overview/)
- [Adding Connectors](https://mi.docs.wso2.com/en/latest/develop/creating-artifacts/adding-connectors/)

## Deploying integrations in Choreo 

WSO2 MI buildpack is where you can deploy integrations developed with WSO2 Micro Integrator as an API. In this preset, you have three different ways to define endpoints. Choreo gives priory to the definition of endpoints in the below-mentioned order. 

1. **Using component.yaml file**
This is the most flexible method to define endpoints. You can configure the endpoint details with the `component.yaml` configuration file. Place this file in the `.choreo` directory in the project path of the component. 
If the Micro Integrator project has inbound endpoints, you can expose them via different endpoints using the `component.yaml`file.

    To learn about the `component.yaml` file, see [Overview of the component.yaml file](../develop-components/manage-component-source-configurations.md#overview-of-the-componentyaml-file).

3. **Auto generating endpoints**
If `component.yaml` is not provided and if the source Micro Integrator project has APIs, Choreo scans the project and generates the API endpoints. If the project has few APIs, an endpoint will be generated for each API. The visibility of this auto-generated endpoint is set to `Public` by default. You can change the visibility in the deployment flow.

4. **Provide default endpoints**
If `component.yaml` is not provided and if the source Micro Integrator project doesn't have APIs, Choreo generates a default endpoint which will expose the default micro integrator port (8290) with `Public` visibility and wildcard context.

!!! note
    If you are currently using `component-config.yaml` or `endpoints.yaml` configuration files, see the respective [migration guide](../develop-components/manage-component-source-configurations.md#migration-guide) for instructions on migrating to the recommended `component.yaml` configuration file.

## Explore Choreo examples on GitHub

For a hands-on experience with MI-based integrations in Choreo, we recommend exploring our samples in Choreo Console. You can filter out the samples based on the buildpack `WSO2 MI`. This will point you to the samples in the [Choreo samples GitHub repository](https://github.com/wso2/choreo-samples)

### [Choreo samples - GitHub Repository](https://github.com/wso2/choreo-samples)

- **Fork the Repository**: Start by forking the repository to your account.

- **Explore & run**: Navigate through the different integration scenarios. Each example has a README.md with setup and execution instructions.



# Develop a Manual Task

This guide walks you through the steps to develop, deploy, test, and observe a manual task using Choreo.

In this guide, you will:

- Develop a manual task to fetch the weather forecast for a specified location for the next 24 hours from the [OpenWeatherMap](https://openweathermap.org) API.
- Process the weather data into a specific format.
- Send the formatted data to a specified email address.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

    !!! info "Repository File Structure"
        The sample code for this guide is in the `<sample-repository-dir>/weather-to-email-integration` directory. The following table describes the key files in the repository:

        | **File Path**         | **File Content**                                                     |
        | --------------------- | -------------------------------------------------------------------- |
        | **Ballerina.toml**    | Contains metadata about the project                                  |
        | **Dependencies.toml** | Lists the dependencies required for the project                      |
        | **main.bal**          | Contains the entry point of the project, including the main function |
        | **types.bal**         | Contains custom data types used in the project                       |
        | **utils.bal**         | Contains utility functions and helper functions used in the project  |

3. Go to [OpenWeatherMap](https://openweathermap.org/) and sign up to obtain an API key. For details, see the [OpenWeatherMap documentation](https://openweathermap.org/appid#signup).

## Step 1: Create a manual task component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Manual Task** card.
6. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:

        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

7. Enter the following information:

    | **Field**             | **Description**                                      |
    | ----------------------| -----------------------------------------------------|
    | **Organization**      | Your GitHub account                                  |
    | **Repository**        | `choreo-samples`                                     |
    | **Branch**            | `main`                                               |
    | **Component Directory** | `weather-to-email-integration`                       |

8. Select **Ballerina** as the **Build Pack**.

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Component Directory** specifies the location of the project to build the component.

4. Enter a unique name and description for the component. You can use the following values:

    | **Field**          | **Value**                        |
    | ------------------ | -------------------------------- |
    | **Component Name** | `WeatherToEmail`                 |
    | **Description**    | `My first manual task`           |


8. Click **Create**. Choreo initializes the component with the sample implementation and opens the **Overview** page of the component.

## Step 2: Build the manual task

1. In the left navigation menu, click **Build**.
2. In the **Builds** pane, click **Build**. This opens the **Commits** pane, where you can see all the commits related to the component.
3. Select the latest commit and click **Build**. This triggers the build process and displays the build progress in the **Build Logs** pane.

    !!! info
        The build process may take some time. Once complete, the build status will be listed in the **Builds** pane. Here, you will see the build status as **Success**.

## Step 3: Deploy the manual task

1. In the left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane, specify values for the configurable variables:

    !!! tip
        The configurable variables populated here are defined in the sample Ballerina project used in this guide. To learn how to declare configurable variables in Ballerina, see the [Ballerina documentation on declaring configurable variables](https://ballerina.io/learn/by-example/configurable-variables/).

    | **Field**     | **Value**                                                               |
    | ------------- | ----------------------------------------------------------------------- |
    | **apiKey**    | The API key you obtained in the prerequisites section                   |
    | **latitude**  | Latitude of the location to get the weather forecast                    |
    | **longitude** | Longitude of the location to get the weather forecast                   |
    | **email**     | The email address to receive the formatted weather forecast information |

    !!! note
        If you use **Ballerina** as the buildpack and want to set a configurable variable as a secret, click the lock icon corresponding to the configurable variable. This marks it as a secret and conceals the input value.

        For example, if you set the **apiKey** as a secret, its input value will be concealed. To update the input value later, click **Update Secret Content** and specify a new value.

4. Click **Deploy**.

## Step 4: Execute the manual task

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the task.

    !!! info "Inject Dynamic Values into Your Application as Command-Line Arguments"
        If you want to inject dynamic values into your application as command-line arguments when you run a manual task, follow these steps:
        1. Click the drop-down icon next to **Run Now** and then click **Run with Arguments**.
        2. In the **Runtime Arguments** pane, enter the arguments you want to pass to your application.
        3. Click **Execute**. This triggers the task with the specified arguments.

        The capability to run a manual task with arguments is supported for the following buildpacks:

        === "Dockerfile"
            To explore a Dockerfile-based manual task with arguments, try out the [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/docker-hello-world-manual-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on Docker projects, the **Run with Arguments** capability is not supported if the Dockerfile contains `CMD`. In such scenarios, use `ENTRYPOINT` to define your default commands.

        === "Go"
            To explore a Go-based manual task with arguments, try out the [Hello World Go Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-go-task) sample. For instructions, see the `readme.md` file in the sample repository.

        === "Java"
            To explore a Java-based manual task with arguments, try out the [Hello World Java Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-java-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on Java projects:
                - The **Run with Arguments** capability is not supported if `Procfile` is available in the project.
                - The `Main` class should be defined in the `manifest` file.
                - If Maven files such as `mvn.cmd` exist in the project without the `.mvn` directory, the build will fail. To ensure a successful build, either commit the `.mvn` directory along with any Maven files or exclude Maven files if you choose not to commit the `.mvn` directory.

        === "NodeJS"
            To explore a NodeJS-based manual task with arguments, try out the [Hello World NodeJS Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-nodejs-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on NodeJS projects:
                - The **Run with Arguments** capability is not supported if `Procfile` is available in the project.
                - The project root must contain the `package.json` file with the `main` attribute defined.

        === "WSO2 MI"
            To explore a WSO2 MI-based manual task with arguments, try out the [Weather to Logs Task](https://github.com/wso2/choreo-samples/tree/main/weather-to-logs-mi-manual-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on WSO2 MI projects and deploying a WSO2 MI integration as a manual task in Choreo, use the WSO2 MI automation mode. For details, see [Running the Micro Integrator in Automation Mode](https://apim.docs.wso2.com/en/latest/install-and-setup/install/running-the-mi-in-automation-mode/).

        === "Ballerina"
            To explore a Ballerina manual task with arguments, try out the [Weather to Email Task](https://github.com/wso2/choreo-samples/tree/main/weather-to-email-integration) sample. For instructions, see the README.md file in the sample repository.

            !!! info
                If you want to pass arguments to Ballerina main functions, use the **Run with Arguments** capability. For details on the arguments you can pass, see the [Ballerina documentation](https://ballerina.io/learn/by-example/main-function/). You can also override configurable values in the same manner. For more information, see [Provide values to configurable variables](https://ballerina.io/learn/provide-values-to-configurable-variables/#provide-via-command-line-arguments).

## Step 5: Test the manual task

Once the task is triggered, an email with the subject `[WSO2 Choreo Demo] Next 24H Weather Forecast` is sent from `choreo.demo@gmail.com` to the email address specified as the **email** configurable variable value in [Step 3](#step-3-deploy-the-manual-task).

If the manual task ran successfully, you should receive an email similar to the following:

![Received email](../../assets/img/develop-components/develop-a-scheduled-integration/Received-email.png)

## Step 6: Observe the manual task

The observability view in Choreo displays graphs that depict details such as throughput, latency, diagnostic data, and logs to identify and troubleshoot anomalies in components you deploy.

1. In the left navigation menu, click **Observability**.
2. Observe the following:
    - The throughput and latencies of requests served over a given period.
    - The logs generated over a given period.
    - The flame graph (Diagnostics View) generated over a given period.
    - The low-code diagram.

To learn more about the observability details you can view via Choreo observability, see [Observability Overview](../../monitoring-and-insights/observability-overview.md).

## Step 7: Monitor executions

To track and monitor executions associated with the deployed manual task, go to the left navigation menu and click **Execute**.

!!! tip
    The **Execute** view is applicable to both scheduled and manual tasks.

You can view the following information:

- **Total executions**: The total number of executions within the past 30 days.

    ![Total Execution](../../assets/img/develop-components/develop-a-scheduled-integration/total_executions.png)

- **Execution history**: The currently active executions and those that are already complete. You can view information such as the execution ID, the revision of the execution, and the time it was triggered.

    ![Execution History](../../assets/img/develop-components/develop-a-scheduled-integration/execution_history.png)

- **Detailed execution logs**: Click on an execution to view detailed logs related to it.

    !!! info
        It may take a few minutes for the logs to appear. You may need to manually refresh to view the latest logs.

    ![Execution Logs](../../assets/img/develop-components/develop-a-scheduled-integration/execution_logs.png)


# Develop a Scheduled Task

Choreo is a versatile integration platform that allows you to create various types of integrations depending on your requirements. If you need to automatically run a specific integration at regular intervals, you can use Choreo to develop a scheduled task. This type of integration can automate the synchronization of data between different systems at specified intervals, reducing errors and improving productivity by eliminating the need for manual intervention.

This guide walks you through the steps to develop, deploy, test, and observe a scheduled task using Choreo.

In this guide, you will:

- Develop a scheduled task to fetch the weather forecast for a specified location for the next 24 hours from the [OpenWeatherMap](https://openweathermap.org) API.
- Process the weather data into a specific format.
- Send the formatted data to a specified email address at a specific time every day.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

    !!! info "Repository File Structure"
        The sample code for this guide is in the `<sample-repository-dir>/weather-to-email-scheduled-task` directory. The following table describes the key files in the repository:

        | **File Path**         | **File Content**                                                     |
        | --------------------- | -------------------------------------------------------------------- |
        | **Ballerina.toml**    | Contains metadata about the project                                  |
        | **Dependencies.toml** | Lists the dependencies required for the project                      |
        | **main.bal**          | Contains the entry point of the project, including the main function |
        | **types.bal**         | Contains custom data types used in the project                       |
        | **utils.bal**         | Contains utility functions and helper functions used in the project  |

3. Go to [OpenWeatherMap](https://openweathermap.org/) and sign up to obtain an API key. For details, see the [OpenWeatherMap documentation](https://openweathermap.org/appid#signup).

## Step 1: Create a scheduled task component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Scheduled Task** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following information:

    | **Field**             | **Description**                                |
    | --------------------- | ---------------------------------------------- |
    | **Organization**      | Your GitHub account                            |
    | **Repository**        | `choreo-samples`                               |
    | **Branch**            | `main`                                         |
    | **Component Directory** | `weather-to-email-scheduled-task`              |

6. Select **Ballerina** as the build pack.

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Component Directory** specifies the location of the project to build the component.

7. Enter a unique name and description for the component. You can use the following values:

    | **Field**          | **Value**                        |
    | ------------------ | -------------------------------- |
    | **Component Name** | `WeatherToEmail`                 |
    | **Description**    | `My first scheduled task`        |

8. Click **Create**. Choreo initializes the component with the sample implementation and opens the **Overview** page of the component.

Now you can proceed to build and deploy the scheduled task.

## Step 2: Build the scheduled task

1. In the left navigation menu, click **Build**.
2. In the **Builds** pane, click **Build**. This opens the **Commits** pane, where you can see all the commits related to the component.
3. Select the latest commit and click **Build**. This triggers the build process and displays the build progress in the **Build Logs** pane.

    !!! info
        The build process may take some time. Once complete, the build status will be listed in the **Builds** pane. Here, you will see the build status as **Success**.

## Step 3: Deploy the scheduled task

1. In the left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane, specify values for the configurable variables:

    !!! tip
        The configurable variables populated here are defined in the sample Ballerina project used in this guide. To learn how to declare configurable variables in Ballerina, see the [Ballerina documentation on declaring configurable variables](https://ballerina.io/learn/by-example/configurable-variables/).

    | **Field**     | **Value**                                                               |
    | ------------- | ----------------------------------------------------------------------- |
    | **apiKey**    | The API key you obtained in the prerequisites section                   |
    | **latitude**  | Latitude of the location to get the weather forecast                    |
    | **longitude** | Longitude of the location to get the weather forecast                   |
    | **email**     | The email address to receive the formatted weather forecast information |

    !!! note
        If you use **Ballerina** as the buildpack and want to set a configurable variable as a secret, click the lock icon corresponding to the configurable variable. This marks it as a secret and conceals the input value.

        For example, if you set the **apiKey** as a secret, its input value will be concealed. To update the input value later, click **Update Secret Content** and specify a new value.

4. Click **Next**.
5. Define a schedule to run the task. In this guide, set the schedule to receive the weather information daily at 8:00 AM UTC. Enter the following values:

    | **Field**            | **Value**                                             |
    | -------------------- | ----------------------------------------------------- |
    | **Select Time Zone** | Select a time zone to schedule the task               |
    | **Select Range**     | **Day**                                               |
    | **Every**            | `1`                                                   |
    | **At**               | `08:00`                                               |

    !!! tip
        To test and verify the task immediately, you can schedule the deployment to run in just a few minutes after you create it. However, to avoid unnecessary expenses, reschedule or stop the deployment once you test and verify.

6. Click **Deploy**. This deploys the scheduled task to the development environment and indicates the **Scheduled Status** as **Active** in the **Development** card.

You can test the scheduled task when it runs at the configured time.

## Step 4: Test the scheduled task

When the scheduled task runs at the configured time, an email with the subject `[WSO2 Choreo Demo] Next 24H Weather Forecast` is sent from `choreo.demo@gmail.com` to the email address specified as the **email** configurable variable value in [Step 3](#step-3-deploy-the-scheduled-task).

If the scheduled task ran successfully, you should receive an email similar to the following:

![Received email](../../assets/img/develop-components/develop-a-scheduled-integration/Received-email.png)

## Step 5: Observe the scheduled task

The observability view in Choreo displays graphs that depict details such as throughput, latency, diagnostic data, and logs to identify and troubleshoot anomalies in components you deploy.

1. In the left navigation menu, click **Observability**.
2. Observe the following:
    - The throughput and latencies of requests served over a given period.
    - The logs generated over a given period.
    - The flame graph (Diagnostics View) generated over a given period.
    - The low-code diagram.

To learn more about the observability details you can view via Choreo observability, see [Observability Overview](../../monitoring-and-insights/observability-overview.md).

## Step 6: Monitor executions

To track and monitor executions associated with the deployed scheduled task, go to the left navigation menu and click **Execute**.

!!! tip
    The **Execute** view is applicable to both scheduled and manual tasks.

You can view the following information:

- **Total executions**: The total number of executions within the past 30 days.

    ![Total Execution](../../assets/img/develop-components/develop-a-scheduled-integration/total_executions.png)

- **Execution history**: The currently active executions and those that are already complete. You can view information such as the execution ID, the revision of the execution, and the time it was triggered.

    ![Execution History](../../assets/img/develop-components/develop-a-scheduled-integration/execution_history.png)

- **Detailed execution logs**: Click on an execution to view detailed logs related to it.

    !!! info
        It may take a few minutes for the logs to appear. You may need to manually refresh to view the latest logs.

    ![Execution Logs](../../assets/img/develop-components/develop-a-scheduled-integration/execution_logs.png)


# Develop an Event Handler

An event handler executes predefined actions in response to specific events. Choreo simplifies the process of creating and deploying such integrations.

This guide walks you through the steps to create and deploy an Event Handler using WSO2 MI and Choreo.

In this guide, you will build a simple event handler that monitors RabbitMQ for new messages and displays them once they become available.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Set up RabbitMQ:
    - Use an existing RabbitMQ instance or start a new [RabbitMQ](https://www.rabbitmq.com/download.html) instance on a server that can be accessed via the internet.
    - Obtain the `username`, `hostname`, `password`, and `vhost` from the RabbitMQ instance to use later as environment variables.

3. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

## Step 1: Create an event handler component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Event Handler** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following information:

    | **Field**             | **Description**              |
    |-----------------------|----------------------------- |
    | **Organization**      | Your GitHub account          |
    | **Repository**        | `choreo-samples`             |
    | **Branch**            | `main`                       |
    | **Component Directory** | `mi-rabbitmq-listener`       |

6. Select **WSO2 MI** as the build pack. (since you are creating the REST API from a [WSO2 Integration Studio](https://wso2.com/micro-integrator/) project)

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Component Directory** specifies the location of the project to build the component.

7. Enter a unique name and description for the component. You can use the following values:

    | **Field**          | **Value**              |
    |--------------------|------------------------|
    | **Component Name** | `SalesOrderListener`   |
    | **Description**    | `RabbitMQ integration` |

8. Click **Create**.

## Step 2: Deploy the integration

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**.
3. In the **Configurations** pane, click **+ Add** corresponding to **Environment Variables** and add the following environment variables:

    !!! tip
        Use the values from your RabbitMQ instance as per the [Prerequisites](#prerequisites) section for the environment variables.

    | **Name**     | **Value**                                         |
    | ------------- |--------------------------------------------------|
    | **HOSTNAME**  | Hostname of your RabbitMQ server                 |
    | **VHOST**     | Virtual hostname of your RabbitMQ server         |
    | **USERNAME**  | Username for connecting to RabbitMQ              |
    | **PASSWORD**  | Password associated with the RabbitMQ username   |

4. Click **Deploy**. This deploys the event handler to the development environment and indicates the **Deployment Status** as **Active** in the **Development** card.

## Step 3: Test the integration

1. Send a sales order message to the **SalesOrderQueue** on the RabbitMQ server. You can send a sample sales order message similar to the following:

    ```json
    {
        "order_id": "12345",
        "customer_name": "John Doe",
        "product": "Widget",
        "quantity": 10,
        "total_amount": 100.00
    }
    ```

2. Observe the logs:
    - In the left navigation menu, click **Logs** and then click **Runtime Logs**. You will see the order message in the logs.

Now you have gained hands-on experience in creating, configuring, and deploying an event handler.


# Develop an Integration with Integration Studio

Choreo simplifies the process of building, deploying, and managing integration components, making it easy to expose integrations as APIs. This guide walks you through the steps to expose an integration created in WSO2 Integration Studio as an API in Choreo.

In this guide, you will:
- Create a component to expose a sample integration from the [Choreo samples repository](https://github.com/wso2/choreo-samples) as an API.
- Deploy, test, and observe the integration component.
- Publish the integration component as an API to the Choreo Developer Portal.

!!! note
    - To develop integrations for **Manual Task** and **Schedule Task** components in Choreo, use the **automation mode** in the WSO2 Micro Integrator. See [Running MI in Automation Mode](https://apim.docs.wso2.com/en/4.2.0/install-and-setup/install/running-the-mi-in-automation-mode/).
    - For other component types (Service, webhook, event-handler, etc.), use the **server mode**.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    - Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    - Enter a unique organization name. For example, `Stark Industries`.
    - Read and accept the privacy policy and terms of use.
    - Click **Create**. This creates the organization and opens the **Project Home** page.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

## Step 1: Create the integration component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the **Project Home** page.

2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following repository details:

    | **Field**             | **Description**              |
    |-----------------------|----------------------------- |
    | **Organization**      | Your GitHub account          |
    | **Repository**        | `choreo-samples`            |
    | **Branch**            | **`main`**                   |
    | **Component Directory** | `hello-world-mi`             |

6. Select WSO2 MI as the build pack (since you're creating the REST API from a [WSO2 Integration Studio](https://wso2.com/micro-integrator/) project).

7. Provide a unique name and description for the component:

    | **Field**          | **Value**              |
    |--------------------|------------------------|
    | **Component Name** | `Hello World`          |
    | **Description**    | `Hello World REST API` |

8. Click **Create**. Choreo initializes the component with the sample integration.

## Step 2: Deploy the integration component

1. In the Choreo Console left navigation menu, click **Deploy**.

2. Configure and deploy:
   - In the **Build Area** card, click **Configure & Deploy**.
   - In the **Configurations** pane, click **Next**. This displays the endpoint details ready for deployment.
   - Click **Deploy**. This deploys the integration component to the development environment.

    !!! tip
        - Choreo uses [endpoints](../../choreo-concepts/endpoint.md) to expose **Service** components to the network. Learn more about configuring endpoints in [Configure Endpoints](../configure-endpoints.md).
        - Automatic deployment is enabled by default, so only the first deployment needs to be done manually.

   The **Development** card shows the **Deployment Status** as **Active** when the integration is successfully deployed.

## Step 3: Test the integration

1. In the Choreo Console left navigation menu, click **Test** and then click **Console**.
2. In the OpenAPI Console, select **Development** from the environment drop-down list.
3. Expand the **GET /integration** operation.
4. Click **Try it out**, then click **Execute**. This sends a request to your deployed integration.
5. Check the response:
    - In the **Response body** section, observe the response. If the integration works as expected, you should see:
     
     ```json
     {"Hello" : "Integration"}
     ```

## Step 4: Observe the integration

1. Click **Observability** in the left navigation menu to monitor the performance of the integration component.

2. View metrics:
   - Observe throughput and latencies of requests over time.
   - View logs generated during a specific period.
   - Analyze the flame graph (Diagnostics View) for performance insights.

   For more details, see [Observability Overview](../../monitoring-and-insights/observability-overview.md).

## Step 5: Publish the integration component

1. In the Choreo Console left navigation menu, click **Manage** and then click **Lifecycle**.
2. The **Lifecycle Management** pane shows the current lifecycle stage as **Created**.
3. Click **Publish**. This changes the lifecycle stage to **Published** and exposes the integration as an API in the Choreo Developer Portal.
   - To view the published API, click **Go to Devportal**. In the Developer Portal, you can manage subscriptions and generate access tokens for testing.

Now you have successfully exposed an integration designed in WSO2 Integration Studio as a REST API in Choreo!


# Develop an API Proxy from a GitHub Repository Source

An API proxy acts as an intermediary between an existing API and Choreo, intercepting all requests made to the API. It also functions as a managed API, allowing you to apply essential API management features such as security policies and rate limiting.

In this guide, you will:

- Create an API proxy component to expose an existing API.
- Deploy the API proxy.
- Test the API proxy to verify its functionality.
- Manage the API.
- Consume the API.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample proxy source](https://github.com/wso2/choreo-samples/tree/main/department-api-proxy-from-github).  

## Step 1: Create an API proxy

You can create an API proxy either by selecting the source from a GitHub repository, uploading an OpenAPI specification file, or providing an OpenAPI specification URL. This guide demonstrates how to create an API proxy using a GitHub repository as the source.

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **API Proxy** card. This opens the **Create an API Proxy** pane.

4. Click on **Authorize With GitHub** card under **Connect a Git Repository** section to connect your GitHub account.
    - If you haven’t connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
         - Read and write access to code and pull requests.
         - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.    

5. Enter the following repository details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **Repository**         | choreo-samples     |
    | **Branch**             | **`main`**         |
    | **API Directory**      | /department-api-proxy-from-github |

    !!! note
        To select the relevant directory, click on the **Edit** action next to the **API Directory** input field. Then, enter `department-api-proxy-from-github` as the directory name to quickly search and locate the correct directory.

6. Specify the following values as Proxy Metadata:

    !!! info
        The **Context** field must be unique and cannot be changed after creation.**Version** and **Target** are mandatory fields. **Target** can be changed at any time after the creation.

    | **Field**       | **Value**                                  |
    |-----------------|--------------------------------------------|
    | **Context**     | `department-service`                                   |
    | **Version**     | `v1.0`                                      |
    | **Target**      | `https://samples.choreoapps.dev/company/hr`|

7. Specify the following values as Component Details:

    !!! info
        The **Component Name** field must be unique and cannot be changed after creation. This value is automatically generated, but you can edit it if necessary.
        **Component Display Name** is a required field.

    | **Field**       | **Value**                                  |
    |-----------------|--------------------------------------------|
    | **Component Display Name**| `Department Service`                    |
    | **Component Name**        | `department-service`                    |
    | **Description**           | `This is a sample proxy for department service`     |    

8. Click **Create**. This creates the API proxy component and takes you to the **Build** page.

!!! note
    When you create an API proxy from a GitHub repository source, the GitHub source serves as the single source of truth. Therefore, any modifications, such as adding or deleting resources, must be made through the GitHub repository.

## Step 2: Build

!!! info
    The initial build starts automatically when you create the API proxy, and you will be redirected to the **Build** page. In this case, you can skip the steps below. If you need to manually trigger a build later, follow these steps.

1. On the project home page, click on the `Department Service` component you created. This takes you to the component overview page.
2. In the left navigation menu, click **Build**.
3. On the **Build** page, click **Build Latest**.

!!! note
    The build process may take some time. You can track progress in the **Build Details** pane. Once complete, the build status changes to **Success**.

## Step 3: Deploy the API proxy

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**. This opens the **Configure & Deploy** pane.
3. Select **External** as the **API Access Mode** and click **Deploy**. The **Development** card indicates the **Deployment Status** as **Active** when the API proxy is successfully deployed.

Now you are ready to test the API proxy.

## Step 4: Test the API proxy

Choreo allows you to test your API proxy using either the [integrated OpenAPI Console](../../testing/test-rest-endpoints-via-the-openapi-console.md) or [cURL](../../testing/test-apis-with-curl.md). In this guide, you will use the OpenAPI Console.

!!! tip
    Choreo enables OAuth 2.0 to secure APIs by default. Therefore, you need an access token to invoke an API.

    - Choreo automatically generates a key to test the API via the OpenAPI Console. To view the key, click the show key icon in the **Security Header** field.
    - To disable security for the entire API or a specific resource:
        1. In the left navigation menu, click **Deploy**.
        2. Go to the **Build Area** card and click **Security Settings**.
        3. In the **Security Settings** pane:
            - To disable security for the entire API, clear the **OAuth2** checkbox.
            - To disable security for a specific resource, expand the relevant resource and turn off the **Security** toggle.
        4. Click **Apply**.

1. In the left navigation menu, click **Test** and then click **OpenAPI Console**.
2. Select **Development** from the environment drop-down list.
3. Expand the `GET /department/{departmentId}` resource and click **Try it Out**.
4. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

    ![API proxy response](../../assets/img/develop-components/develop-a-rest-api-proxy/rest-api-proxy-response.png){.cInlineImage-full}

    This indicates that your API proxy is working as expected.

## Step 5: Manage the API proxy

Now that you have a tested API proxy, you can publish it and make it available for application developers to consume. In this guide, you will apply rate limiting to the API and publish it.

### Step 5.1: Apply rate limiting to the API proxy

1. In the left navigation menu, click **Deploy**.
2. Go to the required environment card and click the settings icon corresponding to **API Configuration**.
3. In the **CORS, Rate Limiting and Resiliency** pane, click **Rate Limiting** to expand the section.
4. Select **API Level** as the **Rate Limiting Level**.
5. Specify appropriate values for the **Request Limit** and **Time Unit** fields. You can proceed with the default values.
6. Click **Apply**. This applies the rate limiting level to the API proxy and redeploys it.

### Step 5.2: Publish the API proxy

1. In the left navigation menu, click **Lifecycle** under **Manage**. This takes you to the **Lifecycle** page.
2. Click **Publish**.
3. In the **Publish API** dialog, click **Confirm** to proceed with publishing the API. If you want to change the display name, make the necessary changes and then click **Confirm**. This changes the API lifecycle state to **Published**.

## Step 6: Invoke the API

To generate credentials for the published API and invoke it via the Choreo Developer Portal, follow these steps:

1. In the **Lifecycle** page, click **Go to Devportal**. This takes you to the `Department Service` in the Choreo Developer Portal.

2. **Invoke the API**:
    1. In the Developer Portal left navigation menu, click **Try Out**.
    2. In the **Endpoint** list, select **Development** as the environment to try out the API.
    3. Click **Get Test Key** to generate an access token.
    4. Expand the `GET /department/{departmentId}` resource and click **Try it out**.
    5. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

        ![Try out response](../../assets/img/develop-components/develop-a-rest-api-proxy/try-out-response.png){.cInlineImage-full}

Now, you have gained hands-on experience creating, deploying, testing, and publishing an API proxy using Choreo.


# Develop an API Proxy from Scratch

An API proxy acts as an intermediary between an existing API and Choreo, intercepting all requests made to the API. It also functions as a managed API, allowing you to apply essential API management features such as security policies and rate limiting.

In this guide, you will:

- Create an API proxy component to expose an existing API.
- Deploy the API proxy.
- Test the API proxy to verify its functionality.
- Manage the API.
- Consume the API.

## Prerequisites

- If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

## Step 1: Create an API proxy

To create an API proxy, you can either upload an OpenAPI specification or provide an OpenAPI specification URL. In this guide, you will specify a URL to an OpenAPI definition of a sample API.

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **API Proxy** card. This opens the **Create an API Proxy** pane.
4. Select **Creare from Scratch** option. 
5. Specify the following values as Proxy Metadata:

    | **Field**       | **Value**                                  |
    |-----------------|--------------------------------------------|
    | **Context**     | `department-service`                                   |
    | **Version**     | `v1.0`                                      |
    | **Target**      | `https://samples.choreoapps.dev/company/hr` |

6. Enter following details for the Component Details:

    !!! info
        The **Component Name** field must be unique and cannot be changed after creation.

    | **Field**                 | **Value**          |
    |---------------------------|--------------------|
    | **Component Display Name**| `Department Service`          |
    | **Component Name**        | `department-service`          |
    | **Description**           | `Sample proxy for department service`     |

7. Click **Create**. This creates the API proxy component and takes you to the **Deploy** page.

## Step 2: Define resources for the API proxy

To add a new resource that retrieves a department by the department ID, follow these steps:

1. In the left navigation menu, click **Develop** and then click **Resources**.
2. Select **GET** as the **HTTP Verb** and enter `/department/{departmentId}` as the **URI Pattern**.
3. Click **+** to add the resource.
4. Expand the added resource and specify the following values:

    | **Field**        | **Value**                            |
    |------------------|--------------------------------------|
    | **Operation ID** | `findDepartment`                     |
    | **Description**  | `Find a department by department ID` |

5. Remove the five default resources that start with `/*` by clicking the delete icon corresponding to each resource.
6. Click **Save**.

## Step 3: Deploy the API proxy

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**. This opens the **Configure & Deploy** pane.
3. Select **External** as the API access mode and click **Deploy**. The **Development** card indicates the **Deployment Status** as **Active** when the API proxy is successfully deployed.

Now you are ready to test the API proxy.

## Step 4: Test the API proxy

Choreo allows you to test your API proxy using either the [integrated OpenAPI Console](../../testing/test-rest-endpoints-via-the-openapi-console.md) or [cURL](../testing/test-apis-with-curl.md). In this guide, you will use the OpenAPI Console.

!!! tip
    Choreo enables OAuth 2.0 to secure APIs by default. Therefore, you need an access token to invoke an API.

    - Choreo automatically generates a key to test the API via the OpenAPI Console. To view the key, click the show key icon in the **Security Header** field.
    - To disable security for the entire API or a specific resource:
        1. In the left navigation menu, click **Deploy**.
        2. Go to the **Build Area** card and click **Security Settings**.
        3. In the **Security Settings** pane:
            - To disable security for the entire API, clear the **OAuth2** checkbox.
            - To disable security for a specific resource, expand the relevant resource and turn off the **Security** toggle.
        4. Click **Apply**.

1. In the left navigation menu, click **Test** and then click **OpenAPI Console**.
2. Select **Development** from the environment drop-down list.
3. Expand the `GET /department/{departmentId}` resource and click **Try it Out**.
4. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

    ![API proxy response](../../assets/img/develop-components/develop-a-rest-api-proxy/rest-api-proxy-response.png){.cInlineImage-full}

    This indicates that your API proxy is working as expected.

## Step 5: Manage the API proxy

Now that you have a tested API proxy, you can publish it and make it available for application developers to consume. In this guide, you will apply rate limiting to the API and publish it.

### Step 5.1: Apply rate limiting to the API proxy

1. In the left navigation menu, click **Deploy**.
2. Go to the required environment card and click the settings icon corresponding to **CORS, Rate Limiting and Resiliency**.
3. In the **CORS, Rate Limiting and Resiliency** pane, click **Rate Limiting** to expand the section.
4. Select **API Level** as the **Rate Limiting Level**.
5. Specify appropriate values for the **Request Limit** and **Time Unit** fields. You can proceed with the default values.
6. Click **Apply**. This applies the rate limiting level to the API proxy and redeploys it.

### Step 5.2: Publish the API proxy

1. In the left navigation menu, click **Lifecycle** under **Manage**. This takes you to the **Lifecycle** page.
2. Click **Publish**.
3. In the **Publish API** dialog, click **Confirm** to proceed with publishing the API. If you want to change the display name, make the necessary changes and then click **Confirm**. This changes the API lifecycle state to **Published**.

## Step 6: Invoke the API

To generate credentials for the published API and invoke it via the Choreo Developer Portal, follow these steps:

1. In the **Lifecycle** page, click **Go to Devportal**. This takes you to the `Department Service` in the Choreo Developer Portal.

2. **Invoke the API**:
    1. In the Developer Portal left navigation menu, click **Try Out**.
    2. In the **Endpoint** list, select **Development** as the environment to try out the API.
    3. Click **Get Test Key** to generate an access token.
    4. Expand the `GET /department/{departmentId}` resource and click **Try it out**.
    5. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

        ![Try out response](../../assets/img/develop-components/develop-a-rest-api-proxy/try-out-response.png){.cInlineImage-full}

Now, you have gained hands-on experience creating, deploying, testing, and publishing an API proxy using Choreo.

# Develop a Ballerina Service

Choreo allows you to develop and deploy applications using your preferred programming language. This guide demonstrates how to deploy a service component that exposes a REST API using the [Ballerina language](https://ballerina.io/). No prior knowledge of Ballerina is required to follow this guide.

A REST API is a web service that adheres to Representational State Transfer (REST) principles, using HTTP methods to access and manage resources. This guide walks you through building a Ballerina service component, deploying it on Choreo, and testing it with an HTTP client application.

In this guide, you will:

 - Build a simple greeting service using a sample implementation. The service has a single resource named `greet` that accepts a query parameter as input.
 - Deploy the service in Choreo.
 - Test the service.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    - Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    - Enter a unique organization name. For example, `Stark Industries`.
    - Read and accept the privacy policy and terms of use.
    - Click **Create**. This creates the organization and opens the **Project Home** page.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample greetings service](https://github.com/wso2/choreo-samples/tree/main/greeting-service) implementation in Ballerina.

### Learn the repository file structure

It’s important to understand the purpose of key files in the sample service. The table below provides an overview of each file in the greeter service:

!!! note
    The file paths are relative to `<sample-repository-dir>/greeting-service`.

| **Filepath**              | **Description**                                                |
|---------------------------|---------------------------------------------------------------|
| `service.bal`             | The greetings service code written in Ballerina.               |
| `tests/service_test.bal`  | Test files related to the `service.bal` file.                  |
| `Ballerina.toml`          | The Ballerina configuration file.                              |

Let’s get started!

## Step 1: Create a service component

To create a Ballerina service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the **Project Home** page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect your GitHub account. If you haven’t connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Provide the following repository details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **Repository**         | choreo-samples     |
    | **Branch**             | **`main`**         |
    |**Component Directory** | `/greeting-service` |

6. Select **Ballerina** as the buildpack.

7. Provide a display name, a unique name, and a description for the service component:

    !!! info
        The **Component Name** field specifies a unique identifier for the component. This name cannot be changed after creation.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Ballerina Greetings`   |
    | **Component Name**        | `ballerina-greetings`   |
    | **Description**           | Send greetings          |

8. Click **Create**. This creates the component and takes you to the **Overview** page.

You have successfully created a service that exposes a REST API written in Ballerina. Next, let’s build and deploy the service.

## Step 2: Build and deploy

Now that you’ve connected the source repository and configured the endpoint details, it’s time to build and deploy the service.

!!! note
    If you’re rebuilding the Ballerina service component after changing the Ballerina version, ensure that the version in the `Ballerina.toml` file matches the version in the `Dependencies.toml` file.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service may take a while. Track the progress via the logs in the **Build Details** pane. Once complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps:

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane, click **Next** to skip the configuration.
4. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service may take a while. Once deployed, the **Development** environment card shows the **Deployment Status** as **Active**.

Once deployed, you can test, manage, and observe the service like any other component in Choreo.

For detailed instructions, see the following sections:
- [Step 3: Test](../../testing/test-rest-endpoints-via-the-openapi-console.md)
- [Step 4: Manage](../../api-management/lifecycle-management.md)

## Manage the deployment

To view Kubernetes-level insights for detailed diagnosis of this Ballerina REST API, see Choreo’s [DevOps capabilities](../../devops-and-ci-cd/view-runtime-details.md).


# Develop a Service with Docker

Choreo allows you to create and deploy applications in any language. This guide demonstrates how to develop and deploy a containerized service component using a Dockerfile.

In this guide, you will:

 - Create a containerized service component using a sample service implementation. The sample service has a single resource named `greet` that accepts a query parameter as input.
 - Deploy the service in Choreo using a Dockerfile. The service will run on port 9090.
 - Test the service.

If you want to create a service component that exposes a Ballerina service, see [Develop a Ballerina Service](develop-a-ballerina-service.md).

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    - Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    - Enter a unique organization name. For example, `Stark Industries`.
    - Read and accept the privacy policy and terms of use.
    - Click **Create**. This creates the organization and opens the **Project Home** page.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample greetings service](https://github.com/wso2/choreo-samples/tree/main/greeting-service-go) implementation with the Dockerfile.

### Learn the repository file structure

It’s important to understand the purpose of key files in the sample service. The table below provides an overview of each file in the greeter service:

!!! note
    The file paths are relative to `<sample-repository-dir>/greeting-service-go`.

| **Filepath**               | **Description**                                                              |
|----------------------------|------------------------------------------------------------------------------|
| `main.go`                  | The Go-based greeter service code.                                           |
| `Dockerfile`               | The Dockerfile to build the container image of the application.              |
| `.choreo/component.yaml`   | Choreo-specific configuration that provides information about how Choreo exposes the service. |
| `openapi.yaml`             | The OpenAPI contract of the greeter service. This is required to publish the service as a managed API. This file is referenced by the `.choreo/component.yaml` file. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints. The greeter service runs on port 9090. To securely expose the service through Choreo, you must provide the port and other required information in the `component.yaml` file. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

In the greeter sample, the `component.yaml` file is located in the `greeting-service-go/.choreo/` directory.

## Step 1: Create a service component from a Dockerfile

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/cloud-native-app-developer) and sign in. This opens the **Project Home** page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect your GitHub account. If you haven’t connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
         - Read and write access to code and pull requests.
         - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following repository details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **Repository**         | choreo-samples     |
    | **Branch**             | `main`         |
    | **Component Directory** | `/greeting-service-go`         |

6. Select **Docker** as the buildpack.
7. Enter the following details:

    | **Field**                | **Value**                        |
    |--------------------------|----------------------------------|
    | **Dockerfile**           | `/greeting-service-go/Dockerfile`|

    !!! info
        1. To successfully build your container with Choreo, explicitly define a user ID (UID) under the `USER` instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-sample-apps/blob/main/go/greeter/Dockerfile).
           - A valid User ID is a numeric value between 10000-20000 (e.g., `10001` or `10500`).
           - Usernames are invalid and should not be used (e.g., `my-custom-user-12221` or `my-custom-user`).

        2. The Dockerfile used in this guide is a multi-stage Dockerfile, which keeps the final image size small and allows building the application with specific versions of tools and libraries.

8. Provide a display name, a unique name, and a description for the service component:

    !!! info
        The **Component Name** field specifies a unique identifier for the component. This name cannot be changed after creation.

    | **Field**                 | **Value**          |
    |---------------------------|--------------------|
    | **Component Display Name**| `Greetings`        |
    | **Component Name**        | `greetings`        |
    | **Description**           | Send greetings     |

9. Click **Create**. This creates the component and takes you to the **Overview** page.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you’ve connected the source repository and configured the endpoint details, it’s time to build the service and create an image. Then, you can deploy the image and test the greeter service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service may take a while. Track the progress via the logs in the **Build Details** pane. Once complete, the build status changes to **Success**.

    You can access the following scans under **Build**:
    - **Dockerfile Scan**: Choreo checks if a non-root user ID is assigned to the Docker container for security. If no non-root user is specified, the build will fail.
    - **Container (Trivy) Vulnerability Scan**: This detects vulnerabilities in the final Docker image. If critical vulnerabilities are found, the build will fail.

    !!! info
        If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps:

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service may take a while. Once deployed, the **Development** environment card shows the **Deployment Status** as **Active**.

Once deployed, you can [test](../../testing/test-rest-endpoints-via-the-openapi-console.md), [manage](../../api-management/lifecycle-management.md), and [observe](../../monitoring-and-insights/observability-overview.md) the service like any other component in Choreo.

To view Kubernetes-level insights for detailed diagnosis of this Dockerfile-based REST API, see [Choreo's DevOps capabilities](../../devops-and-ci-cd/view-runtime-details.md).


# Develop a Service

Choreo allows you to create and deploy applications in your preferred programming language. 

In this guide, you will:

- Build a simple greeting service using a sample service implementation. The sample implementation will have a single resource named `greet` that accepts a single query parameter as input.
- Deploy the service in Choreo using a `Go` buildpack. The service will run on port 9090.
- Test the service.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample greetings service](https://github.com/wso2/choreo-samples/tree/main/greeting-service-go) implementation in `Go`.

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the greeter service:

!!! note 
    The specified file paths are relative to `<sample-repository-dir>/greeting-service-go`.

| **Filepath**             | **Description**                                                               |
|--------------------------|-------------------------------------------------------------------------------|
| `main.go`                | The Go-based greeter service code.                                            |
| `.choreo/component.yaml` | Choreo-specific configuration that provides information about how Choreo exposes the service. |
| `openapi.yaml`           | The OpenAPI contract of the greeter service. This is required to publish the service as a managed API. This `openapi.yaml` file is referenced by the `.choreo/component.yaml` file. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints. To run the greeter service on port 9090 and securely expose it through Choreo, you must provide the port and other required information in the `component.yaml` file. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

In the greeter sample, the `component.yaml` file is located in the `greeting-service-go/.choreo/` directory.

## Step 1: Create a service component

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Public Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Under **Connect a Git Repository**, enter the following details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **GitHub Repository**  | choreo-samples     |
    | **Branch**             | main               |
    | **Component Directory** | `/greeting-service-go` |

6. Select **Go** as the buildpack.
7. Enter the following details:

    | **Field**                | **Value**              |
    |--------------------------|------------------------|
    | **Language Version**     | 1.x                    |

8. Provide component display name, name and description:

    !!! info
        The **Component Name** field must be unique and cannot be changed after creation.

    | **Field**                 | **Value**          |
    |---------------------------|--------------------|
    | **Component Display Name**| Greetings          |
    | **Component Name**        | greetings          |
    | **Description**           | Send greetings     |

9. Click **Create**. This creates the component and lists it under **Component Listing** on the project home page.

You have successfully created the service. The next step is to build and deploy it.

## Step 2: Build and deploy

Now that you have connected the source repository and configured the endpoint details, it's time to build and deploy the greeter service.

### Step 2.1: Build

1. On the project home page, click on the `Greetings` component you created. This takes you to the component overview page.
2. In the left navigation menu, click **Build**.
3. On the **Build** page, click **Build Latest**.

    !!! note
        The build process may take some time. You can track progress in the **Build Details** pane. Once complete, the build status changes to **Success**.

### Step 2.2: Deploy

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take some time. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

Once you have successfully deployed the service, you can [test](../../testing/test-rest-endpoints-via-the-openapi-console.md), [manage](../../api-management/lifecycle-management.md), and [observe](../../monitoring-and-insights/observability-overview.md) it like any other component type in Choreo.


# Expose a Ballerina GraphQL Endpoint via a Service

Choreo offers the flexibility to develop and deploy applications in a language of your preference. This guide shows you how to deploy a service component that exposes a GraphQL API using the Ballerina language in Choreo. No prior knowledge of the Ballerina language is required to follow this guide. 

GraphQL API is a query language and runtime that provides a single endpoint for retrieving flexible and efficient data in a strongly-typed and self-documenting way. By following this guide, you will build a service component in Ballerina and deploy it on Choreo for any GraphQL client application to utilize it.

This guide shows how to build a simple reading list service and deploy it in Choreo using Ballerina. The GraphQL endpoint you create in this guide has two operations: **Query** and **Mutation**. The Query type operations read the data in the data source, and the Mutation operations update the data in the data source. The reading list service has two queries and three mutations as follows:

### Queries

**Retrieve the reading list**

This resource accepts an optional filter, `status`, which filters the reading list by reading status. Accepted values for status are `reading`, `read`, and `to_read`.

**Sample request**:
```
$ curl -X POST -H "Content-Type: application/json" -d '{"query": "query {allBooks (status: \"reading\") { id title author status }}"}' http://localhost:8090
```

**Sample response**
```
$ {
  "data": {
    "allBooks": [
      {
        "id": 1,
        "title": "Sample Book",
        "author": "Test Author",
        "status": "to_read"
      }
    ]
  }
}
```

**Retrieve a book item from the reading list**

This resource accepts a filter, `id`, which will select the book item from the reading list by book id.  The id is an Integer value. 

**Sample request**
```
$ curl -X POST -H "Content-Type: application/json" -d '{"query": "query {book (id: 1) { id title author status }}"}' http://localhost:8090
```

**Sample response**
```
$ {
  "data": {
    "book": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "to_read"
    }
  }
}
```

### Mutations

**Add a book item to the reading list**

This remote function accepts a book record as the input and consists of the title and the author. When you add a new book to the reading list, the method updates the reading status of the newly added book to `to_read`. This method returns the added book item upon successful execution.


**Sample request**

```
$ curl -X POST -H "Content-type: application/json" -d '{ "query": "mutation { addBook(book: {title: \"Sample Book\", author: \"Test Author\"}) { id title author status } }" }' 'http://localhost:8090'
```

**Sample response**

```
$ {
  "data": {
    "addBook": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "to_read"
    }
  }
}
```

**Update the reading status of a book**

This remote function requires `id` and `status` as inputs to update the reading status of the selected book. The `id` refers to the id of the book. It is an integer.  The `status` refers to the reading status that needs to be updated. This method returns the updated book item upon successful execution.

**Sample request**

```
$ curl -X POST -H "Content-type: application/json" -d '{ "query": "mutation { setStatus(id: 1, status: \"reading\") { id title author status } }" }' 'http://localhost:8090'
```

**Sample response**

```
$ {
  "data": {
    "setStatus": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "reading"
    }
  }
}
```

**Delete a book item from the reading list**

This remote function requires the `id` as the input to delete the book item from the reading list. This method returns the removed book item upon successful execution.

**Sample request**

```
$ curl -X POST -H "Content-type: application/json" -d '{ "query": "mutation { deleteBook(id: 1) { id title author status } }" }' 'http://localhost:8090'
```

**Sample response**
```
$ {
  "data": {
    "deleteBook": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "reading"
    }
  }
}
```

Our next step is to set up the resources that you will require to follow the guide, including the sample reading list application and the Choreo GitHub app.

## Prerequisites

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample GraphQL service](https://github.com/wso2/choreo-samples/tree/main/reading-list-graphql) implementation for this guide.

Let's get started!

## Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the reading list service.

!!! note
    The following file paths are relative to the path `<sample-repository-dir>/reading-list-graphql`.

|Filepath                 | Description                                                     |
|-------------------------|-----------------------------------------------------------------|
| `service.bal`           | The reading list service code written in the Ballerina language.|
| `Ballerina.toml`        | The Ballerina configuration file.                               |
| `.choreo/component.yaml`| The configuration file with endpoint details.                   |

## Step 1: Create a service component 

To create a Ballerina service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**| `reading-list-graphql`    |.

6. Select **Ballerina** as the buildpack.

7. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Ballerina Reading List`|
    | **Component Name**        | `ballerina-reading-list`|
    | **Description**           | Manage a reading list   |

8. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service component that exposes a GraphQL API written in the Ballerina language. Next, let's build and deploy the service.

## Step 2: Build and deploy

Now that we have connected the source repository, it's time to build and deploy the reading list service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Configurations** pane that opens, click **Next** to skip the configuration.
4. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.
To build and deploy the service, follow the steps below:

Once you have successfully deployed your service, you can test, manage, and observe it like any other component type in Choreo.

For detailed instructions, see the following sections:

- [Step 3: Test](https://wso2.com/choreo/docs/testing/test-graphql-endpoints-via-the-graphql-console/)
- [Step 4: Manage](https://wso2.com/choreo/docs/manage/api-management/)


# Expose a gRPC Endpoint via a Service

Choreo allows you to create and deploy applications in your preferred programming language. One powerful option is gRPC, a high-performance and language-agnostic remote procedure call (RPC) framework. It utilizes [Protocol Buffers](https://github.com/protocolbuffers/protobuf) to define services and generate client/server code.

In this guide, you will learn to use Choreo to create a service component that exposes a gRPC server implemented in [Go](https://go.dev/), enabling efficient and scalable communication with any gRPC client application. No prior knowledge of the Go language is necessary to follow this guide.

By following this guide, you will:

- Create a simple gRPC server using a Service component.
- Link the containerized gRPC service to the Choreo component using the Dockerfile. 
    The greeter service has a single RPC method named `sayHello`. Following is the proto file the server and the client application are using:

    ```proto
    syntax = "proto3";
    option go_package = "github.com/wso2/choreo-samples/go-grpc/pkg";

    service greeter {
      rpc SayHello (HelloRequest) returns (HelloReply) {}
    }

    message HelloRequest {
      string name = 1;
    }

    message HelloReply {
      string message = 1;
    }
    ```

- Deploy the gRPC server component in Choreo. 
- Create a gRPC client using a Manual Trigger component. 
- Deploy the gRPC client.
- Invoke the gRPC server using a gRPC client and check the response through the Choreo log view.


## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample service](https://github.com/wso2/choreo-samples/tree/main/go-grpc) implementation for this guide.

Let's get started!

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the greeter service.

!!! note 
    The following file paths are relative to the path `<sample-repository-dir>/go-grpc`.

|File Path                |Description                                                                                   |
|-------------------------|----------------------------------------------------------------------------------------------|
| `main.go`               | The greeter service code written in the Go language.                                         |
| `greeter_client/main.go`| The greeter client application written in the Go language.                                   |
| `Dockerfile.server`     | The Dockerfile to build the container image of the server application.                       |
| `Dockerfile.client`     | The Dockerfile to build the container image of the client application.                       |
| `.choreo/component.yaml`| The Choreo-specific configuration that provides information about how Choreo exposes the service.|
| `pkg/greeter.proto`     | The interface definition of the gRPC service. This is used to generate the server and client stubs for the Go application.|

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints.

Let's run the gRPC server service component on port 8080. To securely expose the service through Choreo, you must provide the port and other required information to Choreo. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

Choreo looks for an `component.yaml` file inside the `.choreo` directory to configure the endpoint details of the containerized component. Ensure the `.choreo` directory is at the root of the Docker build context path.

In the gRPC server sample, the `component.yaml` file is at `go-grpc/.choreo/component.yaml`, where the build context path is `go-grpc`.

## Step 1: Create a service component with a gRPC endpoint

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
6. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

7. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory** | `go-grpc`                  |

8. Select **Docker** as the buildpack.
9. Enter the following information:
    
    | **Field**                | **Value**                  |
    |--------------------------|----------------------------|
    | **Dockerfile**           | `go-grpc/Dockerfile.server`|

    !!! info
        1.  To successfully build your container with Choreo, it is essential to explicitly define a User ID (UID) under the USER instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-samples/blob/main/go-grpc/Dockerfile.server).
        To ensure that the defined USER instruction is valid, it must conform to the following conditions:
            - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
            - Usernames are considered invalid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

        2. The Dockerfile utilized in this guide is a multi-stage Dockerfile, which is designed to keep the final image size small and provides the ability to build the application with a specific version of tools and libraries.

4. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go gRPC Server`        |
    | **Component Name**        | `go-grpc-server`        |
    | **Description**           | Send greetings          |
    
10. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you have connected the source repository, and configured the endpoint details, it's time to build the service and create an image. Then you can deploy the image and test the greeter service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

    You can access the following scans under **Build**. 

      - **The Dockerfile scan**: Choreo performs a scan to check if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
      - **Container (Trivy) vulnerability scan**: This detects vulnerabilities in the final docker image. 
      - **Container (Trivy) vulnerability scan**: The details of the vulnerabilities open in a separate pane. If this scan detects critical vulnerabilities, the build will fail.
     
        !!! info
            If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Environment Configurations** pane that opens, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

6. Once you have successfully deployed your service, navigate to the component overview page and copy the gRPC service URL. You need to provide that URL when setting up the client application later in this guide.

You have successfully deployed the gRPC server. Currently, the gRPC service is only accessible by the components deployed within the same project.

## Step 3: Invoke the gRPC service

Let's invoke the gRPC service that you created above, using a gRPC client. 

### Step 3.1: Create a manual task for the gRPC client

To create a manual task component, follow these steps:

1. On the Choreo Console header, click the **Project** list and select the project where you created the gRPC service component. This opens the project home page.
2. Go to the **Component Listing** section and click **+ Create**.
3. Click the **Manual Task** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**       | `go/grpc`                  |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                  |
    |--------------------------|----------------------------|
    | **Dockerfile**           | `go/grpc/Dockerfile.client`|

8. Enter a display name, a unique name, and a description for the component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go gRPC Client`        |
    | **Component Name**        | `go-grpc-client`        |
    | **Description**           | `Receive greetings`     |


9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

### Step 3.2: Build the gRPC client component

To build the component, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 3.3: Setup environment variables and deploy the gRPC client

The client application, in this case, the gRPC client, requires the server URL of the gRPC server service. This is read from the client application as an environment variable. Follow the steps below to configure the environment variable for the client application:

1. On the Choreo Console left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane that opens, click **+ Add**.
4. Specify the following name and value to configure the environment variable for the client application:

    | **Field**       | **Value**               |
    |-----------------|-------------------------|
    | **Name**        | `GREETER_SERVICE`       |
    | **Value**       | Paste the URL value copied after deploying the gRPC service via [step 2.2](#step-22-deploy) above.  Make sure to **drop the `http://` or `grpc://` part and the trailing `/` from the URL when copying**. For example, if the URL is `http://go-grpc-server-3192360657:8080/`, add only `go-grpc-server-3192360657:8080`.|

5.  Click **Add** and then click **Next**.
6.  Click **Deploy**.

### Step 3.4: Execute the gRPC client component

To execute the gRPC client, follow these steps:

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the gRPC client and generates logs.
   You can trigger multiple runs to generate multiple logs.

For details on what you can monitor via the execute page, see [Monitor executions](../develop-integrations/develop-a-manual-task.md#step-7-monitor-executions). 


# Expose a Prism-Based Mock Server Using an OpenAPI Specification

Choreo supports deploying [Prism-based](https://docs.stoplight.io/docs/prism/674b27b261c3c-prism-overview) mock servers using OpenAPI specifications. With the Choreo Prism mock service component, you can serve multiple mock servers, each based on a different OpenAPI specification, as separate endpoints.

By default, these mock servers serve static content generated from the examples in the configured OpenAPI Specification (OAS). 

## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [Prism mock service](https://github.com/wso2/choreo-samples/tree/main/prism-mock-service) artifacts for this guide.

## Step 1: Create a Prism mock service component

To create a Prism mock service component, follow these steps:
    
1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, you can paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    |**Component Directory**  | `prism-mock-service`    |

6. Select **Prism Mock** as the buildpack.
7. Enter a display name, a unique name, and a description for the service component.
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

8. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

## Step 2: Build and deploy the component

Now that you have successfully created the Prism mock service, it's time to build and deploy it.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**. This builds the service from the latest commit.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

Once you have successfully deployed the service, you can [test](../../testing/test-rest-endpoints-via-the-openapi-console.md), [manage](../../api-management/lifecycle-management.md), and [observe](../../monitoring-and-insights/observability-overview.md) it like any other component type in Choreo.

## Serve dynamic content

The Prism mock service can serve dynamic content according to the schema definitions in the OpenAPI specification. To use the Prism mock service with dynamic content, clients must add the `prefer:dynamic=true` header in the request.

To generate meaningful dynamic responses, you can use the `x-faker` attribute in schema definitions of the OpenAPI specification. For more information on dynamically generated responses with the `x-faker` attribute, see the [Prism documentation](https://docs.stoplight.io/docs/prism/9528b5a8272c0-dynamic-response-generation-with-faker).


# Expose a TCP Server via a Service

Choreo offers the flexibility to design and deploy applications in the programming language of your choice. One viable choice for specific network communication needs is TCP (Transmission Control Protocol). TCP provides a reliable, stream-oriented communication mechanism that ensures data integrity and orderliness during transmission. It's the go-to option for scenarios where guaranteed data delivery and error recovery are paramount.

In this guide, you will learn to use Choreo to create a service component that exposes a TCP server implemented in [Go](https://go.dev/), enabling efficient and scalable communication with any TCP client application. No prior knowledge of the Go language is necessary to follow this guide.

By following this guide, you will:

- Setup a TCP server
    - Create a simple TCP server using a service component.
    - Link the containerized TCP service to the Choreo component using a Dockerfile. 
    - Deploy the TCP server component in Choreo. 
- Setup a TCP client
    - Create a TCP client using a manual task component. 
    - Link the containerized TCP client to the Choreo component using a Dockerfile. 
    - Deploy the TCP client component in Choreo.
- Invoke the TCP server using a TCP client and observe the response through the Choreo log view.

## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample service](https://github.com/wso2/choreo-samples/tree/main/docker-tcp-service) implementation for this guide.

Let's get started!

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the sample service.

!!! note 
    The following file paths are relative to the path `<sample-repository-dir>/docker-tcp-service`.

|File Path                 |Description                                                                                   |
|--------------------------|----------------------------------------------------------------------------------------------|
| `server/main.go`         | The greeter service code written in the Go language.                                         |
| `client/main.go`         | The greeter client application written in the Go language.                                   |
| `Dockerfile.server`      | The Dockerfile to build the container image of the server application.                       |
| `Dockerfile.client`      | The Dockerfile to build the container image of the client application.                       |
| `.choreo/component.yaml` | The Choreo-specific configuration provides information about how Choreo exposes the service. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints.

Let's run the TCP server service component on port 5050. To securely expose the service through Choreo, you must provide the port and other required information to Choreo. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

Choreo looks for an `component.yaml` file inside the `.choreo` directory to configure the endpoint details of a containerized component. Place the `.choreo` directory at the root of the Docker build context path.

In our TCP server sample, the `component.yaml` file is at `docker-tcp-service/.choreo/component.yaml`, where the build context path is `docker-tcp-service`.

## Step 1: Create a service component with a TCP endpoint

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory** | `docker-tcp-service`                  |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-tcp-service/Dockerfile.server`|

    !!! info
        1.  To successfully build your container with Choreo, it is essential to explicitly define a User ID (UID) under the USER instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-samples/blob/main/docker-tcp-service/Dockerfile.server).
        To ensure that the defined USER instruction is valid, it must conform to the following conditions:
            - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
            - Usernames are considered invalid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

        2. The Dockerfile utilized in this guide is a multi-stage Dockerfile, which is designed to keep the final image size small and provides the ability to build the application with a specific version of tools and libraries.

8. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go TCP Server`         |
    | **Component Name**        | `go-tcp-server`         |
    | **Description**           | Send greetings          |
    
9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you have connected the source repository, and configured the endpoint details, it's time to build the service and create an image. Then you can deploy the image and test the service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

    You can access the following scans under **Build**. 

      - **The Dockerfile scan**: Choreo performs a scan to check if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
      - **Container (Trivy) vulnerability scan**: This detects vulnerabilities in the final docker image. 
      - **Container (Trivy) vulnerability scan**: The details of the vulnerabilities open in a separate pane. If this scan detects critical vulnerabilities, the build will fail.
     
        !!! info
            If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Environment Configurations** pane that opens, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

6. Once you have successfully deployed your service, navigate to the component overview page and copy the TCP service address. You need to provide that address when setting up the client application later in this guide.

You have successfully deployed the TCP server. Currently, the TCP service is only accessible by the components deployed within the same project.

## Step 3: Invoke the TCP service

Now let's use a TCP client to invoke the TCP service that you created above. To do this, you can create a manual trigger component as the TCP client. This is the recommended approach because, in this example, it's more efficient to have a client that connects to the server, sends a request, and then stops. Here, a continuously executing task isn't required. Furthermore, if you use a manual trigger component, you won't need to expose an endpoint in the client for invocation, unlike with an API.

### Step 3.1: Create a manual trigger for the TCP client

To create a manual task component, follow these steps:

1. On the Choreo Console header, click the **Project** list and select the project where you created the TCP service component. This opens the project home page.
2. Go to the **Component Listing** section and click **+ Create**.
3. Click the **Manual Task** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Docker Context**      |`docker-tcp-service`     |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-tcp-service/Dockerfile.client`|

8. Enter a display name, a unique name, and a description for the component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**              |
    |---------------------------|------------------------|
    | **Component Display Name**| `Go TCP Client`        |
    | **Component Name**        | `go-tcp-client`        |
    | **Description**           | `Receive greetings`    |


9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

### Step 3.2: Build the TCP client component

To build the component, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 3.3: Setup environment variables and deploy the TCP client

The client application, in this case, the TCP client, requires the server URL of the TCP server service. This is read from the client application as an environment variable. Follow the steps below to configure the environment variable for the client application:

1. On the Choreo Console left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane that opens, click **+ Add**.
4. Specify the following name and value to configure the environment variable for the client application:

    | **Field**       | **Value**               |
    |-----------------|-------------------------|
    | **Name**        | `SERVER_ADDRESS`       |
    | **Value**       | Paste the URL value copied after deploying the TCP service via [step 2.2](#step-22-deploy) above.  Make sure to **drop the `tcp://` part and the trailing `/` from the URL when copying**. For example, add only `go-tcp-server-1097922445:8080`.|

5.  Click **Add** and then click **Next**.
6.  Click **Deploy**.

### Step 3.4: Execute the TCP client component

To execute the TCP client, follow these steps:

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the TCP client and generates logs.
   You can trigger multiple runs to generate multiple logs.

For details on what you can monitor via the execute page, see [Monitor executions](../develop-integrations/develop-a-manual-task.md#step-7-monitor-executions).


# Expose a UDP Server via a Service

Choreo offers the flexibility to design and deploy applications in the programming language of your choice. One compelling choice for certain network communication needs is UDP (User Datagram Protocol). UDP is a high-speed, connectionless protocol ideal for scenarios where lightweight, real-time data transmission is essential.

In this guide, you will learn to use Choreo to create a Service component that exposes a UDP server implemented in [Go](https://go.dev/), enabling efficient and scalable communication with any UDP client application. No prior knowledge of the Go language is necessary to follow this guide.

By following this guide, you will:

- Setup a UDP server
    - Create a simple UDP server using a Service component.
    - Link the containerized UDP service to the Choreo component using the Dockerfile. 
    - Deploy the UDP server component in Choreo. 
- Setup a UDP client
    - Create a UDP client using a manual task component. 
    - Link the containerized UDP client to the Choreo component using the Dockerfile. 
    - Deploy the UDP client component in Choreo.
- Invoke the UDP server using a UDP client and check the response through the Choreo log view.

## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample service](https://github.com/wso2/choreo-samples/tree/main/docker-udp-service) implementation for this guide.

Let's get started!

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the sample service.

!!! note 
    The following file paths are relative to the path `<sample-repository-dir>/docker-udp-service`.

|File Path                |Description                                                                                   |
|-------------------------|----------------------------------------------------------------------------------------------|
| `server/main.go`        | The greeter service code written in the Go language.                                         |
| `client/main.go`        | The greeter client application written in the Go language.                                   |
| `Dockerfile.server`     | The Dockerfile to build the container image of the server application.                       |
| `Dockerfile.client`     | The Dockerfile to build the container image of the client application.                       |
| `.choreo/component.yaml`| The Choreo-specific configuration provides information about how Choreo exposes the service. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints.

Let's run the UDP server service component on port 5050. To securely expose the service through Choreo, you must provide the port and other required information to Choreo. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

Choreo looks for an `component.yaml` file inside the `.choreo` directory to configure the endpoint details of a containerized component. Place the `.choreo` directory at the root of the Docker build context path.

In our gRPC server sample, the `component.yaml` file is at `docker-udp-service/.choreo/component.yaml`, where the build context path is `docker-udp-service`.

## Step 1: Create a service component with a UDP endpoint

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
6. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

7. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**   | `docker-udp-service`    |    

8. Select **Docker** as the buildpack.
9. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-udp-service/Dockerfile.server`|

    !!! info
        1.  To successfully build your container with Choreo, it is essential to explicitly define a User ID (UID) under the USER instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-samples/blob/main/docker-udp-service/Dockerfile.server).
        To ensure that the defined USER instruction is valid, it must conform to the following conditions:
            - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
            - Usernames are considered invalid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

        2. The Dockerfile utilized in this guide is a multi-stage Dockerfile, which is designed to keep the final image size small and provides the ability to build the application with a specific version of tools and libraries.

4. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go UDP Server`         |
    | **Component Name**        | `go-udp-server`         |
    | **Description**           | Send greetings          |

10. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you have connected the source repository, and configured the endpoint details, it's time to build the service and create an image. Then you can deploy the image and test the service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

    You can access the following scans under **Build**. 

      - **The Dockerfile scan**: Choreo performs a scan to check if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
      - **Container (Trivy) vulnerability scan**: This detects vulnerabilities in the final docker image. 
      - **Container (Trivy) vulnerability scan**: The details of the vulnerabilities open in a separate pane. If this scan detects critical vulnerabilities, the build will fail.
     
        !!! info
            If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Environment Configurations** pane that opens, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

6. Once you have successfully deployed your service, navigate to the component overview page and copy the UDP service address. You must provide that address when setting up the client application later in this guide.

You have successfully deployed the UDP server. Currently, the UDP service is only accessible by the components deployed within the same project.

## Step 3: Invoke the UDP service

Now let's use a UDP client to invoke the UDP service that you created above. To do this, you can create a manual trigger component as the UDP client. This is the recommended approach because, in this example, it's more efficient to have a client that connects to the server, sends a request, and then stops. Here, a continuously executing task isn't required. Furthermore, if you use a manual trigger component, you won't need to expose an endpoint in the client for invocation, unlike with an API.

### Step 3.1: Create a manual trigger for the UDP client

To create a manual task component, follow these steps:

1. On the Choreo Console header, click the **Project** list and select the project where you created the UDP service component. This opens the project home page.
2. Go to the **Component Listing** section and click **+ Create**.
3. Click the **Manual Task** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory** | `docker-udp-service`    |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-udp-service/Dockerfile.client`|

8. Enter a display name, a unique name, and a description for the component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**              |
    |---------------------------|------------------------|
    | **Component Display Name**| `Go UDP Client`        |
    | **Component Name**        | `go-udp-client`        |
    | **Description**           | `Receive greetings`    |


9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

### Step 3.2: Build the UDP client component

To build the component, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 3.3: Setup environment variables and deploy the UDP client

The client application, in this case, the UDP client, requires the server URL of the UDP server service. This is read from the client application as an environment variable. Follow the steps below to configure the environment variable for the client application:

1. On the Choreo Console left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane that opens, click **+ Add**.
4. Specify the following name and value to configure the environment variable for the client application:

    | **Field**       | **Value**               |
    |-----------------|-------------------------|
    | **Name**        | `SERVER_ADDRESS`       |
    | **Value**       | Paste the URL value copied after deploying the UDP service via [step 2.2](#step-22-deploy) above.  Make sure to **drop the `udp://` part and the trailing `/` from the URL when copying**. For example, add only `go-udp-server-1097922445:8080`.|

5.  Click **Add** and then click **Next**.
6.  Click **Deploy**.

### Step 3.4: Execute the UDP client component

To execute the UDP client, follow these steps:

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the UDP client and generates logs.
   You can trigger multiple runs to generate multiple logs.

For details on what you can monitor via the execute page, see [Monitor executions](../develop-integrations/develop-a-manual-task.md#step-7-monitor-executions).


# Expose a WebSocket Endpoint via a Service

Choreo allows you to create and deploy applications in your preferred programming language, offering a seamless platform for building dynamic and scalable solutions. This guide walks you through the steps to deploy a WebSocket service using the NodeJS buildpack.

WebSockets provide real-time, two-way communication between a client and server over a persistent TCP connection. This makes WebSocket APIs ideal for applications that require real-time updates.

In this guide, you will:

- Build a simple WebSocket service using a sample implementation in NodeJS.
- Deploy the service in Choreo, allowing any WebSocket client application to establish a connection and exchange real-time messages with your service.

## Prerequisites

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample WebSocket service](https://github.com/wso2/choreo-samples/tree/main/websocket-chat-app) implementation for this guide.

Let's get started!

## Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the NodeJS chat Application.

!!! note
    The following file paths are relative to the path `<sample-repository-dir>/websocket-chat-app/websocket-chat-service-nodejs`.

|Filepath                        | Description                                                     |
|--------------------------------|-----------------------------------------------------------------|
| `server.js`                    | The NodeJS chat service.                                        |
| `.choreo/component.yaml`       | The configuration file with endpoint details.                   |

!!! note
    Choreo currently supports defining WebSocket APIs using the AsyncAPI 2.0 specification.

## Step 1: Create a service component 

To create a NodeJS service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**   | `websocket-chat-app/websocket-chat-service-nodejs`  |

6. Select **NodeJS** as the buildpack and **18.x.x** as the Language Version

8. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:

    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `NodeJS Chat Service`   |
    | **Component Name**        | `nodejs-chat-service`   |
    | **Description**           | Manage a chat service   |

9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service component that provides a WebSocket API built with NodeJS. The next step is to proceed with building and deploying the service.

## Step 2: Build and deploy

Now that you have connected the source repository, it's time to build and deploy the chat service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane that opens, click **Next** to skip the configuration.
4. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

Once you have successfully deployed your service, you can [test](../../testing/test-websocket-endpoints-via-the-websocket-console.md), [manage](../../api-management/lifecycle-management.md), and observe it like any other component type in Choreo.

During testing, once the WebSocket connection is established, you can send {"type": "Connect", "username": "user1"} to the WebSocket endpoint to connect to the chat service. You can then send chat messages by using {"type": "Data", "message": "Hello, World!"}.

!!! note
     Some clients, such as certain browsers, may not support adding headers to the WebSocket handshake. In these cases, you can include the access token or test key required for WebSocket API invocation within the `sec-websocket-protocol` header, along with any specified subprotocols.

     For example: `sec-websocket-protocol: choreo-oauth2-token, {access token}, subprotocols`

     If you are using a test key, replace `choreo-oauth2-token` with `choreo-test-key`.


# Service Component Overview

Explore how to create, deploy, manage, and observe service components in Choreo.

## What is a service component?

A service component in Choreo lets you deploy and expose REST, GraphQL, gRPC, UDP, WS or TCP services. It is a fundamental building block for creating cloud-native applications in Choreo. They provide a simple and effective way to expose functionality as a service to other components within Choreo or to the outside world.

Service components encapsulate business logic and provide standardized interfaces, called endpoints, for communicating with other components or systems. You can deploy and scale services independently, which makes them highly flexible and adaptable to changing workloads.

With the help of the service component, developers can quickly create APIs and microservices, making it easier to implement and manage complex software systems. Service components can also be integrated with other Choreo components, that acts as message processors, connectors, and data sources, etc to create powerful end-to-end solutions.

You can expose a service to other components through endpoints. For details on configuring endpoints, see [Configure Endpoints](../configure-endpoints.md).


# Build and Deploy a Single-Page Web Application

A web application is an application program hosted on a server and serves ingress traffic through a browser. In Choreo, you can deploy a web application by creating a Web Application component and connecting it to a Git repository that contains the implementation of the web application. Web applications can fall into one of the following categories:

- **Single page applications (SPAs)**: Examples include React, Angular, Vue, Svelte, etc.
- **Web servers**: These serve static content or provide server-side rendering/static site generation (SSR/SSG).
- **Static content**: Examples include websites and other static resources that do not require a backend, usually comprising static HTML/JS/CSS files.

## Prerequisites

- To deploy a web application component, you must have a GitHub account with a repository containing the web application's implementation. For this guide, fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample web application implementation.

## Create a web application

You can create a web application in Choreo as follows:

### Build and deploy a SPA from source code

1. To create a web application component, connect a repository that includes the web application source code.
2. Select the relevant buildpack: Default buildpacks include **React**, **Angular**, and **Vue.js**. If you are using a different SPA framework, you can try one of these buildpacks because the configurations can be overridden to support most JavaScript-based SPAs.
3. Enter the build command: Based on your package manager (NPM, yarn, or pnpm). The relevant package manager is run based on the dependency lock file in your repository (defaults to NPM if no lock file is present).
4. Specify the build output directory.
5. Specify the NodeJS version: Choreo does not pick the Node.js version from the `package.json` engine property. The required Node version must be explicitly set in the build configuration.

Once you create the Web Application component, Choreo automatically generates a build pipeline for your single-page application and deploys it.

### Bring your Dockerfile

1. To create a web application component, connect a repository that contains the Dockerfile for your containerized web application.
2. Commit a Dockerfile to your connected Git repository to have full control over your build process.

This approach is recommended if you are deploying a web server and not just a single-page application (or a single-page application with a complex build process).

### Host static websites

1. Create a web application component and connect it to the GitHub repository that contains the required static assets.
2. Select the **Static Websites** buildpack: This buildpack does not trigger a build process. It only fetches the files from the path specified in the repository and serves them as-is.

## Build and deploy a SPA from source code

Follow the steps below to create a sample Web Application component and deploy it in Choreo:

1. Sign in to the Choreo Console at [https://console.choreo.dev/login/](https://console.choreo.dev/login/). This opens the **Project Home** page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Web Application** card.
6. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

7. Enter the following information:

    | **Field**                 | **Description**        |
    |---------------------------|------------------------|
    | **GitHub Account**        | Your account           |
    | **GitHub Repository**     | choreo-samples         |
    | **Branch**                | main                   |
    | **Component Directory**     | /react-single-page-app |

8. Select **React** as the **Buildpack**.
9. Enter the following information:

    | **Field**                 | **Description**        |
    |---------------------------|------------------------|
    | **Build Command**         | `npm run build`        |
    | **Build Path**            | `build`                |
    | **Node Version**          | `18`                   |

    !!! tip
        Managed authentication is enabled by default when you create a web application using **React**, **Angular**, or **Vue.js** buildpacks. To learn how to set up authentication for your web application with Choreo's managed authentication, see [Secure Web Applications with Managed Authentication](../../authentication-and-authorization/secure-web-applications-with-managed-authentication.md).

4. Specify a display name, a unique name and description for the component.
10. Click **Create**. Choreo initializes the component with the sample implementation and opens the **Overview** page of the component.

You have successfully created a Web Application component from the source code. Now let's build and deploy the web application.

## Build your web application

1. In the left navigation menu, click **Build**.
2. In the **Builds** pane, click **Build**. This opens the **Commits** pane, where you can see all the commits related to the component.
3. Select the latest commit and click **Build**. This triggers the build process and displays the progress in the **Build Logs** pane.

    You can access the following scans in the **Build Logs** pane:

    - **Dockerfile Scan**: Choreo checks if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
    - **Container (Trivy) Vulnerability Scan**: Detects vulnerabilities in the final Docker image. If critical vulnerabilities are detected, the build will fail.

    !!! info
        If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

    !!! note
        The build process may take some time. Once complete, the build status will be listed in the **Builds** pane. Here, you will see the build status as **Success**.

## Deploy and access your web application

1. In the left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure and Deploy**. This opens the **Configure & Deploy** pane. In this guide, you do not need to add a file mount.
3. Click **Next** to proceed to the **Authentication Settings** pane.
4. Keep the default settings and click **Deploy**.

    !!! note
        The deployment process may take a few minutes. Once complete, the **Deployment Status** will show as **Active** in the **Development** card.

5. To verify that the web application is hosted successfully, click the **Web App URL** in the **Development** card. This takes you to the web application.

## Create a short URL for your web application in production

!!! info
    This feature is only available on the Choreo cloud data plane.

When you promote your component to the Production environment, you can create a personalized short URL for your web application. The URL follows the `https://{your-short-prefix}.choreoapps.dev` structure, where you can select a name of your preference for `{your-short-prefix}`.

1. Click **Promote** in the **Development** card and promote your web application to production.
2. In the **Production** card, click **Create a short URL**.
3. Specify a **Short URL prefix** of your choice and click **Save**.

    !!! note
        Short URL names/prefixes are subject to availability, provided on a first-come-first-serve basis.

## Manage runtime configurations for web applications

For web applications with a backend server, Choreo allows you to mount runtime configurations and secrets as environment variables and/or file mounts for a specific environment. Alternatively, you can also inject them into the client application during server-side rendering or when serving static content.

For SPAs that run completely on the browser, Choreo does not support *baking-in* environment variables or other configurations. Instead, Choreo recommends the following approach (applicable to most SPA frameworks, including React):

!!! note
    - With SPAs, anything you mount as a runtime config will be available to your users in the browser.
    - **Do not include sensitive secrets that are not browser-safe**.

1. Go to your forked [Choreo samples repository](https://github.com/wso2/choreo-samples).
2. Open the `public` directory.
3. Create and commit a new file named `config.js` in the `public` directory of your React application. This file should contain the runtime configuration variables you want to expose to your application, such as API endpoints or feature flags. For example:

    ```javascript
    window.config = {
        apiUrl: 'https://api.example.com',
        featureFlags: {
            enableNewFeature: true,
            enableExperimentalFeature: false,
        },
    };
    ```

4. In your `index.html` file inside the `public` directory, add a script tag to include the `config.js` file inside the `<body>` tag:

    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>My React App</title>
    </head>
    <body>
        <div id="root"></div>
        <script src="%PUBLIC_URL%/config.js"></script>
    </body>
    </html>
    ```

5. In your React component, access the configuration variables by referencing the `window.config` object:

    ```javascript
    import React from 'react';

    function MyComponent() {
        const apiUrl = window.config.apiUrl;
        const enableNewFeature = window.config.featureFlags.enableNewFeature;
        const enableExperimentalFeature = window.config.featureFlags.enableExperimentalFeature;

        // ...
    }
    ```

6. When you deploy your component to Choreo, create a config file mount in the specified path for each environment (where your `index.html` expects the `config.js` file). For more details, see [Manage Configurations and Secrets](https://wso2.com/choreo/docs/devops-and-ci-cd/manage-configurations-and-secrets/#apply-a-file-mount-to-your-container).

## Limitations

The following limitations are specific to the Choreo cloud data plane:

- **Request size limit**: 256KB (including headers, cookies, and payloads).
- **Response body size limit**: 20MB.
- **Open ports**: Only one open port is permitted per web application. While you can have multiple ports open for project-level communication within a data plane, incoming traffic from the internet can only be directed to one port. This differs from Service-type components, which support multiple endpoints.

## Troubleshoot a web application

- **Blank page or 502 error after deployment**:
    If you encounter a blank page or a 502 error after deploying your web application, it typically indicates that the wrong directory is being served. To resolve this issue:
    1. Double-check the build output directory, especially if you are using a Dockerfile-less buildpack.
    2. Ensure that the specified output directory matches the actual output directory generated during the build process. For example, if you have erroneously entered `public/` as the output directory when it should have been `build/`.

By verifying and correcting the output directory alignment, you should be able to address the issue of encountering a blank page or experiencing a 502 error on deploying your web application.


# Develop Web Applications Locally with Choreo’s Managed Authentication

Choreo’s managed authentication capability provides a set of backend for frontend (BFF) endpoints to facilitate authentication and authorization for web applications. These endpoints are readily available for single-page web applications deployed on Choreo.

As a web application developer, you may need to run the application on your local workstation. Choreo’s local development capability ensures that authentication and authorization during local development work the same way as they do when the application is deployed to Choreo, eliminating the need for code changes.

This guide explains how to configure and use Choreo’s local development capability to streamline your workflow.

## How local development works in Choreo

Local development uses a proxy that sits in front of the locally running web application. This proxy intercepts all incoming requests:
- Requests to `/choreo-apis/*` and `/auth/*` are forwarded to Choreo.
- All other requests are forwarded to the locally running web application.

The proxy runs on HTTPS using a self-signed certificate, which is essential for secure, HTTP-only cookie-based managed authentication. Once the proxy is running, you can access the web application using the proxy's URL and start developing locally. The behavior of the web application, in terms of managed authentication, will mirror its behavior when deployed to Choreo.

## Configure local development

### Prerequisites

- Create a single-page application (SPA) with managed authentication enabled. For details, see [Secure Web Applications with Managed Authentication](../../authentication-and-authorization/secure-web-applications-with-managed-authentication.md#step-1-set-up-managed-authentication-for-your-web-application).
- Promote and deploy the application to the environment where you want to enable local development.

    !!! note
        - The locally running web application will use the same managed authentication configuration as the environment where local development is configured.
        - Local development is only allowed in non-critical environments.

### Apply configurations

1. Sign in to the Choreo Console.
2. In the **Component Listing** pane, click on the component you created and deployed.
3. In the left navigation menu, click **Deploy**.
4. Go to the respective environment card and click **Local Development**.
5. In the **Local Development** pane, toggle **Local Development** to enable it.
6. (Optional) To update the port on which the local development proxy server runs, expand **Advanced Configurations** and specify a value for **Proxy Port**.
7. Click **Apply**.

You have now configured local development. The next section explains how to access your web application for local development.

## Access your web application locally

### Prerequisites

- Ensure local development is enabled in the desired environment.
- Ensure your web application is running locally on `http://localhost` on a specific port.

### Access your web application locally

You can use either the Choreo built-in identity provider or an external identity provider to access your web application locally.

=== "Use the Choreo built-in identity provider"

    1. Sign in to the Choreo Console.
    2. In the **Component Listing** pane, click on the component you created and deployed.
    3. In the left navigation menu, click **Deploy**.
    4. Go to the respective environment card and click **Local Development**.
    5. In the **Local Development** pane, copy the command under **Step 1**.
    6. Paste the command in a terminal, replace `[APP_PORT]` with the port on which your application is running locally, and run the command.
    7. To access the application, go to the URL provided under **Step 2** in the **Local Development** pane.

        !!! note
            The local development proxy runs on HTTPS using a self-signed certificate. Your browser may warn that the certificate is not valid. Accept the risk and proceed.

=== "Use an external identity provider"

    1. Sign in to the Choreo Console.
    2. In the **Component Listing** pane, click on the component you created and deployed.
    3. In the left navigation menu, click **Deploy**.
    4. Go to the respective environment card and click **Local Development**.
    5. In the **Local Development** pane, copy the redirect URLs under **Step 1**.
    6. Go to the settings in the OAuth application in your identity provider and specify the copied URLs as allowed redirect URLs.
    7. In the **Local Development** pane, copy the command under **Step 2**.
    8. Paste the command in a terminal, replace `[APP_PORT]` with the port on which your application is running locally, and run the command.
    9. To access the application, go to the URL provided under **Step 3** in the **Local Development** pane.

        !!! note
            The local development proxy runs on HTTPS using a self-signed certificate. Your browser may warn that the certificate is not valid. Accept the risk and proceed.


# Create a Connection

Connections in Choreo provide a simple and uniform approach to seamlessly integrate components with services or resources.

Choreo allows you to create connections to services deployed in Choreo or registered as external services. It also allows you to create connections to any Choreo-managed database.

To create a connection to a service or a database, follow the step-by-step instructions in the respective tab:

=== "Create a connection to a service"

    <h2>Create a connection to a Choreo service</h2>

    Follow these steps to create a connection to a service deployed in Choreo:

    1. In the Choreo Console, go to the top navigation menu and set the visibility level as [project](../../choreo-concepts/connections.md#project-connections) or [component](../../choreo-concepts/connections.md#component-connections) as follows: 

        - **Project Connection**: Select an organization and a project in that organization. 
        - **Component Connection**: Select an organization, a project in that organization, and a component in the selected project. 

    2. In the left navigation menu, click **Dependencies**  and then **Connections**. This page lists all the existing connections.
    3. Click **+Create**. This opens the Marketplace view where you can browse and search for services or databases.
    4. Click the **Services** tab. You can search and apply filters to efficiently find a service.
    5. Click on the service you want to connect to. 
    6. Enter a name and a description for the connection.
    7. Select an **Access Mode** and **Authentication Scheme** for the connection.
    8. Click **Create**.
   
    This creates the connection and displays its details for each environment, along with an inline guide on how to use the connection in your component. 

    !!! note
        During connection creation, secret values for the lowest environment are visible, allowing you to copy them for local use if necessary. Secret values for higher environments remain hidden to ensure security
     
    <h2>Create a connection to an external service</h2>

    Follow these steps to create a connection to an external service:

    1. Follow steps 1–5 from the previous section.
    2. Expand the **Environment to Endpoint** section and verify the service endpoints assigned to the Choreo environments.
    3. Click **Create**.

      For step-by-step instructions on using a connection in your service, see [Use a Connection in Your Service](./use-a-connection-in-your-service.md).

      For step-by-step instructions on using a connection in your web application, see [Use a Connection in Your Web Application](./use-a-connection-in-your-web-application.md).


=== "Create a connection to a database"

    Prerequisites:

     - Create a Choreo-managed database. For details, see [Choreo-Managed Databases and Caches](../../manage-databases-and-caches/choreo-managed-databases-and-caches.md).
     - Add the database to the Marketplace. For details, see [Add Choreo-Managed Databases and Caches to the Marketplace](../../manage-databases-and-caches/add-choreo-managed-databases-and-caches-to-the-marketplace.md).

    Follow these steps to create a connection to a Choreo-managed database:

    1. In the Choreo Console, go to the top navigation menu and set the visibility level as [project](../../choreo-concepts/connections.md#project-connections) or [component](../../choreo-concepts/connections.md#component-connections) as follows: 

        - **Project Connection**: Select an organization and a project in that organization. 
        - **Component Connection**: Select an organization, a project in that organization, and a component in the selected project. 

    2. In the left navigation menu, click **Dependencies**  and then **Connections**. This page lists all the existing connections.
    3. Click **+Create**. This opens the Marketplace view where you can browse and search for services or databases.
    4. Click the **Databases** tab. You can search and apply filters to efficiently find a database.
    5. Click on the database you want to connect to. 
    6. To create the connection, follow these steps:

        1. Enter a name and description.
        2. Under **Environment Configuration**, select credentials for each environment.

            !!! note
                 By default, the selected database is applied to all environments. To use different databases for specific environments, select the appropriate database and provide the corresponding credentials for each environment.

        3. Click **Create**.  
    
    This creates the connection and displays the database connection details for each environment, along with an inline guide on how to use the connection in your component. 

    !!! note
        During connection creation, secret values for the lowest environment are visible, allowing you to copy them for local use if necessary. Secret values for higher environments remain hidden to ensure security
    
    For step-by-step instructions on using a database in your component, see [Use a Database Connection in Your Component](./use-a-database-connection-in-your-component.md).


# Use a Connection in Your Service

Choreo allows you to share and reuse your services, accelerating development and enhancing efficiency in building integrated applications through connections.

For step-by-step on instruction on creating a connection, see [Create a Connection](create-a-connection.md).

To learn more about Choreo Connections, see the documentation on [Connections](../../choreo-concepts/connections.md).

## Consume a service through a connection

You can consume a Choreo-deployed service within another service. Consuming connections from within Choreo services is seamless and straightforward. Follow the steps below to consume a Choreo service:

### Step 1: Add connection configurations

To integrate another service into your application, click the appropriate tab below based on your current configuration file and follow the step-by-step instructions:

=== "Component.yaml file (v1.1)"

    1. Copy and paste the snippet from the in-line developer guide into the `component.yaml` file.

        The following is a sample snippet: 

        ``` yaml

        dependencies:
            connectionReferences:
            - name: <CONNECTION_NAME>
              resourceRef: <RESOURCE_IDENTIFIER>

        ```

          | Field            | Description                                                         |
          |------------------|---------------------------------------------------------------------|
          | name             | The name given to the connection.                                   |
          | resourceRef      | A unique, readable identifier of the service being connected to.    |


    2. If you've previously added a `connectionReferences` section under `dependencies`, append this as another item under `connectionReferences`. Upon deploying the component, Choreo automatically creates a subscription if applicable and the necessary configurations to establish the connection will be injected into the Choreo-defined environment variables.
      
          The following table details the Choreo-defined environment variables:

          | Configuration Key       | Choreo-Defined Environment Variable Name                       |
          |-------------------------|----------------------------------------------------------------|
          | ServiceURL              | CHOREO_<CONNECTION_NAME\>_SERVICEURL                           |
          | ConsumerKey             | CHOREO_<CONNECTION_NAME\>_CONSUMERKEY                          |
          | ConsumerSecret          | CHOREO_<CONNECTION_NAME\>_CONSUMERSECRET                       |
          | TokenURL                | CHOREO_<CONNECTION_NAME\>_TOKENURL                             |
          | ChoreoAPIKey            | CHOREO_<CONNECTION_NAME\>CHOREOAPIKEY                          |


          If you want to use custom environment variable names instead of the Choreo-defined ones, you must define the environment configurations under the `configuration` section in the same file.
          The following is a sample snippet: 

          ``` yaml
          configuration:
            env:
              - name: HR_SERVICE_URL
                valueFrom:
                  connectionRef:
                    name: hr-connection
                    key: ServiceURL
          ```

          The following table provides details on the configuration keys associated with the connection. These keys can be referenced as `env[i].valueFrom.connectionRef.key`.

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | ServiceURL     | string     | Service URL of the Choreo service     | false         | false        |
          | ConsumerKey    | string     | Consumer key of the Choreo service    | false         | false        |
          | ConsumerSecret | string     | Consumer secret of the Choreo service | false         | true         |
          | TokenURL       | string     | Token URL of the STS                  | false         | false        |
          | ChoreoAPIKey   | string     | API key of the Choreo service         | false         | true         |

          For more details, see the instructions under the **component.yaml file (v1.1)** tab.

    ### Step 2: Read configurations within the application

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const serviceURL = process.env.CHOREO_<CONNECTION_NAME>_SERVICEURL;
    ```

=== "Component.yaml file (v1.0)"

    !!! note
        This `component.yaml v1.0` is a legacy configuration format. For new projects, we recommend using the latest version (v1.1) of `component.yaml` for improved usability and features.
  
    1. Copy and paste the snippet from the in-line developer guide into the `component.yaml` file.
      
        The following is a sample snippet:

        ``` yaml

        dependencies:
            serviceReferences:
            - name: <SERVICE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: ServiceURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerSecret
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: TokenURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ChoreoAPIKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>

        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the service you are connecting to.              |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added a service reference section under `dependencies`, append this as another item under `serviceReferences`. 

          Upon deploying the component, Choreo automatically creates a subscription if applicable and populates the specified environment variables with actual values.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | ServiceURL     | string     | Service URL of the Choreo service     | false         | false        |
          | ConsumerKey    | string     | Consumer key of the Choreo service    | false         | false        |
          | ConsumerSecret | string     | Consumer secret of the Choreo service | false         | true         |
          | TokenURL       | string     | Token URL of the STS                  | false         | false        |
          | ChoreoAPIKey   | string     | API key of the Choreo service         | false         | true         |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const serviceURL = process.env.SVC_URL;
    ```

=== "Component-config.yaml file"

    !!! note
        This `component-config.yaml` is a legacy configuration format. For new projects, we recommend using the latest version (v1.1) of `component.yaml` for improved usability and features.

    1. Copy and paste the snippet from the in-line developer guide into the `component-config` file under the `spec` section.

        The following is a sample snippet:

        ``` yaml

        outbound:
            serviceReferences:
            - name: <SERVICE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: ServiceURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerSecret
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: TokenURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ChoreoAPIKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>

        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the service you are connecting to.              |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added an outbound service reference, append this as another item under `serviceReferences`. 

          Upon deploying the component, Choreo automatically creates a subscription if applicable and populates the specified environment variables with actual values.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | ServiceURL     | string     | Service URL of the Choreo service     | false         | false        |
          | ConsumerKey    | string     | Consumer key of the Choreo service    | false         | false        |
          | ConsumerSecret | string     | Consumer secret of the Choreo service | false         | true         |
          | TokenURL       | string     | Token URL of the STS                  | false         | false        |
          | ChoreoAPIKey   | string     | API key of the Choreo service         | false         | true         |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const serviceURL = process.env.SVC_URL;
    ```

If you're using the API key security scheme for the connection, skip Step 3 and follow the instructions in [Step 4: API key security scheme](#step-4-invoke-the-service) tab.

### Step 3: Acquire an OAuth 2.0 access token

To consume a Choreo service with the visibility level set to organization or public and secured by the OAuth 2.0 security scheme, you must obtain an OAuth 2.0 token from the token endpoint. Subsequently, you can use the token to invoke the service.

- For languages with OAuth 2.0-aware HTTP clients, you must pass the OAuth 2.0-related configurations such as client id, client secret and so on, obtained when creating the connection to your HTTP client configuration. The HTTP client autonomously manages token retrieval and refreshing.

- For languages without OAuth 2.0-aware HTTP clients, you must manually initiate a call to the token endpoint. This includes fetching the token and managing token expiration and refresh directly within your application code. The following is a sample curl command to obtain a token:


    ```bash
    CONSUMER_KEY="your_consumer_key"
    CONSUMER_SECRET="your_consumer_secret"
    TOKEN_URL="your_token_url"

    # Encode client credentials as Base64
    CLIENT_CREDENTIALS=$(echo -n "$CLIENT_ID:$CLIENT_SECRET" | base64)

    curl -X POST $TOKEN_URL \
      -H "Content-Type: application/x-www-form-urlencoded" \
      -H "Authorization: Basic $CLIENT_CREDENTIALS" \
      --data-urlencode "grant_type=client_credentials"

    ```

### Step 4: Invoke the service

Click the tab that matches the security scheme of your service and follow the instructions below:

=== "API key security scheme"

     To invoke the API, use the `choreo-api-key` header with the API key value retrieved from the corresponding environment variable as described in [step 2](#step-2-read-configurations-within-the-application).

     The following is a sample code snippet in NodeJS:

     ``` java
       const response = await axios.get(serviceURL/{RESOURCE_PATH}, {
           headers: {
             'Choreo-API-Key': `${choreoApiKey}`
           }
       });
     ```

=== "OAuth 2.0 security scheme"

     To invoke the service, use the following instructions based on your programming language:

      - For languages with OAuth 2.0-aware HTTP clients, use the service URL resolved in [Step 2](#step-2-read-configurations-within-the-application). The OAuth-aware client manages authentication automatically. For sample requests and responses, see the API definition provided via the Choreo marketplace for the service.

      - For languages without OAuth 2.0-aware HTTP clients, use the token obtained in [step 3](#step-3-acquire-an-oauth-20-access-token) to make calls to the dependent service. Subsequently, add the obtained token to the HTTP authorization header with the bearer prefix. As the service URL, use the URL resolved in [step 2](#step-2-read-configurations-within-the-application). For sample requests and responses, see the API definition of the service provided via the Choreo marketplace.

       The following is a sample code snippet in NodeJS:

       ``` java
       const response = await axios.get(serviceURL/{RESOURCE_PATH}, {
           headers: {
             'Authorization': `Bearer ${accessToken}`
             'Choreo-API-Key': `${choreoApiKey}`
           }
       });
       ```

    !!! note
        If you want to consume a Choreo service at the project visibility level, you don't need to obtain a token. You can directly invoke the service using the resolved URL.


# Use a Connection in Your Web Application

Choreo simplifies the process of integrating services into your web application. The approach to connect to a service can vary based on your web application. 

To connect to a selected service, follow the step-by-step instructions given below depending on the authentication mechanism used in your web application.

=== "Managed authentication"
    
    Choreo-managed authentication allows you to seamlessly handle authentication for your web application. You can configure your web application to work with the built-in identity provider of Choreo or any external identity provider that supports OIDC/OAuth2.0

    !!! note 
         Choreo's managed authentication is currently available only for web applications created with **React**, **Angular**, or **Vue.js** buildpacks.

    Follow the steps below to use an existing connection within your web application: 

    <h2> Step 1: Add the connection configuration</h2>

    To integrate a service into your application, you must first add the connection configuration as follows: 

    1. For single page applications (SPAs), you must add the connection configuration as a file mount. You can mount a file via the **Configurations** pane on the **Deploy** page. You must mount a file (for example, `config.js`) and add the configuration provided in the inline developer documentation into it. 

        The following is a sample configuration:

        ``` yaml
             window.configs = {
                 apiUrl: '<SERVICE_URL>',        
             };

        ```

    2.  To ensure accessibility of the `config.js` file via JavaScript at runtime, add a script tag as follows in the `index.html` file to reference the `config.js` file:

        ``` html
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="utf-8" />
            <title>My React App</title>
        </head>
        <body>
            <div id="root"></div>
            <script src="/public/config.js"></script>
        </body>
        </html>
        ``` 

        !!! note
             If you use an external IdP, you must add the IdP's configuration to the same file.
    
             For more information on working with IdPs, see [Configure Asgardeo as an External Identity Provider](https://wso2.com/choreo/docs/administer/configure-an-external-idp/configure-asgardeo-as-an-external-idp/).


    <h2> Step 2: Read the configuration</h2>

    Once you add the connection configuration, you can proceed to read the configuration from your application. The steps to read depend on the programming language you use.

    The following is a sample code snippet in NodeJS:

    ``` java
         const serviceURL = window?.configs?.apiUrl ? window.configs.apiUrl : "/";
    ```

    <h2> Step 3: Invoke the service</h2>

    If you use Choreo-managed authentication, Choreo handles the security handshaking for the application during deployment. The connected service will be accessible under the same domain as your application. Therefore, you can call the configured path directly using your preferred HTTP client.

    The following is a sample code snippet in NodeJS:

    ``` java
         const response = await axios.get(serviceURL/{RESOURCE_PATH});
    ```

    !!! note
         If you are using an external IdP provider instead of Choreo-managed authentication, you must obtain an access token from your IdP and add it to the HTTP authorization header with the bearer prefix.


=== "Custom authentication or no authentication"

    If you are not using Choreo-managed authentication or your web application lacks authentication, follow the steps below to connect to a service from your web application:

    <h2> Step 1: Add the connection configuration</h2>

    1. For single-page applications (SPAs), you must add the connection configuration as a file mount. You can mount a file via the **Configurations** pane on the **Deploy** page. You must mount a file (for example, `config.js`) and add the configuration provided in the inline developer documentation into it.
 
        The following is a sample configuration:

        ``` yaml
             window.configs = {
                 apiUrl: '<SERVICE_URL>',
                 consumerKey: '<CONSUMER_KEY>',
                 consumerSecret: '<CONSUMER_SECRET>',
                 tokenUrl: '<TOKEN_URL>',
             };
        ```

    2.  To ensure accessibility of the `config.js` file via JavaScript at runtime, add a script tag as follows in the `index.html` file to reference the `config.js` file:

        ``` html
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="utf-8" />
            <title>My React App</title>
        </head>
        <body>
            <div id="root"></div>
            <script src="/public/config.js"></script>
        </body>
        </html>
        ``` 

    For other types of web applications, you must add the respective configuration into your application.

    <h2> Step 2: Read the configuration</h2>

    Once you have added the connection configuration, you can proceed to read the configuration from your application. The steps to read depend on the programming language you use.

    The following is a sample code snippet in NodeJS:

    ``` java
         const serviceURL = window?.configs?.apiUrl ? window.configs.apiUrl : "/";
    ```

    <h2> Step 3: Acquire an OAuth 2.0 access token</h2>

    - For languages with OAuth 2.0-aware HTTP clients, you must pass the OAuth 2.0-related configurations such as client id, client secret and so on, obtained when creating the connection to your HTTP client configuration. The HTTP client autonomously manages token retrieval and refreshing.
  
    - For languages without OAuth 2.0-aware HTTP clients, you must manually initiate a call to the token endpoint. This includes fetching the token and managing token expiration and refresh directly within your application code. The following is a sample curl command to obtain a token:


        ```bash
        CONSUMER_KEY="your_consumer_key"
        CONSUMER_SECRET="your_consumer_secret"
        TOKEN_URL="your_token_url"

        # Encode client credentials as Base64
        CLIENT_CREDENTIALS=$(echo -n "$CLIENT_ID:$CLIENT_SECRET" | base64)

        curl -X POST $TOKEN_URL \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -H "Authorization: Basic $CLIENT_CREDENTIALS" \
        --data-urlencode "grant_type=client_credentials"

        ```

    <h2> Step 4: Invoke the service</h2>

    You can invoke the service as follows:

    - For languages with OAuth 2.0-aware HTTP clients, you can invoke the service in a straightforward manner. The HTTP client seamlessly manages OAuth 2.0 authentication without requiring additional intervention.

        As the service URL you can use the URL that you resolved in step 2 above. For sample requests and responses, see the API definition provided via the Choreo marketplace for the service.

    - For languages without OAuth 2.0-aware HTTP clients, you can use the token obtained in step 3 above to make calls to the dependent service. Subsequently, add the obtained token to the HTTP authorization header with the bearer prefix.

        As the service URL you can use the URL that you resolved in step 2 above. For sample requests and responses, see the API definition of the service provided via the Choreo marketplace.

        The following is a sample code snippet in NodeJS:

        ```java 
            const response = await axios.get(serviceURL/{RESOURCE_PATH}, {
                headers: {
                'Authorization': `Bearer ${accessToken}`
                }
            })
        ```


# Use a Database Connection in Your Component

Choreo allows you to share and reuse Choreo-managed databases, accelerating development and enhancing efficiency in building integrated applications through connections.

For step-by-step instructions on creating a database connection, see [Create a Connection](create-a-connection.md).

To learn more about Choreo Connections, see the documentation on [Connections](../../choreo-concepts/connections.md).

## Consume a database through a connection

To consume a Choreo-managed database via a connection, follow these steps:

### Step 1: Add connection configurations

To integrate a database into your application, click the appropriate tab below based on your current configuration file and follow the step-by-step instructions:

=== "Component.yaml file (v1.1)"

    1. Copy and paste the snippet from the  developer guide into the `component.yaml` file.

        The following is a sample snippet:

        ``` yaml

        dependencies:
            connectionReferences:
            - name: <CONNECTION_NAME>
              resourceRef: <RESOURCE_IDENTIFIER>

        ```

          | Field            | Description                                                         |
          |------------------|---------------------------------------------------------------------|
          | name             | The name given to the connection.                                   |
          | resourceRef      | A unique, readable identifier of the database being connected to.    |


    2. If you've previously added a `connectionReferences` section under `dependencies`, append this as another item under `connectionReferences`. Upon deploying the component, the necessary configurations to establish the connection will be injected into Choreo-defined environment variables.

          The following table details the Choreo-defined environment variables:

          | Configuration Key       | Choreo-Defined Environment Variable Name                       |
          |-------------------------|----------------------------------------------------------------|
          | HostName                | CHOREO_<CONNECTION_NAME\>_HOSTNAME                             |
          | Port                    | CHOREO_<CONNECTION_NAME\>_PORT                                 |
          | Username                | CHOREO_<CONNECTION_NAME\>_USERNAME                             |
          | Password                | CHOREO_<CONNECTION_NAME\>_PASSWORD                             |
          | DatabaseName            | CHOREO_<CONNECTION_NAME\>DATABASENAME                          |


          If you'd like to use custom environment variable names instead of the Choreo-defined ones, add the dependency as a service reference under `dependencies` in the same file. For more details, refer to the instructions under the `component.yaml file (v1.0)` tab.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | HostName       | string     | Hostname of the database server       | false         | false        |
          | Port           | string     | Port of the database server           | false         | false        |
          | Username | string           | Username of the database server       | false         | false        |
          | Password       | string     | Password of the database server       | false         | true         |
          | DatabaseName   | string     | Name of the database                  | false         | false        |
    ### Step 2: Read configurations within the application

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const hostName = process.env.CHOREO_<CONNECTION_NAME>_HOSTNAME;
    ```

=== "Component.yaml file (v1.0)"

    !!! note
        The `component.yaml v1.0` file is considered legacy. For new components, we recommend using the latest version, `component.yaml v1.1`, which offers enhanced usability and features.

    1. Copy and paste the snippet from the  developer guide into the `component.yaml` file.

        The following is a sample snippet:

        ``` yaml

        dependencies:
            serviceReferences:
            - name: database:<DATABASE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: HostName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Port
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Username
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Password
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: DatabaseName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>


        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the database you are connecting to.             |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added a service reference section under `dependencies`, append this as another item under `serviceReferences`.

          Upon deploying the component, Choreo automatically populates the specified environment variables with actual values.

          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | HostName       | string     | Hostname of the database server       | false         | false        |
          | Port           | string     | Port of the database server           | false         | false        |
          | Username | string           | Username of the database server       | false         | false        |
          | Password       | string     | Password of the database server       | false         | true         |
          | DatabaseName   | string     | Name of the database                  | false         | false        |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const hostName = process.env.HOSTNAME;
    ```

=== "Component-config.yaml file"

    !!! note
        The `component-config.yaml` file is considered legacy. For new components, we recommend using the latest version, `component.yaml v1.1`, which offers enhanced usability and features.

    1. Copy and paste the snippet from the  developer guide into the `component-config` file under the `spec` section.

        The following is a sample snippet:

        ``` yaml

        outbound:
            serviceReferences:
            - name: database:<DATABASE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: HostName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Port
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Username
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Password
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: DatabaseName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>

        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the database you are connecting to.              |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added an outbound service reference, append this as another item under `serviceReferences`.

          Upon deploying the component, Choreo automatically populates the specified environment variables with actual values.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | HostName       | string     | Hostname of the database server       | false         | false        |
          | Port           | string     | Port of the database server           | false         | false        |
          | Username | string           | Username of the database server       | false         | false        |
          | Password       | string     | Password of the database server       | false         | true         |
          | DatabaseName   | string     | Name of the database                  | false         | false        |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const hostName = process.env.HOSTNAME;
    ```

### Step 3: Initiate a database connection

To initiate a connection to the database, follow these steps:

In this example, you will connect to a MySQL database.

#### Step 3.1: Install the required packages

For the MySQL database, install the `mysql2` package using npm:

```bash
// Install the mysql2 package
npm install mysql2

```

#### Step 3.2: Import required packages

```java

const client = require('mysql2')

```

#### Step 3.3: Establish a connection

To establish the connection, use the environment variables for `hostName`, `username`, `password`, `databaseName`, and `port` as follows:

```java

var connection = client.createConnection({
      host: hostName,
      user: username,
      password: password,
      database: databaseName,
      port: port
});

connection.connect((err) => {
      if (err) {
          return;
      }
      // Connection is successful
});

```

By following these steps, your component can interact with the Choreo-managed database seamlessly.




# Integrate Unit Tests into the Build Pipeline

Choreo allows you to integrate unit tests into the build pipeline, enabling code validation before deployment. This ensures early testing of code changes, reducing the risk of defects in production.

!!! note
        Currently, Choreo supports unit tests only for the `WSO2 MI` buildpack.

## How it works

### Step 1: Write tests

You can create unit tests in your source code using standard testing libraries. For step-by-step instructions on creating unit tests for WSO2 Micro Integrator projects, see [Creating a Unit Test Suite](https://mi.docs.wso2.com/en/latest/develop/creating-unit-test-suite/).

### Step 2: Enable unit tests

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click the component for which you want to enable unit tests.
3. In the left navigation menu, click **Build**.
4. On the **Build** page, click to edit **Build Configurations**.
5. Turn on the **Unit Test** toggle.
6. Click **Save**.

### Step 3: Trigger a new build

- On the **Build** page, click **Build Latest**.

This starts a new build with unit tests enabled. You can monitor its progress in the **Build Details** pane.

## View failed unit tests

If a unit test fails during the build, you can view its detailed logs for troubleshooting. Click **View Details** corresponding to the failed build, then expand the failed unit test step to view the logs.

## Explore a sample

To see unit tests in action within the build pipeline, try out the [WSO2 MI helloworld](https://github.com/wso2/choreo-samples/tree/main/hello-world-mi) sample. 


# Manage Component Source Configurations

In Choreo, you can configure service endpoints and connections via the `component.yaml` source configuration file. This file ensures that the configurations required to initialize endpoints and connections are defined, as they cannot be inferred from the source code. This guide provides an overview of how to configure and manage these settings effectively.

The source configuration file must be committed to your repository within the `.choreo` directory at the root of the project directory. This ensures the ability to version the configuration files alongside repository commits, enabling better tracking and management of configurations.

!!! note
    -  The `component-config.yaml` and `endpoints.yaml` files will eventually be deprecated and replaced by the `component.yaml` file. 
        - For details on how to seamlessly update to the latest `component.yaml` file`, see [Update to the latest source configuration file](#update-to-the-latest-source-configuration-file).
    - Choreo prioritizes configuration files in the following order: `component.yaml` takes the highest precedence, followed by `component-config.yaml`, and then `endpoints.yaml`.

## Overview of the `component.yaml` file 

**File location**:

```bash
<build-context-path>/.choreo/component.yaml
```

!!! note
    - For components built using **Buildpacks**, replace `build-context-path` with the `<project-directory>`. 
    For example, `<project-directory>/.choreo/component.yaml`.
    - For components built using **Docker**, replace `build-context-path` with the `<docker-context-path>`. 
    For example, `<docker-context-path>/.choreo/component.yaml`.

**Sample `component.yaml` file content**:

Click the respective tab to view the structure for your current configuration file version:

=== "Version 1.1"

    ``` yaml
    # +required The configuration file schema version
    schemaVersion: 1.1

    # +optional Incoming connection details for the component
    endpoints:
      # +required Unique name for the endpoint.
      # This name will be used when generating the managed API
      - name: greeter-sample
        # +optional Display name for the endpoint.
        displayName: Go Greeter Sample
        # +required Service section has the user service endpoint details
        service:
          # +optional Context (base path) of the API that gets exposed via the endpoint.
          basePath: /greeting-service
          # +required Numeric port value that gets exposed via the endpoint
          port: 9090
        # +required Type of traffic that the endpoint is accepting.
        # Allowed values: REST, GraphQL, WS, GRPC, TCP, UDP.
        type: REST
        # +optional Network level visibilities of the endpoint.
        # Accepted values: Project|Organization|Public(Default).
        networkVisibilities: 
          - Public
          - Organization
        # +optional Path to the schema definition file. Defaults to wild card route if not provided
        # This is only applicable to REST or WS endpoint types.
        # The path should be relative to the docker context.
        schemaFilePath: openapi.yaml
      
      # +optional Outgoing connection details for the component.
      dependencies:
        # +optional Defines the connection references from the Internal Marketplace.
        connectionReferences:
          # +required Name of the connection.
          - name: hr-connection
            # +required service identifer of the dependent component.
            resourceRef: service:/HRProject/UserComponent/v1/ad088/PUBLIC
      # +optional Defines runtime configurations
      configurations:
        # +optional List of environment variables to be injected into the component.
        env:
          # +required Name of the environment variable
          - name: HR_SERVICE_URL
            # +required value source
            # Allowed value sources: connectionRef
            valueFrom:
              # +required Choreo connection value source
              connectionRef:
                # +required Choreo connection name to refer the value from
                name: hr-connection
                # +required Choreo connection configuration key to refer the value from
                key: ServiceURL
    ```

    The descriptor-based approach of the `component.yaml` file simplifies and streamlines endpoint and connection configuration management. The use of versioned schemas ensures backward compatibility, providing a seamless transition with future updates.

    You can define the following root-level configurations via the `component.yaml` file:

    | Configuration        | Required     | Description                                                              |
    |----------------------|--------------|--------------------------------------------------------------------------|
    | **schemaVersion**    | Required     | The version of the `component.yaml` file. Defaults to the latest version.|
    | **endpoints**        | Optional     | The list of endpoint configurations.                                     |
    | **dependencies**     | Optional     | The list of dependency configurations.                                   |
    | **configurations**    | Optional     | The runtime configuration definitions.                                   |

    ### Endpoint configurations
    In the `endpoints` section of the `component.yaml` file, you can define multiple service endpoint configurations. Each endpoint must have a unique name and the required fields specified in the schema overview.

    !!! tip "Why have a unique name?"
          When you define multiple endpoints, the `endpoint.name` is appended to the Choreo-generated URL. A unique name ensures the endpoint is easily recognizable and readable within the URL.
          
    | Configuration        | Required     | Description                                                                                             |
    |----------------------|--------------|---------------------------------------------------------------------------------------------------------|
    | **name**             | Required     | A unique identifier for the endpoint within the service component. Avoid using excessively long names.  |
    | **displayName**      | Optional     | A display name for the endpoint.                                                                        |
    | **service**          | Required     | Service details for the endpoint.                                                                       |
    | **.basePath**        | Required     | The base path of the API exposed via this endpoint.                                                     |
    | **.port**            | Required     | The numeric port value exposed via this endpoint.                                                       |
    | **type**             | Required     | The type of traffic the endpoint accepts. For example, `REST`, `GraphQL`, `WS`, `gRPC`, `UDP`, or `TCP`.|
    | **networkVisibilities** | Required | The network-level visibility of the endpoint. For example, project, organization, or public.             |
    | **schemaFilePath** | Required | The file path to the swagger definition  or AsyncAPI 2.0 specification file. Defaults to the wildcard route if not specified. This field should be a relative path to the project path when using **Java**, **Python**, **NodeJS**, **Go**, **PHP**, **Ruby**, or **WSO2 MI** buildpacks. For REST or WebSocket endpoint types, when using the **Ballerina** or **Dockerfile** buildpack, the path should be relative to the component root or Docker context. |

    ### Dependency configurations

    In the `dependencies` section of the `component.yaml` file, you can define multiple connection configurations under `dependencies.connectionReferences`. You can use the connection reference generated in the inline developer guide when creating a connection. For instructions on copying [connection configurations](https://wso2.com/choreo/docs/develop-components/sharing-and-reusing/use-a-connection-in-your-service/), see the inline developer guide displayed during connection creation.

    You must include the following configurations in the `dependencies.connectionReferences` schema:

    | Configuration        | Required     | Description                                                                      |
    |----------------------|--------------|----------------------------------------------------------------------------------|
    | **name**             | Required     | The name given to the connection.                                                |
    | **resourceRef**      | Required     | A unique, human-readable identifier for the service you are connecting.          |


    !!! note
        Choreo automatically generates connection configurations when you create a connection. The properties such as **name** and **resourceRef** are automatically generated. The configurations required to establish the connection will be injected into Choreo-defined environment variables.

        To use custom environment variable names instead of Choreo's default ones, add the dependency as a `serviceReference` in your `component.yaml v1.1` file. You can copy the `serviceReference` section from the `component.yaml v1.0` tab and paste it under `dependencies` in your `component.yaml v1.1` file, which maintains backward compatibility with the v1.0 format.

    ### Runtime configurations
    In the `configurations` section of the `component.yaml` file, you can define runtime configurations for the component. These configurations currently support environment variable injection related to dependencies.
    
    | Configuration                 | Required     | Description                                                                       |
    |-------------------------------|--------------|-----------------------------------------------------------------------------------|
    | **env**                       | Optional     | An array of env variable configurations.                                          |
    | **name**                      | Required     | A unique name for the environment variable, starting with a letter or an underscore, and containing only letters, numbers, or underscores. |
    | **valueFrom**                 | Required     | The source of the environment variable value.                                     |
    | **connectionRef**             | Required     | Connection reference value source definition.                                     |
    | **name**                      | Required     | The name of the Choreo connection to reference the value from.                    |
    | **key**                       | Required     | The Choreo connection configuration key to reference the value from. For details on available keys, see [connection configurations](https://wso2.com/choreo/docs/develop-components/sharing-and-reusing/use-a-connection-in-your-service/) or the inline developer guide. |

    !!! note
        Runtime configurations are supported starting from `component.yaml v1.1`.

        When an environment variable value is specified using `connectionRef`, the connection's environment variable is renamed to the environment variable name defined in the `configurations` section. For example, in the sample `component.yaml` file given above, the `CHOREO_HR_CONNECTION_SERVICEURL` variable in the `hr-connection` is renamed to `HR_SERVICE_URL`.

=== "Version 1.0"

    ``` yaml
    # +required The configuration file schema version
    schemaVersion: 1.0

    # +optional Incoming connection details for the component
    endpoints:
      # +required Unique name for the endpoint.
      # This name will be used when generating the managed API
      - name: greeter-sample
        # +optional Display name for the endpoint.
        displayName: Go Greeter Sample
        # +required Service section has the user service endpoint details
        service:
          # +optional Context (base path) of the API that gets exposed via the endpoint.
          basePath: /greeting-service
          # +required Numeric port value that gets exposed via the endpoint
          port: 9090
        # +required Type of traffic that the endpoint is accepting.
        # Allowed values: REST, GraphQL, WS, GRPC, TCP, UDP.
        type: REST
        # +optional Network level visibilities of the endpoint.
        # Accepted values: Project|Organization|Public(Default).
        networkVisibilities: 
          - Public
          - Organization
        # +optional Path to the schema definition file. Defaults to wild card route if not provided
        # This is only applicable to REST or WS endpoint types.
        # The path should be relative to the docker context.
        schemaFilePath: openapi.yaml
      
    # +optional Outgoing connection details for the component.
    dependencies:
      # +optional Defines the service references from the Internal Marketplace.
      serviceReferences:
        # +required Name of the service reference.
        - name: choreo:///apifirst/HRProject/UserComponent/ad088/v1/PUBLIC
          # +required Name of the connection instance.
          connectionConfig: 19d2648b-d29c-4452-afdd-1b9311e81412
          # +required Environment variables injected into the component for connection configuration.
          env:
            # +required Key name of the connection configuration.
            - from: ServiceURL
              # +required Environment variable injected into the container.
              to: SERVICE_URL
    ```

    The descriptor-based approach of the `component.yaml` file simplifies and streamlines endpoint and connection configuration management. The use of versioned schemas ensures backward compatibility, providing a seamless transition with future updates.

    You can define the following root-level configurations via the `component.yaml` file:

    | Configuration        | Required     | Description                                                              |
    |----------------------|--------------|--------------------------------------------------------------------------|
    | **schemaVersion**    | Required     | The version of the `component.yaml` file. Defaults to the latest version.|
    | **endpoints**        | Optional     | The list of endpoint configurations.                                     |
    | **dependencies**     | Optional     | The list of dependency configurations.                                   |

    <h3> Endpoint configurations </h3>
    In the `endpoints` section of the `component.yaml` file, you can define multiple service endpoint configurations. Each endpoint must have a unique name and the required fields specified in the schema overview.

    !!! tip "Why have a unique name?"
          When you define multiple endpoints, the `endpoint.name` is appended to the Choreo-generated URL. A unique name ensures the endpoint is easily recognizable and readable within the URL.
          
    | Configuration           | Required     | Description                                                                                             |
    |-------------------------|--------------|---------------------------------------------------------------------------------------------------------|
    | **name**                | Required     | A unique identifier for the endpoint within the service component. Avoid using excessively long names.  |
    | **displayName**         | Optional     | A display name for the endpoint.                                                                        |
    | **service**             | Required     | Service details for the endpoint.                                                                       |
    | **.basePath**           | Required     | The base path of the API exposed via this endpoint.                                                     |
    | **.port**               | Required     | The numeric port value exposed via this endpoint.                                                       |
    | **type**                | Required     | The type of traffic the endpoint accepts. For example, `REST`, `GraphQL`, `gRPC`, `WS`, `UDP`, or `TCP`.|
    | **networkVisibilities** | Required     | The network-level visibility of the endpoint. For example, project, organization, or public.            |
    | **schemaFilePath**      | Required     | The file path to the swagger definition or AsyncAPI 2.0 specification file. Defaults to the wildcard route if not specified. This field should be a relative path to the project path when using **Java**, **Python**, **NodeJS**, **Go**, **PHP**, **Ruby**, or **WSO2 MI** buildpacks. For REST or WebSocket endpoint types, when using the **Ballerina** or **Dockerfile** buildpack, the path should be relative to the component root or Docker context. |

    <h3> Dependency configurations </h3>

    In the `dependencies` section of the `component.yaml` file, you can define multiple service connection configurations under `dependencies.serviceReferences`. You can use the service references generated in the inline developer guide when creating a service connection. For instructions on copying [connection configurations](https://wso2.com/choreo/docs/develop-components/sharing-and-reusing/use-a-connection-in-your-service/), see the inline developer guide displayed during connection creation.

    You must include the following configurations in the `dependencies.serviceReferences` schema:

    | Configuration        | Required     | Description                                                                      |
    |----------------------|--------------|----------------------------------------------------------------------------------|
    | **name**             | Required     | A unique name for the service reference.                                         |
    | **connectionConfig** | Required     | A unique name for the connection instance.                                       |
    | **env**              | Required     | The list of environment variable mappings to inject into the container.          |
    | **.from**            | Required     | The key name of the connection configuration.                                    |
    | **.to**              | Required     | The environment variable to inject into the container.                           |

    !!! note
        Choreo automatically generates connection configurations when you create a connection. The properties such as **name**, **connectionConfig**, and **env.from** are automatically generated. However, you must manually set the **env.to** value.

## Overview of the `component-config.yaml` file 

**File location**:

```bash
<build-context-path>/.choreo/component-config.yaml
```

**Sample `component-config.yaml` file content**:

```yaml
apiVersion: core.choreo.dev/v1beta1
kind: ComponentConfig
spec:
  # +optional Incoming connection details for the component (AKA endpoints).
  inbound:
    # +required Unique name for the endpoint.
    # This name will be used when generating the managed API
    - name: Greeting Service
      # +required Numeric port value that gets exposed via the endpoint
      port: 9090
      # +required Type of traffic that the endpoint is accepting.
      # Allowed values: REST, GraphQL, GRPC, TCP, UDP, WS.
      type: REST
      # +optional Network level visibility of the endpoint. Defaults to Public
      # Accepted values: Project|Organization|Public.
      networkVisibility: Public
      # +optional Context (base path) of the API that gets exposed via the endpoint.
      # This is mandatory if the endpoint type is set to REST, GraphQL or WS.
      context: /greeting
      # +optional The path to the schema definition file. Defaults to wildcard route if not specified.
      # This is only applicable to REST and WS endpoint types.
      # The path should be relative to the Docker context.
      schemaFilePath: greeting_openapi.yaml
  # +optional Outgoing connection details for the component.
  outbound:
    # +optional Defines the service references from the Internal Marketplace.
    serviceReferences:
      # +required Name of the service reference.
      - name: choreo:///apifirst/mttm/mmvhxd/ad088/v1.0/PUBLIC
        # +required Name of the connection instance.
        connectionConfig: 19d2648b-d29c-4452-afdd-1b9311e81412
        # +required Environment variables injected to the component for connection configuration.
        env:
          # +required Key name of the connection configuration.
          - from: ServiceURL
            # +required Environment variable injected to the container.
            to: SERVICE_URL
```

The `component-config.yaml` file complements and enhances the existing endpoint configuration process. It allows you to define how the endpoints (inbound connections) in your service are exposed and how your service connects to external services or components (outbound connections).

You can define the following root-level configurations via the `component-config.yaml` file:

| Configuration        | Required     | Description                                                                           |
|----------------------|--------------|---------------------------------------------------------------------------------------|
| **apiVersion**       | Required     | The version of the `component-config.yaml` file defaults to `core.choreo.dev/v1beta1`.|
| **kind**             | Required     | The resource type of the file defaults to `ComponentConfig`.                          |
| **spec.inbound**     | Optional     | The list of inbound connection configurations.                                        |
| **spec.outbound**    | Optional     | The list of outbound connection configurations.                                       |

#### Inbound connection configurations (`spec.inbound`)

In the `spec.inbound` configuration section, you can specify endpoints to set up inbound connections. To specify endpoints, you can follow the existing endpoints schema structure. For details on the endpoints schema structure, see the [endpoints schema documentation](#overview-of-the-endpointsyaml-file).

#### Outbound connection configurations (`spec.outbound`)

In the `spec.outbound` section, you can define `serviceReferences`. To define `serviceReferences`, you can use the service references generated in the Internal Marketplace when creating a service connection. To copy the [outbound connection configurations](../sharing-and-reusing/use-a-connection-in-your-service/#use-a-connection-in-your-service), see the inline developer guide displayed when you create a connection.

You must include the following configurations in the `serviceReferences` schema:

| Configuration        | Required     | Description                                                                      |
|----------------------|--------------|----------------------------------------------------------------------------------|
| **name**             | Required     | A unique name for the service reference.                                         |
| **connectionConfig** | Required     | A unique name for the connection instance.                                       |
| **env**              | Optional     | The list of environment variable mappings to inject into the container.          |
| **env.from**         | Required     | The key name of the connection configuration.                                    |
| **env.to**           | Required     | The environment variable to inject into the container.                           |

## Overview of the `endpoints.yaml` file

**File location**:

```bash
<build-context-path>/.choreo/endpoints.yaml
```

**Sample `endpoints.yaml` file content**:

```yaml
# +required Version of the endpoint configuration YAML
version: 0.1

# +required List of endpoints to create
endpoints:
  # +required Unique name for the endpoint.
  # This name will be used when generating the managed API
- name: Greeting Service
  # +required Numeric port value that gets exposed via this endpoint
  port: 9090
  # +required Type of the traffic this endpoint is accepting.
  # Allowed values: REST, GraphQL, GRPC, UDP, TCP, WS.
  type: REST
  # +optional Network level visibility of this endpoint. Defaults to Public
  # Accepted values: Project|Organization|Public.
  networkVisibility: Project
  # +optional Context (base path) of the API that is exposed via this endpoint.
  # This is mandatory if the endpoint type is set to REST, GraphQL or WS.
  context: /greeting
  # +optional Path to the schema definition file. Defaults to wild card route if not provided
  # This is only applicable to REST and WS endpoint types.
  # The path should be relative to the docker context.
  schemaFilePath: greeting_openapi.yaml
```

The `endpoints.yaml` configuration file allows you to define configurations for multiple endpoints necessary for Choreo service components. This schema is essential to identify the context, port binding, network exposure level, and other attributes required to generate a Choreo endpoint.

You can define the following root-level configurations via the `endpoints.yaml` file:

| Configuration        | Required     | Description                                                                       |
|----------------------|--------------|-----------------------------------------------------------------------------------|
| **version**          | Required     | The version of the `endpoints.yaml` file.                                         |
| **name**             | Required     | A unique name for the endpoint, which Choreo will use to generate the managed API.|
| **port**             | Required     | The numeric port value that gets exposed via this endpoint.                       |
| **type**             | Required     | The type of traffic this endpoint accepts, such as `REST`, `GraphQL`, `gRPC`, `WS`, `UDP`, or `TCP`. Currently, the MI preset supports only the `REST` type.                                         |
| **networkVisibility**| Required     | The network level visibility of this endpoint, which defaults to `Public` if not specified. Accepted values are `Project`, `Organization`, or `Public`.|
| **context**          | Required     | The context (base path) of the API that Choreo exposes via this endpoint.         |
| **schemaFilePath**   | Required     | The swagger definition file path. Defaults to the wildcard route if not provided. This field should be a relative path to the project path when using the **Java**, **Python**, **NodeJS**, **Go**, **PHP**, **Ruby**, and **WSO2 MI** buildpacks. For REST endpoint types, when using the **Ballerina** or **Dockerfile** buildpack, this field should be a relative path to the component root or Docker context.|

## Update to the latest source configuration file

With the upcoming deprecation of the `component-config.yaml` file and the `endpoints.yaml` file, Choreo provides a seamless process to move to the latest `component.yaml`  version of the `component.yaml` file. Follow these steps to transition seamlessly:

### Step 1: Identify whether your current source configuration file is outdated

You can determine whether you’re using an outdated configuration file in the following ways:

- **During a build:**
     - On the **Build** page, after triggering a build, a warning will appear if your source configuration file is outdated. Click **View Details** in the **Initialization** -> **Source Config Validation** step. You will see an information banner with an option to update the file.

- **In existing deployments:**
     - If an existing deployment uses a build with an outdated source configuration file, you will see a warning icon on the build card of the relevant environment card.


### Step 2: Generate the latest `component.yaml` file

- In either of the scenarios above, click **Update** to initiate the process of generating the latest `component.yaml` file. The updated file will retain your existing configurations to ensure a smooth update process.


### Step 3: Add the generated configuration file to your repository

1. Download the generated `component.yaml` file.
2. Replace the existing source configuration file in the `.choreo` folder within your source repository.
    - Ensure the file name is `component.yaml`.


### Step 4: Trigger a new build

1. Commit the new `component.yaml` file to your repository. Push changes to the remote Git repository.
2. Trigger a build using the latest commit.


### Step 5: Verify the update

Once the build is complete:

  - Deploy the build.
  - Confirm that the warning messages no longer appear.

You can benefit from the latest features and enhancements provided by the updated source configuration file.


# Manage Deployment Tracks for Choreo Components

Choreo allows you to create and manage dedicated [deployment tracks](../choreo-concepts/deployment-tracks.md) for components, facilitating independent version control and deployment. This capability also allows you to unlink deployment tracks from associated branches or relink them to different branches so that you can align with your preferred Git workflows, such as the feature branch workflow or GitFlow workflow.

!!! info
     Deployment track creation and management does not apply to API Proxy and [BYOI components](../develop-components/bring-your-own-image.md).

## Create a deployment track

**Prerequisites**:

 - Create a component in Choreo.

Follow the steps below to create a deployment track for a component:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to create a deployment track for.
3. On the header of the component overview page, click the **Deployment Track** drop-down list.
4. Click **+ Create New** to open the **Create Deployment Track** dialog.
5. In the **Create Deployment Track** dialog, do the following:
    1. Select a branch to associate with the deployment track.
    2. Optionally, specify a description for the deployment track. 
    3. To create a deployment track for a service component, specify a unique API version indicating the major and minor version numbers.
6. Click **Create**.

## Unlink a deployment track

If you want to detach a branch reference from a deployment track, you must unlink the branch.

!!! info
     When you unlink the branch of a deployment track, the active deployments are unaffected. However, while you can redeploy the existing deployment, you cannot perform a new deployment.

Follow the steps below to unlink a deployment track of a component:
  
1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to unlink a deployment track.
3. On the header of the component overview page, click the **Deployment Track** drop-down list and then click **View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
4. Click the edit icon corresponding to the deployment track you want to unlink.
5. In the **Edit Branch** dialog that opens, click the **Branch Name** list and select **None**.
6. Click **Save**.

## Link a deployment track

To associate a branch reference to an unlinked deployment track, you must link a branch.

!!! info
    To build and deploy the contents of the linked branch,  you must perform a manual build and deploy.

**Prerequisites**:

 - A minimum of two branches in your GitHub repository.

Follow the steps below to link a branch to an unlinked deployment track:
  
1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to associate a branch reference for.
3. On the header of the component overview page, click the **Deployment Track** drop-down list and then click **View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
4. Click **+ Link Branch** corresponding to the unlinked deployment track for which you want to associate a branch.
5. In the **Link Branch** dialog that opens, click the **Branch Name** list and select the branch you want to relink.
6. Click **Save**.

## Relink a deployment track

To switch the branch reference of a linked deployment track, you must relink to an appropriate branch.

!!! info
      If you unlink the existing branch of a deployment track and link a different branch, you must perform a manual build and deploy to build and deploy the contents of the recently linked branch.

**Prerequisites**:

 - A minimum of two branches in your GitHub repository.

Follow the steps below to switch the branch reference of a linked deployment track:
  
1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to relink a deployment track for.
3. On the header of the component overview page,  click the **Deployment Track** drop-down list and then click **View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
4. Click the **Edit Branch** icon corresponding to the deployment track you want to relink.
5. In the **Edit Branch** dialog that opens, click the **Branch Name** list and select the branch you want to relink.
6. Click **Save**.

Now that you understand how to create and manage deployment tracks for components, let’s explore a sample scenario to see how a developer can use deployment tracks to manage version releases in Choreo.

## Sample Scenario: Manage version releases with deployment tracks

Let’s consider the following version release scenario: 

- To initiate work on a new feature, a developer creates a new branch, named `feature-x` from either the `main` or `dev` branch.
- Once development is complete, the developer proceeds to merge the `feature-x` branch into the `dev` branch for testing.
- Upon successful testing in the `dev` branch, the developer proceeds to merge all the changes into the `main` branch for production deployment.

Following are the actions you need to take from a deployment track perspective to manage the version release:

1. To prepare for the new version release, unlink the `main` branch from the associated deployment track (let’s consider this as the deployment track 1).
2. Proceed to merge the `dev` branch containing the tested changes into the `main` branch.
3. Unlink the `dev` branch from the associated deployment track (let’s consider this as deployment track 2).
4. Link deployment track 2 containing the latest version of the service to the `main` branch for deployment.
5. To facilitate ongoing development and testing, create another deployment track (let’s consider this as deployment track 3) and link it to the `dev` branch.

!!! tip
     - As a developer, you can strategically unlink and relink deployment tracks to effectively manage different versions of your services within Choreo.
     - You can create new deployment tracks for ongoing development branches like `dev` to ensure a continuous development and release cycle.

## Delete a deployment track

If you no longer need a deployment track, you can delete it.

!!! note
    If the component exposes an endpoint or proxy and you want to delete the last version in the major version range, the recommended approach is to retire that version first. This allows consumers to transition to the next major version and prevents a sudden break in their experience.
    For example, if you have deployment tracks for v1.0 and v2.0, notify consumers to switch to v2.0 before deleting v1.0. Then, retire the APIs in v1.0 and proceed to delete the associated deployment track.




**Prerequisites**:

- At least 2 deployment tracks in a component.

Follow the steps below to delete a deployment track:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to delete a deployment track.
3. On the header of the component overview page, click the **Deployment Track** drop-down list.
4. Click **+ View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
5. Click the **Delete** icon corresponding to the deployment track you want to delete.
6. Click **Delete** to confirm the deletion.

# Manage the Micro Integrator Runtime Version in Your Integration Project

Choreo allows you to use a preferred WSO2 Micro Integrator (MI) runtime version in your integration project. Currently, Choreo supports MI product versions 4.1.0 and 4.2.0. You have the flexibility to deploy WSO2 updates within these specified versions. 

When you create an integration project, you can specify a required runtime version to gain control over the environment in which your integration runs. This version management capability empowers you to tailor your projects depending on your runtime requirements, enhancing the customization and adaptability of your integration workflows.

## Understand the version string

WSO2 Micro Integrator (MI) utilizes a versioning system consisting of three-digit numbers, such as `4.1.0` and `4.2.0`, following semantic versioning principles. The product remains committed to receiving updates from WSO2, including security fixes, bug resolutions, and enhancements. Within the Choreo platform, the MI runtime version is constructed by combining the product release version with its corresponding update level.

In Choreo, the MI runtime version is structured as a four-digit number, for example, `4.1.0.14` or `4.2.0.17`. The first three digits represent the product release version, while the last digit signifies the update level of the product. The fourth digit is optional and can be omitted.

![Version string](../assets/img/develop-components/micro-integrator/version-string.png)

## Version management in WSO2 Integration Studio

If you are using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/) to build and deploy integration artifacts in WSO2 Micro Integrator, you can create multiple runtime environments and execute projects on any selected environment. WSO2 Integration Studio also allows you to configure multiple Micro Integrator runtime environments, offering flexibility and customization in the execution of integration processes.

You can specify the Runtime version when you create an integration project in WSO2 Integration Studio. In the project creation wizard, specify the runtime version in the **Runtime version** field, as shown below.
![Specify Runtime version](../assets/img/develop-components/micro-integrator/specify_runtime_version.png)


An integration project is structured as a Maven project with multiple sub-modules. The root `pom.xml` file holds crucial information about the target runtime. The runtime version you configure when you create a new project is saved within the root `pom.xml` file. The version information is stored in the <project.runtime.version> element under the <properties> in the `pom.xml` file. If there is a need to update the runtime version, you have the flexibility to modify the value to a valid runtime version and ensure that the project runs in the required runtime environment.

![project runtime version](../assets/img/develop-components/micro-integrator/project-runtime-version.png)

You can establish multiple runtime environments by utilizing updated MI instances. With a valid WSO2 subscription, you can also access and download updates to set up an updated MI server locally. This update process allows you to select a preferred update level as the runtime version. Consequently, you can run your integration on a runtime with the latest updates, ensuring optimal performance and access to new features.

### Configure a Micro Integrator runtime environment in Integration Studio

If you are using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), follow these steps to set up a remote server instance with a Micro Integrator runtime environment to execute your integration project:

!!! info "Note"
    If you have not downloaded and installed WSO2 Integration Studio, you can follow the [installation instructions](https://apim.docs.wso2.com/en/latest/integrate/develop/installing-wso2-integration-studio/) in the WSO2 API Manager documentation.

1. Launch WSO2 Integration Studio and click **Add Server** in the **Getting Started** view.
   ![Add server](../assets/img/develop-components/micro-integrator/add-server.png)
2. In the **Define a New Server** dialog, click to expand the `WSO2` directory and select **WSO2 Remote Server**.
   ![Define a remote server instance](../assets/img/develop-components/micro-integrator/define-a-remote-server-instance.png)
3. Enter the WSO2 Micro Integrator Management API URL in the **Server URL** field and click **Test Connection**.

    !!! info "Note"
        The Management API of WSO2 Micro Integrator is an internal REST API introduced to substitute MI admin services. The default HTTPS port of the Management API of WSO2 Micro Integrator is `9164`. If you have not manually changed the default port, you must set the Management API URL as `https://localhost:9164/management`.  If you have changed the default HTTPS port, you must set the port number appropriately when specifying the **Server URL**. For more information on the default ports of WSO2 Micro Integrator, see [WSO2 Micro Integrator default ports](https://apim.docs.wso2.com/en/latest/install-and-setup/setup/reference/default-product-ports/#micro-integrator-ports) in the WSO2 API Manager documentation.

    ![Set server URL](../assets/img/develop-components/micro-integrator/set-server-url.png)
    
4. Click **Finish**.
5. In the **Add and Remove** dialog, select the integration components to move from the left side to the right side.
6. Click **Add >**.
7. Click **Finish**. 

Your integration project is now running in a remote server instance with the Micro Integrator runtime environment you require.
If you need to make changes to the integration project, expand the remote server instance, right-click on the deployed exporter project, and select **Redeploy** to apply the changes.

![Redeploy project](../assets/img/develop-components/micro-integrator/redeploy-project.png)

## Convention for version interpretation in Choreo deployments

You can use the following convention to indicate the required MI runtime version in your integration project:


| **Version format**           | **Example**       | **Description**   |
|------------------------------|-------------------|-------------------|
| Product version              | `4.1.0`, `4.2.0`  | Deploy on the latest update level of the mentioned product version.                 |
| Product version with update level  | `4.1.0.15`, `4.2.0.17` |  Deploy on the exact update level of the mentioned product version.    |
| GA version                   | `4.1.0.0`, `4.2.0.0` | Deploy on the exact GA version without any update.                  |
| Default version            | Empty value         | Deploy on the latest update level of the default product version.                  |


Choreo utilizes Alpine images for configuring and deploying the Micro Integrator runtime. This includes automated configuration of the JRE/JDK, customized to the compatibility of the chosen runtime version, simplifying the setup procedure.

## Migrate between runtime versions

Changing the runtime version in an integration project may become necessary during product version upgrades or when you want to apply updates. 

To change the runtime version of a MI Integration, follow the below steps.

### Update the runtime version in the integration project
    
To change the runtime version in the integration project, follow the steps below:
1. Open the project in Integration Studio.
2. Right-click on the project and select **Change Runtime MI Version**.
    ![Update Runtime version](../assets/img/develop-components/micro-integrator/click_change_runtime.png)
3.  Specify the new runtime version as shown below:
    ![Update Runtime version](../assets/img/develop-components/micro-integrator/update_runtime_version.png)
4. Alternatively, you can manually update the version by opening the root `pom.xml` file.  Open pom.xml and change the required runtime version in `<project.runtime.version>` element under `<properties>` section.

To test the changes locally, you must download and set up the runtime environment locally. Then, you must [configure the Integration Studio runtime environment](#configure-a-micro-integrator-runtime-environment-in-integration-studio) by directing it to the locally installed MI runtime. Once the setup is complete, you can deploy your integrations on the MI runtime environment and proceed to the testing phase.

After completing the tests to ensure everything works as expected, you can follow below steps to deploy the project in Choreo:

1. Commit and push the changes to your repository.
2. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
3. Select your project from the **Project** list in the header.
4. Select your MI integration component from the **Component** list in the header.
5. In the left navigation menu, click **Build**.
6. Select the latest commit and click **Build**.
7. In the left navigation menu, click **Deploy**.
8. Click on the **Configure and Deploy** and deploy the component.
9. Verify the Runtime version by checking the logs by selecting the **Runtime Logs** under the **Observability** section.

  You will see the runtime version in the logs as shown below:
  ![Runtime version in logs](../assets/img/develop-components/micro-integrator/runtime_version_in_logs.png)

Next, you must conduct additional testing in the development environment on Choreo before you promote the integration to production environments.

## Troubleshoot errors

The following error codes can help you troubleshoot errors that occur during the integration component build:

| **Error code** | **Description**            |
|----------------|----------------------------|
| 110 - 119      | Internal server error.     |
| 121            | Malformed runtime version. |
| 122            | The specified runtime version is not available. Either the product or update level is not available.    |
| 123            | Trivy security vulnerabilities found in the `libs` directory. |
| 124            | Trivy security vulnerabilities found in the `dropins` directory. |
| 125            | Trivy security vulnerabilities found in the `libs` or `dropins` directory. |
| 126            | Error building integration project. |


# Submit and Manage Workflow Approval Requests

In Choreo, if an administrator [configures a workflow to require approval](../administer/configure-approvals-for-choreo-workflows.md), you must submit a request to obtain approval to perform the task.

Upon submitting a workflow approval request, Choreo notifies all authorized assignees via email about the [review request](../administer/review-workflow-approval-requests.md). When an authorized assignee approves or rejects the request, you will receive an email with details of the decision.

The approach to request approval can vary depending on the workflow. 

## Request approval for environment promotion

**Prerequisites**:

- Ensure you have a component created, built, and deployed to the development environment.
- Ensure that an approval workflow is configured for environment promotion.
- Ensure you are promoting the component to a critical environment, such as production.

To request approval to promote a component from the development environment to production, follow these steps:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to deploy. This takes you to the **Overview** page of the component.
3. In the left navigation menu, click **Deploy**.
4. Go to the **Development** card and click **Request to Promote**.
5. In the **Request Approval** pane that opens, enter your request details and click **Submit**. This creates a request and notifies all authorized assignees via email about the request.

    !!! note
         When an environment promotion request for a specific component is pending review, Choreo restricts other developers from making the same request until the pending request is either approved or rejected.

When an authorized assignee approves the request, you will receive a confirmation email and can proceed to promote the component to production.

## Cancel a workflow approval request

If you want to cancel a workflow approval request that is already submitted, you can do so before the request is approved or rejected. 

When you submit a workflow approval request, the **Request to Promote** button changes to **Cancel Request**. To cancel an approval request, click **Cancel Request**. Upon confirming the cancellation, all configured approvers are notified immediately, and the request will no longer be pending.


# Work with the Micro Integrator Runtime in Choreo

WSO2 Micro Integrator (WSO2 MI) is a lightweight, high-performance integration runtime. It allows you to run integrations developed using WSO2 Integration Studio within Choreo. 

The topics on this page walk you through the key aspects you need to understand to use the WSO2 MI runtime effectively in Choreo.

## Integration types

Choreo supports the following WSO2 MI integrations that cater to different use cases and requirements. Each integration type serves a specific purpose. Therefore, it is essential to understand their differences to easily choose the most appropriate integration for your use case.

- **Service**: Exposes an integration as an API via HTTP, making it possible to create a RESTful interface for your integration services. This type is ideal for scenarios where you need to provide an API for external systems or clients to interact with your integration.
- **Event Handler**: Triggers an integration based on external events such as messages arriving on a queue or updates in a database. This type is well-suited for implementing event-driven architectures or responding to changes in your system's environment.
- **Scheduled Task**: Runs an integration automatically at predefined time intervals, ensuring that specific integration tasks occur at regular intervals. This type is ideal for batch processing, data synchronization, or periodic maintenance tasks.
- **Manual Task**: Initiates an integration via user action, giving you full control over when the integration executes. This type is useful for on-demand tasks, testing, or debugging purposes.

## Develop integrations with WSO2 Integration Studio

[WSO2 Integration Studio](https://wso2.com/integration/integration-studio/) is a powerful, Eclipse-based graphical development environment that enables you to build and deploy integration artifacts in WSO2 Micro Integrator. This comprehensive IDE offers a robust set of tools for designing and testing integration flows and crafting integration artifacts. By utilizing the visual, drag-and-drop capabilities of WSO2 Integration Studio, developers can significantly reduce the time and effort needed to construct and deploy integration flows.

In addition to streamlining the development process, Integration Studio offers features such as debugging, testing, and version control to ensure the quality and reliability of integration flows. By creating an Integration project and Composite Exporter project in WSO2 Integration Studio, developers can export their integration projects as a single deployment artifact, known as a composite application. This composite application encompasses all the components and configurations necessary for deploying the integration project to WSO2 Micro Integrator.

The Composite Exporter project simplifies the deployment process by allowing developers to package their integration projects as a single, self-contained artifact that can be easily deployed and managed. This approach enhances the consistency and reliability of integration projects while streamlining the overall deployment process.

To start developing integrations with WSO2 Micro Integrator, see [WSO2 Micro Integrator documentation - Developing Integration Solutions](https://mi.docs.wso2.com/en/latest/develop/intro-integration-development/).

## Integration project directory structure

An Integration Project in WSO2 Integration Studio is a multi-module Maven project that can contain multiple modules with WSO2 Synapse configurations and a composite application module to export all the configurations as a single deployable artifact.

An integration project directory structure includes the following key components:

 - WSO2 Synapse configurations: These modules contain the essential configurations for the integration project.
 - Composite Application module: This module is responsible for exporting all the Synapse configurations as a single deployable artifact.

Optionally, you can include the following components in your integration project:

 - OpenAPI definition file: You can add the OpenAPI definition file to any location within the project. When creating a component, you'll need to define the path to this file. Choreo will automatically generate an OpenAPI definition for you based on your integration project, if you don't provide one.
 - Java libraries: If your integration project requires additional Java libraries, you can add them to the libs directory located in the project root.
 - deployment.toml file: This optional configuration file allows you to customize the preconfigured settings of WSO2 MI instances running on Choreo. By including this file, you can tailor the behavior of your WSO2 MI instances to better suit your project's specific requirements.

Understanding the Integration Project directory structure is crucial for organizing your project and ensuring that all necessary components are included in the final deployable artifact.

## OpenAPI support

OpenAPI Support plays a crucial role in enhancing the functionality of integrations exposed as APIs. By providing an OpenAPI definition for your exposed integration, you can streamline testing and management processes, ensuring a more efficient and user-friendly experience. Choreo will automatically generate an OpenAPI definition for you based on your integration project, if you don't provide one, saving you time and effort.

To incorporate OpenAPI support, store the OpenAPI definition file within the repository hosting your Integration Studio project. When creating the project, simply point to the file's location in the repository. If needed, you can change the location of the OpenAPI definition file later via the deploy page.

![Open API file](../assets/img/develop-components/micro-integrator/openapi_file.png)

By leveraging OpenAPI Support, you can optimize the way you test and manage your integrations, resulting in a more efficient development process and a smoother user experience.

## Work with third-party libraries

The use of third-party libraries in your Micro Integrator project can offer several advantages, such as enhanced functionality, improved integration capabilities, optimized performance, and reduced development time.

Here are some of the benefits of adding third-party JARs to the Micro Integrator:

 - Increased functionality: Third-party libraries can extend the core Micro Integrator distribution, allowing for greater flexibility and customization of integration solutions.
 - Enhanced integration capabilities: Third-party libraries enable the Micro Integrator to interact with existing systems such as databases or other APIs, improving overall integration capabilities.
 - Optimized performance: By offering optimized implementations of common functions, third-party libraries can improve the performance of the Micro Integrator.
 - Efficient development: Developers can avoid re-implementing commonly used functions, reducing development time and increasing efficiency.

To incorporate third-party libraries into your Micro Integrator project, create a new directory called `libs` at the
root of your project. If your project root and GitHub repository root are not the same, place the `libs` directory in
the project root. After adding the required JAR files to the `libs` directory, the Micro Integrator runtime will
automatically include them when deploying the component. This process ensures that any dependencies needed by your
integration flow are available at runtime.

In addition to `jar` libraries, you may also need to incorporate OSGi bundle JARs into your project. To do this,
create another directory called `dropins` at the root of your project. Similarly, if the project root and GitHub
repository root differ, place the `dropins` directory in the project root. Within the `dropins` directory, add the OSGi
bundle JAR files. The OSGI runtime will pick up these bundles during deployment, enabling you to utilize their
functionality within your Micro Integrator project.

![Libs directory](../assets/img/develop-components/micro-integrator/libs_dir.png)

## Importing custom certificates to MI

The feature enables Choreo MI users to import certificates into the MI `client-truststore.jks` file. This functionality
proves valuable when users need to establish connections with servers or services utilizing SSL/TLS encryption and
possessing self-signed certificates or certificates issued by private certificate authorities (CAs) that are not
automatically trusted. Importing the certificate to the MI `client-truststore.jks` file enables MI clients to establish secure connections with
the server or service seamlessly, eliminating SSL/TLS errors or warnings.

Before importing the certificate, it is necessary to obtain the certificate file, which can be in PEM or DER format. You
can get the certificate from the server or service provider or export it from a web browser. Certificates should be
added to the `/wso2mi/certs/` folder. Users need to verify that the mount path for the certificate file aligns with this
specific path.

1. In the Choreo console, select the component you wish to add a certificate to.
2. From the left navigation click **Deploy**.
3. Click on the **Configs and Secrets** tab.
4. Click **Create**.
5. Select **ConfigMap** as the **Config Type** and **File Mount** as the **Mount Type**.
6. Click **Next**.
7. Specify the following values as mount configurations:

    | **Field**       | **Value**                                              |                                    
    |-----------------|--------------------------------------------------------|
    | **Config Name** | An appropriate name for the certificate.             |
    | **Mount path**  | `/wso2mi/certs/<filename>`. For example, `/wso2mi/certs/certificate.crt` |

8. Click **Upload File** and attach the certificate.
9. Click **Create**.

## Working with sensitive data using MI Secure Vault

MI Secure Vault is a feature that allows users to securely store sensitive data, such as passwords and tokens, and
provide access to that data to MI Integrations. This feature provides an added layer of security to your integrations by
reducing the risk of accidental exposure of sensitive data.

To use MI Secure Vault to work with sensitive data, follow these steps:

1. Select the component from the Choreo Console.
2. From the left navigation, click Deploy.
3. Click on the **Configure and Deploy**.
4. Click on the **Add Environment Configurations**
5. Specify the following values as configurations:

    | **Field**       | **Value**                                 |                                    
    |-------------------------------------------|--------------------------------------------------------|
    | **Name** | An appropriate name for the secret/alias. |
    | **Value**       | Value for the secret                      |

6. Select **Mark as a Secret**.
7. Click **Add**.
8. Click **Deploy**.
9. Once the secret has been created, you can access it in your integration code using the following syntax:

```xml
<property name="secret_value_1" expression="wso2:vault-lookup('user_pass')" scope="default" type="STRING"/>
```
This code retrieves the secret named "user_pass" from the MI Secure Vault and stores it in the property named "
secret_value_1". You can then use this property in your integration code to access the secret value.

For more information on these features, see the [Accessing secrets](https://mi.docs.wso2.com/en/latest/install-and-setup/setup/security/encrypting-plain-text/#step-3-accessing-secrets) section of the MI Secure Vault documentation. By using MI
Secure Vault to store and access sensitive data in your integrations, you can ensure that your integrations
remain secure and protect sensitive data from unauthorized access.


## Scan third-party libraries to identify security vulnerabilities

Scanning third-party libraries for security vulnerabilities is essential for identifying potential weaknesses in an application that could be exploited by attackers. Taking a proactive approach to security helps organizations detect and mitigate risks before they can be exploited, preventing data breaches, system compromises, and other security incidents.

Choreo incorporates a security vulnerability scanning process during deployment. It uses Trivy to scan and detect critical vulnerabilities in third-party libraries added to the integration component. If the scan uncovers any critical vulnerabilities, the deployment process is halted. The deployment pane displays the Trivy scan status and any security failures in the Library (Trivy) vulnerable scan step, which can be accessed by clicking on it. Once the vulnerability has been addressed, you can redeploy the component.

## Customize WSO2 Micro Integrator preconfigured settings

Customizing WSO2 Micro Integrator Preconfigured Settings is essential for ensuring that the integration solution works optimally within the specific context of your organization. While WSO2 MI comes with preconfigured settings designed for general use, these settings may not be suitable for every organization's unique requirements. Customizing these settings can help optimize performance and ensure compatibility with your organization's systems and applications.

To customize the preconfigured settings of WSO2 MI instances running on Choreo, define a `deployment.toml` file in the GitHub repository subpath of your Micro Integrator project:

![deployment.toml](../assets/img/develop-components/micro-integrator/config_file.png)

!!! note
    If you change critical configuration parameters such as port offset and hostname, it can break internal communication.
    Therefore, the recommended approach is to update only the necessary configuration parameters.

Given below is a sample `deployment.toml` file that can be used to configure the JMS transport. For more information on WSO2 MI
configuration parameters, see the [MI Configuration Catalog](https://mi.docs.wso2.com/en/latest/reference/config-catalog-mi/).

```
[[transport.jms.sender]]
name = "myQueueSender"
parameter.initial_naming_factory = "org.apache.activemq.jndi.ActiveMQInitialContextFactory"
parameter.provider_url = "$env{JMS_PROVIDER_URL}"
parameter.connection_factory_name = "QueueConnectionFactory"
parameter.connection_factory_type = "queue"
parameter.cache_level = "producer"

[[transport.jms.listener]]
name = "myQueueListener"
parameter.initial_naming_factory = "org.apache.activemq.jndi.ActiveMQInitialContextFactory"
parameter.provider_url = "$env{JMS_PROVIDER_URL}"
parameter.connection_factory_name = "QueueConnectionFactory"
parameter.connection_factory_type = "queue"
parameter.cache_level = "consumer"
```

## Environment variables

Using environment variables is a recommended practice when developing integration artifacts with WSO2 Integration Studio, as it improves configuration management, security, portability, and manageability. By leveraging environment variables, organizations can streamline the management and maintenance of their integrations, ensuring that updates can be implemented quickly and efficiently.

The component's Deploy page provides a user-friendly interface to manage environment variables across different environments. For information on managing environment variables for complex use cases, see [Configurations and secrets](../devops-and-ci-cd/manage-configurations-and-secrets.md).

![Environment variables](../assets/img/develop-components/micro-integrator/env_variables.png)

Environment variables offer several benefits:

 - Configuration management: They simplify the process of managing and updating configuration settings, making it easier to maintain consistency across different environments.
 - Security: Environment variables help protect sensitive information by storing it securely and separating it from the main codebase.
 - Portability: By using environment variables, you can ensure that your integration artifacts can be easily migrated and deployed across various environments with minimal changes.
 - Manageability: Environment variables offer a centralized way to manage configuration settings, making it easier to update and maintain your integrations over time.

For a comprehensive list of parameters that can be configured as environment variables, see [WSO2 Micro Integrator documentation - Injecting Parameters - Supported parameters](https://mi.docs.wso2.com/en/latest/develop/injecting-parameters/#supported-parameters).

## Configure logging

Configuring logging is crucial when developing and maintaining a software system, as it can significantly improve efficiency during the development, testing, and maintenance phases of the software development process. Logging captures events and messages that occur during an application's execution, providing valuable insights for troubleshooting and debugging issues.

With Micro Integrator instances, you can configure and customize logging according to your requirements. Logging configurations can be added to each MI instance's environment, allowing you to fine-tune logging depending on the specific environment or deployment scenario.

To configure logging in MI instances, follow the steps given below: 

!!! tip
     You can use environment variables with specific naming conventions.

1. Start the variable name with `logging_level_` followed by the package or class name.
2. Replace the dot character in the package name with an underscore.
3. Set the variable value to the required logging level for the corresponding package or class.

    For example, to enable wire logs, change the logging level of the `org.apache.synapse.transport.http.wire` package to `debug`. 

To configure logging, set the environment variable as follows:

1. In the left navigation menu, click **Deploy** and then click **Configs & Secrets**. 
2. Click **+ Create**. 
3. Select **ConfigMap** as the **Config Type** and **Environment Variables** as the **Mount Type**. 
4. Click **Next**. 
5. Specify the following values as mount configurations:

    | **Field**       | **Value**                                              |                                    
    |-----------------|--------------------------------------------------------|
    | **Config Name** | An appropriate name for the configuration.             |
    | **Name**        | `logging_level_org_apache_synapse_transport_http_wire` |
    | **Value**       | `debug`                                                |

6. Click **Create**.

## Connectors

WSO2 Micro Integrator (MI) Connectors are prebuilt connectors designed to simplify integration between WSO2 MI and various other systems. They enable seamless connections to databases, message brokers, REST APIs, and more, allowing you to perform actions such as sending messages, executing queries, or retrieving data. These connectors are easy to use, making it straightforward to incorporate them into your WSO2 MI integration flows. Micro Integrator connectors are versatile and can be utilized in various integration scenarios, including data integration, service-oriented architecture (SOA) integration, and event-driven architecture (EDA) integration.

WSO2 Integration Studio is a comprehensive development environment that facilitates the creation of integration flows using WSO2 Micro Integrator Connectors. With Integration Studio, you can design and implement integration flows that connect diverse systems and execute various actions, such as sending messages, executing queries, or retrieving data. You can build integration flows using either prebuilt connectors provided by WSO2 MI or custom connectors developed using the Connector Development Toolkit. Integration Studio offers a graphical user interface that simplifies the process of building and testing integration flows while also providing a set of tools for managing and deploying these flows in a WSO2 MI runtime environment.

For more information, see the following topics in the WSO2 Micro Integrator documentation.

- [Connectors Overview](https://mi.docs.wso2.com/en/latest/reference/connectors/connectors-overview/)
- [Adding Connectors](https://mi.docs.wso2.com/en/latest/develop/creating-artifacts/adding-connectors/)

## Deploying integrations in Choreo 

WSO2 MI buildpack is where you can deploy integrations developed with WSO2 Micro Integrator as an API. In this preset, you have three different ways to define endpoints. Choreo gives priory to the definition of endpoints in the below-mentioned order. 

1. **Using component.yaml file**
This is the most flexible method to define endpoints. You can configure the endpoint details with the `component.yaml` configuration file. Place this file in the `.choreo` directory in the project path of the component. 
If the Micro Integrator project has inbound endpoints, you can expose them via different endpoints using the `component.yaml`file.

    To learn about the `component.yaml` file, see [Overview of the component.yaml file](../develop-components/manage-component-source-configurations.md#overview-of-the-componentyaml-file).

3. **Auto generating endpoints**
If `component.yaml` is not provided and if the source Micro Integrator project has APIs, Choreo scans the project and generates the API endpoints. If the project has few APIs, an endpoint will be generated for each API. The visibility of this auto-generated endpoint is set to `Public` by default. You can change the visibility in the deployment flow.

4. **Provide default endpoints**
If `component.yaml` is not provided and if the source Micro Integrator project doesn't have APIs, Choreo generates a default endpoint which will expose the default micro integrator port (8290) with `Public` visibility and wildcard context.

!!! note
    If you are currently using `component-config.yaml` or `endpoints.yaml` configuration files, see the respective [migration guide](../develop-components/manage-component-source-configurations.md#migration-guide) for instructions on migrating to the recommended `component.yaml` configuration file.

## Explore Choreo examples on GitHub

For a hands-on experience with MI-based integrations in Choreo, we recommend exploring our samples in Choreo Console. You can filter out the samples based on the buildpack `WSO2 MI`. This will point you to the samples in the [Choreo samples GitHub repository](https://github.com/wso2/choreo-samples)

### [Choreo samples - GitHub Repository](https://github.com/wso2/choreo-samples)

- **Fork the Repository**: Start by forking the repository to your account.

- **Explore & run**: Navigate through the different integration scenarios. Each example has a README.md with setup and execution instructions.



# Develop a Manual Task

This guide walks you through the steps to develop, deploy, test, and observe a manual task using Choreo.

In this guide, you will:

- Develop a manual task to fetch the weather forecast for a specified location for the next 24 hours from the [OpenWeatherMap](https://openweathermap.org) API.
- Process the weather data into a specific format.
- Send the formatted data to a specified email address.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

    !!! info "Repository File Structure"
        The sample code for this guide is in the `<sample-repository-dir>/weather-to-email-integration` directory. The following table describes the key files in the repository:

        | **File Path**         | **File Content**                                                     |
        | --------------------- | -------------------------------------------------------------------- |
        | **Ballerina.toml**    | Contains metadata about the project                                  |
        | **Dependencies.toml** | Lists the dependencies required for the project                      |
        | **main.bal**          | Contains the entry point of the project, including the main function |
        | **types.bal**         | Contains custom data types used in the project                       |
        | **utils.bal**         | Contains utility functions and helper functions used in the project  |

3. Go to [OpenWeatherMap](https://openweathermap.org/) and sign up to obtain an API key. For details, see the [OpenWeatherMap documentation](https://openweathermap.org/appid#signup).

## Step 1: Create a manual task component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Manual Task** card.
6. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:

        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

7. Enter the following information:

    | **Field**             | **Description**                                      |
    | ----------------------| -----------------------------------------------------|
    | **Organization**      | Your GitHub account                                  |
    | **Repository**        | `choreo-samples`                                     |
    | **Branch**            | `main`                                               |
    | **Component Directory** | `weather-to-email-integration`                       |

8. Select **Ballerina** as the **Build Pack**.

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Component Directory** specifies the location of the project to build the component.

4. Enter a unique name and description for the component. You can use the following values:

    | **Field**          | **Value**                        |
    | ------------------ | -------------------------------- |
    | **Component Name** | `WeatherToEmail`                 |
    | **Description**    | `My first manual task`           |


8. Click **Create**. Choreo initializes the component with the sample implementation and opens the **Overview** page of the component.

## Step 2: Build the manual task

1. In the left navigation menu, click **Build**.
2. In the **Builds** pane, click **Build**. This opens the **Commits** pane, where you can see all the commits related to the component.
3. Select the latest commit and click **Build**. This triggers the build process and displays the build progress in the **Build Logs** pane.

    !!! info
        The build process may take some time. Once complete, the build status will be listed in the **Builds** pane. Here, you will see the build status as **Success**.

## Step 3: Deploy the manual task

1. In the left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane, specify values for the configurable variables:

    !!! tip
        The configurable variables populated here are defined in the sample Ballerina project used in this guide. To learn how to declare configurable variables in Ballerina, see the [Ballerina documentation on declaring configurable variables](https://ballerina.io/learn/by-example/configurable-variables/).

    | **Field**     | **Value**                                                               |
    | ------------- | ----------------------------------------------------------------------- |
    | **apiKey**    | The API key you obtained in the prerequisites section                   |
    | **latitude**  | Latitude of the location to get the weather forecast                    |
    | **longitude** | Longitude of the location to get the weather forecast                   |
    | **email**     | The email address to receive the formatted weather forecast information |

    !!! note
        If you use **Ballerina** as the buildpack and want to set a configurable variable as a secret, click the lock icon corresponding to the configurable variable. This marks it as a secret and conceals the input value.

        For example, if you set the **apiKey** as a secret, its input value will be concealed. To update the input value later, click **Update Secret Content** and specify a new value.

4. Click **Deploy**.

## Step 4: Execute the manual task

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the task.

    !!! info "Inject Dynamic Values into Your Application as Command-Line Arguments"
        If you want to inject dynamic values into your application as command-line arguments when you run a manual task, follow these steps:
        1. Click the drop-down icon next to **Run Now** and then click **Run with Arguments**.
        2. In the **Runtime Arguments** pane, enter the arguments you want to pass to your application.
        3. Click **Execute**. This triggers the task with the specified arguments.

        The capability to run a manual task with arguments is supported for the following buildpacks:

        === "Dockerfile"
            To explore a Dockerfile-based manual task with arguments, try out the [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/docker-hello-world-manual-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on Docker projects, the **Run with Arguments** capability is not supported if the Dockerfile contains `CMD`. In such scenarios, use `ENTRYPOINT` to define your default commands.

        === "Go"
            To explore a Go-based manual task with arguments, try out the [Hello World Go Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-go-task) sample. For instructions, see the `readme.md` file in the sample repository.

        === "Java"
            To explore a Java-based manual task with arguments, try out the [Hello World Java Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-java-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on Java projects:
                - The **Run with Arguments** capability is not supported if `Procfile` is available in the project.
                - The `Main` class should be defined in the `manifest` file.
                - If Maven files such as `mvn.cmd` exist in the project without the `.mvn` directory, the build will fail. To ensure a successful build, either commit the `.mvn` directory along with any Maven files or exclude Maven files if you choose not to commit the `.mvn` directory.

        === "NodeJS"
            To explore a NodeJS-based manual task with arguments, try out the [Hello World NodeJS Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-nodejs-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on NodeJS projects:
                - The **Run with Arguments** capability is not supported if `Procfile` is available in the project.
                - The project root must contain the `package.json` file with the `main` attribute defined.

        === "WSO2 MI"
            To explore a WSO2 MI-based manual task with arguments, try out the [Weather to Logs Task](https://github.com/wso2/choreo-samples/tree/main/weather-to-logs-mi-manual-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on WSO2 MI projects and deploying a WSO2 MI integration as a manual task in Choreo, use the WSO2 MI automation mode. For details, see [Running the Micro Integrator in Automation Mode](https://apim.docs.wso2.com/en/latest/install-and-setup/install/running-the-mi-in-automation-mode/).

        === "Ballerina"
            To explore a Ballerina manual task with arguments, try out the [Weather to Email Task](https://github.com/wso2/choreo-samples/tree/main/weather-to-email-integration) sample. For instructions, see the README.md file in the sample repository.

            !!! info
                If you want to pass arguments to Ballerina main functions, use the **Run with Arguments** capability. For details on the arguments you can pass, see the [Ballerina documentation](https://ballerina.io/learn/by-example/main-function/). You can also override configurable values in the same manner. For more information, see [Provide values to configurable variables](https://ballerina.io/learn/provide-values-to-configurable-variables/#provide-via-command-line-arguments).

## Step 5: Test the manual task

Once the task is triggered, an email with the subject `[WSO2 Choreo Demo] Next 24H Weather Forecast` is sent from `choreo.demo@gmail.com` to the email address specified as the **email** configurable variable value in [Step 3](#step-3-deploy-the-manual-task).

If the manual task ran successfully, you should receive an email similar to the following:

![Received email](../../assets/img/develop-components/develop-a-scheduled-integration/Received-email.png)

## Step 6: Observe the manual task

The observability view in Choreo displays graphs that depict details such as throughput, latency, diagnostic data, and logs to identify and troubleshoot anomalies in components you deploy.

1. In the left navigation menu, click **Observability**.
2. Observe the following:
    - The throughput and latencies of requests served over a given period.
    - The logs generated over a given period.
    - The flame graph (Diagnostics View) generated over a given period.
    - The low-code diagram.

To learn more about the observability details you can view via Choreo observability, see [Observability Overview](../../monitoring-and-insights/observability-overview.md).

## Step 7: Monitor executions

To track and monitor executions associated with the deployed manual task, go to the left navigation menu and click **Execute**.

!!! tip
    The **Execute** view is applicable to both scheduled and manual tasks.

You can view the following information:

- **Total executions**: The total number of executions within the past 30 days.

    ![Total Execution](../../assets/img/develop-components/develop-a-scheduled-integration/total_executions.png)

- **Execution history**: The currently active executions and those that are already complete. You can view information such as the execution ID, the revision of the execution, and the time it was triggered.

    ![Execution History](../../assets/img/develop-components/develop-a-scheduled-integration/execution_history.png)

- **Detailed execution logs**: Click on an execution to view detailed logs related to it.

    !!! info
        It may take a few minutes for the logs to appear. You may need to manually refresh to view the latest logs.

    ![Execution Logs](../../assets/img/develop-components/develop-a-scheduled-integration/execution_logs.png)


# Develop a Scheduled Task

Choreo is a versatile integration platform that allows you to create various types of integrations depending on your requirements. If you need to automatically run a specific integration at regular intervals, you can use Choreo to develop a scheduled task. This type of integration can automate the synchronization of data between different systems at specified intervals, reducing errors and improving productivity by eliminating the need for manual intervention.

This guide walks you through the steps to develop, deploy, test, and observe a scheduled task using Choreo.

In this guide, you will:

- Develop a scheduled task to fetch the weather forecast for a specified location for the next 24 hours from the [OpenWeatherMap](https://openweathermap.org) API.
- Process the weather data into a specific format.
- Send the formatted data to a specified email address at a specific time every day.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

    !!! info "Repository File Structure"
        The sample code for this guide is in the `<sample-repository-dir>/weather-to-email-scheduled-task` directory. The following table describes the key files in the repository:

        | **File Path**         | **File Content**                                                     |
        | --------------------- | -------------------------------------------------------------------- |
        | **Ballerina.toml**    | Contains metadata about the project                                  |
        | **Dependencies.toml** | Lists the dependencies required for the project                      |
        | **main.bal**          | Contains the entry point of the project, including the main function |
        | **types.bal**         | Contains custom data types used in the project                       |
        | **utils.bal**         | Contains utility functions and helper functions used in the project  |

3. Go to [OpenWeatherMap](https://openweathermap.org/) and sign up to obtain an API key. For details, see the [OpenWeatherMap documentation](https://openweathermap.org/appid#signup).

## Step 1: Create a scheduled task component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Scheduled Task** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following information:

    | **Field**             | **Description**                                |
    | --------------------- | ---------------------------------------------- |
    | **Organization**      | Your GitHub account                            |
    | **Repository**        | `choreo-samples`                               |
    | **Branch**            | `main`                                         |
    | **Component Directory** | `weather-to-email-scheduled-task`              |

6. Select **Ballerina** as the build pack.

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Component Directory** specifies the location of the project to build the component.

7. Enter a unique name and description for the component. You can use the following values:

    | **Field**          | **Value**                        |
    | ------------------ | -------------------------------- |
    | **Component Name** | `WeatherToEmail`                 |
    | **Description**    | `My first scheduled task`        |

8. Click **Create**. Choreo initializes the component with the sample implementation and opens the **Overview** page of the component.

Now you can proceed to build and deploy the scheduled task.

## Step 2: Build the scheduled task

1. In the left navigation menu, click **Build**.
2. In the **Builds** pane, click **Build**. This opens the **Commits** pane, where you can see all the commits related to the component.
3. Select the latest commit and click **Build**. This triggers the build process and displays the build progress in the **Build Logs** pane.

    !!! info
        The build process may take some time. Once complete, the build status will be listed in the **Builds** pane. Here, you will see the build status as **Success**.

## Step 3: Deploy the scheduled task

1. In the left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane, specify values for the configurable variables:

    !!! tip
        The configurable variables populated here are defined in the sample Ballerina project used in this guide. To learn how to declare configurable variables in Ballerina, see the [Ballerina documentation on declaring configurable variables](https://ballerina.io/learn/by-example/configurable-variables/).

    | **Field**     | **Value**                                                               |
    | ------------- | ----------------------------------------------------------------------- |
    | **apiKey**    | The API key you obtained in the prerequisites section                   |
    | **latitude**  | Latitude of the location to get the weather forecast                    |
    | **longitude** | Longitude of the location to get the weather forecast                   |
    | **email**     | The email address to receive the formatted weather forecast information |

    !!! note
        If you use **Ballerina** as the buildpack and want to set a configurable variable as a secret, click the lock icon corresponding to the configurable variable. This marks it as a secret and conceals the input value.

        For example, if you set the **apiKey** as a secret, its input value will be concealed. To update the input value later, click **Update Secret Content** and specify a new value.

4. Click **Next**.
5. Define a schedule to run the task. In this guide, set the schedule to receive the weather information daily at 8:00 AM UTC. Enter the following values:

    | **Field**            | **Value**                                             |
    | -------------------- | ----------------------------------------------------- |
    | **Select Time Zone** | Select a time zone to schedule the task               |
    | **Select Range**     | **Day**                                               |
    | **Every**            | `1`                                                   |
    | **At**               | `08:00`                                               |

    !!! tip
        To test and verify the task immediately, you can schedule the deployment to run in just a few minutes after you create it. However, to avoid unnecessary expenses, reschedule or stop the deployment once you test and verify.

6. Click **Deploy**. This deploys the scheduled task to the development environment and indicates the **Scheduled Status** as **Active** in the **Development** card.

You can test the scheduled task when it runs at the configured time.

## Step 4: Test the scheduled task

When the scheduled task runs at the configured time, an email with the subject `[WSO2 Choreo Demo] Next 24H Weather Forecast` is sent from `choreo.demo@gmail.com` to the email address specified as the **email** configurable variable value in [Step 3](#step-3-deploy-the-scheduled-task).

If the scheduled task ran successfully, you should receive an email similar to the following:

![Received email](../../assets/img/develop-components/develop-a-scheduled-integration/Received-email.png)

## Step 5: Observe the scheduled task

The observability view in Choreo displays graphs that depict details such as throughput, latency, diagnostic data, and logs to identify and troubleshoot anomalies in components you deploy.

1. In the left navigation menu, click **Observability**.
2. Observe the following:
    - The throughput and latencies of requests served over a given period.
    - The logs generated over a given period.
    - The flame graph (Diagnostics View) generated over a given period.
    - The low-code diagram.

To learn more about the observability details you can view via Choreo observability, see [Observability Overview](../../monitoring-and-insights/observability-overview.md).

## Step 6: Monitor executions

To track and monitor executions associated with the deployed scheduled task, go to the left navigation menu and click **Execute**.

!!! tip
    The **Execute** view is applicable to both scheduled and manual tasks.

You can view the following information:

- **Total executions**: The total number of executions within the past 30 days.

    ![Total Execution](../../assets/img/develop-components/develop-a-scheduled-integration/total_executions.png)

- **Execution history**: The currently active executions and those that are already complete. You can view information such as the execution ID, the revision of the execution, and the time it was triggered.

    ![Execution History](../../assets/img/develop-components/develop-a-scheduled-integration/execution_history.png)

- **Detailed execution logs**: Click on an execution to view detailed logs related to it.

    !!! info
        It may take a few minutes for the logs to appear. You may need to manually refresh to view the latest logs.

    ![Execution Logs](../../assets/img/develop-components/develop-a-scheduled-integration/execution_logs.png)


# Develop an Event Handler

An event handler executes predefined actions in response to specific events. Choreo simplifies the process of creating and deploying such integrations.

This guide walks you through the steps to create and deploy an Event Handler using WSO2 MI and Choreo.

In this guide, you will build a simple event handler that monitors RabbitMQ for new messages and displays them once they become available.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Set up RabbitMQ:
    - Use an existing RabbitMQ instance or start a new [RabbitMQ](https://www.rabbitmq.com/download.html) instance on a server that can be accessed via the internet.
    - Obtain the `username`, `hostname`, `password`, and `vhost` from the RabbitMQ instance to use later as environment variables.

3. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

## Step 1: Create an event handler component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Event Handler** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following information:

    | **Field**             | **Description**              |
    |-----------------------|----------------------------- |
    | **Organization**      | Your GitHub account          |
    | **Repository**        | `choreo-samples`             |
    | **Branch**            | `main`                       |
    | **Component Directory** | `mi-rabbitmq-listener`       |

6. Select **WSO2 MI** as the build pack. (since you are creating the REST API from a [WSO2 Integration Studio](https://wso2.com/micro-integrator/) project)

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Component Directory** specifies the location of the project to build the component.

7. Enter a unique name and description for the component. You can use the following values:

    | **Field**          | **Value**              |
    |--------------------|------------------------|
    | **Component Name** | `SalesOrderListener`   |
    | **Description**    | `RabbitMQ integration` |

8. Click **Create**.

## Step 2: Deploy the integration

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**.
3. In the **Configurations** pane, click **+ Add** corresponding to **Environment Variables** and add the following environment variables:

    !!! tip
        Use the values from your RabbitMQ instance as per the [Prerequisites](#prerequisites) section for the environment variables.

    | **Name**     | **Value**                                         |
    | ------------- |--------------------------------------------------|
    | **HOSTNAME**  | Hostname of your RabbitMQ server                 |
    | **VHOST**     | Virtual hostname of your RabbitMQ server         |
    | **USERNAME**  | Username for connecting to RabbitMQ              |
    | **PASSWORD**  | Password associated with the RabbitMQ username   |

4. Click **Deploy**. This deploys the event handler to the development environment and indicates the **Deployment Status** as **Active** in the **Development** card.

## Step 3: Test the integration

1. Send a sales order message to the **SalesOrderQueue** on the RabbitMQ server. You can send a sample sales order message similar to the following:

    ```json
    {
        "order_id": "12345",
        "customer_name": "John Doe",
        "product": "Widget",
        "quantity": 10,
        "total_amount": 100.00
    }
    ```

2. Observe the logs:
    - In the left navigation menu, click **Logs** and then click **Runtime Logs**. You will see the order message in the logs.

Now you have gained hands-on experience in creating, configuring, and deploying an event handler.


# Develop an Integration with Integration Studio

Choreo simplifies the process of building, deploying, and managing integration components, making it easy to expose integrations as APIs. This guide walks you through the steps to expose an integration created in WSO2 Integration Studio as an API in Choreo.

In this guide, you will:
- Create a component to expose a sample integration from the [Choreo samples repository](https://github.com/wso2/choreo-samples) as an API.
- Deploy, test, and observe the integration component.
- Publish the integration component as an API to the Choreo Developer Portal.

!!! note
    - To develop integrations for **Manual Task** and **Schedule Task** components in Choreo, use the **automation mode** in the WSO2 Micro Integrator. See [Running MI in Automation Mode](https://apim.docs.wso2.com/en/4.2.0/install-and-setup/install/running-the-mi-in-automation-mode/).
    - For other component types (Service, webhook, event-handler, etc.), use the **server mode**.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    - Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    - Enter a unique organization name. For example, `Stark Industries`.
    - Read and accept the privacy policy and terms of use.
    - Click **Create**. This creates the organization and opens the **Project Home** page.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

## Step 1: Create the integration component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the **Project Home** page.

2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following repository details:

    | **Field**             | **Description**              |
    |-----------------------|----------------------------- |
    | **Organization**      | Your GitHub account          |
    | **Repository**        | `choreo-samples`            |
    | **Branch**            | **`main`**                   |
    | **Component Directory** | `hello-world-mi`             |

6. Select WSO2 MI as the build pack (since you're creating the REST API from a [WSO2 Integration Studio](https://wso2.com/micro-integrator/) project).

7. Provide a unique name and description for the component:

    | **Field**          | **Value**              |
    |--------------------|------------------------|
    | **Component Name** | `Hello World`          |
    | **Description**    | `Hello World REST API` |

8. Click **Create**. Choreo initializes the component with the sample integration.

## Step 2: Deploy the integration component

1. In the Choreo Console left navigation menu, click **Deploy**.

2. Configure and deploy:
   - In the **Build Area** card, click **Configure & Deploy**.
   - In the **Configurations** pane, click **Next**. This displays the endpoint details ready for deployment.
   - Click **Deploy**. This deploys the integration component to the development environment.

    !!! tip
        - Choreo uses [endpoints](../../choreo-concepts/endpoint.md) to expose **Service** components to the network. Learn more about configuring endpoints in [Configure Endpoints](../configure-endpoints.md).
        - Automatic deployment is enabled by default, so only the first deployment needs to be done manually.

   The **Development** card shows the **Deployment Status** as **Active** when the integration is successfully deployed.

## Step 3: Test the integration

1. In the Choreo Console left navigation menu, click **Test** and then click **Console**.
2. In the OpenAPI Console, select **Development** from the environment drop-down list.
3. Expand the **GET /integration** operation.
4. Click **Try it out**, then click **Execute**. This sends a request to your deployed integration.
5. Check the response:
    - In the **Response body** section, observe the response. If the integration works as expected, you should see:
     
     ```json
     {"Hello" : "Integration"}
     ```

## Step 4: Observe the integration

1. Click **Observability** in the left navigation menu to monitor the performance of the integration component.

2. View metrics:
   - Observe throughput and latencies of requests over time.
   - View logs generated during a specific period.
   - Analyze the flame graph (Diagnostics View) for performance insights.

   For more details, see [Observability Overview](../../monitoring-and-insights/observability-overview.md).

## Step 5: Publish the integration component

1. In the Choreo Console left navigation menu, click **Manage** and then click **Lifecycle**.
2. The **Lifecycle Management** pane shows the current lifecycle stage as **Created**.
3. Click **Publish**. This changes the lifecycle stage to **Published** and exposes the integration as an API in the Choreo Developer Portal.
   - To view the published API, click **Go to Devportal**. In the Developer Portal, you can manage subscriptions and generate access tokens for testing.

Now you have successfully exposed an integration designed in WSO2 Integration Studio as a REST API in Choreo!


# Develop an API Proxy from a GitHub Repository Source

An API proxy acts as an intermediary between an existing API and Choreo, intercepting all requests made to the API. It also functions as a managed API, allowing you to apply essential API management features such as security policies and rate limiting.

In this guide, you will:

- Create an API proxy component to expose an existing API.
- Deploy the API proxy.
- Test the API proxy to verify its functionality.
- Manage the API.
- Consume the API.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample proxy source](https://github.com/wso2/choreo-samples/tree/main/department-api-proxy-from-github).  

## Step 1: Create an API proxy

You can create an API proxy either by selecting the source from a GitHub repository, uploading an OpenAPI specification file, or providing an OpenAPI specification URL. This guide demonstrates how to create an API proxy using a GitHub repository as the source.

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **API Proxy** card. This opens the **Create an API Proxy** pane.

4. Click on **Authorize With GitHub** card under **Connect a Git Repository** section to connect your GitHub account.
    - If you haven’t connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
         - Read and write access to code and pull requests.
         - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.    

5. Enter the following repository details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **Repository**         | choreo-samples     |
    | **Branch**             | **`main`**         |
    | **API Directory**      | /department-api-proxy-from-github |

    !!! note
        To select the relevant directory, click on the **Edit** action next to the **API Directory** input field. Then, enter `department-api-proxy-from-github` as the directory name to quickly search and locate the correct directory.

6. Specify the following values as Proxy Metadata:

    !!! info
        The **Context** field must be unique and cannot be changed after creation.**Version** and **Target** are mandatory fields. **Target** can be changed at any time after the creation.

    | **Field**       | **Value**                                  |
    |-----------------|--------------------------------------------|
    | **Context**     | `department-service`                                   |
    | **Version**     | `v1.0`                                      |
    | **Target**      | `https://samples.choreoapps.dev/company/hr`|

7. Specify the following values as Component Details:

    !!! info
        The **Component Name** field must be unique and cannot be changed after creation. This value is automatically generated, but you can edit it if necessary.
        **Component Display Name** is a required field.

    | **Field**       | **Value**                                  |
    |-----------------|--------------------------------------------|
    | **Component Display Name**| `Department Service`                    |
    | **Component Name**        | `department-service`                    |
    | **Description**           | `This is a sample proxy for department service`     |    

8. Click **Create**. This creates the API proxy component and takes you to the **Build** page.

!!! note
    When you create an API proxy from a GitHub repository source, the GitHub source serves as the single source of truth. Therefore, any modifications, such as adding or deleting resources, must be made through the GitHub repository.

## Step 2: Build

!!! info
    The initial build starts automatically when you create the API proxy, and you will be redirected to the **Build** page. In this case, you can skip the steps below. If you need to manually trigger a build later, follow these steps.

1. On the project home page, click on the `Department Service` component you created. This takes you to the component overview page.
2. In the left navigation menu, click **Build**.
3. On the **Build** page, click **Build Latest**.

!!! note
    The build process may take some time. You can track progress in the **Build Details** pane. Once complete, the build status changes to **Success**.

## Step 3: Deploy the API proxy

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**. This opens the **Configure & Deploy** pane.
3. Select **External** as the **API Access Mode** and click **Deploy**. The **Development** card indicates the **Deployment Status** as **Active** when the API proxy is successfully deployed.

Now you are ready to test the API proxy.

## Step 4: Test the API proxy

Choreo allows you to test your API proxy using either the [integrated OpenAPI Console](../../testing/test-rest-endpoints-via-the-openapi-console.md) or [cURL](../../testing/test-apis-with-curl.md). In this guide, you will use the OpenAPI Console.

!!! tip
    Choreo enables OAuth 2.0 to secure APIs by default. Therefore, you need an access token to invoke an API.

    - Choreo automatically generates a key to test the API via the OpenAPI Console. To view the key, click the show key icon in the **Security Header** field.
    - To disable security for the entire API or a specific resource:
        1. In the left navigation menu, click **Deploy**.
        2. Go to the **Build Area** card and click **Security Settings**.
        3. In the **Security Settings** pane:
            - To disable security for the entire API, clear the **OAuth2** checkbox.
            - To disable security for a specific resource, expand the relevant resource and turn off the **Security** toggle.
        4. Click **Apply**.

1. In the left navigation menu, click **Test** and then click **OpenAPI Console**.
2. Select **Development** from the environment drop-down list.
3. Expand the `GET /department/{departmentId}` resource and click **Try it Out**.
4. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

    ![API proxy response](../../assets/img/develop-components/develop-a-rest-api-proxy/rest-api-proxy-response.png){.cInlineImage-full}

    This indicates that your API proxy is working as expected.

## Step 5: Manage the API proxy

Now that you have a tested API proxy, you can publish it and make it available for application developers to consume. In this guide, you will apply rate limiting to the API and publish it.

### Step 5.1: Apply rate limiting to the API proxy

1. In the left navigation menu, click **Deploy**.
2. Go to the required environment card and click the settings icon corresponding to **API Configuration**.
3. In the **CORS, Rate Limiting and Resiliency** pane, click **Rate Limiting** to expand the section.
4. Select **API Level** as the **Rate Limiting Level**.
5. Specify appropriate values for the **Request Limit** and **Time Unit** fields. You can proceed with the default values.
6. Click **Apply**. This applies the rate limiting level to the API proxy and redeploys it.

### Step 5.2: Publish the API proxy

1. In the left navigation menu, click **Lifecycle** under **Manage**. This takes you to the **Lifecycle** page.
2. Click **Publish**.
3. In the **Publish API** dialog, click **Confirm** to proceed with publishing the API. If you want to change the display name, make the necessary changes and then click **Confirm**. This changes the API lifecycle state to **Published**.

## Step 6: Invoke the API

To generate credentials for the published API and invoke it via the Choreo Developer Portal, follow these steps:

1. In the **Lifecycle** page, click **Go to Devportal**. This takes you to the `Department Service` in the Choreo Developer Portal.

2. **Invoke the API**:
    1. In the Developer Portal left navigation menu, click **Try Out**.
    2. In the **Endpoint** list, select **Development** as the environment to try out the API.
    3. Click **Get Test Key** to generate an access token.
    4. Expand the `GET /department/{departmentId}` resource and click **Try it out**.
    5. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

        ![Try out response](../../assets/img/develop-components/develop-a-rest-api-proxy/try-out-response.png){.cInlineImage-full}

Now, you have gained hands-on experience creating, deploying, testing, and publishing an API proxy using Choreo.


# Develop an API Proxy from Scratch

An API proxy acts as an intermediary between an existing API and Choreo, intercepting all requests made to the API. It also functions as a managed API, allowing you to apply essential API management features such as security policies and rate limiting.

In this guide, you will:

- Create an API proxy component to expose an existing API.
- Deploy the API proxy.
- Test the API proxy to verify its functionality.
- Manage the API.
- Consume the API.

## Prerequisites

- If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

## Step 1: Create an API proxy

To create an API proxy, you can either upload an OpenAPI specification or provide an OpenAPI specification URL. In this guide, you will specify a URL to an OpenAPI definition of a sample API.

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **API Proxy** card. This opens the **Create an API Proxy** pane.
4. Select **Creare from Scratch** option. 
5. Specify the following values as Proxy Metadata:

    | **Field**       | **Value**                                  |
    |-----------------|--------------------------------------------|
    | **Context**     | `department-service`                                   |
    | **Version**     | `v1.0`                                      |
    | **Target**      | `https://samples.choreoapps.dev/company/hr` |

6. Enter following details for the Component Details:

    !!! info
        The **Component Name** field must be unique and cannot be changed after creation.

    | **Field**                 | **Value**          |
    |---------------------------|--------------------|
    | **Component Display Name**| `Department Service`          |
    | **Component Name**        | `department-service`          |
    | **Description**           | `Sample proxy for department service`     |

7. Click **Create**. This creates the API proxy component and takes you to the **Deploy** page.

## Step 2: Define resources for the API proxy

To add a new resource that retrieves a department by the department ID, follow these steps:

1. In the left navigation menu, click **Develop** and then click **Resources**.
2. Select **GET** as the **HTTP Verb** and enter `/department/{departmentId}` as the **URI Pattern**.
3. Click **+** to add the resource.
4. Expand the added resource and specify the following values:

    | **Field**        | **Value**                            |
    |------------------|--------------------------------------|
    | **Operation ID** | `findDepartment`                     |
    | **Description**  | `Find a department by department ID` |

5. Remove the five default resources that start with `/*` by clicking the delete icon corresponding to each resource.
6. Click **Save**.

## Step 3: Deploy the API proxy

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**. This opens the **Configure & Deploy** pane.
3. Select **External** as the API access mode and click **Deploy**. The **Development** card indicates the **Deployment Status** as **Active** when the API proxy is successfully deployed.

Now you are ready to test the API proxy.

## Step 4: Test the API proxy

Choreo allows you to test your API proxy using either the [integrated OpenAPI Console](../../testing/test-rest-endpoints-via-the-openapi-console.md) or [cURL](../testing/test-apis-with-curl.md). In this guide, you will use the OpenAPI Console.

!!! tip
    Choreo enables OAuth 2.0 to secure APIs by default. Therefore, you need an access token to invoke an API.

    - Choreo automatically generates a key to test the API via the OpenAPI Console. To view the key, click the show key icon in the **Security Header** field.
    - To disable security for the entire API or a specific resource:
        1. In the left navigation menu, click **Deploy**.
        2. Go to the **Build Area** card and click **Security Settings**.
        3. In the **Security Settings** pane:
            - To disable security for the entire API, clear the **OAuth2** checkbox.
            - To disable security for a specific resource, expand the relevant resource and turn off the **Security** toggle.
        4. Click **Apply**.

1. In the left navigation menu, click **Test** and then click **OpenAPI Console**.
2. Select **Development** from the environment drop-down list.
3. Expand the `GET /department/{departmentId}` resource and click **Try it Out**.
4. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

    ![API proxy response](../../assets/img/develop-components/develop-a-rest-api-proxy/rest-api-proxy-response.png){.cInlineImage-full}

    This indicates that your API proxy is working as expected.

## Step 5: Manage the API proxy

Now that you have a tested API proxy, you can publish it and make it available for application developers to consume. In this guide, you will apply rate limiting to the API and publish it.

### Step 5.1: Apply rate limiting to the API proxy

1. In the left navigation menu, click **Deploy**.
2. Go to the required environment card and click the settings icon corresponding to **CORS, Rate Limiting and Resiliency**.
3. In the **CORS, Rate Limiting and Resiliency** pane, click **Rate Limiting** to expand the section.
4. Select **API Level** as the **Rate Limiting Level**.
5. Specify appropriate values for the **Request Limit** and **Time Unit** fields. You can proceed with the default values.
6. Click **Apply**. This applies the rate limiting level to the API proxy and redeploys it.

### Step 5.2: Publish the API proxy

1. In the left navigation menu, click **Lifecycle** under **Manage**. This takes you to the **Lifecycle** page.
2. Click **Publish**.
3. In the **Publish API** dialog, click **Confirm** to proceed with publishing the API. If you want to change the display name, make the necessary changes and then click **Confirm**. This changes the API lifecycle state to **Published**.

## Step 6: Invoke the API

To generate credentials for the published API and invoke it via the Choreo Developer Portal, follow these steps:

1. In the **Lifecycle** page, click **Go to Devportal**. This takes you to the `Department Service` in the Choreo Developer Portal.

2. **Invoke the API**:
    1. In the Developer Portal left navigation menu, click **Try Out**.
    2. In the **Endpoint** list, select **Development** as the environment to try out the API.
    3. Click **Get Test Key** to generate an access token.
    4. Expand the `GET /department/{departmentId}` resource and click **Try it out**.
    5. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

        ![Try out response](../../assets/img/develop-components/develop-a-rest-api-proxy/try-out-response.png){.cInlineImage-full}

Now, you have gained hands-on experience creating, deploying, testing, and publishing an API proxy using Choreo.

# Develop a Ballerina Service

Choreo allows you to develop and deploy applications using your preferred programming language. This guide demonstrates how to deploy a service component that exposes a REST API using the [Ballerina language](https://ballerina.io/). No prior knowledge of Ballerina is required to follow this guide.

A REST API is a web service that adheres to Representational State Transfer (REST) principles, using HTTP methods to access and manage resources. This guide walks you through building a Ballerina service component, deploying it on Choreo, and testing it with an HTTP client application.

In this guide, you will:

 - Build a simple greeting service using a sample implementation. The service has a single resource named `greet` that accepts a query parameter as input.
 - Deploy the service in Choreo.
 - Test the service.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    - Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    - Enter a unique organization name. For example, `Stark Industries`.
    - Read and accept the privacy policy and terms of use.
    - Click **Create**. This creates the organization and opens the **Project Home** page.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample greetings service](https://github.com/wso2/choreo-samples/tree/main/greeting-service) implementation in Ballerina.

### Learn the repository file structure

It’s important to understand the purpose of key files in the sample service. The table below provides an overview of each file in the greeter service:

!!! note
    The file paths are relative to `<sample-repository-dir>/greeting-service`.

| **Filepath**              | **Description**                                                |
|---------------------------|---------------------------------------------------------------|
| `service.bal`             | The greetings service code written in Ballerina.               |
| `tests/service_test.bal`  | Test files related to the `service.bal` file.                  |
| `Ballerina.toml`          | The Ballerina configuration file.                              |

Let’s get started!

## Step 1: Create a service component

To create a Ballerina service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the **Project Home** page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect your GitHub account. If you haven’t connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Provide the following repository details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **Repository**         | choreo-samples     |
    | **Branch**             | **`main`**         |
    |**Component Directory** | `/greeting-service` |

6. Select **Ballerina** as the buildpack.

7. Provide a display name, a unique name, and a description for the service component:

    !!! info
        The **Component Name** field specifies a unique identifier for the component. This name cannot be changed after creation.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Ballerina Greetings`   |
    | **Component Name**        | `ballerina-greetings`   |
    | **Description**           | Send greetings          |

8. Click **Create**. This creates the component and takes you to the **Overview** page.

You have successfully created a service that exposes a REST API written in Ballerina. Next, let’s build and deploy the service.

## Step 2: Build and deploy

Now that you’ve connected the source repository and configured the endpoint details, it’s time to build and deploy the service.

!!! note
    If you’re rebuilding the Ballerina service component after changing the Ballerina version, ensure that the version in the `Ballerina.toml` file matches the version in the `Dependencies.toml` file.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service may take a while. Track the progress via the logs in the **Build Details** pane. Once complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps:

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane, click **Next** to skip the configuration.
4. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service may take a while. Once deployed, the **Development** environment card shows the **Deployment Status** as **Active**.

Once deployed, you can test, manage, and observe the service like any other component in Choreo.

For detailed instructions, see the following sections:
- [Step 3: Test](../../testing/test-rest-endpoints-via-the-openapi-console.md)
- [Step 4: Manage](../../api-management/lifecycle-management.md)

## Manage the deployment

To view Kubernetes-level insights for detailed diagnosis of this Ballerina REST API, see Choreo’s [DevOps capabilities](../../devops-and-ci-cd/view-runtime-details.md).


# Develop a Service with Docker

Choreo allows you to create and deploy applications in any language. This guide demonstrates how to develop and deploy a containerized service component using a Dockerfile.

In this guide, you will:

 - Create a containerized service component using a sample service implementation. The sample service has a single resource named `greet` that accepts a query parameter as input.
 - Deploy the service in Choreo using a Dockerfile. The service will run on port 9090.
 - Test the service.

If you want to create a service component that exposes a Ballerina service, see [Develop a Ballerina Service](develop-a-ballerina-service.md).

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    - Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    - Enter a unique organization name. For example, `Stark Industries`.
    - Read and accept the privacy policy and terms of use.
    - Click **Create**. This creates the organization and opens the **Project Home** page.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample greetings service](https://github.com/wso2/choreo-samples/tree/main/greeting-service-go) implementation with the Dockerfile.

### Learn the repository file structure

It’s important to understand the purpose of key files in the sample service. The table below provides an overview of each file in the greeter service:

!!! note
    The file paths are relative to `<sample-repository-dir>/greeting-service-go`.

| **Filepath**               | **Description**                                                              |
|----------------------------|------------------------------------------------------------------------------|
| `main.go`                  | The Go-based greeter service code.                                           |
| `Dockerfile`               | The Dockerfile to build the container image of the application.              |
| `.choreo/component.yaml`   | Choreo-specific configuration that provides information about how Choreo exposes the service. |
| `openapi.yaml`             | The OpenAPI contract of the greeter service. This is required to publish the service as a managed API. This file is referenced by the `.choreo/component.yaml` file. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints. The greeter service runs on port 9090. To securely expose the service through Choreo, you must provide the port and other required information in the `component.yaml` file. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

In the greeter sample, the `component.yaml` file is located in the `greeting-service-go/.choreo/` directory.

## Step 1: Create a service component from a Dockerfile

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/cloud-native-app-developer) and sign in. This opens the **Project Home** page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect your GitHub account. If you haven’t connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
         - Read and write access to code and pull requests.
         - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following repository details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **Repository**         | choreo-samples     |
    | **Branch**             | `main`         |
    | **Component Directory** | `/greeting-service-go`         |

6. Select **Docker** as the buildpack.
7. Enter the following details:

    | **Field**                | **Value**                        |
    |--------------------------|----------------------------------|
    | **Dockerfile**           | `/greeting-service-go/Dockerfile`|

    !!! info
        1. To successfully build your container with Choreo, explicitly define a user ID (UID) under the `USER` instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-sample-apps/blob/main/go/greeter/Dockerfile).
           - A valid User ID is a numeric value between 10000-20000 (e.g., `10001` or `10500`).
           - Usernames are invalid and should not be used (e.g., `my-custom-user-12221` or `my-custom-user`).

        2. The Dockerfile used in this guide is a multi-stage Dockerfile, which keeps the final image size small and allows building the application with specific versions of tools and libraries.

8. Provide a display name, a unique name, and a description for the service component:

    !!! info
        The **Component Name** field specifies a unique identifier for the component. This name cannot be changed after creation.

    | **Field**                 | **Value**          |
    |---------------------------|--------------------|
    | **Component Display Name**| `Greetings`        |
    | **Component Name**        | `greetings`        |
    | **Description**           | Send greetings     |

9. Click **Create**. This creates the component and takes you to the **Overview** page.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you’ve connected the source repository and configured the endpoint details, it’s time to build the service and create an image. Then, you can deploy the image and test the greeter service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service may take a while. Track the progress via the logs in the **Build Details** pane. Once complete, the build status changes to **Success**.

    You can access the following scans under **Build**:
    - **Dockerfile Scan**: Choreo checks if a non-root user ID is assigned to the Docker container for security. If no non-root user is specified, the build will fail.
    - **Container (Trivy) Vulnerability Scan**: This detects vulnerabilities in the final Docker image. If critical vulnerabilities are found, the build will fail.

    !!! info
        If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps:

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service may take a while. Once deployed, the **Development** environment card shows the **Deployment Status** as **Active**.

Once deployed, you can [test](../../testing/test-rest-endpoints-via-the-openapi-console.md), [manage](../../api-management/lifecycle-management.md), and [observe](../../monitoring-and-insights/observability-overview.md) the service like any other component in Choreo.

To view Kubernetes-level insights for detailed diagnosis of this Dockerfile-based REST API, see [Choreo's DevOps capabilities](../../devops-and-ci-cd/view-runtime-details.md).


# Develop a Service

Choreo allows you to create and deploy applications in your preferred programming language. 

In this guide, you will:

- Build a simple greeting service using a sample service implementation. The sample implementation will have a single resource named `greet` that accepts a single query parameter as input.
- Deploy the service in Choreo using a `Go` buildpack. The service will run on port 9090.
- Test the service.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample greetings service](https://github.com/wso2/choreo-samples/tree/main/greeting-service-go) implementation in `Go`.

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the greeter service:

!!! note 
    The specified file paths are relative to `<sample-repository-dir>/greeting-service-go`.

| **Filepath**             | **Description**                                                               |
|--------------------------|-------------------------------------------------------------------------------|
| `main.go`                | The Go-based greeter service code.                                            |
| `.choreo/component.yaml` | Choreo-specific configuration that provides information about how Choreo exposes the service. |
| `openapi.yaml`           | The OpenAPI contract of the greeter service. This is required to publish the service as a managed API. This `openapi.yaml` file is referenced by the `.choreo/component.yaml` file. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints. To run the greeter service on port 9090 and securely expose it through Choreo, you must provide the port and other required information in the `component.yaml` file. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

In the greeter sample, the `component.yaml` file is located in the `greeting-service-go/.choreo/` directory.

## Step 1: Create a service component

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Public Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Under **Connect a Git Repository**, enter the following details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **GitHub Repository**  | choreo-samples     |
    | **Branch**             | main               |
    | **Component Directory** | `/greeting-service-go` |

6. Select **Go** as the buildpack.
7. Enter the following details:

    | **Field**                | **Value**              |
    |--------------------------|------------------------|
    | **Language Version**     | 1.x                    |

8. Provide component display name, name and description:

    !!! info
        The **Component Name** field must be unique and cannot be changed after creation.

    | **Field**                 | **Value**          |
    |---------------------------|--------------------|
    | **Component Display Name**| Greetings          |
    | **Component Name**        | greetings          |
    | **Description**           | Send greetings     |

9. Click **Create**. This creates the component and lists it under **Component Listing** on the project home page.

You have successfully created the service. The next step is to build and deploy it.

## Step 2: Build and deploy

Now that you have connected the source repository and configured the endpoint details, it's time to build and deploy the greeter service.

### Step 2.1: Build

1. On the project home page, click on the `Greetings` component you created. This takes you to the component overview page.
2. In the left navigation menu, click **Build**.
3. On the **Build** page, click **Build Latest**.

    !!! note
        The build process may take some time. You can track progress in the **Build Details** pane. Once complete, the build status changes to **Success**.

### Step 2.2: Deploy

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take some time. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

Once you have successfully deployed the service, you can [test](../../testing/test-rest-endpoints-via-the-openapi-console.md), [manage](../../api-management/lifecycle-management.md), and [observe](../../monitoring-and-insights/observability-overview.md) it like any other component type in Choreo.


# Expose a Ballerina GraphQL Endpoint via a Service

Choreo offers the flexibility to develop and deploy applications in a language of your preference. This guide shows you how to deploy a service component that exposes a GraphQL API using the Ballerina language in Choreo. No prior knowledge of the Ballerina language is required to follow this guide. 

GraphQL API is a query language and runtime that provides a single endpoint for retrieving flexible and efficient data in a strongly-typed and self-documenting way. By following this guide, you will build a service component in Ballerina and deploy it on Choreo for any GraphQL client application to utilize it.

This guide shows how to build a simple reading list service and deploy it in Choreo using Ballerina. The GraphQL endpoint you create in this guide has two operations: **Query** and **Mutation**. The Query type operations read the data in the data source, and the Mutation operations update the data in the data source. The reading list service has two queries and three mutations as follows:

### Queries

**Retrieve the reading list**

This resource accepts an optional filter, `status`, which filters the reading list by reading status. Accepted values for status are `reading`, `read`, and `to_read`.

**Sample request**:
```
$ curl -X POST -H "Content-Type: application/json" -d '{"query": "query {allBooks (status: \"reading\") { id title author status }}"}' http://localhost:8090
```

**Sample response**
```
$ {
  "data": {
    "allBooks": [
      {
        "id": 1,
        "title": "Sample Book",
        "author": "Test Author",
        "status": "to_read"
      }
    ]
  }
}
```

**Retrieve a book item from the reading list**

This resource accepts a filter, `id`, which will select the book item from the reading list by book id.  The id is an Integer value. 

**Sample request**
```
$ curl -X POST -H "Content-Type: application/json" -d '{"query": "query {book (id: 1) { id title author status }}"}' http://localhost:8090
```

**Sample response**
```
$ {
  "data": {
    "book": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "to_read"
    }
  }
}
```

### Mutations

**Add a book item to the reading list**

This remote function accepts a book record as the input and consists of the title and the author. When you add a new book to the reading list, the method updates the reading status of the newly added book to `to_read`. This method returns the added book item upon successful execution.


**Sample request**

```
$ curl -X POST -H "Content-type: application/json" -d '{ "query": "mutation { addBook(book: {title: \"Sample Book\", author: \"Test Author\"}) { id title author status } }" }' 'http://localhost:8090'
```

**Sample response**

```
$ {
  "data": {
    "addBook": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "to_read"
    }
  }
}
```

**Update the reading status of a book**

This remote function requires `id` and `status` as inputs to update the reading status of the selected book. The `id` refers to the id of the book. It is an integer.  The `status` refers to the reading status that needs to be updated. This method returns the updated book item upon successful execution.

**Sample request**

```
$ curl -X POST -H "Content-type: application/json" -d '{ "query": "mutation { setStatus(id: 1, status: \"reading\") { id title author status } }" }' 'http://localhost:8090'
```

**Sample response**

```
$ {
  "data": {
    "setStatus": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "reading"
    }
  }
}
```

**Delete a book item from the reading list**

This remote function requires the `id` as the input to delete the book item from the reading list. This method returns the removed book item upon successful execution.

**Sample request**

```
$ curl -X POST -H "Content-type: application/json" -d '{ "query": "mutation { deleteBook(id: 1) { id title author status } }" }' 'http://localhost:8090'
```

**Sample response**
```
$ {
  "data": {
    "deleteBook": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "reading"
    }
  }
}
```

Our next step is to set up the resources that you will require to follow the guide, including the sample reading list application and the Choreo GitHub app.

## Prerequisites

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample GraphQL service](https://github.com/wso2/choreo-samples/tree/main/reading-list-graphql) implementation for this guide.

Let's get started!

## Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the reading list service.

!!! note
    The following file paths are relative to the path `<sample-repository-dir>/reading-list-graphql`.

|Filepath                 | Description                                                     |
|-------------------------|-----------------------------------------------------------------|
| `service.bal`           | The reading list service code written in the Ballerina language.|
| `Ballerina.toml`        | The Ballerina configuration file.                               |
| `.choreo/component.yaml`| The configuration file with endpoint details.                   |

## Step 1: Create a service component 

To create a Ballerina service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**| `reading-list-graphql`    |.

6. Select **Ballerina** as the buildpack.

7. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Ballerina Reading List`|
    | **Component Name**        | `ballerina-reading-list`|
    | **Description**           | Manage a reading list   |

8. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service component that exposes a GraphQL API written in the Ballerina language. Next, let's build and deploy the service.

## Step 2: Build and deploy

Now that we have connected the source repository, it's time to build and deploy the reading list service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Configurations** pane that opens, click **Next** to skip the configuration.
4. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.
To build and deploy the service, follow the steps below:

Once you have successfully deployed your service, you can test, manage, and observe it like any other component type in Choreo.

For detailed instructions, see the following sections:

- [Step 3: Test](https://wso2.com/choreo/docs/testing/test-graphql-endpoints-via-the-graphql-console/)
- [Step 4: Manage](https://wso2.com/choreo/docs/manage/api-management/)


# Expose a gRPC Endpoint via a Service

Choreo allows you to create and deploy applications in your preferred programming language. One powerful option is gRPC, a high-performance and language-agnostic remote procedure call (RPC) framework. It utilizes [Protocol Buffers](https://github.com/protocolbuffers/protobuf) to define services and generate client/server code.

In this guide, you will learn to use Choreo to create a service component that exposes a gRPC server implemented in [Go](https://go.dev/), enabling efficient and scalable communication with any gRPC client application. No prior knowledge of the Go language is necessary to follow this guide.

By following this guide, you will:

- Create a simple gRPC server using a Service component.
- Link the containerized gRPC service to the Choreo component using the Dockerfile. 
    The greeter service has a single RPC method named `sayHello`. Following is the proto file the server and the client application are using:

    ```proto
    syntax = "proto3";
    option go_package = "github.com/wso2/choreo-samples/go-grpc/pkg";

    service greeter {
      rpc SayHello (HelloRequest) returns (HelloReply) {}
    }

    message HelloRequest {
      string name = 1;
    }

    message HelloReply {
      string message = 1;
    }
    ```

- Deploy the gRPC server component in Choreo. 
- Create a gRPC client using a Manual Trigger component. 
- Deploy the gRPC client.
- Invoke the gRPC server using a gRPC client and check the response through the Choreo log view.


## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample service](https://github.com/wso2/choreo-samples/tree/main/go-grpc) implementation for this guide.

Let's get started!

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the greeter service.

!!! note 
    The following file paths are relative to the path `<sample-repository-dir>/go-grpc`.

|File Path                |Description                                                                                   |
|-------------------------|----------------------------------------------------------------------------------------------|
| `main.go`               | The greeter service code written in the Go language.                                         |
| `greeter_client/main.go`| The greeter client application written in the Go language.                                   |
| `Dockerfile.server`     | The Dockerfile to build the container image of the server application.                       |
| `Dockerfile.client`     | The Dockerfile to build the container image of the client application.                       |
| `.choreo/component.yaml`| The Choreo-specific configuration that provides information about how Choreo exposes the service.|
| `pkg/greeter.proto`     | The interface definition of the gRPC service. This is used to generate the server and client stubs for the Go application.|

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints.

Let's run the gRPC server service component on port 8080. To securely expose the service through Choreo, you must provide the port and other required information to Choreo. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

Choreo looks for an `component.yaml` file inside the `.choreo` directory to configure the endpoint details of the containerized component. Ensure the `.choreo` directory is at the root of the Docker build context path.

In the gRPC server sample, the `component.yaml` file is at `go-grpc/.choreo/component.yaml`, where the build context path is `go-grpc`.

## Step 1: Create a service component with a gRPC endpoint

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
6. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

7. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory** | `go-grpc`                  |

8. Select **Docker** as the buildpack.
9. Enter the following information:
    
    | **Field**                | **Value**                  |
    |--------------------------|----------------------------|
    | **Dockerfile**           | `go-grpc/Dockerfile.server`|

    !!! info
        1.  To successfully build your container with Choreo, it is essential to explicitly define a User ID (UID) under the USER instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-samples/blob/main/go-grpc/Dockerfile.server).
        To ensure that the defined USER instruction is valid, it must conform to the following conditions:
            - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
            - Usernames are considered invalid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

        2. The Dockerfile utilized in this guide is a multi-stage Dockerfile, which is designed to keep the final image size small and provides the ability to build the application with a specific version of tools and libraries.

4. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go gRPC Server`        |
    | **Component Name**        | `go-grpc-server`        |
    | **Description**           | Send greetings          |
    
10. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you have connected the source repository, and configured the endpoint details, it's time to build the service and create an image. Then you can deploy the image and test the greeter service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

    You can access the following scans under **Build**. 

      - **The Dockerfile scan**: Choreo performs a scan to check if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
      - **Container (Trivy) vulnerability scan**: This detects vulnerabilities in the final docker image. 
      - **Container (Trivy) vulnerability scan**: The details of the vulnerabilities open in a separate pane. If this scan detects critical vulnerabilities, the build will fail.
     
        !!! info
            If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Environment Configurations** pane that opens, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

6. Once you have successfully deployed your service, navigate to the component overview page and copy the gRPC service URL. You need to provide that URL when setting up the client application later in this guide.

You have successfully deployed the gRPC server. Currently, the gRPC service is only accessible by the components deployed within the same project.

## Step 3: Invoke the gRPC service

Let's invoke the gRPC service that you created above, using a gRPC client. 

### Step 3.1: Create a manual task for the gRPC client

To create a manual task component, follow these steps:

1. On the Choreo Console header, click the **Project** list and select the project where you created the gRPC service component. This opens the project home page.
2. Go to the **Component Listing** section and click **+ Create**.
3. Click the **Manual Task** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**       | `go/grpc`                  |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                  |
    |--------------------------|----------------------------|
    | **Dockerfile**           | `go/grpc/Dockerfile.client`|

8. Enter a display name, a unique name, and a description for the component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go gRPC Client`        |
    | **Component Name**        | `go-grpc-client`        |
    | **Description**           | `Receive greetings`     |


9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

### Step 3.2: Build the gRPC client component

To build the component, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 3.3: Setup environment variables and deploy the gRPC client

The client application, in this case, the gRPC client, requires the server URL of the gRPC server service. This is read from the client application as an environment variable. Follow the steps below to configure the environment variable for the client application:

1. On the Choreo Console left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane that opens, click **+ Add**.
4. Specify the following name and value to configure the environment variable for the client application:

    | **Field**       | **Value**               |
    |-----------------|-------------------------|
    | **Name**        | `GREETER_SERVICE`       |
    | **Value**       | Paste the URL value copied after deploying the gRPC service via [step 2.2](#step-22-deploy) above.  Make sure to **drop the `http://` or `grpc://` part and the trailing `/` from the URL when copying**. For example, if the URL is `http://go-grpc-server-3192360657:8080/`, add only `go-grpc-server-3192360657:8080`.|

5.  Click **Add** and then click **Next**.
6.  Click **Deploy**.

### Step 3.4: Execute the gRPC client component

To execute the gRPC client, follow these steps:

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the gRPC client and generates logs.
   You can trigger multiple runs to generate multiple logs.

For details on what you can monitor via the execute page, see [Monitor executions](../develop-integrations/develop-a-manual-task.md#step-7-monitor-executions). 


# Expose a Prism-Based Mock Server Using an OpenAPI Specification

Choreo supports deploying [Prism-based](https://docs.stoplight.io/docs/prism/674b27b261c3c-prism-overview) mock servers using OpenAPI specifications. With the Choreo Prism mock service component, you can serve multiple mock servers, each based on a different OpenAPI specification, as separate endpoints.

By default, these mock servers serve static content generated from the examples in the configured OpenAPI Specification (OAS). 

## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [Prism mock service](https://github.com/wso2/choreo-samples/tree/main/prism-mock-service) artifacts for this guide.

## Step 1: Create a Prism mock service component

To create a Prism mock service component, follow these steps:
    
1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, you can paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    |**Component Directory**  | `prism-mock-service`    |

6. Select **Prism Mock** as the buildpack.
7. Enter a display name, a unique name, and a description for the service component.
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

8. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

## Step 2: Build and deploy the component

Now that you have successfully created the Prism mock service, it's time to build and deploy it.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**. This builds the service from the latest commit.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

Once you have successfully deployed the service, you can [test](../../testing/test-rest-endpoints-via-the-openapi-console.md), [manage](../../api-management/lifecycle-management.md), and [observe](../../monitoring-and-insights/observability-overview.md) it like any other component type in Choreo.

## Serve dynamic content

The Prism mock service can serve dynamic content according to the schema definitions in the OpenAPI specification. To use the Prism mock service with dynamic content, clients must add the `prefer:dynamic=true` header in the request.

To generate meaningful dynamic responses, you can use the `x-faker` attribute in schema definitions of the OpenAPI specification. For more information on dynamically generated responses with the `x-faker` attribute, see the [Prism documentation](https://docs.stoplight.io/docs/prism/9528b5a8272c0-dynamic-response-generation-with-faker).


# Expose a TCP Server via a Service

Choreo offers the flexibility to design and deploy applications in the programming language of your choice. One viable choice for specific network communication needs is TCP (Transmission Control Protocol). TCP provides a reliable, stream-oriented communication mechanism that ensures data integrity and orderliness during transmission. It's the go-to option for scenarios where guaranteed data delivery and error recovery are paramount.

In this guide, you will learn to use Choreo to create a service component that exposes a TCP server implemented in [Go](https://go.dev/), enabling efficient and scalable communication with any TCP client application. No prior knowledge of the Go language is necessary to follow this guide.

By following this guide, you will:

- Setup a TCP server
    - Create a simple TCP server using a service component.
    - Link the containerized TCP service to the Choreo component using a Dockerfile. 
    - Deploy the TCP server component in Choreo. 
- Setup a TCP client
    - Create a TCP client using a manual task component. 
    - Link the containerized TCP client to the Choreo component using a Dockerfile. 
    - Deploy the TCP client component in Choreo.
- Invoke the TCP server using a TCP client and observe the response through the Choreo log view.

## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample service](https://github.com/wso2/choreo-samples/tree/main/docker-tcp-service) implementation for this guide.

Let's get started!

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the sample service.

!!! note 
    The following file paths are relative to the path `<sample-repository-dir>/docker-tcp-service`.

|File Path                 |Description                                                                                   |
|--------------------------|----------------------------------------------------------------------------------------------|
| `server/main.go`         | The greeter service code written in the Go language.                                         |
| `client/main.go`         | The greeter client application written in the Go language.                                   |
| `Dockerfile.server`      | The Dockerfile to build the container image of the server application.                       |
| `Dockerfile.client`      | The Dockerfile to build the container image of the client application.                       |
| `.choreo/component.yaml` | The Choreo-specific configuration provides information about how Choreo exposes the service. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints.

Let's run the TCP server service component on port 5050. To securely expose the service through Choreo, you must provide the port and other required information to Choreo. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

Choreo looks for an `component.yaml` file inside the `.choreo` directory to configure the endpoint details of a containerized component. Place the `.choreo` directory at the root of the Docker build context path.

In our TCP server sample, the `component.yaml` file is at `docker-tcp-service/.choreo/component.yaml`, where the build context path is `docker-tcp-service`.

## Step 1: Create a service component with a TCP endpoint

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory** | `docker-tcp-service`                  |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-tcp-service/Dockerfile.server`|

    !!! info
        1.  To successfully build your container with Choreo, it is essential to explicitly define a User ID (UID) under the USER instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-samples/blob/main/docker-tcp-service/Dockerfile.server).
        To ensure that the defined USER instruction is valid, it must conform to the following conditions:
            - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
            - Usernames are considered invalid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

        2. The Dockerfile utilized in this guide is a multi-stage Dockerfile, which is designed to keep the final image size small and provides the ability to build the application with a specific version of tools and libraries.

8. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go TCP Server`         |
    | **Component Name**        | `go-tcp-server`         |
    | **Description**           | Send greetings          |
    
9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you have connected the source repository, and configured the endpoint details, it's time to build the service and create an image. Then you can deploy the image and test the service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

    You can access the following scans under **Build**. 

      - **The Dockerfile scan**: Choreo performs a scan to check if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
      - **Container (Trivy) vulnerability scan**: This detects vulnerabilities in the final docker image. 
      - **Container (Trivy) vulnerability scan**: The details of the vulnerabilities open in a separate pane. If this scan detects critical vulnerabilities, the build will fail.
     
        !!! info
            If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Environment Configurations** pane that opens, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

6. Once you have successfully deployed your service, navigate to the component overview page and copy the TCP service address. You need to provide that address when setting up the client application later in this guide.

You have successfully deployed the TCP server. Currently, the TCP service is only accessible by the components deployed within the same project.

## Step 3: Invoke the TCP service

Now let's use a TCP client to invoke the TCP service that you created above. To do this, you can create a manual trigger component as the TCP client. This is the recommended approach because, in this example, it's more efficient to have a client that connects to the server, sends a request, and then stops. Here, a continuously executing task isn't required. Furthermore, if you use a manual trigger component, you won't need to expose an endpoint in the client for invocation, unlike with an API.

### Step 3.1: Create a manual trigger for the TCP client

To create a manual task component, follow these steps:

1. On the Choreo Console header, click the **Project** list and select the project where you created the TCP service component. This opens the project home page.
2. Go to the **Component Listing** section and click **+ Create**.
3. Click the **Manual Task** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Docker Context**      |`docker-tcp-service`     |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-tcp-service/Dockerfile.client`|

8. Enter a display name, a unique name, and a description for the component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**              |
    |---------------------------|------------------------|
    | **Component Display Name**| `Go TCP Client`        |
    | **Component Name**        | `go-tcp-client`        |
    | **Description**           | `Receive greetings`    |


9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

### Step 3.2: Build the TCP client component

To build the component, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 3.3: Setup environment variables and deploy the TCP client

The client application, in this case, the TCP client, requires the server URL of the TCP server service. This is read from the client application as an environment variable. Follow the steps below to configure the environment variable for the client application:

1. On the Choreo Console left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane that opens, click **+ Add**.
4. Specify the following name and value to configure the environment variable for the client application:

    | **Field**       | **Value**               |
    |-----------------|-------------------------|
    | **Name**        | `SERVER_ADDRESS`       |
    | **Value**       | Paste the URL value copied after deploying the TCP service via [step 2.2](#step-22-deploy) above.  Make sure to **drop the `tcp://` part and the trailing `/` from the URL when copying**. For example, add only `go-tcp-server-1097922445:8080`.|

5.  Click **Add** and then click **Next**.
6.  Click **Deploy**.

### Step 3.4: Execute the TCP client component

To execute the TCP client, follow these steps:

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the TCP client and generates logs.
   You can trigger multiple runs to generate multiple logs.

For details on what you can monitor via the execute page, see [Monitor executions](../develop-integrations/develop-a-manual-task.md#step-7-monitor-executions).


# Expose a UDP Server via a Service

Choreo offers the flexibility to design and deploy applications in the programming language of your choice. One compelling choice for certain network communication needs is UDP (User Datagram Protocol). UDP is a high-speed, connectionless protocol ideal for scenarios where lightweight, real-time data transmission is essential.

In this guide, you will learn to use Choreo to create a Service component that exposes a UDP server implemented in [Go](https://go.dev/), enabling efficient and scalable communication with any UDP client application. No prior knowledge of the Go language is necessary to follow this guide.

By following this guide, you will:

- Setup a UDP server
    - Create a simple UDP server using a Service component.
    - Link the containerized UDP service to the Choreo component using the Dockerfile. 
    - Deploy the UDP server component in Choreo. 
- Setup a UDP client
    - Create a UDP client using a manual task component. 
    - Link the containerized UDP client to the Choreo component using the Dockerfile. 
    - Deploy the UDP client component in Choreo.
- Invoke the UDP server using a UDP client and check the response through the Choreo log view.

## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample service](https://github.com/wso2/choreo-samples/tree/main/docker-udp-service) implementation for this guide.

Let's get started!

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the sample service.

!!! note 
    The following file paths are relative to the path `<sample-repository-dir>/docker-udp-service`.

|File Path                |Description                                                                                   |
|-------------------------|----------------------------------------------------------------------------------------------|
| `server/main.go`        | The greeter service code written in the Go language.                                         |
| `client/main.go`        | The greeter client application written in the Go language.                                   |
| `Dockerfile.server`     | The Dockerfile to build the container image of the server application.                       |
| `Dockerfile.client`     | The Dockerfile to build the container image of the client application.                       |
| `.choreo/component.yaml`| The Choreo-specific configuration provides information about how Choreo exposes the service. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints.

Let's run the UDP server service component on port 5050. To securely expose the service through Choreo, you must provide the port and other required information to Choreo. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

Choreo looks for an `component.yaml` file inside the `.choreo` directory to configure the endpoint details of a containerized component. Place the `.choreo` directory at the root of the Docker build context path.

In our gRPC server sample, the `component.yaml` file is at `docker-udp-service/.choreo/component.yaml`, where the build context path is `docker-udp-service`.

## Step 1: Create a service component with a UDP endpoint

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
6. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

7. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**   | `docker-udp-service`    |    

8. Select **Docker** as the buildpack.
9. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-udp-service/Dockerfile.server`|

    !!! info
        1.  To successfully build your container with Choreo, it is essential to explicitly define a User ID (UID) under the USER instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-samples/blob/main/docker-udp-service/Dockerfile.server).
        To ensure that the defined USER instruction is valid, it must conform to the following conditions:
            - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
            - Usernames are considered invalid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

        2. The Dockerfile utilized in this guide is a multi-stage Dockerfile, which is designed to keep the final image size small and provides the ability to build the application with a specific version of tools and libraries.

4. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go UDP Server`         |
    | **Component Name**        | `go-udp-server`         |
    | **Description**           | Send greetings          |

10. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you have connected the source repository, and configured the endpoint details, it's time to build the service and create an image. Then you can deploy the image and test the service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

    You can access the following scans under **Build**. 

      - **The Dockerfile scan**: Choreo performs a scan to check if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
      - **Container (Trivy) vulnerability scan**: This detects vulnerabilities in the final docker image. 
      - **Container (Trivy) vulnerability scan**: The details of the vulnerabilities open in a separate pane. If this scan detects critical vulnerabilities, the build will fail.
     
        !!! info
            If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Environment Configurations** pane that opens, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

6. Once you have successfully deployed your service, navigate to the component overview page and copy the UDP service address. You must provide that address when setting up the client application later in this guide.

You have successfully deployed the UDP server. Currently, the UDP service is only accessible by the components deployed within the same project.

## Step 3: Invoke the UDP service

Now let's use a UDP client to invoke the UDP service that you created above. To do this, you can create a manual trigger component as the UDP client. This is the recommended approach because, in this example, it's more efficient to have a client that connects to the server, sends a request, and then stops. Here, a continuously executing task isn't required. Furthermore, if you use a manual trigger component, you won't need to expose an endpoint in the client for invocation, unlike with an API.

### Step 3.1: Create a manual trigger for the UDP client

To create a manual task component, follow these steps:

1. On the Choreo Console header, click the **Project** list and select the project where you created the UDP service component. This opens the project home page.
2. Go to the **Component Listing** section and click **+ Create**.
3. Click the **Manual Task** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory** | `docker-udp-service`    |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-udp-service/Dockerfile.client`|

8. Enter a display name, a unique name, and a description for the component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**              |
    |---------------------------|------------------------|
    | **Component Display Name**| `Go UDP Client`        |
    | **Component Name**        | `go-udp-client`        |
    | **Description**           | `Receive greetings`    |


9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

### Step 3.2: Build the UDP client component

To build the component, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 3.3: Setup environment variables and deploy the UDP client

The client application, in this case, the UDP client, requires the server URL of the UDP server service. This is read from the client application as an environment variable. Follow the steps below to configure the environment variable for the client application:

1. On the Choreo Console left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane that opens, click **+ Add**.
4. Specify the following name and value to configure the environment variable for the client application:

    | **Field**       | **Value**               |
    |-----------------|-------------------------|
    | **Name**        | `SERVER_ADDRESS`       |
    | **Value**       | Paste the URL value copied after deploying the UDP service via [step 2.2](#step-22-deploy) above.  Make sure to **drop the `udp://` part and the trailing `/` from the URL when copying**. For example, add only `go-udp-server-1097922445:8080`.|

5.  Click **Add** and then click **Next**.
6.  Click **Deploy**.

### Step 3.4: Execute the UDP client component

To execute the UDP client, follow these steps:

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the UDP client and generates logs.
   You can trigger multiple runs to generate multiple logs.

For details on what you can monitor via the execute page, see [Monitor executions](../develop-integrations/develop-a-manual-task.md#step-7-monitor-executions).


# Expose a WebSocket Endpoint via a Service

Choreo allows you to create and deploy applications in your preferred programming language, offering a seamless platform for building dynamic and scalable solutions. This guide walks you through the steps to deploy a WebSocket service using the NodeJS buildpack.

WebSockets provide real-time, two-way communication between a client and server over a persistent TCP connection. This makes WebSocket APIs ideal for applications that require real-time updates.

In this guide, you will:

- Build a simple WebSocket service using a sample implementation in NodeJS.
- Deploy the service in Choreo, allowing any WebSocket client application to establish a connection and exchange real-time messages with your service.

## Prerequisites

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample WebSocket service](https://github.com/wso2/choreo-samples/tree/main/websocket-chat-app) implementation for this guide.

Let's get started!

## Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the NodeJS chat Application.

!!! note
    The following file paths are relative to the path `<sample-repository-dir>/websocket-chat-app/websocket-chat-service-nodejs`.

|Filepath                        | Description                                                     |
|--------------------------------|-----------------------------------------------------------------|
| `server.js`                    | The NodeJS chat service.                                        |
| `.choreo/component.yaml`       | The configuration file with endpoint details.                   |

!!! note
    Choreo currently supports defining WebSocket APIs using the AsyncAPI 2.0 specification.

## Step 1: Create a service component 

To create a NodeJS service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**   | `websocket-chat-app/websocket-chat-service-nodejs`  |

6. Select **NodeJS** as the buildpack and **18.x.x** as the Language Version

8. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:

    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `NodeJS Chat Service`   |
    | **Component Name**        | `nodejs-chat-service`   |
    | **Description**           | Manage a chat service   |

9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service component that provides a WebSocket API built with NodeJS. The next step is to proceed with building and deploying the service.

## Step 2: Build and deploy

Now that you have connected the source repository, it's time to build and deploy the chat service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane that opens, click **Next** to skip the configuration.
4. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

Once you have successfully deployed your service, you can [test](../../testing/test-websocket-endpoints-via-the-websocket-console.md), [manage](../../api-management/lifecycle-management.md), and observe it like any other component type in Choreo.

During testing, once the WebSocket connection is established, you can send {"type": "Connect", "username": "user1"} to the WebSocket endpoint to connect to the chat service. You can then send chat messages by using {"type": "Data", "message": "Hello, World!"}.

!!! note
     Some clients, such as certain browsers, may not support adding headers to the WebSocket handshake. In these cases, you can include the access token or test key required for WebSocket API invocation within the `sec-websocket-protocol` header, along with any specified subprotocols.

     For example: `sec-websocket-protocol: choreo-oauth2-token, {access token}, subprotocols`

     If you are using a test key, replace `choreo-oauth2-token` with `choreo-test-key`.


# Service Component Overview

Explore how to create, deploy, manage, and observe service components in Choreo.

## What is a service component?

A service component in Choreo lets you deploy and expose REST, GraphQL, gRPC, UDP, WS or TCP services. It is a fundamental building block for creating cloud-native applications in Choreo. They provide a simple and effective way to expose functionality as a service to other components within Choreo or to the outside world.

Service components encapsulate business logic and provide standardized interfaces, called endpoints, for communicating with other components or systems. You can deploy and scale services independently, which makes them highly flexible and adaptable to changing workloads.

With the help of the service component, developers can quickly create APIs and microservices, making it easier to implement and manage complex software systems. Service components can also be integrated with other Choreo components, that acts as message processors, connectors, and data sources, etc to create powerful end-to-end solutions.

You can expose a service to other components through endpoints. For details on configuring endpoints, see [Configure Endpoints](../configure-endpoints.md).


# Build and Deploy a Single-Page Web Application

A web application is an application program hosted on a server and serves ingress traffic through a browser. In Choreo, you can deploy a web application by creating a Web Application component and connecting it to a Git repository that contains the implementation of the web application. Web applications can fall into one of the following categories:

- **Single page applications (SPAs)**: Examples include React, Angular, Vue, Svelte, etc.
- **Web servers**: These serve static content or provide server-side rendering/static site generation (SSR/SSG).
- **Static content**: Examples include websites and other static resources that do not require a backend, usually comprising static HTML/JS/CSS files.

## Prerequisites

- To deploy a web application component, you must have a GitHub account with a repository containing the web application's implementation. For this guide, fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample web application implementation.

## Create a web application

You can create a web application in Choreo as follows:

### Build and deploy a SPA from source code

1. To create a web application component, connect a repository that includes the web application source code.
2. Select the relevant buildpack: Default buildpacks include **React**, **Angular**, and **Vue.js**. If you are using a different SPA framework, you can try one of these buildpacks because the configurations can be overridden to support most JavaScript-based SPAs.
3. Enter the build command: Based on your package manager (NPM, yarn, or pnpm). The relevant package manager is run based on the dependency lock file in your repository (defaults to NPM if no lock file is present).
4. Specify the build output directory.
5. Specify the NodeJS version: Choreo does not pick the Node.js version from the `package.json` engine property. The required Node version must be explicitly set in the build configuration.

Once you create the Web Application component, Choreo automatically generates a build pipeline for your single-page application and deploys it.

### Bring your Dockerfile

1. To create a web application component, connect a repository that contains the Dockerfile for your containerized web application.
2. Commit a Dockerfile to your connected Git repository to have full control over your build process.

This approach is recommended if you are deploying a web server and not just a single-page application (or a single-page application with a complex build process).

### Host static websites

1. Create a web application component and connect it to the GitHub repository that contains the required static assets.
2. Select the **Static Websites** buildpack: This buildpack does not trigger a build process. It only fetches the files from the path specified in the repository and serves them as-is.

## Build and deploy a SPA from source code

Follow the steps below to create a sample Web Application component and deploy it in Choreo:

1. Sign in to the Choreo Console at [https://console.choreo.dev/login/](https://console.choreo.dev/login/). This opens the **Project Home** page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Web Application** card.
6. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

7. Enter the following information:

    | **Field**                 | **Description**        |
    |---------------------------|------------------------|
    | **GitHub Account**        | Your account           |
    | **GitHub Repository**     | choreo-samples         |
    | **Branch**                | main                   |
    | **Component Directory**     | /react-single-page-app |

8. Select **React** as the **Buildpack**.
9. Enter the following information:

    | **Field**                 | **Description**        |
    |---------------------------|------------------------|
    | **Build Command**         | `npm run build`        |
    | **Build Path**            | `build`                |
    | **Node Version**          | `18`                   |

    !!! tip
        Managed authentication is enabled by default when you create a web application using **React**, **Angular**, or **Vue.js** buildpacks. To learn how to set up authentication for your web application with Choreo's managed authentication, see [Secure Web Applications with Managed Authentication](../../authentication-and-authorization/secure-web-applications-with-managed-authentication.md).

4. Specify a display name, a unique name and description for the component.
10. Click **Create**. Choreo initializes the component with the sample implementation and opens the **Overview** page of the component.

You have successfully created a Web Application component from the source code. Now let's build and deploy the web application.

## Build your web application

1. In the left navigation menu, click **Build**.
2. In the **Builds** pane, click **Build**. This opens the **Commits** pane, where you can see all the commits related to the component.
3. Select the latest commit and click **Build**. This triggers the build process and displays the progress in the **Build Logs** pane.

    You can access the following scans in the **Build Logs** pane:

    - **Dockerfile Scan**: Choreo checks if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
    - **Container (Trivy) Vulnerability Scan**: Detects vulnerabilities in the final Docker image. If critical vulnerabilities are detected, the build will fail.

    !!! info
        If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

    !!! note
        The build process may take some time. Once complete, the build status will be listed in the **Builds** pane. Here, you will see the build status as **Success**.

## Deploy and access your web application

1. In the left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure and Deploy**. This opens the **Configure & Deploy** pane. In this guide, you do not need to add a file mount.
3. Click **Next** to proceed to the **Authentication Settings** pane.
4. Keep the default settings and click **Deploy**.

    !!! note
        The deployment process may take a few minutes. Once complete, the **Deployment Status** will show as **Active** in the **Development** card.

5. To verify that the web application is hosted successfully, click the **Web App URL** in the **Development** card. This takes you to the web application.

## Create a short URL for your web application in production

!!! info
    This feature is only available on the Choreo cloud data plane.

When you promote your component to the Production environment, you can create a personalized short URL for your web application. The URL follows the `https://{your-short-prefix}.choreoapps.dev` structure, where you can select a name of your preference for `{your-short-prefix}`.

1. Click **Promote** in the **Development** card and promote your web application to production.
2. In the **Production** card, click **Create a short URL**.
3. Specify a **Short URL prefix** of your choice and click **Save**.

    !!! note
        Short URL names/prefixes are subject to availability, provided on a first-come-first-serve basis.

## Manage runtime configurations for web applications

For web applications with a backend server, Choreo allows you to mount runtime configurations and secrets as environment variables and/or file mounts for a specific environment. Alternatively, you can also inject them into the client application during server-side rendering or when serving static content.

For SPAs that run completely on the browser, Choreo does not support *baking-in* environment variables or other configurations. Instead, Choreo recommends the following approach (applicable to most SPA frameworks, including React):

!!! note
    - With SPAs, anything you mount as a runtime config will be available to your users in the browser.
    - **Do not include sensitive secrets that are not browser-safe**.

1. Go to your forked [Choreo samples repository](https://github.com/wso2/choreo-samples).
2. Open the `public` directory.
3. Create and commit a new file named `config.js` in the `public` directory of your React application. This file should contain the runtime configuration variables you want to expose to your application, such as API endpoints or feature flags. For example:

    ```javascript
    window.config = {
        apiUrl: 'https://api.example.com',
        featureFlags: {
            enableNewFeature: true,
            enableExperimentalFeature: false,
        },
    };
    ```

4. In your `index.html` file inside the `public` directory, add a script tag to include the `config.js` file inside the `<body>` tag:

    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>My React App</title>
    </head>
    <body>
        <div id="root"></div>
        <script src="%PUBLIC_URL%/config.js"></script>
    </body>
    </html>
    ```

5. In your React component, access the configuration variables by referencing the `window.config` object:

    ```javascript
    import React from 'react';

    function MyComponent() {
        const apiUrl = window.config.apiUrl;
        const enableNewFeature = window.config.featureFlags.enableNewFeature;
        const enableExperimentalFeature = window.config.featureFlags.enableExperimentalFeature;

        // ...
    }
    ```

6. When you deploy your component to Choreo, create a config file mount in the specified path for each environment (where your `index.html` expects the `config.js` file). For more details, see [Manage Configurations and Secrets](https://wso2.com/choreo/docs/devops-and-ci-cd/manage-configurations-and-secrets/#apply-a-file-mount-to-your-container).

## Limitations

The following limitations are specific to the Choreo cloud data plane:

- **Request size limit**: 256KB (including headers, cookies, and payloads).
- **Response body size limit**: 20MB.
- **Open ports**: Only one open port is permitted per web application. While you can have multiple ports open for project-level communication within a data plane, incoming traffic from the internet can only be directed to one port. This differs from Service-type components, which support multiple endpoints.

## Troubleshoot a web application

- **Blank page or 502 error after deployment**:
    If you encounter a blank page or a 502 error after deploying your web application, it typically indicates that the wrong directory is being served. To resolve this issue:
    1. Double-check the build output directory, especially if you are using a Dockerfile-less buildpack.
    2. Ensure that the specified output directory matches the actual output directory generated during the build process. For example, if you have erroneously entered `public/` as the output directory when it should have been `build/`.

By verifying and correcting the output directory alignment, you should be able to address the issue of encountering a blank page or experiencing a 502 error on deploying your web application.


# Develop Web Applications Locally with Choreo’s Managed Authentication

Choreo’s managed authentication capability provides a set of backend for frontend (BFF) endpoints to facilitate authentication and authorization for web applications. These endpoints are readily available for single-page web applications deployed on Choreo.

As a web application developer, you may need to run the application on your local workstation. Choreo’s local development capability ensures that authentication and authorization during local development work the same way as they do when the application is deployed to Choreo, eliminating the need for code changes.

This guide explains how to configure and use Choreo’s local development capability to streamline your workflow.

## How local development works in Choreo

Local development uses a proxy that sits in front of the locally running web application. This proxy intercepts all incoming requests:
- Requests to `/choreo-apis/*` and `/auth/*` are forwarded to Choreo.
- All other requests are forwarded to the locally running web application.

The proxy runs on HTTPS using a self-signed certificate, which is essential for secure, HTTP-only cookie-based managed authentication. Once the proxy is running, you can access the web application using the proxy's URL and start developing locally. The behavior of the web application, in terms of managed authentication, will mirror its behavior when deployed to Choreo.

## Configure local development

### Prerequisites

- Create a single-page application (SPA) with managed authentication enabled. For details, see [Secure Web Applications with Managed Authentication](../../authentication-and-authorization/secure-web-applications-with-managed-authentication.md#step-1-set-up-managed-authentication-for-your-web-application).
- Promote and deploy the application to the environment where you want to enable local development.

    !!! note
        - The locally running web application will use the same managed authentication configuration as the environment where local development is configured.
        - Local development is only allowed in non-critical environments.

### Apply configurations

1. Sign in to the Choreo Console.
2. In the **Component Listing** pane, click on the component you created and deployed.
3. In the left navigation menu, click **Deploy**.
4. Go to the respective environment card and click **Local Development**.
5. In the **Local Development** pane, toggle **Local Development** to enable it.
6. (Optional) To update the port on which the local development proxy server runs, expand **Advanced Configurations** and specify a value for **Proxy Port**.
7. Click **Apply**.

You have now configured local development. The next section explains how to access your web application for local development.

## Access your web application locally

### Prerequisites

- Ensure local development is enabled in the desired environment.
- Ensure your web application is running locally on `http://localhost` on a specific port.

### Access your web application locally

You can use either the Choreo built-in identity provider or an external identity provider to access your web application locally.

=== "Use the Choreo built-in identity provider"

    1. Sign in to the Choreo Console.
    2. In the **Component Listing** pane, click on the component you created and deployed.
    3. In the left navigation menu, click **Deploy**.
    4. Go to the respective environment card and click **Local Development**.
    5. In the **Local Development** pane, copy the command under **Step 1**.
    6. Paste the command in a terminal, replace `[APP_PORT]` with the port on which your application is running locally, and run the command.
    7. To access the application, go to the URL provided under **Step 2** in the **Local Development** pane.

        !!! note
            The local development proxy runs on HTTPS using a self-signed certificate. Your browser may warn that the certificate is not valid. Accept the risk and proceed.

=== "Use an external identity provider"

    1. Sign in to the Choreo Console.
    2. In the **Component Listing** pane, click on the component you created and deployed.
    3. In the left navigation menu, click **Deploy**.
    4. Go to the respective environment card and click **Local Development**.
    5. In the **Local Development** pane, copy the redirect URLs under **Step 1**.
    6. Go to the settings in the OAuth application in your identity provider and specify the copied URLs as allowed redirect URLs.
    7. In the **Local Development** pane, copy the command under **Step 2**.
    8. Paste the command in a terminal, replace `[APP_PORT]` with the port on which your application is running locally, and run the command.
    9. To access the application, go to the URL provided under **Step 3** in the **Local Development** pane.

        !!! note
            The local development proxy runs on HTTPS using a self-signed certificate. Your browser may warn that the certificate is not valid. Accept the risk and proceed.


# Create a Connection

Connections in Choreo provide a simple and uniform approach to seamlessly integrate components with services or resources.

Choreo allows you to create connections to services deployed in Choreo or registered as external services. It also allows you to create connections to any Choreo-managed database.

To create a connection to a service or a database, follow the step-by-step instructions in the respective tab:

=== "Create a connection to a service"

    <h2>Create a connection to a Choreo service</h2>

    Follow these steps to create a connection to a service deployed in Choreo:

    1. In the Choreo Console, go to the top navigation menu and set the visibility level as [project](../../choreo-concepts/connections.md#project-connections) or [component](../../choreo-concepts/connections.md#component-connections) as follows: 

        - **Project Connection**: Select an organization and a project in that organization. 
        - **Component Connection**: Select an organization, a project in that organization, and a component in the selected project. 

    2. In the left navigation menu, click **Dependencies**  and then **Connections**. This page lists all the existing connections.
    3. Click **+Create**. This opens the Marketplace view where you can browse and search for services or databases.
    4. Click the **Services** tab. You can search and apply filters to efficiently find a service.
    5. Click on the service you want to connect to. 
    6. Enter a name and a description for the connection.
    7. Select an **Access Mode** and **Authentication Scheme** for the connection.
    8. Click **Create**.
   
    This creates the connection and displays its details for each environment, along with an inline guide on how to use the connection in your component. 

    !!! note
        During connection creation, secret values for the lowest environment are visible, allowing you to copy them for local use if necessary. Secret values for higher environments remain hidden to ensure security
     
    <h2>Create a connection to an external service</h2>

    Follow these steps to create a connection to an external service:

    1. Follow steps 1–5 from the previous section.
    2. Expand the **Environment to Endpoint** section and verify the service endpoints assigned to the Choreo environments.
    3. Click **Create**.

      For step-by-step instructions on using a connection in your service, see [Use a Connection in Your Service](./use-a-connection-in-your-service.md).

      For step-by-step instructions on using a connection in your web application, see [Use a Connection in Your Web Application](./use-a-connection-in-your-web-application.md).


=== "Create a connection to a database"

    Prerequisites:

     - Create a Choreo-managed database. For details, see [Choreo-Managed Databases and Caches](../../manage-databases-and-caches/choreo-managed-databases-and-caches.md).
     - Add the database to the Marketplace. For details, see [Add Choreo-Managed Databases and Caches to the Marketplace](../../manage-databases-and-caches/add-choreo-managed-databases-and-caches-to-the-marketplace.md).

    Follow these steps to create a connection to a Choreo-managed database:

    1. In the Choreo Console, go to the top navigation menu and set the visibility level as [project](../../choreo-concepts/connections.md#project-connections) or [component](../../choreo-concepts/connections.md#component-connections) as follows: 

        - **Project Connection**: Select an organization and a project in that organization. 
        - **Component Connection**: Select an organization, a project in that organization, and a component in the selected project. 

    2. In the left navigation menu, click **Dependencies**  and then **Connections**. This page lists all the existing connections.
    3. Click **+Create**. This opens the Marketplace view where you can browse and search for services or databases.
    4. Click the **Databases** tab. You can search and apply filters to efficiently find a database.
    5. Click on the database you want to connect to. 
    6. To create the connection, follow these steps:

        1. Enter a name and description.
        2. Under **Environment Configuration**, select credentials for each environment.

            !!! note
                 By default, the selected database is applied to all environments. To use different databases for specific environments, select the appropriate database and provide the corresponding credentials for each environment.

        3. Click **Create**.  
    
    This creates the connection and displays the database connection details for each environment, along with an inline guide on how to use the connection in your component. 

    !!! note
        During connection creation, secret values for the lowest environment are visible, allowing you to copy them for local use if necessary. Secret values for higher environments remain hidden to ensure security
    
    For step-by-step instructions on using a database in your component, see [Use a Database Connection in Your Component](./use-a-database-connection-in-your-component.md).


# Use a Connection in Your Service

Choreo allows you to share and reuse your services, accelerating development and enhancing efficiency in building integrated applications through connections.

For step-by-step on instruction on creating a connection, see [Create a Connection](create-a-connection.md).

To learn more about Choreo Connections, see the documentation on [Connections](../../choreo-concepts/connections.md).

## Consume a service through a connection

You can consume a Choreo-deployed service within another service. Consuming connections from within Choreo services is seamless and straightforward. Follow the steps below to consume a Choreo service:

### Step 1: Add connection configurations

To integrate another service into your application, click the appropriate tab below based on your current configuration file and follow the step-by-step instructions:

=== "Component.yaml file (v1.1)"

    1. Copy and paste the snippet from the in-line developer guide into the `component.yaml` file.

        The following is a sample snippet: 

        ``` yaml

        dependencies:
            connectionReferences:
            - name: <CONNECTION_NAME>
              resourceRef: <RESOURCE_IDENTIFIER>

        ```

          | Field            | Description                                                         |
          |------------------|---------------------------------------------------------------------|
          | name             | The name given to the connection.                                   |
          | resourceRef      | A unique, readable identifier of the service being connected to.    |


    2. If you've previously added a `connectionReferences` section under `dependencies`, append this as another item under `connectionReferences`. Upon deploying the component, Choreo automatically creates a subscription if applicable and the necessary configurations to establish the connection will be injected into the Choreo-defined environment variables.
      
          The following table details the Choreo-defined environment variables:

          | Configuration Key       | Choreo-Defined Environment Variable Name                       |
          |-------------------------|----------------------------------------------------------------|
          | ServiceURL              | CHOREO_<CONNECTION_NAME\>_SERVICEURL                           |
          | ConsumerKey             | CHOREO_<CONNECTION_NAME\>_CONSUMERKEY                          |
          | ConsumerSecret          | CHOREO_<CONNECTION_NAME\>_CONSUMERSECRET                       |
          | TokenURL                | CHOREO_<CONNECTION_NAME\>_TOKENURL                             |
          | ChoreoAPIKey            | CHOREO_<CONNECTION_NAME\>CHOREOAPIKEY                          |


          If you want to use custom environment variable names instead of the Choreo-defined ones, you must define the environment configurations under the `configuration` section in the same file.
          The following is a sample snippet: 

          ``` yaml
          configuration:
            env:
              - name: HR_SERVICE_URL
                valueFrom:
                  connectionRef:
                    name: hr-connection
                    key: ServiceURL
          ```

          The following table provides details on the configuration keys associated with the connection. These keys can be referenced as `env[i].valueFrom.connectionRef.key`.

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | ServiceURL     | string     | Service URL of the Choreo service     | false         | false        |
          | ConsumerKey    | string     | Consumer key of the Choreo service    | false         | false        |
          | ConsumerSecret | string     | Consumer secret of the Choreo service | false         | true         |
          | TokenURL       | string     | Token URL of the STS                  | false         | false        |
          | ChoreoAPIKey   | string     | API key of the Choreo service         | false         | true         |

          For more details, see the instructions under the **component.yaml file (v1.1)** tab.

    ### Step 2: Read configurations within the application

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const serviceURL = process.env.CHOREO_<CONNECTION_NAME>_SERVICEURL;
    ```

=== "Component.yaml file (v1.0)"

    !!! note
        This `component.yaml v1.0` is a legacy configuration format. For new projects, we recommend using the latest version (v1.1) of `component.yaml` for improved usability and features.
  
    1. Copy and paste the snippet from the in-line developer guide into the `component.yaml` file.
      
        The following is a sample snippet:

        ``` yaml

        dependencies:
            serviceReferences:
            - name: <SERVICE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: ServiceURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerSecret
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: TokenURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ChoreoAPIKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>

        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the service you are connecting to.              |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added a service reference section under `dependencies`, append this as another item under `serviceReferences`. 

          Upon deploying the component, Choreo automatically creates a subscription if applicable and populates the specified environment variables with actual values.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | ServiceURL     | string     | Service URL of the Choreo service     | false         | false        |
          | ConsumerKey    | string     | Consumer key of the Choreo service    | false         | false        |
          | ConsumerSecret | string     | Consumer secret of the Choreo service | false         | true         |
          | TokenURL       | string     | Token URL of the STS                  | false         | false        |
          | ChoreoAPIKey   | string     | API key of the Choreo service         | false         | true         |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const serviceURL = process.env.SVC_URL;
    ```

=== "Component-config.yaml file"

    !!! note
        This `component-config.yaml` is a legacy configuration format. For new projects, we recommend using the latest version (v1.1) of `component.yaml` for improved usability and features.

    1. Copy and paste the snippet from the in-line developer guide into the `component-config` file under the `spec` section.

        The following is a sample snippet:

        ``` yaml

        outbound:
            serviceReferences:
            - name: <SERVICE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: ServiceURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerSecret
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: TokenURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ChoreoAPIKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>

        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the service you are connecting to.              |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added an outbound service reference, append this as another item under `serviceReferences`. 

          Upon deploying the component, Choreo automatically creates a subscription if applicable and populates the specified environment variables with actual values.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | ServiceURL     | string     | Service URL of the Choreo service     | false         | false        |
          | ConsumerKey    | string     | Consumer key of the Choreo service    | false         | false        |
          | ConsumerSecret | string     | Consumer secret of the Choreo service | false         | true         |
          | TokenURL       | string     | Token URL of the STS                  | false         | false        |
          | ChoreoAPIKey   | string     | API key of the Choreo service         | false         | true         |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const serviceURL = process.env.SVC_URL;
    ```

If you're using the API key security scheme for the connection, skip Step 3 and follow the instructions in [Step 4: API key security scheme](#step-4-invoke-the-service) tab.

### Step 3: Acquire an OAuth 2.0 access token

To consume a Choreo service with the visibility level set to organization or public and secured by the OAuth 2.0 security scheme, you must obtain an OAuth 2.0 token from the token endpoint. Subsequently, you can use the token to invoke the service.

- For languages with OAuth 2.0-aware HTTP clients, you must pass the OAuth 2.0-related configurations such as client id, client secret and so on, obtained when creating the connection to your HTTP client configuration. The HTTP client autonomously manages token retrieval and refreshing.

- For languages without OAuth 2.0-aware HTTP clients, you must manually initiate a call to the token endpoint. This includes fetching the token and managing token expiration and refresh directly within your application code. The following is a sample curl command to obtain a token:


    ```bash
    CONSUMER_KEY="your_consumer_key"
    CONSUMER_SECRET="your_consumer_secret"
    TOKEN_URL="your_token_url"

    # Encode client credentials as Base64
    CLIENT_CREDENTIALS=$(echo -n "$CLIENT_ID:$CLIENT_SECRET" | base64)

    curl -X POST $TOKEN_URL \
      -H "Content-Type: application/x-www-form-urlencoded" \
      -H "Authorization: Basic $CLIENT_CREDENTIALS" \
      --data-urlencode "grant_type=client_credentials"

    ```

### Step 4: Invoke the service

Click the tab that matches the security scheme of your service and follow the instructions below:

=== "API key security scheme"

     To invoke the API, use the `choreo-api-key` header with the API key value retrieved from the corresponding environment variable as described in [step 2](#step-2-read-configurations-within-the-application).

     The following is a sample code snippet in NodeJS:

     ``` java
       const response = await axios.get(serviceURL/{RESOURCE_PATH}, {
           headers: {
             'Choreo-API-Key': `${choreoApiKey}`
           }
       });
     ```

=== "OAuth 2.0 security scheme"

     To invoke the service, use the following instructions based on your programming language:

      - For languages with OAuth 2.0-aware HTTP clients, use the service URL resolved in [Step 2](#step-2-read-configurations-within-the-application). The OAuth-aware client manages authentication automatically. For sample requests and responses, see the API definition provided via the Choreo marketplace for the service.

      - For languages without OAuth 2.0-aware HTTP clients, use the token obtained in [step 3](#step-3-acquire-an-oauth-20-access-token) to make calls to the dependent service. Subsequently, add the obtained token to the HTTP authorization header with the bearer prefix. As the service URL, use the URL resolved in [step 2](#step-2-read-configurations-within-the-application). For sample requests and responses, see the API definition of the service provided via the Choreo marketplace.

       The following is a sample code snippet in NodeJS:

       ``` java
       const response = await axios.get(serviceURL/{RESOURCE_PATH}, {
           headers: {
             'Authorization': `Bearer ${accessToken}`
             'Choreo-API-Key': `${choreoApiKey}`
           }
       });
       ```

    !!! note
        If you want to consume a Choreo service at the project visibility level, you don't need to obtain a token. You can directly invoke the service using the resolved URL.


# Use a Connection in Your Web Application

Choreo simplifies the process of integrating services into your web application. The approach to connect to a service can vary based on your web application. 

To connect to a selected service, follow the step-by-step instructions given below depending on the authentication mechanism used in your web application.

=== "Managed authentication"
    
    Choreo-managed authentication allows you to seamlessly handle authentication for your web application. You can configure your web application to work with the built-in identity provider of Choreo or any external identity provider that supports OIDC/OAuth2.0

    !!! note 
         Choreo's managed authentication is currently available only for web applications created with **React**, **Angular**, or **Vue.js** buildpacks.

    Follow the steps below to use an existing connection within your web application: 

    <h2> Step 1: Add the connection configuration</h2>

    To integrate a service into your application, you must first add the connection configuration as follows: 

    1. For single page applications (SPAs), you must add the connection configuration as a file mount. You can mount a file via the **Configurations** pane on the **Deploy** page. You must mount a file (for example, `config.js`) and add the configuration provided in the inline developer documentation into it. 

        The following is a sample configuration:

        ``` yaml
             window.configs = {
                 apiUrl: '<SERVICE_URL>',        
             };

        ```

    2.  To ensure accessibility of the `config.js` file via JavaScript at runtime, add a script tag as follows in the `index.html` file to reference the `config.js` file:

        ``` html
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="utf-8" />
            <title>My React App</title>
        </head>
        <body>
            <div id="root"></div>
            <script src="/public/config.js"></script>
        </body>
        </html>
        ``` 

        !!! note
             If you use an external IdP, you must add the IdP's configuration to the same file.
    
             For more information on working with IdPs, see [Configure Asgardeo as an External Identity Provider](https://wso2.com/choreo/docs/administer/configure-an-external-idp/configure-asgardeo-as-an-external-idp/).


    <h2> Step 2: Read the configuration</h2>

    Once you add the connection configuration, you can proceed to read the configuration from your application. The steps to read depend on the programming language you use.

    The following is a sample code snippet in NodeJS:

    ``` java
         const serviceURL = window?.configs?.apiUrl ? window.configs.apiUrl : "/";
    ```

    <h2> Step 3: Invoke the service</h2>

    If you use Choreo-managed authentication, Choreo handles the security handshaking for the application during deployment. The connected service will be accessible under the same domain as your application. Therefore, you can call the configured path directly using your preferred HTTP client.

    The following is a sample code snippet in NodeJS:

    ``` java
         const response = await axios.get(serviceURL/{RESOURCE_PATH});
    ```

    !!! note
         If you are using an external IdP provider instead of Choreo-managed authentication, you must obtain an access token from your IdP and add it to the HTTP authorization header with the bearer prefix.


=== "Custom authentication or no authentication"

    If you are not using Choreo-managed authentication or your web application lacks authentication, follow the steps below to connect to a service from your web application:

    <h2> Step 1: Add the connection configuration</h2>

    1. For single-page applications (SPAs), you must add the connection configuration as a file mount. You can mount a file via the **Configurations** pane on the **Deploy** page. You must mount a file (for example, `config.js`) and add the configuration provided in the inline developer documentation into it.
 
        The following is a sample configuration:

        ``` yaml
             window.configs = {
                 apiUrl: '<SERVICE_URL>',
                 consumerKey: '<CONSUMER_KEY>',
                 consumerSecret: '<CONSUMER_SECRET>',
                 tokenUrl: '<TOKEN_URL>',
             };
        ```

    2.  To ensure accessibility of the `config.js` file via JavaScript at runtime, add a script tag as follows in the `index.html` file to reference the `config.js` file:

        ``` html
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="utf-8" />
            <title>My React App</title>
        </head>
        <body>
            <div id="root"></div>
            <script src="/public/config.js"></script>
        </body>
        </html>
        ``` 

    For other types of web applications, you must add the respective configuration into your application.

    <h2> Step 2: Read the configuration</h2>

    Once you have added the connection configuration, you can proceed to read the configuration from your application. The steps to read depend on the programming language you use.

    The following is a sample code snippet in NodeJS:

    ``` java
         const serviceURL = window?.configs?.apiUrl ? window.configs.apiUrl : "/";
    ```

    <h2> Step 3: Acquire an OAuth 2.0 access token</h2>

    - For languages with OAuth 2.0-aware HTTP clients, you must pass the OAuth 2.0-related configurations such as client id, client secret and so on, obtained when creating the connection to your HTTP client configuration. The HTTP client autonomously manages token retrieval and refreshing.
  
    - For languages without OAuth 2.0-aware HTTP clients, you must manually initiate a call to the token endpoint. This includes fetching the token and managing token expiration and refresh directly within your application code. The following is a sample curl command to obtain a token:


        ```bash
        CONSUMER_KEY="your_consumer_key"
        CONSUMER_SECRET="your_consumer_secret"
        TOKEN_URL="your_token_url"

        # Encode client credentials as Base64
        CLIENT_CREDENTIALS=$(echo -n "$CLIENT_ID:$CLIENT_SECRET" | base64)

        curl -X POST $TOKEN_URL \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -H "Authorization: Basic $CLIENT_CREDENTIALS" \
        --data-urlencode "grant_type=client_credentials"

        ```

    <h2> Step 4: Invoke the service</h2>

    You can invoke the service as follows:

    - For languages with OAuth 2.0-aware HTTP clients, you can invoke the service in a straightforward manner. The HTTP client seamlessly manages OAuth 2.0 authentication without requiring additional intervention.

        As the service URL you can use the URL that you resolved in step 2 above. For sample requests and responses, see the API definition provided via the Choreo marketplace for the service.

    - For languages without OAuth 2.0-aware HTTP clients, you can use the token obtained in step 3 above to make calls to the dependent service. Subsequently, add the obtained token to the HTTP authorization header with the bearer prefix.

        As the service URL you can use the URL that you resolved in step 2 above. For sample requests and responses, see the API definition of the service provided via the Choreo marketplace.

        The following is a sample code snippet in NodeJS:

        ```java 
            const response = await axios.get(serviceURL/{RESOURCE_PATH}, {
                headers: {
                'Authorization': `Bearer ${accessToken}`
                }
            })
        ```


# Use a Database Connection in Your Component

Choreo allows you to share and reuse Choreo-managed databases, accelerating development and enhancing efficiency in building integrated applications through connections.

For step-by-step instructions on creating a database connection, see [Create a Connection](create-a-connection.md).

To learn more about Choreo Connections, see the documentation on [Connections](../../choreo-concepts/connections.md).

## Consume a database through a connection

To consume a Choreo-managed database via a connection, follow these steps:

### Step 1: Add connection configurations

To integrate a database into your application, click the appropriate tab below based on your current configuration file and follow the step-by-step instructions:

=== "Component.yaml file (v1.1)"

    1. Copy and paste the snippet from the  developer guide into the `component.yaml` file.

        The following is a sample snippet:

        ``` yaml

        dependencies:
            connectionReferences:
            - name: <CONNECTION_NAME>
              resourceRef: <RESOURCE_IDENTIFIER>

        ```

          | Field            | Description                                                         |
          |------------------|---------------------------------------------------------------------|
          | name             | The name given to the connection.                                   |
          | resourceRef      | A unique, readable identifier of the database being connected to.    |


    2. If you've previously added a `connectionReferences` section under `dependencies`, append this as another item under `connectionReferences`. Upon deploying the component, the necessary configurations to establish the connection will be injected into Choreo-defined environment variables.

          The following table details the Choreo-defined environment variables:

          | Configuration Key       | Choreo-Defined Environment Variable Name                       |
          |-------------------------|----------------------------------------------------------------|
          | HostName                | CHOREO_<CONNECTION_NAME\>_HOSTNAME                             |
          | Port                    | CHOREO_<CONNECTION_NAME\>_PORT                                 |
          | Username                | CHOREO_<CONNECTION_NAME\>_USERNAME                             |
          | Password                | CHOREO_<CONNECTION_NAME\>_PASSWORD                             |
          | DatabaseName            | CHOREO_<CONNECTION_NAME\>DATABASENAME                          |


          If you'd like to use custom environment variable names instead of the Choreo-defined ones, add the dependency as a service reference under `dependencies` in the same file. For more details, refer to the instructions under the `component.yaml file (v1.0)` tab.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | HostName       | string     | Hostname of the database server       | false         | false        |
          | Port           | string     | Port of the database server           | false         | false        |
          | Username | string           | Username of the database server       | false         | false        |
          | Password       | string     | Password of the database server       | false         | true         |
          | DatabaseName   | string     | Name of the database                  | false         | false        |
    ### Step 2: Read configurations within the application

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const hostName = process.env.CHOREO_<CONNECTION_NAME>_HOSTNAME;
    ```

=== "Component.yaml file (v1.0)"

    !!! note
        The `component.yaml v1.0` file is considered legacy. For new components, we recommend using the latest version, `component.yaml v1.1`, which offers enhanced usability and features.

    1. Copy and paste the snippet from the  developer guide into the `component.yaml` file.

        The following is a sample snippet:

        ``` yaml

        dependencies:
            serviceReferences:
            - name: database:<DATABASE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: HostName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Port
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Username
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Password
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: DatabaseName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>


        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the database you are connecting to.             |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added a service reference section under `dependencies`, append this as another item under `serviceReferences`.

          Upon deploying the component, Choreo automatically populates the specified environment variables with actual values.

          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | HostName       | string     | Hostname of the database server       | false         | false        |
          | Port           | string     | Port of the database server           | false         | false        |
          | Username | string           | Username of the database server       | false         | false        |
          | Password       | string     | Password of the database server       | false         | true         |
          | DatabaseName   | string     | Name of the database                  | false         | false        |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const hostName = process.env.HOSTNAME;
    ```

=== "Component-config.yaml file"

    !!! note
        The `component-config.yaml` file is considered legacy. For new components, we recommend using the latest version, `component.yaml v1.1`, which offers enhanced usability and features.

    1. Copy and paste the snippet from the  developer guide into the `component-config` file under the `spec` section.

        The following is a sample snippet:

        ``` yaml

        outbound:
            serviceReferences:
            - name: database:<DATABASE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: HostName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Port
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Username
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Password
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: DatabaseName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>

        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the database you are connecting to.              |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added an outbound service reference, append this as another item under `serviceReferences`.

          Upon deploying the component, Choreo automatically populates the specified environment variables with actual values.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | HostName       | string     | Hostname of the database server       | false         | false        |
          | Port           | string     | Port of the database server           | false         | false        |
          | Username | string           | Username of the database server       | false         | false        |
          | Password       | string     | Password of the database server       | false         | true         |
          | DatabaseName   | string     | Name of the database                  | false         | false        |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const hostName = process.env.HOSTNAME;
    ```

### Step 3: Initiate a database connection

To initiate a connection to the database, follow these steps:

In this example, you will connect to a MySQL database.

#### Step 3.1: Install the required packages

For the MySQL database, install the `mysql2` package using npm:

```bash
// Install the mysql2 package
npm install mysql2

```

#### Step 3.2: Import required packages

```java

const client = require('mysql2')

```

#### Step 3.3: Establish a connection

To establish the connection, use the environment variables for `hostName`, `username`, `password`, `databaseName`, and `port` as follows:

```java

var connection = client.createConnection({
      host: hostName,
      user: username,
      password: password,
      database: databaseName,
      port: port
});

connection.connect((err) => {
      if (err) {
          return;
      }
      // Connection is successful
});

```

By following these steps, your component can interact with the Choreo-managed database seamlessly.




# Integrate Unit Tests into the Build Pipeline

Choreo allows you to integrate unit tests into the build pipeline, enabling code validation before deployment. This ensures early testing of code changes, reducing the risk of defects in production.

!!! note
        Currently, Choreo supports unit tests only for the `WSO2 MI` buildpack.

## How it works

### Step 1: Write tests

You can create unit tests in your source code using standard testing libraries. For step-by-step instructions on creating unit tests for WSO2 Micro Integrator projects, see [Creating a Unit Test Suite](https://mi.docs.wso2.com/en/latest/develop/creating-unit-test-suite/).

### Step 2: Enable unit tests

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click the component for which you want to enable unit tests.
3. In the left navigation menu, click **Build**.
4. On the **Build** page, click to edit **Build Configurations**.
5. Turn on the **Unit Test** toggle.
6. Click **Save**.

### Step 3: Trigger a new build

- On the **Build** page, click **Build Latest**.

This starts a new build with unit tests enabled. You can monitor its progress in the **Build Details** pane.

## View failed unit tests

If a unit test fails during the build, you can view its detailed logs for troubleshooting. Click **View Details** corresponding to the failed build, then expand the failed unit test step to view the logs.

## Explore a sample

To see unit tests in action within the build pipeline, try out the [WSO2 MI helloworld](https://github.com/wso2/choreo-samples/tree/main/hello-world-mi) sample. 


# Manage Component Source Configurations

In Choreo, you can configure service endpoints and connections via the `component.yaml` source configuration file. This file ensures that the configurations required to initialize endpoints and connections are defined, as they cannot be inferred from the source code. This guide provides an overview of how to configure and manage these settings effectively.

The source configuration file must be committed to your repository within the `.choreo` directory at the root of the project directory. This ensures the ability to version the configuration files alongside repository commits, enabling better tracking and management of configurations.

!!! note
    -  The `component-config.yaml` and `endpoints.yaml` files will eventually be deprecated and replaced by the `component.yaml` file. 
        - For details on how to seamlessly update to the latest `component.yaml` file`, see [Update to the latest source configuration file](#update-to-the-latest-source-configuration-file).
    - Choreo prioritizes configuration files in the following order: `component.yaml` takes the highest precedence, followed by `component-config.yaml`, and then `endpoints.yaml`.

## Overview of the `component.yaml` file 

**File location**:

```bash
<build-context-path>/.choreo/component.yaml
```

!!! note
    - For components built using **Buildpacks**, replace `build-context-path` with the `<project-directory>`. 
    For example, `<project-directory>/.choreo/component.yaml`.
    - For components built using **Docker**, replace `build-context-path` with the `<docker-context-path>`. 
    For example, `<docker-context-path>/.choreo/component.yaml`.

**Sample `component.yaml` file content**:

Click the respective tab to view the structure for your current configuration file version:

=== "Version 1.1"

    ``` yaml
    # +required The configuration file schema version
    schemaVersion: 1.1

    # +optional Incoming connection details for the component
    endpoints:
      # +required Unique name for the endpoint.
      # This name will be used when generating the managed API
      - name: greeter-sample
        # +optional Display name for the endpoint.
        displayName: Go Greeter Sample
        # +required Service section has the user service endpoint details
        service:
          # +optional Context (base path) of the API that gets exposed via the endpoint.
          basePath: /greeting-service
          # +required Numeric port value that gets exposed via the endpoint
          port: 9090
        # +required Type of traffic that the endpoint is accepting.
        # Allowed values: REST, GraphQL, WS, GRPC, TCP, UDP.
        type: REST
        # +optional Network level visibilities of the endpoint.
        # Accepted values: Project|Organization|Public(Default).
        networkVisibilities: 
          - Public
          - Organization
        # +optional Path to the schema definition file. Defaults to wild card route if not provided
        # This is only applicable to REST or WS endpoint types.
        # The path should be relative to the docker context.
        schemaFilePath: openapi.yaml
      
      # +optional Outgoing connection details for the component.
      dependencies:
        # +optional Defines the connection references from the Internal Marketplace.
        connectionReferences:
          # +required Name of the connection.
          - name: hr-connection
            # +required service identifer of the dependent component.
            resourceRef: service:/HRProject/UserComponent/v1/ad088/PUBLIC
      # +optional Defines runtime configurations
      configurations:
        # +optional List of environment variables to be injected into the component.
        env:
          # +required Name of the environment variable
          - name: HR_SERVICE_URL
            # +required value source
            # Allowed value sources: connectionRef
            valueFrom:
              # +required Choreo connection value source
              connectionRef:
                # +required Choreo connection name to refer the value from
                name: hr-connection
                # +required Choreo connection configuration key to refer the value from
                key: ServiceURL
    ```

    The descriptor-based approach of the `component.yaml` file simplifies and streamlines endpoint and connection configuration management. The use of versioned schemas ensures backward compatibility, providing a seamless transition with future updates.

    You can define the following root-level configurations via the `component.yaml` file:

    | Configuration        | Required     | Description                                                              |
    |----------------------|--------------|--------------------------------------------------------------------------|
    | **schemaVersion**    | Required     | The version of the `component.yaml` file. Defaults to the latest version.|
    | **endpoints**        | Optional     | The list of endpoint configurations.                                     |
    | **dependencies**     | Optional     | The list of dependency configurations.                                   |
    | **configurations**    | Optional     | The runtime configuration definitions.                                   |

    ### Endpoint configurations
    In the `endpoints` section of the `component.yaml` file, you can define multiple service endpoint configurations. Each endpoint must have a unique name and the required fields specified in the schema overview.

    !!! tip "Why have a unique name?"
          When you define multiple endpoints, the `endpoint.name` is appended to the Choreo-generated URL. A unique name ensures the endpoint is easily recognizable and readable within the URL.
          
    | Configuration        | Required     | Description                                                                                             |
    |----------------------|--------------|---------------------------------------------------------------------------------------------------------|
    | **name**             | Required     | A unique identifier for the endpoint within the service component. Avoid using excessively long names.  |
    | **displayName**      | Optional     | A display name for the endpoint.                                                                        |
    | **service**          | Required     | Service details for the endpoint.                                                                       |
    | **.basePath**        | Required     | The base path of the API exposed via this endpoint.                                                     |
    | **.port**            | Required     | The numeric port value exposed via this endpoint.                                                       |
    | **type**             | Required     | The type of traffic the endpoint accepts. For example, `REST`, `GraphQL`, `WS`, `gRPC`, `UDP`, or `TCP`.|
    | **networkVisibilities** | Required | The network-level visibility of the endpoint. For example, project, organization, or public.             |
    | **schemaFilePath** | Required | The file path to the swagger definition  or AsyncAPI 2.0 specification file. Defaults to the wildcard route if not specified. This field should be a relative path to the project path when using **Java**, **Python**, **NodeJS**, **Go**, **PHP**, **Ruby**, or **WSO2 MI** buildpacks. For REST or WebSocket endpoint types, when using the **Ballerina** or **Dockerfile** buildpack, the path should be relative to the component root or Docker context. |

    ### Dependency configurations

    In the `dependencies` section of the `component.yaml` file, you can define multiple connection configurations under `dependencies.connectionReferences`. You can use the connection reference generated in the inline developer guide when creating a connection. For instructions on copying [connection configurations](https://wso2.com/choreo/docs/develop-components/sharing-and-reusing/use-a-connection-in-your-service/), see the inline developer guide displayed during connection creation.

    You must include the following configurations in the `dependencies.connectionReferences` schema:

    | Configuration        | Required     | Description                                                                      |
    |----------------------|--------------|----------------------------------------------------------------------------------|
    | **name**             | Required     | The name given to the connection.                                                |
    | **resourceRef**      | Required     | A unique, human-readable identifier for the service you are connecting.          |


    !!! note
        Choreo automatically generates connection configurations when you create a connection. The properties such as **name** and **resourceRef** are automatically generated. The configurations required to establish the connection will be injected into Choreo-defined environment variables.

        To use custom environment variable names instead of Choreo's default ones, add the dependency as a `serviceReference` in your `component.yaml v1.1` file. You can copy the `serviceReference` section from the `component.yaml v1.0` tab and paste it under `dependencies` in your `component.yaml v1.1` file, which maintains backward compatibility with the v1.0 format.

    ### Runtime configurations
    In the `configurations` section of the `component.yaml` file, you can define runtime configurations for the component. These configurations currently support environment variable injection related to dependencies.
    
    | Configuration                 | Required     | Description                                                                       |
    |-------------------------------|--------------|-----------------------------------------------------------------------------------|
    | **env**                       | Optional     | An array of env variable configurations.                                          |
    | **name**                      | Required     | A unique name for the environment variable, starting with a letter or an underscore, and containing only letters, numbers, or underscores. |
    | **valueFrom**                 | Required     | The source of the environment variable value.                                     |
    | **connectionRef**             | Required     | Connection reference value source definition.                                     |
    | **name**                      | Required     | The name of the Choreo connection to reference the value from.                    |
    | **key**                       | Required     | The Choreo connection configuration key to reference the value from. For details on available keys, see [connection configurations](https://wso2.com/choreo/docs/develop-components/sharing-and-reusing/use-a-connection-in-your-service/) or the inline developer guide. |

    !!! note
        Runtime configurations are supported starting from `component.yaml v1.1`.

        When an environment variable value is specified using `connectionRef`, the connection's environment variable is renamed to the environment variable name defined in the `configurations` section. For example, in the sample `component.yaml` file given above, the `CHOREO_HR_CONNECTION_SERVICEURL` variable in the `hr-connection` is renamed to `HR_SERVICE_URL`.

=== "Version 1.0"

    ``` yaml
    # +required The configuration file schema version
    schemaVersion: 1.0

    # +optional Incoming connection details for the component
    endpoints:
      # +required Unique name for the endpoint.
      # This name will be used when generating the managed API
      - name: greeter-sample
        # +optional Display name for the endpoint.
        displayName: Go Greeter Sample
        # +required Service section has the user service endpoint details
        service:
          # +optional Context (base path) of the API that gets exposed via the endpoint.
          basePath: /greeting-service
          # +required Numeric port value that gets exposed via the endpoint
          port: 9090
        # +required Type of traffic that the endpoint is accepting.
        # Allowed values: REST, GraphQL, WS, GRPC, TCP, UDP.
        type: REST
        # +optional Network level visibilities of the endpoint.
        # Accepted values: Project|Organization|Public(Default).
        networkVisibilities: 
          - Public
          - Organization
        # +optional Path to the schema definition file. Defaults to wild card route if not provided
        # This is only applicable to REST or WS endpoint types.
        # The path should be relative to the docker context.
        schemaFilePath: openapi.yaml
      
    # +optional Outgoing connection details for the component.
    dependencies:
      # +optional Defines the service references from the Internal Marketplace.
      serviceReferences:
        # +required Name of the service reference.
        - name: choreo:///apifirst/HRProject/UserComponent/ad088/v1/PUBLIC
          # +required Name of the connection instance.
          connectionConfig: 19d2648b-d29c-4452-afdd-1b9311e81412
          # +required Environment variables injected into the component for connection configuration.
          env:
            # +required Key name of the connection configuration.
            - from: ServiceURL
              # +required Environment variable injected into the container.
              to: SERVICE_URL
    ```

    The descriptor-based approach of the `component.yaml` file simplifies and streamlines endpoint and connection configuration management. The use of versioned schemas ensures backward compatibility, providing a seamless transition with future updates.

    You can define the following root-level configurations via the `component.yaml` file:

    | Configuration        | Required     | Description                                                              |
    |----------------------|--------------|--------------------------------------------------------------------------|
    | **schemaVersion**    | Required     | The version of the `component.yaml` file. Defaults to the latest version.|
    | **endpoints**        | Optional     | The list of endpoint configurations.                                     |
    | **dependencies**     | Optional     | The list of dependency configurations.                                   |

    <h3> Endpoint configurations </h3>
    In the `endpoints` section of the `component.yaml` file, you can define multiple service endpoint configurations. Each endpoint must have a unique name and the required fields specified in the schema overview.

    !!! tip "Why have a unique name?"
          When you define multiple endpoints, the `endpoint.name` is appended to the Choreo-generated URL. A unique name ensures the endpoint is easily recognizable and readable within the URL.
          
    | Configuration           | Required     | Description                                                                                             |
    |-------------------------|--------------|---------------------------------------------------------------------------------------------------------|
    | **name**                | Required     | A unique identifier for the endpoint within the service component. Avoid using excessively long names.  |
    | **displayName**         | Optional     | A display name for the endpoint.                                                                        |
    | **service**             | Required     | Service details for the endpoint.                                                                       |
    | **.basePath**           | Required     | The base path of the API exposed via this endpoint.                                                     |
    | **.port**               | Required     | The numeric port value exposed via this endpoint.                                                       |
    | **type**                | Required     | The type of traffic the endpoint accepts. For example, `REST`, `GraphQL`, `gRPC`, `WS`, `UDP`, or `TCP`.|
    | **networkVisibilities** | Required     | The network-level visibility of the endpoint. For example, project, organization, or public.            |
    | **schemaFilePath**      | Required     | The file path to the swagger definition or AsyncAPI 2.0 specification file. Defaults to the wildcard route if not specified. This field should be a relative path to the project path when using **Java**, **Python**, **NodeJS**, **Go**, **PHP**, **Ruby**, or **WSO2 MI** buildpacks. For REST or WebSocket endpoint types, when using the **Ballerina** or **Dockerfile** buildpack, the path should be relative to the component root or Docker context. |

    <h3> Dependency configurations </h3>

    In the `dependencies` section of the `component.yaml` file, you can define multiple service connection configurations under `dependencies.serviceReferences`. You can use the service references generated in the inline developer guide when creating a service connection. For instructions on copying [connection configurations](https://wso2.com/choreo/docs/develop-components/sharing-and-reusing/use-a-connection-in-your-service/), see the inline developer guide displayed during connection creation.

    You must include the following configurations in the `dependencies.serviceReferences` schema:

    | Configuration        | Required     | Description                                                                      |
    |----------------------|--------------|----------------------------------------------------------------------------------|
    | **name**             | Required     | A unique name for the service reference.                                         |
    | **connectionConfig** | Required     | A unique name for the connection instance.                                       |
    | **env**              | Required     | The list of environment variable mappings to inject into the container.          |
    | **.from**            | Required     | The key name of the connection configuration.                                    |
    | **.to**              | Required     | The environment variable to inject into the container.                           |

    !!! note
        Choreo automatically generates connection configurations when you create a connection. The properties such as **name**, **connectionConfig**, and **env.from** are automatically generated. However, you must manually set the **env.to** value.

## Overview of the `component-config.yaml` file 

**File location**:

```bash
<build-context-path>/.choreo/component-config.yaml
```

**Sample `component-config.yaml` file content**:

```yaml
apiVersion: core.choreo.dev/v1beta1
kind: ComponentConfig
spec:
  # +optional Incoming connection details for the component (AKA endpoints).
  inbound:
    # +required Unique name for the endpoint.
    # This name will be used when generating the managed API
    - name: Greeting Service
      # +required Numeric port value that gets exposed via the endpoint
      port: 9090
      # +required Type of traffic that the endpoint is accepting.
      # Allowed values: REST, GraphQL, GRPC, TCP, UDP, WS.
      type: REST
      # +optional Network level visibility of the endpoint. Defaults to Public
      # Accepted values: Project|Organization|Public.
      networkVisibility: Public
      # +optional Context (base path) of the API that gets exposed via the endpoint.
      # This is mandatory if the endpoint type is set to REST, GraphQL or WS.
      context: /greeting
      # +optional The path to the schema definition file. Defaults to wildcard route if not specified.
      # This is only applicable to REST and WS endpoint types.
      # The path should be relative to the Docker context.
      schemaFilePath: greeting_openapi.yaml
  # +optional Outgoing connection details for the component.
  outbound:
    # +optional Defines the service references from the Internal Marketplace.
    serviceReferences:
      # +required Name of the service reference.
      - name: choreo:///apifirst/mttm/mmvhxd/ad088/v1.0/PUBLIC
        # +required Name of the connection instance.
        connectionConfig: 19d2648b-d29c-4452-afdd-1b9311e81412
        # +required Environment variables injected to the component for connection configuration.
        env:
          # +required Key name of the connection configuration.
          - from: ServiceURL
            # +required Environment variable injected to the container.
            to: SERVICE_URL
```

The `component-config.yaml` file complements and enhances the existing endpoint configuration process. It allows you to define how the endpoints (inbound connections) in your service are exposed and how your service connects to external services or components (outbound connections).

You can define the following root-level configurations via the `component-config.yaml` file:

| Configuration        | Required     | Description                                                                           |
|----------------------|--------------|---------------------------------------------------------------------------------------|
| **apiVersion**       | Required     | The version of the `component-config.yaml` file defaults to `core.choreo.dev/v1beta1`.|
| **kind**             | Required     | The resource type of the file defaults to `ComponentConfig`.                          |
| **spec.inbound**     | Optional     | The list of inbound connection configurations.                                        |
| **spec.outbound**    | Optional     | The list of outbound connection configurations.                                       |

#### Inbound connection configurations (`spec.inbound`)

In the `spec.inbound` configuration section, you can specify endpoints to set up inbound connections. To specify endpoints, you can follow the existing endpoints schema structure. For details on the endpoints schema structure, see the [endpoints schema documentation](#overview-of-the-endpointsyaml-file).

#### Outbound connection configurations (`spec.outbound`)

In the `spec.outbound` section, you can define `serviceReferences`. To define `serviceReferences`, you can use the service references generated in the Internal Marketplace when creating a service connection. To copy the [outbound connection configurations](../sharing-and-reusing/use-a-connection-in-your-service/#use-a-connection-in-your-service), see the inline developer guide displayed when you create a connection.

You must include the following configurations in the `serviceReferences` schema:

| Configuration        | Required     | Description                                                                      |
|----------------------|--------------|----------------------------------------------------------------------------------|
| **name**             | Required     | A unique name for the service reference.                                         |
| **connectionConfig** | Required     | A unique name for the connection instance.                                       |
| **env**              | Optional     | The list of environment variable mappings to inject into the container.          |
| **env.from**         | Required     | The key name of the connection configuration.                                    |
| **env.to**           | Required     | The environment variable to inject into the container.                           |

## Overview of the `endpoints.yaml` file

**File location**:

```bash
<build-context-path>/.choreo/endpoints.yaml
```

**Sample `endpoints.yaml` file content**:

```yaml
# +required Version of the endpoint configuration YAML
version: 0.1

# +required List of endpoints to create
endpoints:
  # +required Unique name for the endpoint.
  # This name will be used when generating the managed API
- name: Greeting Service
  # +required Numeric port value that gets exposed via this endpoint
  port: 9090
  # +required Type of the traffic this endpoint is accepting.
  # Allowed values: REST, GraphQL, GRPC, UDP, TCP, WS.
  type: REST
  # +optional Network level visibility of this endpoint. Defaults to Public
  # Accepted values: Project|Organization|Public.
  networkVisibility: Project
  # +optional Context (base path) of the API that is exposed via this endpoint.
  # This is mandatory if the endpoint type is set to REST, GraphQL or WS.
  context: /greeting
  # +optional Path to the schema definition file. Defaults to wild card route if not provided
  # This is only applicable to REST and WS endpoint types.
  # The path should be relative to the docker context.
  schemaFilePath: greeting_openapi.yaml
```

The `endpoints.yaml` configuration file allows you to define configurations for multiple endpoints necessary for Choreo service components. This schema is essential to identify the context, port binding, network exposure level, and other attributes required to generate a Choreo endpoint.

You can define the following root-level configurations via the `endpoints.yaml` file:

| Configuration        | Required     | Description                                                                       |
|----------------------|--------------|-----------------------------------------------------------------------------------|
| **version**          | Required     | The version of the `endpoints.yaml` file.                                         |
| **name**             | Required     | A unique name for the endpoint, which Choreo will use to generate the managed API.|
| **port**             | Required     | The numeric port value that gets exposed via this endpoint.                       |
| **type**             | Required     | The type of traffic this endpoint accepts, such as `REST`, `GraphQL`, `gRPC`, `WS`, `UDP`, or `TCP`. Currently, the MI preset supports only the `REST` type.                                         |
| **networkVisibility**| Required     | The network level visibility of this endpoint, which defaults to `Public` if not specified. Accepted values are `Project`, `Organization`, or `Public`.|
| **context**          | Required     | The context (base path) of the API that Choreo exposes via this endpoint.         |
| **schemaFilePath**   | Required     | The swagger definition file path. Defaults to the wildcard route if not provided. This field should be a relative path to the project path when using the **Java**, **Python**, **NodeJS**, **Go**, **PHP**, **Ruby**, and **WSO2 MI** buildpacks. For REST endpoint types, when using the **Ballerina** or **Dockerfile** buildpack, this field should be a relative path to the component root or Docker context.|

## Update to the latest source configuration file

With the upcoming deprecation of the `component-config.yaml` file and the `endpoints.yaml` file, Choreo provides a seamless process to move to the latest `component.yaml`  version of the `component.yaml` file. Follow these steps to transition seamlessly:

### Step 1: Identify whether your current source configuration file is outdated

You can determine whether you’re using an outdated configuration file in the following ways:

- **During a build:**
     - On the **Build** page, after triggering a build, a warning will appear if your source configuration file is outdated. Click **View Details** in the **Initialization** -> **Source Config Validation** step. You will see an information banner with an option to update the file.

- **In existing deployments:**
     - If an existing deployment uses a build with an outdated source configuration file, you will see a warning icon on the build card of the relevant environment card.


### Step 2: Generate the latest `component.yaml` file

- In either of the scenarios above, click **Update** to initiate the process of generating the latest `component.yaml` file. The updated file will retain your existing configurations to ensure a smooth update process.


### Step 3: Add the generated configuration file to your repository

1. Download the generated `component.yaml` file.
2. Replace the existing source configuration file in the `.choreo` folder within your source repository.
    - Ensure the file name is `component.yaml`.


### Step 4: Trigger a new build

1. Commit the new `component.yaml` file to your repository. Push changes to the remote Git repository.
2. Trigger a build using the latest commit.


### Step 5: Verify the update

Once the build is complete:

  - Deploy the build.
  - Confirm that the warning messages no longer appear.

You can benefit from the latest features and enhancements provided by the updated source configuration file.


# Manage Deployment Tracks for Choreo Components

Choreo allows you to create and manage dedicated [deployment tracks](../choreo-concepts/deployment-tracks.md) for components, facilitating independent version control and deployment. This capability also allows you to unlink deployment tracks from associated branches or relink them to different branches so that you can align with your preferred Git workflows, such as the feature branch workflow or GitFlow workflow.

!!! info
     Deployment track creation and management does not apply to API Proxy and [BYOI components](../develop-components/bring-your-own-image.md).

## Create a deployment track

**Prerequisites**:

 - Create a component in Choreo.

Follow the steps below to create a deployment track for a component:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to create a deployment track for.
3. On the header of the component overview page, click the **Deployment Track** drop-down list.
4. Click **+ Create New** to open the **Create Deployment Track** dialog.
5. In the **Create Deployment Track** dialog, do the following:
    1. Select a branch to associate with the deployment track.
    2. Optionally, specify a description for the deployment track. 
    3. To create a deployment track for a service component, specify a unique API version indicating the major and minor version numbers.
6. Click **Create**.

## Unlink a deployment track

If you want to detach a branch reference from a deployment track, you must unlink the branch.

!!! info
     When you unlink the branch of a deployment track, the active deployments are unaffected. However, while you can redeploy the existing deployment, you cannot perform a new deployment.

Follow the steps below to unlink a deployment track of a component:
  
1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to unlink a deployment track.
3. On the header of the component overview page, click the **Deployment Track** drop-down list and then click **View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
4. Click the edit icon corresponding to the deployment track you want to unlink.
5. In the **Edit Branch** dialog that opens, click the **Branch Name** list and select **None**.
6. Click **Save**.

## Link a deployment track

To associate a branch reference to an unlinked deployment track, you must link a branch.

!!! info
    To build and deploy the contents of the linked branch,  you must perform a manual build and deploy.

**Prerequisites**:

 - A minimum of two branches in your GitHub repository.

Follow the steps below to link a branch to an unlinked deployment track:
  
1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to associate a branch reference for.
3. On the header of the component overview page, click the **Deployment Track** drop-down list and then click **View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
4. Click **+ Link Branch** corresponding to the unlinked deployment track for which you want to associate a branch.
5. In the **Link Branch** dialog that opens, click the **Branch Name** list and select the branch you want to relink.
6. Click **Save**.

## Relink a deployment track

To switch the branch reference of a linked deployment track, you must relink to an appropriate branch.

!!! info
      If you unlink the existing branch of a deployment track and link a different branch, you must perform a manual build and deploy to build and deploy the contents of the recently linked branch.

**Prerequisites**:

 - A minimum of two branches in your GitHub repository.

Follow the steps below to switch the branch reference of a linked deployment track:
  
1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to relink a deployment track for.
3. On the header of the component overview page,  click the **Deployment Track** drop-down list and then click **View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
4. Click the **Edit Branch** icon corresponding to the deployment track you want to relink.
5. In the **Edit Branch** dialog that opens, click the **Branch Name** list and select the branch you want to relink.
6. Click **Save**.

Now that you understand how to create and manage deployment tracks for components, let’s explore a sample scenario to see how a developer can use deployment tracks to manage version releases in Choreo.

## Sample Scenario: Manage version releases with deployment tracks

Let’s consider the following version release scenario: 

- To initiate work on a new feature, a developer creates a new branch, named `feature-x` from either the `main` or `dev` branch.
- Once development is complete, the developer proceeds to merge the `feature-x` branch into the `dev` branch for testing.
- Upon successful testing in the `dev` branch, the developer proceeds to merge all the changes into the `main` branch for production deployment.

Following are the actions you need to take from a deployment track perspective to manage the version release:

1. To prepare for the new version release, unlink the `main` branch from the associated deployment track (let’s consider this as the deployment track 1).
2. Proceed to merge the `dev` branch containing the tested changes into the `main` branch.
3. Unlink the `dev` branch from the associated deployment track (let’s consider this as deployment track 2).
4. Link deployment track 2 containing the latest version of the service to the `main` branch for deployment.
5. To facilitate ongoing development and testing, create another deployment track (let’s consider this as deployment track 3) and link it to the `dev` branch.

!!! tip
     - As a developer, you can strategically unlink and relink deployment tracks to effectively manage different versions of your services within Choreo.
     - You can create new deployment tracks for ongoing development branches like `dev` to ensure a continuous development and release cycle.

## Delete a deployment track

If you no longer need a deployment track, you can delete it.

!!! note
    If the component exposes an endpoint or proxy and you want to delete the last version in the major version range, the recommended approach is to retire that version first. This allows consumers to transition to the next major version and prevents a sudden break in their experience.
    For example, if you have deployment tracks for v1.0 and v2.0, notify consumers to switch to v2.0 before deleting v1.0. Then, retire the APIs in v1.0 and proceed to delete the associated deployment track.




**Prerequisites**:

- At least 2 deployment tracks in a component.

Follow the steps below to delete a deployment track:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to delete a deployment track.
3. On the header of the component overview page, click the **Deployment Track** drop-down list.
4. Click **+ View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
5. Click the **Delete** icon corresponding to the deployment track you want to delete.
6. Click **Delete** to confirm the deletion.

# Manage the Micro Integrator Runtime Version in Your Integration Project

Choreo allows you to use a preferred WSO2 Micro Integrator (MI) runtime version in your integration project. Currently, Choreo supports MI product versions 4.1.0 and 4.2.0. You have the flexibility to deploy WSO2 updates within these specified versions. 

When you create an integration project, you can specify a required runtime version to gain control over the environment in which your integration runs. This version management capability empowers you to tailor your projects depending on your runtime requirements, enhancing the customization and adaptability of your integration workflows.

## Understand the version string

WSO2 Micro Integrator (MI) utilizes a versioning system consisting of three-digit numbers, such as `4.1.0` and `4.2.0`, following semantic versioning principles. The product remains committed to receiving updates from WSO2, including security fixes, bug resolutions, and enhancements. Within the Choreo platform, the MI runtime version is constructed by combining the product release version with its corresponding update level.

In Choreo, the MI runtime version is structured as a four-digit number, for example, `4.1.0.14` or `4.2.0.17`. The first three digits represent the product release version, while the last digit signifies the update level of the product. The fourth digit is optional and can be omitted.

![Version string](../assets/img/develop-components/micro-integrator/version-string.png)

## Version management in WSO2 Integration Studio

If you are using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/) to build and deploy integration artifacts in WSO2 Micro Integrator, you can create multiple runtime environments and execute projects on any selected environment. WSO2 Integration Studio also allows you to configure multiple Micro Integrator runtime environments, offering flexibility and customization in the execution of integration processes.

You can specify the Runtime version when you create an integration project in WSO2 Integration Studio. In the project creation wizard, specify the runtime version in the **Runtime version** field, as shown below.
![Specify Runtime version](../assets/img/develop-components/micro-integrator/specify_runtime_version.png)


An integration project is structured as a Maven project with multiple sub-modules. The root `pom.xml` file holds crucial information about the target runtime. The runtime version you configure when you create a new project is saved within the root `pom.xml` file. The version information is stored in the <project.runtime.version> element under the <properties> in the `pom.xml` file. If there is a need to update the runtime version, you have the flexibility to modify the value to a valid runtime version and ensure that the project runs in the required runtime environment.

![project runtime version](../assets/img/develop-components/micro-integrator/project-runtime-version.png)

You can establish multiple runtime environments by utilizing updated MI instances. With a valid WSO2 subscription, you can also access and download updates to set up an updated MI server locally. This update process allows you to select a preferred update level as the runtime version. Consequently, you can run your integration on a runtime with the latest updates, ensuring optimal performance and access to new features.

### Configure a Micro Integrator runtime environment in Integration Studio

If you are using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), follow these steps to set up a remote server instance with a Micro Integrator runtime environment to execute your integration project:

!!! info "Note"
    If you have not downloaded and installed WSO2 Integration Studio, you can follow the [installation instructions](https://apim.docs.wso2.com/en/latest/integrate/develop/installing-wso2-integration-studio/) in the WSO2 API Manager documentation.

1. Launch WSO2 Integration Studio and click **Add Server** in the **Getting Started** view.
   ![Add server](../assets/img/develop-components/micro-integrator/add-server.png)
2. In the **Define a New Server** dialog, click to expand the `WSO2` directory and select **WSO2 Remote Server**.
   ![Define a remote server instance](../assets/img/develop-components/micro-integrator/define-a-remote-server-instance.png)
3. Enter the WSO2 Micro Integrator Management API URL in the **Server URL** field and click **Test Connection**.

    !!! info "Note"
        The Management API of WSO2 Micro Integrator is an internal REST API introduced to substitute MI admin services. The default HTTPS port of the Management API of WSO2 Micro Integrator is `9164`. If you have not manually changed the default port, you must set the Management API URL as `https://localhost:9164/management`.  If you have changed the default HTTPS port, you must set the port number appropriately when specifying the **Server URL**. For more information on the default ports of WSO2 Micro Integrator, see [WSO2 Micro Integrator default ports](https://apim.docs.wso2.com/en/latest/install-and-setup/setup/reference/default-product-ports/#micro-integrator-ports) in the WSO2 API Manager documentation.

    ![Set server URL](../assets/img/develop-components/micro-integrator/set-server-url.png)
    
4. Click **Finish**.
5. In the **Add and Remove** dialog, select the integration components to move from the left side to the right side.
6. Click **Add >**.
7. Click **Finish**. 

Your integration project is now running in a remote server instance with the Micro Integrator runtime environment you require.
If you need to make changes to the integration project, expand the remote server instance, right-click on the deployed exporter project, and select **Redeploy** to apply the changes.

![Redeploy project](../assets/img/develop-components/micro-integrator/redeploy-project.png)

## Convention for version interpretation in Choreo deployments

You can use the following convention to indicate the required MI runtime version in your integration project:


| **Version format**           | **Example**       | **Description**   |
|------------------------------|-------------------|-------------------|
| Product version              | `4.1.0`, `4.2.0`  | Deploy on the latest update level of the mentioned product version.                 |
| Product version with update level  | `4.1.0.15`, `4.2.0.17` |  Deploy on the exact update level of the mentioned product version.    |
| GA version                   | `4.1.0.0`, `4.2.0.0` | Deploy on the exact GA version without any update.                  |
| Default version            | Empty value         | Deploy on the latest update level of the default product version.                  |


Choreo utilizes Alpine images for configuring and deploying the Micro Integrator runtime. This includes automated configuration of the JRE/JDK, customized to the compatibility of the chosen runtime version, simplifying the setup procedure.

## Migrate between runtime versions

Changing the runtime version in an integration project may become necessary during product version upgrades or when you want to apply updates. 

To change the runtime version of a MI Integration, follow the below steps.

### Update the runtime version in the integration project
    
To change the runtime version in the integration project, follow the steps below:
1. Open the project in Integration Studio.
2. Right-click on the project and select **Change Runtime MI Version**.
    ![Update Runtime version](../assets/img/develop-components/micro-integrator/click_change_runtime.png)
3.  Specify the new runtime version as shown below:
    ![Update Runtime version](../assets/img/develop-components/micro-integrator/update_runtime_version.png)
4. Alternatively, you can manually update the version by opening the root `pom.xml` file.  Open pom.xml and change the required runtime version in `<project.runtime.version>` element under `<properties>` section.

To test the changes locally, you must download and set up the runtime environment locally. Then, you must [configure the Integration Studio runtime environment](#configure-a-micro-integrator-runtime-environment-in-integration-studio) by directing it to the locally installed MI runtime. Once the setup is complete, you can deploy your integrations on the MI runtime environment and proceed to the testing phase.

After completing the tests to ensure everything works as expected, you can follow below steps to deploy the project in Choreo:

1. Commit and push the changes to your repository.
2. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
3. Select your project from the **Project** list in the header.
4. Select your MI integration component from the **Component** list in the header.
5. In the left navigation menu, click **Build**.
6. Select the latest commit and click **Build**.
7. In the left navigation menu, click **Deploy**.
8. Click on the **Configure and Deploy** and deploy the component.
9. Verify the Runtime version by checking the logs by selecting the **Runtime Logs** under the **Observability** section.

  You will see the runtime version in the logs as shown below:
  ![Runtime version in logs](../assets/img/develop-components/micro-integrator/runtime_version_in_logs.png)

Next, you must conduct additional testing in the development environment on Choreo before you promote the integration to production environments.

## Troubleshoot errors

The following error codes can help you troubleshoot errors that occur during the integration component build:

| **Error code** | **Description**            |
|----------------|----------------------------|
| 110 - 119      | Internal server error.     |
| 121            | Malformed runtime version. |
| 122            | The specified runtime version is not available. Either the product or update level is not available.    |
| 123            | Trivy security vulnerabilities found in the `libs` directory. |
| 124            | Trivy security vulnerabilities found in the `dropins` directory. |
| 125            | Trivy security vulnerabilities found in the `libs` or `dropins` directory. |
| 126            | Error building integration project. |


# Submit and Manage Workflow Approval Requests

In Choreo, if an administrator [configures a workflow to require approval](../administer/configure-approvals-for-choreo-workflows.md), you must submit a request to obtain approval to perform the task.

Upon submitting a workflow approval request, Choreo notifies all authorized assignees via email about the [review request](../administer/review-workflow-approval-requests.md). When an authorized assignee approves or rejects the request, you will receive an email with details of the decision.

The approach to request approval can vary depending on the workflow. 

## Request approval for environment promotion

**Prerequisites**:

- Ensure you have a component created, built, and deployed to the development environment.
- Ensure that an approval workflow is configured for environment promotion.
- Ensure you are promoting the component to a critical environment, such as production.

To request approval to promote a component from the development environment to production, follow these steps:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to deploy. This takes you to the **Overview** page of the component.
3. In the left navigation menu, click **Deploy**.
4. Go to the **Development** card and click **Request to Promote**.
5. In the **Request Approval** pane that opens, enter your request details and click **Submit**. This creates a request and notifies all authorized assignees via email about the request.

    !!! note
         When an environment promotion request for a specific component is pending review, Choreo restricts other developers from making the same request until the pending request is either approved or rejected.

When an authorized assignee approves the request, you will receive a confirmation email and can proceed to promote the component to production.

## Cancel a workflow approval request

If you want to cancel a workflow approval request that is already submitted, you can do so before the request is approved or rejected. 

When you submit a workflow approval request, the **Request to Promote** button changes to **Cancel Request**. To cancel an approval request, click **Cancel Request**. Upon confirming the cancellation, all configured approvers are notified immediately, and the request will no longer be pending.


# Work with the Micro Integrator Runtime in Choreo

WSO2 Micro Integrator (WSO2 MI) is a lightweight, high-performance integration runtime. It allows you to run integrations developed using WSO2 Integration Studio within Choreo. 

The topics on this page walk you through the key aspects you need to understand to use the WSO2 MI runtime effectively in Choreo.

## Integration types

Choreo supports the following WSO2 MI integrations that cater to different use cases and requirements. Each integration type serves a specific purpose. Therefore, it is essential to understand their differences to easily choose the most appropriate integration for your use case.

- **Service**: Exposes an integration as an API via HTTP, making it possible to create a RESTful interface for your integration services. This type is ideal for scenarios where you need to provide an API for external systems or clients to interact with your integration.
- **Event Handler**: Triggers an integration based on external events such as messages arriving on a queue or updates in a database. This type is well-suited for implementing event-driven architectures or responding to changes in your system's environment.
- **Scheduled Task**: Runs an integration automatically at predefined time intervals, ensuring that specific integration tasks occur at regular intervals. This type is ideal for batch processing, data synchronization, or periodic maintenance tasks.
- **Manual Task**: Initiates an integration via user action, giving you full control over when the integration executes. This type is useful for on-demand tasks, testing, or debugging purposes.

## Develop integrations with WSO2 Integration Studio

[WSO2 Integration Studio](https://wso2.com/integration/integration-studio/) is a powerful, Eclipse-based graphical development environment that enables you to build and deploy integration artifacts in WSO2 Micro Integrator. This comprehensive IDE offers a robust set of tools for designing and testing integration flows and crafting integration artifacts. By utilizing the visual, drag-and-drop capabilities of WSO2 Integration Studio, developers can significantly reduce the time and effort needed to construct and deploy integration flows.

In addition to streamlining the development process, Integration Studio offers features such as debugging, testing, and version control to ensure the quality and reliability of integration flows. By creating an Integration project and Composite Exporter project in WSO2 Integration Studio, developers can export their integration projects as a single deployment artifact, known as a composite application. This composite application encompasses all the components and configurations necessary for deploying the integration project to WSO2 Micro Integrator.

The Composite Exporter project simplifies the deployment process by allowing developers to package their integration projects as a single, self-contained artifact that can be easily deployed and managed. This approach enhances the consistency and reliability of integration projects while streamlining the overall deployment process.

To start developing integrations with WSO2 Micro Integrator, see [WSO2 Micro Integrator documentation - Developing Integration Solutions](https://mi.docs.wso2.com/en/latest/develop/intro-integration-development/).

## Integration project directory structure

An Integration Project in WSO2 Integration Studio is a multi-module Maven project that can contain multiple modules with WSO2 Synapse configurations and a composite application module to export all the configurations as a single deployable artifact.

An integration project directory structure includes the following key components:

 - WSO2 Synapse configurations: These modules contain the essential configurations for the integration project.
 - Composite Application module: This module is responsible for exporting all the Synapse configurations as a single deployable artifact.

Optionally, you can include the following components in your integration project:

 - OpenAPI definition file: You can add the OpenAPI definition file to any location within the project. When creating a component, you'll need to define the path to this file. Choreo will automatically generate an OpenAPI definition for you based on your integration project, if you don't provide one.
 - Java libraries: If your integration project requires additional Java libraries, you can add them to the libs directory located in the project root.
 - deployment.toml file: This optional configuration file allows you to customize the preconfigured settings of WSO2 MI instances running on Choreo. By including this file, you can tailor the behavior of your WSO2 MI instances to better suit your project's specific requirements.

Understanding the Integration Project directory structure is crucial for organizing your project and ensuring that all necessary components are included in the final deployable artifact.

## OpenAPI support

OpenAPI Support plays a crucial role in enhancing the functionality of integrations exposed as APIs. By providing an OpenAPI definition for your exposed integration, you can streamline testing and management processes, ensuring a more efficient and user-friendly experience. Choreo will automatically generate an OpenAPI definition for you based on your integration project, if you don't provide one, saving you time and effort.

To incorporate OpenAPI support, store the OpenAPI definition file within the repository hosting your Integration Studio project. When creating the project, simply point to the file's location in the repository. If needed, you can change the location of the OpenAPI definition file later via the deploy page.

![Open API file](../assets/img/develop-components/micro-integrator/openapi_file.png)

By leveraging OpenAPI Support, you can optimize the way you test and manage your integrations, resulting in a more efficient development process and a smoother user experience.

## Work with third-party libraries

The use of third-party libraries in your Micro Integrator project can offer several advantages, such as enhanced functionality, improved integration capabilities, optimized performance, and reduced development time.

Here are some of the benefits of adding third-party JARs to the Micro Integrator:

 - Increased functionality: Third-party libraries can extend the core Micro Integrator distribution, allowing for greater flexibility and customization of integration solutions.
 - Enhanced integration capabilities: Third-party libraries enable the Micro Integrator to interact with existing systems such as databases or other APIs, improving overall integration capabilities.
 - Optimized performance: By offering optimized implementations of common functions, third-party libraries can improve the performance of the Micro Integrator.
 - Efficient development: Developers can avoid re-implementing commonly used functions, reducing development time and increasing efficiency.

To incorporate third-party libraries into your Micro Integrator project, create a new directory called `libs` at the
root of your project. If your project root and GitHub repository root are not the same, place the `libs` directory in
the project root. After adding the required JAR files to the `libs` directory, the Micro Integrator runtime will
automatically include them when deploying the component. This process ensures that any dependencies needed by your
integration flow are available at runtime.

In addition to `jar` libraries, you may also need to incorporate OSGi bundle JARs into your project. To do this,
create another directory called `dropins` at the root of your project. Similarly, if the project root and GitHub
repository root differ, place the `dropins` directory in the project root. Within the `dropins` directory, add the OSGi
bundle JAR files. The OSGI runtime will pick up these bundles during deployment, enabling you to utilize their
functionality within your Micro Integrator project.

![Libs directory](../assets/img/develop-components/micro-integrator/libs_dir.png)

## Importing custom certificates to MI

The feature enables Choreo MI users to import certificates into the MI `client-truststore.jks` file. This functionality
proves valuable when users need to establish connections with servers or services utilizing SSL/TLS encryption and
possessing self-signed certificates or certificates issued by private certificate authorities (CAs) that are not
automatically trusted. Importing the certificate to the MI `client-truststore.jks` file enables MI clients to establish secure connections with
the server or service seamlessly, eliminating SSL/TLS errors or warnings.

Before importing the certificate, it is necessary to obtain the certificate file, which can be in PEM or DER format. You
can get the certificate from the server or service provider or export it from a web browser. Certificates should be
added to the `/wso2mi/certs/` folder. Users need to verify that the mount path for the certificate file aligns with this
specific path.

1. In the Choreo console, select the component you wish to add a certificate to.
2. From the left navigation click **Deploy**.
3. Click on the **Configs and Secrets** tab.
4. Click **Create**.
5. Select **ConfigMap** as the **Config Type** and **File Mount** as the **Mount Type**.
6. Click **Next**.
7. Specify the following values as mount configurations:

    | **Field**       | **Value**                                              |                                    
    |-----------------|--------------------------------------------------------|
    | **Config Name** | An appropriate name for the certificate.             |
    | **Mount path**  | `/wso2mi/certs/<filename>`. For example, `/wso2mi/certs/certificate.crt` |

8. Click **Upload File** and attach the certificate.
9. Click **Create**.

## Working with sensitive data using MI Secure Vault

MI Secure Vault is a feature that allows users to securely store sensitive data, such as passwords and tokens, and
provide access to that data to MI Integrations. This feature provides an added layer of security to your integrations by
reducing the risk of accidental exposure of sensitive data.

To use MI Secure Vault to work with sensitive data, follow these steps:

1. Select the component from the Choreo Console.
2. From the left navigation, click Deploy.
3. Click on the **Configure and Deploy**.
4. Click on the **Add Environment Configurations**
5. Specify the following values as configurations:

    | **Field**       | **Value**                                 |                                    
    |-------------------------------------------|--------------------------------------------------------|
    | **Name** | An appropriate name for the secret/alias. |
    | **Value**       | Value for the secret                      |

6. Select **Mark as a Secret**.
7. Click **Add**.
8. Click **Deploy**.
9. Once the secret has been created, you can access it in your integration code using the following syntax:

```xml
<property name="secret_value_1" expression="wso2:vault-lookup('user_pass')" scope="default" type="STRING"/>
```
This code retrieves the secret named "user_pass" from the MI Secure Vault and stores it in the property named "
secret_value_1". You can then use this property in your integration code to access the secret value.

For more information on these features, see the [Accessing secrets](https://mi.docs.wso2.com/en/latest/install-and-setup/setup/security/encrypting-plain-text/#step-3-accessing-secrets) section of the MI Secure Vault documentation. By using MI
Secure Vault to store and access sensitive data in your integrations, you can ensure that your integrations
remain secure and protect sensitive data from unauthorized access.


## Scan third-party libraries to identify security vulnerabilities

Scanning third-party libraries for security vulnerabilities is essential for identifying potential weaknesses in an application that could be exploited by attackers. Taking a proactive approach to security helps organizations detect and mitigate risks before they can be exploited, preventing data breaches, system compromises, and other security incidents.

Choreo incorporates a security vulnerability scanning process during deployment. It uses Trivy to scan and detect critical vulnerabilities in third-party libraries added to the integration component. If the scan uncovers any critical vulnerabilities, the deployment process is halted. The deployment pane displays the Trivy scan status and any security failures in the Library (Trivy) vulnerable scan step, which can be accessed by clicking on it. Once the vulnerability has been addressed, you can redeploy the component.

## Customize WSO2 Micro Integrator preconfigured settings

Customizing WSO2 Micro Integrator Preconfigured Settings is essential for ensuring that the integration solution works optimally within the specific context of your organization. While WSO2 MI comes with preconfigured settings designed for general use, these settings may not be suitable for every organization's unique requirements. Customizing these settings can help optimize performance and ensure compatibility with your organization's systems and applications.

To customize the preconfigured settings of WSO2 MI instances running on Choreo, define a `deployment.toml` file in the GitHub repository subpath of your Micro Integrator project:

![deployment.toml](../assets/img/develop-components/micro-integrator/config_file.png)

!!! note
    If you change critical configuration parameters such as port offset and hostname, it can break internal communication.
    Therefore, the recommended approach is to update only the necessary configuration parameters.

Given below is a sample `deployment.toml` file that can be used to configure the JMS transport. For more information on WSO2 MI
configuration parameters, see the [MI Configuration Catalog](https://mi.docs.wso2.com/en/latest/reference/config-catalog-mi/).

```
[[transport.jms.sender]]
name = "myQueueSender"
parameter.initial_naming_factory = "org.apache.activemq.jndi.ActiveMQInitialContextFactory"
parameter.provider_url = "$env{JMS_PROVIDER_URL}"
parameter.connection_factory_name = "QueueConnectionFactory"
parameter.connection_factory_type = "queue"
parameter.cache_level = "producer"

[[transport.jms.listener]]
name = "myQueueListener"
parameter.initial_naming_factory = "org.apache.activemq.jndi.ActiveMQInitialContextFactory"
parameter.provider_url = "$env{JMS_PROVIDER_URL}"
parameter.connection_factory_name = "QueueConnectionFactory"
parameter.connection_factory_type = "queue"
parameter.cache_level = "consumer"
```

## Environment variables

Using environment variables is a recommended practice when developing integration artifacts with WSO2 Integration Studio, as it improves configuration management, security, portability, and manageability. By leveraging environment variables, organizations can streamline the management and maintenance of their integrations, ensuring that updates can be implemented quickly and efficiently.

The component's Deploy page provides a user-friendly interface to manage environment variables across different environments. For information on managing environment variables for complex use cases, see [Configurations and secrets](../devops-and-ci-cd/manage-configurations-and-secrets.md).

![Environment variables](../assets/img/develop-components/micro-integrator/env_variables.png)

Environment variables offer several benefits:

 - Configuration management: They simplify the process of managing and updating configuration settings, making it easier to maintain consistency across different environments.
 - Security: Environment variables help protect sensitive information by storing it securely and separating it from the main codebase.
 - Portability: By using environment variables, you can ensure that your integration artifacts can be easily migrated and deployed across various environments with minimal changes.
 - Manageability: Environment variables offer a centralized way to manage configuration settings, making it easier to update and maintain your integrations over time.

For a comprehensive list of parameters that can be configured as environment variables, see [WSO2 Micro Integrator documentation - Injecting Parameters - Supported parameters](https://mi.docs.wso2.com/en/latest/develop/injecting-parameters/#supported-parameters).

## Configure logging

Configuring logging is crucial when developing and maintaining a software system, as it can significantly improve efficiency during the development, testing, and maintenance phases of the software development process. Logging captures events and messages that occur during an application's execution, providing valuable insights for troubleshooting and debugging issues.

With Micro Integrator instances, you can configure and customize logging according to your requirements. Logging configurations can be added to each MI instance's environment, allowing you to fine-tune logging depending on the specific environment or deployment scenario.

To configure logging in MI instances, follow the steps given below: 

!!! tip
     You can use environment variables with specific naming conventions.

1. Start the variable name with `logging_level_` followed by the package or class name.
2. Replace the dot character in the package name with an underscore.
3. Set the variable value to the required logging level for the corresponding package or class.

    For example, to enable wire logs, change the logging level of the `org.apache.synapse.transport.http.wire` package to `debug`. 

To configure logging, set the environment variable as follows:

1. In the left navigation menu, click **Deploy** and then click **Configs & Secrets**. 
2. Click **+ Create**. 
3. Select **ConfigMap** as the **Config Type** and **Environment Variables** as the **Mount Type**. 
4. Click **Next**. 
5. Specify the following values as mount configurations:

    | **Field**       | **Value**                                              |                                    
    |-----------------|--------------------------------------------------------|
    | **Config Name** | An appropriate name for the configuration.             |
    | **Name**        | `logging_level_org_apache_synapse_transport_http_wire` |
    | **Value**       | `debug`                                                |

6. Click **Create**.

## Connectors

WSO2 Micro Integrator (MI) Connectors are prebuilt connectors designed to simplify integration between WSO2 MI and various other systems. They enable seamless connections to databases, message brokers, REST APIs, and more, allowing you to perform actions such as sending messages, executing queries, or retrieving data. These connectors are easy to use, making it straightforward to incorporate them into your WSO2 MI integration flows. Micro Integrator connectors are versatile and can be utilized in various integration scenarios, including data integration, service-oriented architecture (SOA) integration, and event-driven architecture (EDA) integration.

WSO2 Integration Studio is a comprehensive development environment that facilitates the creation of integration flows using WSO2 Micro Integrator Connectors. With Integration Studio, you can design and implement integration flows that connect diverse systems and execute various actions, such as sending messages, executing queries, or retrieving data. You can build integration flows using either prebuilt connectors provided by WSO2 MI or custom connectors developed using the Connector Development Toolkit. Integration Studio offers a graphical user interface that simplifies the process of building and testing integration flows while also providing a set of tools for managing and deploying these flows in a WSO2 MI runtime environment.

For more information, see the following topics in the WSO2 Micro Integrator documentation.

- [Connectors Overview](https://mi.docs.wso2.com/en/latest/reference/connectors/connectors-overview/)
- [Adding Connectors](https://mi.docs.wso2.com/en/latest/develop/creating-artifacts/adding-connectors/)

## Deploying integrations in Choreo 

WSO2 MI buildpack is where you can deploy integrations developed with WSO2 Micro Integrator as an API. In this preset, you have three different ways to define endpoints. Choreo gives priory to the definition of endpoints in the below-mentioned order. 

1. **Using component.yaml file**
This is the most flexible method to define endpoints. You can configure the endpoint details with the `component.yaml` configuration file. Place this file in the `.choreo` directory in the project path of the component. 
If the Micro Integrator project has inbound endpoints, you can expose them via different endpoints using the `component.yaml`file.

    To learn about the `component.yaml` file, see [Overview of the component.yaml file](../develop-components/manage-component-source-configurations.md#overview-of-the-componentyaml-file).

3. **Auto generating endpoints**
If `component.yaml` is not provided and if the source Micro Integrator project has APIs, Choreo scans the project and generates the API endpoints. If the project has few APIs, an endpoint will be generated for each API. The visibility of this auto-generated endpoint is set to `Public` by default. You can change the visibility in the deployment flow.

4. **Provide default endpoints**
If `component.yaml` is not provided and if the source Micro Integrator project doesn't have APIs, Choreo generates a default endpoint which will expose the default micro integrator port (8290) with `Public` visibility and wildcard context.

!!! note
    If you are currently using `component-config.yaml` or `endpoints.yaml` configuration files, see the respective [migration guide](../develop-components/manage-component-source-configurations.md#migration-guide) for instructions on migrating to the recommended `component.yaml` configuration file.

## Explore Choreo examples on GitHub

For a hands-on experience with MI-based integrations in Choreo, we recommend exploring our samples in Choreo Console. You can filter out the samples based on the buildpack `WSO2 MI`. This will point you to the samples in the [Choreo samples GitHub repository](https://github.com/wso2/choreo-samples)

### [Choreo samples - GitHub Repository](https://github.com/wso2/choreo-samples)

- **Fork the Repository**: Start by forking the repository to your account.

- **Explore & run**: Navigate through the different integration scenarios. Each example has a README.md with setup and execution instructions.



# Develop a Manual Task

This guide walks you through the steps to develop, deploy, test, and observe a manual task using Choreo.

In this guide, you will:

- Develop a manual task to fetch the weather forecast for a specified location for the next 24 hours from the [OpenWeatherMap](https://openweathermap.org) API.
- Process the weather data into a specific format.
- Send the formatted data to a specified email address.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

    !!! info "Repository File Structure"
        The sample code for this guide is in the `<sample-repository-dir>/weather-to-email-integration` directory. The following table describes the key files in the repository:

        | **File Path**         | **File Content**                                                     |
        | --------------------- | -------------------------------------------------------------------- |
        | **Ballerina.toml**    | Contains metadata about the project                                  |
        | **Dependencies.toml** | Lists the dependencies required for the project                      |
        | **main.bal**          | Contains the entry point of the project, including the main function |
        | **types.bal**         | Contains custom data types used in the project                       |
        | **utils.bal**         | Contains utility functions and helper functions used in the project  |

3. Go to [OpenWeatherMap](https://openweathermap.org/) and sign up to obtain an API key. For details, see the [OpenWeatherMap documentation](https://openweathermap.org/appid#signup).

## Step 1: Create a manual task component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Manual Task** card.
6. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:

        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

7. Enter the following information:

    | **Field**             | **Description**                                      |
    | ----------------------| -----------------------------------------------------|
    | **Organization**      | Your GitHub account                                  |
    | **Repository**        | `choreo-samples`                                     |
    | **Branch**            | `main`                                               |
    | **Component Directory** | `weather-to-email-integration`                       |

8. Select **Ballerina** as the **Build Pack**.

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Component Directory** specifies the location of the project to build the component.

4. Enter a unique name and description for the component. You can use the following values:

    | **Field**          | **Value**                        |
    | ------------------ | -------------------------------- |
    | **Component Name** | `WeatherToEmail`                 |
    | **Description**    | `My first manual task`           |


8. Click **Create**. Choreo initializes the component with the sample implementation and opens the **Overview** page of the component.

## Step 2: Build the manual task

1. In the left navigation menu, click **Build**.
2. In the **Builds** pane, click **Build**. This opens the **Commits** pane, where you can see all the commits related to the component.
3. Select the latest commit and click **Build**. This triggers the build process and displays the build progress in the **Build Logs** pane.

    !!! info
        The build process may take some time. Once complete, the build status will be listed in the **Builds** pane. Here, you will see the build status as **Success**.

## Step 3: Deploy the manual task

1. In the left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane, specify values for the configurable variables:

    !!! tip
        The configurable variables populated here are defined in the sample Ballerina project used in this guide. To learn how to declare configurable variables in Ballerina, see the [Ballerina documentation on declaring configurable variables](https://ballerina.io/learn/by-example/configurable-variables/).

    | **Field**     | **Value**                                                               |
    | ------------- | ----------------------------------------------------------------------- |
    | **apiKey**    | The API key you obtained in the prerequisites section                   |
    | **latitude**  | Latitude of the location to get the weather forecast                    |
    | **longitude** | Longitude of the location to get the weather forecast                   |
    | **email**     | The email address to receive the formatted weather forecast information |

    !!! note
        If you use **Ballerina** as the buildpack and want to set a configurable variable as a secret, click the lock icon corresponding to the configurable variable. This marks it as a secret and conceals the input value.

        For example, if you set the **apiKey** as a secret, its input value will be concealed. To update the input value later, click **Update Secret Content** and specify a new value.

4. Click **Deploy**.

## Step 4: Execute the manual task

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the task.

    !!! info "Inject Dynamic Values into Your Application as Command-Line Arguments"
        If you want to inject dynamic values into your application as command-line arguments when you run a manual task, follow these steps:
        1. Click the drop-down icon next to **Run Now** and then click **Run with Arguments**.
        2. In the **Runtime Arguments** pane, enter the arguments you want to pass to your application.
        3. Click **Execute**. This triggers the task with the specified arguments.

        The capability to run a manual task with arguments is supported for the following buildpacks:

        === "Dockerfile"
            To explore a Dockerfile-based manual task with arguments, try out the [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/docker-hello-world-manual-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on Docker projects, the **Run with Arguments** capability is not supported if the Dockerfile contains `CMD`. In such scenarios, use `ENTRYPOINT` to define your default commands.

        === "Go"
            To explore a Go-based manual task with arguments, try out the [Hello World Go Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-go-task) sample. For instructions, see the `readme.md` file in the sample repository.

        === "Java"
            To explore a Java-based manual task with arguments, try out the [Hello World Java Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-java-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on Java projects:
                - The **Run with Arguments** capability is not supported if `Procfile` is available in the project.
                - The `Main` class should be defined in the `manifest` file.
                - If Maven files such as `mvn.cmd` exist in the project without the `.mvn` directory, the build will fail. To ensure a successful build, either commit the `.mvn` directory along with any Maven files or exclude Maven files if you choose not to commit the `.mvn` directory.

        === "NodeJS"
            To explore a NodeJS-based manual task with arguments, try out the [Hello World NodeJS Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-nodejs-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on NodeJS projects:
                - The **Run with Arguments** capability is not supported if `Procfile` is available in the project.
                - The project root must contain the `package.json` file with the `main` attribute defined.

        === "WSO2 MI"
            To explore a WSO2 MI-based manual task with arguments, try out the [Weather to Logs Task](https://github.com/wso2/choreo-samples/tree/main/weather-to-logs-mi-manual-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on WSO2 MI projects and deploying a WSO2 MI integration as a manual task in Choreo, use the WSO2 MI automation mode. For details, see [Running the Micro Integrator in Automation Mode](https://apim.docs.wso2.com/en/latest/install-and-setup/install/running-the-mi-in-automation-mode/).

        === "Ballerina"
            To explore a Ballerina manual task with arguments, try out the [Weather to Email Task](https://github.com/wso2/choreo-samples/tree/main/weather-to-email-integration) sample. For instructions, see the README.md file in the sample repository.

            !!! info
                If you want to pass arguments to Ballerina main functions, use the **Run with Arguments** capability. For details on the arguments you can pass, see the [Ballerina documentation](https://ballerina.io/learn/by-example/main-function/). You can also override configurable values in the same manner. For more information, see [Provide values to configurable variables](https://ballerina.io/learn/provide-values-to-configurable-variables/#provide-via-command-line-arguments).

## Step 5: Test the manual task

Once the task is triggered, an email with the subject `[WSO2 Choreo Demo] Next 24H Weather Forecast` is sent from `choreo.demo@gmail.com` to the email address specified as the **email** configurable variable value in [Step 3](#step-3-deploy-the-manual-task).

If the manual task ran successfully, you should receive an email similar to the following:

![Received email](../../assets/img/develop-components/develop-a-scheduled-integration/Received-email.png)

## Step 6: Observe the manual task

The observability view in Choreo displays graphs that depict details such as throughput, latency, diagnostic data, and logs to identify and troubleshoot anomalies in components you deploy.

1. In the left navigation menu, click **Observability**.
2. Observe the following:
    - The throughput and latencies of requests served over a given period.
    - The logs generated over a given period.
    - The flame graph (Diagnostics View) generated over a given period.
    - The low-code diagram.

To learn more about the observability details you can view via Choreo observability, see [Observability Overview](../../monitoring-and-insights/observability-overview.md).

## Step 7: Monitor executions

To track and monitor executions associated with the deployed manual task, go to the left navigation menu and click **Execute**.

!!! tip
    The **Execute** view is applicable to both scheduled and manual tasks.

You can view the following information:

- **Total executions**: The total number of executions within the past 30 days.

    ![Total Execution](../../assets/img/develop-components/develop-a-scheduled-integration/total_executions.png)

- **Execution history**: The currently active executions and those that are already complete. You can view information such as the execution ID, the revision of the execution, and the time it was triggered.

    ![Execution History](../../assets/img/develop-components/develop-a-scheduled-integration/execution_history.png)

- **Detailed execution logs**: Click on an execution to view detailed logs related to it.

    !!! info
        It may take a few minutes for the logs to appear. You may need to manually refresh to view the latest logs.

    ![Execution Logs](../../assets/img/develop-components/develop-a-scheduled-integration/execution_logs.png)


# Develop a Scheduled Task

Choreo is a versatile integration platform that allows you to create various types of integrations depending on your requirements. If you need to automatically run a specific integration at regular intervals, you can use Choreo to develop a scheduled task. This type of integration can automate the synchronization of data between different systems at specified intervals, reducing errors and improving productivity by eliminating the need for manual intervention.

This guide walks you through the steps to develop, deploy, test, and observe a scheduled task using Choreo.

In this guide, you will:

- Develop a scheduled task to fetch the weather forecast for a specified location for the next 24 hours from the [OpenWeatherMap](https://openweathermap.org) API.
- Process the weather data into a specific format.
- Send the formatted data to a specified email address at a specific time every day.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

    !!! info "Repository File Structure"
        The sample code for this guide is in the `<sample-repository-dir>/weather-to-email-scheduled-task` directory. The following table describes the key files in the repository:

        | **File Path**         | **File Content**                                                     |
        | --------------------- | -------------------------------------------------------------------- |
        | **Ballerina.toml**    | Contains metadata about the project                                  |
        | **Dependencies.toml** | Lists the dependencies required for the project                      |
        | **main.bal**          | Contains the entry point of the project, including the main function |
        | **types.bal**         | Contains custom data types used in the project                       |
        | **utils.bal**         | Contains utility functions and helper functions used in the project  |

3. Go to [OpenWeatherMap](https://openweathermap.org/) and sign up to obtain an API key. For details, see the [OpenWeatherMap documentation](https://openweathermap.org/appid#signup).

## Step 1: Create a scheduled task component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Scheduled Task** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following information:

    | **Field**             | **Description**                                |
    | --------------------- | ---------------------------------------------- |
    | **Organization**      | Your GitHub account                            |
    | **Repository**        | `choreo-samples`                               |
    | **Branch**            | `main`                                         |
    | **Component Directory** | `weather-to-email-scheduled-task`              |

6. Select **Ballerina** as the build pack.

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Component Directory** specifies the location of the project to build the component.

7. Enter a unique name and description for the component. You can use the following values:

    | **Field**          | **Value**                        |
    | ------------------ | -------------------------------- |
    | **Component Name** | `WeatherToEmail`                 |
    | **Description**    | `My first scheduled task`        |

8. Click **Create**. Choreo initializes the component with the sample implementation and opens the **Overview** page of the component.

Now you can proceed to build and deploy the scheduled task.

## Step 2: Build the scheduled task

1. In the left navigation menu, click **Build**.
2. In the **Builds** pane, click **Build**. This opens the **Commits** pane, where you can see all the commits related to the component.
3. Select the latest commit and click **Build**. This triggers the build process and displays the build progress in the **Build Logs** pane.

    !!! info
        The build process may take some time. Once complete, the build status will be listed in the **Builds** pane. Here, you will see the build status as **Success**.

## Step 3: Deploy the scheduled task

1. In the left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane, specify values for the configurable variables:

    !!! tip
        The configurable variables populated here are defined in the sample Ballerina project used in this guide. To learn how to declare configurable variables in Ballerina, see the [Ballerina documentation on declaring configurable variables](https://ballerina.io/learn/by-example/configurable-variables/).

    | **Field**     | **Value**                                                               |
    | ------------- | ----------------------------------------------------------------------- |
    | **apiKey**    | The API key you obtained in the prerequisites section                   |
    | **latitude**  | Latitude of the location to get the weather forecast                    |
    | **longitude** | Longitude of the location to get the weather forecast                   |
    | **email**     | The email address to receive the formatted weather forecast information |

    !!! note
        If you use **Ballerina** as the buildpack and want to set a configurable variable as a secret, click the lock icon corresponding to the configurable variable. This marks it as a secret and conceals the input value.

        For example, if you set the **apiKey** as a secret, its input value will be concealed. To update the input value later, click **Update Secret Content** and specify a new value.

4. Click **Next**.
5. Define a schedule to run the task. In this guide, set the schedule to receive the weather information daily at 8:00 AM UTC. Enter the following values:

    | **Field**            | **Value**                                             |
    | -------------------- | ----------------------------------------------------- |
    | **Select Time Zone** | Select a time zone to schedule the task               |
    | **Select Range**     | **Day**                                               |
    | **Every**            | `1`                                                   |
    | **At**               | `08:00`                                               |

    !!! tip
        To test and verify the task immediately, you can schedule the deployment to run in just a few minutes after you create it. However, to avoid unnecessary expenses, reschedule or stop the deployment once you test and verify.

6. Click **Deploy**. This deploys the scheduled task to the development environment and indicates the **Scheduled Status** as **Active** in the **Development** card.

You can test the scheduled task when it runs at the configured time.

## Step 4: Test the scheduled task

When the scheduled task runs at the configured time, an email with the subject `[WSO2 Choreo Demo] Next 24H Weather Forecast` is sent from `choreo.demo@gmail.com` to the email address specified as the **email** configurable variable value in [Step 3](#step-3-deploy-the-scheduled-task).

If the scheduled task ran successfully, you should receive an email similar to the following:

![Received email](../../assets/img/develop-components/develop-a-scheduled-integration/Received-email.png)

## Step 5: Observe the scheduled task

The observability view in Choreo displays graphs that depict details such as throughput, latency, diagnostic data, and logs to identify and troubleshoot anomalies in components you deploy.

1. In the left navigation menu, click **Observability**.
2. Observe the following:
    - The throughput and latencies of requests served over a given period.
    - The logs generated over a given period.
    - The flame graph (Diagnostics View) generated over a given period.
    - The low-code diagram.

To learn more about the observability details you can view via Choreo observability, see [Observability Overview](../../monitoring-and-insights/observability-overview.md).

## Step 6: Monitor executions

To track and monitor executions associated with the deployed scheduled task, go to the left navigation menu and click **Execute**.

!!! tip
    The **Execute** view is applicable to both scheduled and manual tasks.

You can view the following information:

- **Total executions**: The total number of executions within the past 30 days.

    ![Total Execution](../../assets/img/develop-components/develop-a-scheduled-integration/total_executions.png)

- **Execution history**: The currently active executions and those that are already complete. You can view information such as the execution ID, the revision of the execution, and the time it was triggered.

    ![Execution History](../../assets/img/develop-components/develop-a-scheduled-integration/execution_history.png)

- **Detailed execution logs**: Click on an execution to view detailed logs related to it.

    !!! info
        It may take a few minutes for the logs to appear. You may need to manually refresh to view the latest logs.

    ![Execution Logs](../../assets/img/develop-components/develop-a-scheduled-integration/execution_logs.png)


# Develop an Event Handler

An event handler executes predefined actions in response to specific events. Choreo simplifies the process of creating and deploying such integrations.

This guide walks you through the steps to create and deploy an Event Handler using WSO2 MI and Choreo.

In this guide, you will build a simple event handler that monitors RabbitMQ for new messages and displays them once they become available.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Set up RabbitMQ:
    - Use an existing RabbitMQ instance or start a new [RabbitMQ](https://www.rabbitmq.com/download.html) instance on a server that can be accessed via the internet.
    - Obtain the `username`, `hostname`, `password`, and `vhost` from the RabbitMQ instance to use later as environment variables.

3. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

## Step 1: Create an event handler component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Event Handler** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following information:

    | **Field**             | **Description**              |
    |-----------------------|----------------------------- |
    | **Organization**      | Your GitHub account          |
    | **Repository**        | `choreo-samples`             |
    | **Branch**            | `main`                       |
    | **Component Directory** | `mi-rabbitmq-listener`       |

6. Select **WSO2 MI** as the build pack. (since you are creating the REST API from a [WSO2 Integration Studio](https://wso2.com/micro-integrator/) project)

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Component Directory** specifies the location of the project to build the component.

7. Enter a unique name and description for the component. You can use the following values:

    | **Field**          | **Value**              |
    |--------------------|------------------------|
    | **Component Name** | `SalesOrderListener`   |
    | **Description**    | `RabbitMQ integration` |

8. Click **Create**.

## Step 2: Deploy the integration

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**.
3. In the **Configurations** pane, click **+ Add** corresponding to **Environment Variables** and add the following environment variables:

    !!! tip
        Use the values from your RabbitMQ instance as per the [Prerequisites](#prerequisites) section for the environment variables.

    | **Name**     | **Value**                                         |
    | ------------- |--------------------------------------------------|
    | **HOSTNAME**  | Hostname of your RabbitMQ server                 |
    | **VHOST**     | Virtual hostname of your RabbitMQ server         |
    | **USERNAME**  | Username for connecting to RabbitMQ              |
    | **PASSWORD**  | Password associated with the RabbitMQ username   |

4. Click **Deploy**. This deploys the event handler to the development environment and indicates the **Deployment Status** as **Active** in the **Development** card.

## Step 3: Test the integration

1. Send a sales order message to the **SalesOrderQueue** on the RabbitMQ server. You can send a sample sales order message similar to the following:

    ```json
    {
        "order_id": "12345",
        "customer_name": "John Doe",
        "product": "Widget",
        "quantity": 10,
        "total_amount": 100.00
    }
    ```

2. Observe the logs:
    - In the left navigation menu, click **Logs** and then click **Runtime Logs**. You will see the order message in the logs.

Now you have gained hands-on experience in creating, configuring, and deploying an event handler.


# Develop an Integration with Integration Studio

Choreo simplifies the process of building, deploying, and managing integration components, making it easy to expose integrations as APIs. This guide walks you through the steps to expose an integration created in WSO2 Integration Studio as an API in Choreo.

In this guide, you will:
- Create a component to expose a sample integration from the [Choreo samples repository](https://github.com/wso2/choreo-samples) as an API.
- Deploy, test, and observe the integration component.
- Publish the integration component as an API to the Choreo Developer Portal.

!!! note
    - To develop integrations for **Manual Task** and **Schedule Task** components in Choreo, use the **automation mode** in the WSO2 Micro Integrator. See [Running MI in Automation Mode](https://apim.docs.wso2.com/en/4.2.0/install-and-setup/install/running-the-mi-in-automation-mode/).
    - For other component types (Service, webhook, event-handler, etc.), use the **server mode**.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    - Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    - Enter a unique organization name. For example, `Stark Industries`.
    - Read and accept the privacy policy and terms of use.
    - Click **Create**. This creates the organization and opens the **Project Home** page.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

## Step 1: Create the integration component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the **Project Home** page.

2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following repository details:

    | **Field**             | **Description**              |
    |-----------------------|----------------------------- |
    | **Organization**      | Your GitHub account          |
    | **Repository**        | `choreo-samples`            |
    | **Branch**            | **`main`**                   |
    | **Component Directory** | `hello-world-mi`             |

6. Select WSO2 MI as the build pack (since you're creating the REST API from a [WSO2 Integration Studio](https://wso2.com/micro-integrator/) project).

7. Provide a unique name and description for the component:

    | **Field**          | **Value**              |
    |--------------------|------------------------|
    | **Component Name** | `Hello World`          |
    | **Description**    | `Hello World REST API` |

8. Click **Create**. Choreo initializes the component with the sample integration.

## Step 2: Deploy the integration component

1. In the Choreo Console left navigation menu, click **Deploy**.

2. Configure and deploy:
   - In the **Build Area** card, click **Configure & Deploy**.
   - In the **Configurations** pane, click **Next**. This displays the endpoint details ready for deployment.
   - Click **Deploy**. This deploys the integration component to the development environment.

    !!! tip
        - Choreo uses [endpoints](../../choreo-concepts/endpoint.md) to expose **Service** components to the network. Learn more about configuring endpoints in [Configure Endpoints](../configure-endpoints.md).
        - Automatic deployment is enabled by default, so only the first deployment needs to be done manually.

   The **Development** card shows the **Deployment Status** as **Active** when the integration is successfully deployed.

## Step 3: Test the integration

1. In the Choreo Console left navigation menu, click **Test** and then click **Console**.
2. In the OpenAPI Console, select **Development** from the environment drop-down list.
3. Expand the **GET /integration** operation.
4. Click **Try it out**, then click **Execute**. This sends a request to your deployed integration.
5. Check the response:
    - In the **Response body** section, observe the response. If the integration works as expected, you should see:
     
     ```json
     {"Hello" : "Integration"}
     ```

## Step 4: Observe the integration

1. Click **Observability** in the left navigation menu to monitor the performance of the integration component.

2. View metrics:
   - Observe throughput and latencies of requests over time.
   - View logs generated during a specific period.
   - Analyze the flame graph (Diagnostics View) for performance insights.

   For more details, see [Observability Overview](../../monitoring-and-insights/observability-overview.md).

## Step 5: Publish the integration component

1. In the Choreo Console left navigation menu, click **Manage** and then click **Lifecycle**.
2. The **Lifecycle Management** pane shows the current lifecycle stage as **Created**.
3. Click **Publish**. This changes the lifecycle stage to **Published** and exposes the integration as an API in the Choreo Developer Portal.
   - To view the published API, click **Go to Devportal**. In the Developer Portal, you can manage subscriptions and generate access tokens for testing.

Now you have successfully exposed an integration designed in WSO2 Integration Studio as a REST API in Choreo!


# Develop an API Proxy from a GitHub Repository Source

An API proxy acts as an intermediary between an existing API and Choreo, intercepting all requests made to the API. It also functions as a managed API, allowing you to apply essential API management features such as security policies and rate limiting.

In this guide, you will:

- Create an API proxy component to expose an existing API.
- Deploy the API proxy.
- Test the API proxy to verify its functionality.
- Manage the API.
- Consume the API.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample proxy source](https://github.com/wso2/choreo-samples/tree/main/department-api-proxy-from-github).  

## Step 1: Create an API proxy

You can create an API proxy either by selecting the source from a GitHub repository, uploading an OpenAPI specification file, or providing an OpenAPI specification URL. This guide demonstrates how to create an API proxy using a GitHub repository as the source.

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **API Proxy** card. This opens the **Create an API Proxy** pane.

4. Click on **Authorize With GitHub** card under **Connect a Git Repository** section to connect your GitHub account.
    - If you haven’t connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
         - Read and write access to code and pull requests.
         - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.    

5. Enter the following repository details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **Repository**         | choreo-samples     |
    | **Branch**             | **`main`**         |
    | **API Directory**      | /department-api-proxy-from-github |

    !!! note
        To select the relevant directory, click on the **Edit** action next to the **API Directory** input field. Then, enter `department-api-proxy-from-github` as the directory name to quickly search and locate the correct directory.

6. Specify the following values as Proxy Metadata:

    !!! info
        The **Context** field must be unique and cannot be changed after creation.**Version** and **Target** are mandatory fields. **Target** can be changed at any time after the creation.

    | **Field**       | **Value**                                  |
    |-----------------|--------------------------------------------|
    | **Context**     | `department-service`                                   |
    | **Version**     | `v1.0`                                      |
    | **Target**      | `https://samples.choreoapps.dev/company/hr`|

7. Specify the following values as Component Details:

    !!! info
        The **Component Name** field must be unique and cannot be changed after creation. This value is automatically generated, but you can edit it if necessary.
        **Component Display Name** is a required field.

    | **Field**       | **Value**                                  |
    |-----------------|--------------------------------------------|
    | **Component Display Name**| `Department Service`                    |
    | **Component Name**        | `department-service`                    |
    | **Description**           | `This is a sample proxy for department service`     |    

8. Click **Create**. This creates the API proxy component and takes you to the **Build** page.

!!! note
    When you create an API proxy from a GitHub repository source, the GitHub source serves as the single source of truth. Therefore, any modifications, such as adding or deleting resources, must be made through the GitHub repository.

## Step 2: Build

!!! info
    The initial build starts automatically when you create the API proxy, and you will be redirected to the **Build** page. In this case, you can skip the steps below. If you need to manually trigger a build later, follow these steps.

1. On the project home page, click on the `Department Service` component you created. This takes you to the component overview page.
2. In the left navigation menu, click **Build**.
3. On the **Build** page, click **Build Latest**.

!!! note
    The build process may take some time. You can track progress in the **Build Details** pane. Once complete, the build status changes to **Success**.

## Step 3: Deploy the API proxy

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**. This opens the **Configure & Deploy** pane.
3. Select **External** as the **API Access Mode** and click **Deploy**. The **Development** card indicates the **Deployment Status** as **Active** when the API proxy is successfully deployed.

Now you are ready to test the API proxy.

## Step 4: Test the API proxy

Choreo allows you to test your API proxy using either the [integrated OpenAPI Console](../../testing/test-rest-endpoints-via-the-openapi-console.md) or [cURL](../../testing/test-apis-with-curl.md). In this guide, you will use the OpenAPI Console.

!!! tip
    Choreo enables OAuth 2.0 to secure APIs by default. Therefore, you need an access token to invoke an API.

    - Choreo automatically generates a key to test the API via the OpenAPI Console. To view the key, click the show key icon in the **Security Header** field.
    - To disable security for the entire API or a specific resource:
        1. In the left navigation menu, click **Deploy**.
        2. Go to the **Build Area** card and click **Security Settings**.
        3. In the **Security Settings** pane:
            - To disable security for the entire API, clear the **OAuth2** checkbox.
            - To disable security for a specific resource, expand the relevant resource and turn off the **Security** toggle.
        4. Click **Apply**.

1. In the left navigation menu, click **Test** and then click **OpenAPI Console**.
2. Select **Development** from the environment drop-down list.
3. Expand the `GET /department/{departmentId}` resource and click **Try it Out**.
4. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

    ![API proxy response](../../assets/img/develop-components/develop-a-rest-api-proxy/rest-api-proxy-response.png){.cInlineImage-full}

    This indicates that your API proxy is working as expected.

## Step 5: Manage the API proxy

Now that you have a tested API proxy, you can publish it and make it available for application developers to consume. In this guide, you will apply rate limiting to the API and publish it.

### Step 5.1: Apply rate limiting to the API proxy

1. In the left navigation menu, click **Deploy**.
2. Go to the required environment card and click the settings icon corresponding to **API Configuration**.
3. In the **CORS, Rate Limiting and Resiliency** pane, click **Rate Limiting** to expand the section.
4. Select **API Level** as the **Rate Limiting Level**.
5. Specify appropriate values for the **Request Limit** and **Time Unit** fields. You can proceed with the default values.
6. Click **Apply**. This applies the rate limiting level to the API proxy and redeploys it.

### Step 5.2: Publish the API proxy

1. In the left navigation menu, click **Lifecycle** under **Manage**. This takes you to the **Lifecycle** page.
2. Click **Publish**.
3. In the **Publish API** dialog, click **Confirm** to proceed with publishing the API. If you want to change the display name, make the necessary changes and then click **Confirm**. This changes the API lifecycle state to **Published**.

## Step 6: Invoke the API

To generate credentials for the published API and invoke it via the Choreo Developer Portal, follow these steps:

1. In the **Lifecycle** page, click **Go to Devportal**. This takes you to the `Department Service` in the Choreo Developer Portal.

2. **Invoke the API**:
    1. In the Developer Portal left navigation menu, click **Try Out**.
    2. In the **Endpoint** list, select **Development** as the environment to try out the API.
    3. Click **Get Test Key** to generate an access token.
    4. Expand the `GET /department/{departmentId}` resource and click **Try it out**.
    5. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

        ![Try out response](../../assets/img/develop-components/develop-a-rest-api-proxy/try-out-response.png){.cInlineImage-full}

Now, you have gained hands-on experience creating, deploying, testing, and publishing an API proxy using Choreo.


# Develop an API Proxy from Scratch

An API proxy acts as an intermediary between an existing API and Choreo, intercepting all requests made to the API. It also functions as a managed API, allowing you to apply essential API management features such as security policies and rate limiting.

In this guide, you will:

- Create an API proxy component to expose an existing API.
- Deploy the API proxy.
- Test the API proxy to verify its functionality.
- Manage the API.
- Consume the API.

## Prerequisites

- If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

## Step 1: Create an API proxy

To create an API proxy, you can either upload an OpenAPI specification or provide an OpenAPI specification URL. In this guide, you will specify a URL to an OpenAPI definition of a sample API.

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **API Proxy** card. This opens the **Create an API Proxy** pane.
4. Select **Creare from Scratch** option. 
5. Specify the following values as Proxy Metadata:

    | **Field**       | **Value**                                  |
    |-----------------|--------------------------------------------|
    | **Context**     | `department-service`                                   |
    | **Version**     | `v1.0`                                      |
    | **Target**      | `https://samples.choreoapps.dev/company/hr` |

6. Enter following details for the Component Details:

    !!! info
        The **Component Name** field must be unique and cannot be changed after creation.

    | **Field**                 | **Value**          |
    |---------------------------|--------------------|
    | **Component Display Name**| `Department Service`          |
    | **Component Name**        | `department-service`          |
    | **Description**           | `Sample proxy for department service`     |

7. Click **Create**. This creates the API proxy component and takes you to the **Deploy** page.

## Step 2: Define resources for the API proxy

To add a new resource that retrieves a department by the department ID, follow these steps:

1. In the left navigation menu, click **Develop** and then click **Resources**.
2. Select **GET** as the **HTTP Verb** and enter `/department/{departmentId}` as the **URI Pattern**.
3. Click **+** to add the resource.
4. Expand the added resource and specify the following values:

    | **Field**        | **Value**                            |
    |------------------|--------------------------------------|
    | **Operation ID** | `findDepartment`                     |
    | **Description**  | `Find a department by department ID` |

5. Remove the five default resources that start with `/*` by clicking the delete icon corresponding to each resource.
6. Click **Save**.

## Step 3: Deploy the API proxy

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**. This opens the **Configure & Deploy** pane.
3. Select **External** as the API access mode and click **Deploy**. The **Development** card indicates the **Deployment Status** as **Active** when the API proxy is successfully deployed.

Now you are ready to test the API proxy.

## Step 4: Test the API proxy

Choreo allows you to test your API proxy using either the [integrated OpenAPI Console](../../testing/test-rest-endpoints-via-the-openapi-console.md) or [cURL](../testing/test-apis-with-curl.md). In this guide, you will use the OpenAPI Console.

!!! tip
    Choreo enables OAuth 2.0 to secure APIs by default. Therefore, you need an access token to invoke an API.

    - Choreo automatically generates a key to test the API via the OpenAPI Console. To view the key, click the show key icon in the **Security Header** field.
    - To disable security for the entire API or a specific resource:
        1. In the left navigation menu, click **Deploy**.
        2. Go to the **Build Area** card and click **Security Settings**.
        3. In the **Security Settings** pane:
            - To disable security for the entire API, clear the **OAuth2** checkbox.
            - To disable security for a specific resource, expand the relevant resource and turn off the **Security** toggle.
        4. Click **Apply**.

1. In the left navigation menu, click **Test** and then click **OpenAPI Console**.
2. Select **Development** from the environment drop-down list.
3. Expand the `GET /department/{departmentId}` resource and click **Try it Out**.
4. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

    ![API proxy response](../../assets/img/develop-components/develop-a-rest-api-proxy/rest-api-proxy-response.png){.cInlineImage-full}

    This indicates that your API proxy is working as expected.

## Step 5: Manage the API proxy

Now that you have a tested API proxy, you can publish it and make it available for application developers to consume. In this guide, you will apply rate limiting to the API and publish it.

### Step 5.1: Apply rate limiting to the API proxy

1. In the left navigation menu, click **Deploy**.
2. Go to the required environment card and click the settings icon corresponding to **CORS, Rate Limiting and Resiliency**.
3. In the **CORS, Rate Limiting and Resiliency** pane, click **Rate Limiting** to expand the section.
4. Select **API Level** as the **Rate Limiting Level**.
5. Specify appropriate values for the **Request Limit** and **Time Unit** fields. You can proceed with the default values.
6. Click **Apply**. This applies the rate limiting level to the API proxy and redeploys it.

### Step 5.2: Publish the API proxy

1. In the left navigation menu, click **Lifecycle** under **Manage**. This takes you to the **Lifecycle** page.
2. Click **Publish**.
3. In the **Publish API** dialog, click **Confirm** to proceed with publishing the API. If you want to change the display name, make the necessary changes and then click **Confirm**. This changes the API lifecycle state to **Published**.

## Step 6: Invoke the API

To generate credentials for the published API and invoke it via the Choreo Developer Portal, follow these steps:

1. In the **Lifecycle** page, click **Go to Devportal**. This takes you to the `Department Service` in the Choreo Developer Portal.

2. **Invoke the API**:
    1. In the Developer Portal left navigation menu, click **Try Out**.
    2. In the **Endpoint** list, select **Development** as the environment to try out the API.
    3. Click **Get Test Key** to generate an access token.
    4. Expand the `GET /department/{departmentId}` resource and click **Try it out**.
    5. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

        ![Try out response](../../assets/img/develop-components/develop-a-rest-api-proxy/try-out-response.png){.cInlineImage-full}

Now, you have gained hands-on experience creating, deploying, testing, and publishing an API proxy using Choreo.

# Develop a Ballerina Service

Choreo allows you to develop and deploy applications using your preferred programming language. This guide demonstrates how to deploy a service component that exposes a REST API using the [Ballerina language](https://ballerina.io/). No prior knowledge of Ballerina is required to follow this guide.

A REST API is a web service that adheres to Representational State Transfer (REST) principles, using HTTP methods to access and manage resources. This guide walks you through building a Ballerina service component, deploying it on Choreo, and testing it with an HTTP client application.

In this guide, you will:

 - Build a simple greeting service using a sample implementation. The service has a single resource named `greet` that accepts a query parameter as input.
 - Deploy the service in Choreo.
 - Test the service.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    - Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    - Enter a unique organization name. For example, `Stark Industries`.
    - Read and accept the privacy policy and terms of use.
    - Click **Create**. This creates the organization and opens the **Project Home** page.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample greetings service](https://github.com/wso2/choreo-samples/tree/main/greeting-service) implementation in Ballerina.

### Learn the repository file structure

It’s important to understand the purpose of key files in the sample service. The table below provides an overview of each file in the greeter service:

!!! note
    The file paths are relative to `<sample-repository-dir>/greeting-service`.

| **Filepath**              | **Description**                                                |
|---------------------------|---------------------------------------------------------------|
| `service.bal`             | The greetings service code written in Ballerina.               |
| `tests/service_test.bal`  | Test files related to the `service.bal` file.                  |
| `Ballerina.toml`          | The Ballerina configuration file.                              |

Let’s get started!

## Step 1: Create a service component

To create a Ballerina service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the **Project Home** page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect your GitHub account. If you haven’t connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Provide the following repository details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **Repository**         | choreo-samples     |
    | **Branch**             | **`main`**         |
    |**Component Directory** | `/greeting-service` |

6. Select **Ballerina** as the buildpack.

7. Provide a display name, a unique name, and a description for the service component:

    !!! info
        The **Component Name** field specifies a unique identifier for the component. This name cannot be changed after creation.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Ballerina Greetings`   |
    | **Component Name**        | `ballerina-greetings`   |
    | **Description**           | Send greetings          |

8. Click **Create**. This creates the component and takes you to the **Overview** page.

You have successfully created a service that exposes a REST API written in Ballerina. Next, let’s build and deploy the service.

## Step 2: Build and deploy

Now that you’ve connected the source repository and configured the endpoint details, it’s time to build and deploy the service.

!!! note
    If you’re rebuilding the Ballerina service component after changing the Ballerina version, ensure that the version in the `Ballerina.toml` file matches the version in the `Dependencies.toml` file.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service may take a while. Track the progress via the logs in the **Build Details** pane. Once complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps:

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane, click **Next** to skip the configuration.
4. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service may take a while. Once deployed, the **Development** environment card shows the **Deployment Status** as **Active**.

Once deployed, you can test, manage, and observe the service like any other component in Choreo.

For detailed instructions, see the following sections:
- [Step 3: Test](../../testing/test-rest-endpoints-via-the-openapi-console.md)
- [Step 4: Manage](../../api-management/lifecycle-management.md)

## Manage the deployment

To view Kubernetes-level insights for detailed diagnosis of this Ballerina REST API, see Choreo’s [DevOps capabilities](../../devops-and-ci-cd/view-runtime-details.md).


# Develop a Service with Docker

Choreo allows you to create and deploy applications in any language. This guide demonstrates how to develop and deploy a containerized service component using a Dockerfile.

In this guide, you will:

 - Create a containerized service component using a sample service implementation. The sample service has a single resource named `greet` that accepts a query parameter as input.
 - Deploy the service in Choreo using a Dockerfile. The service will run on port 9090.
 - Test the service.

If you want to create a service component that exposes a Ballerina service, see [Develop a Ballerina Service](develop-a-ballerina-service.md).

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    - Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    - Enter a unique organization name. For example, `Stark Industries`.
    - Read and accept the privacy policy and terms of use.
    - Click **Create**. This creates the organization and opens the **Project Home** page.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample greetings service](https://github.com/wso2/choreo-samples/tree/main/greeting-service-go) implementation with the Dockerfile.

### Learn the repository file structure

It’s important to understand the purpose of key files in the sample service. The table below provides an overview of each file in the greeter service:

!!! note
    The file paths are relative to `<sample-repository-dir>/greeting-service-go`.

| **Filepath**               | **Description**                                                              |
|----------------------------|------------------------------------------------------------------------------|
| `main.go`                  | The Go-based greeter service code.                                           |
| `Dockerfile`               | The Dockerfile to build the container image of the application.              |
| `.choreo/component.yaml`   | Choreo-specific configuration that provides information about how Choreo exposes the service. |
| `openapi.yaml`             | The OpenAPI contract of the greeter service. This is required to publish the service as a managed API. This file is referenced by the `.choreo/component.yaml` file. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints. The greeter service runs on port 9090. To securely expose the service through Choreo, you must provide the port and other required information in the `component.yaml` file. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

In the greeter sample, the `component.yaml` file is located in the `greeting-service-go/.choreo/` directory.

## Step 1: Create a service component from a Dockerfile

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/cloud-native-app-developer) and sign in. This opens the **Project Home** page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect your GitHub account. If you haven’t connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
         - Read and write access to code and pull requests.
         - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following repository details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **Repository**         | choreo-samples     |
    | **Branch**             | `main`         |
    | **Component Directory** | `/greeting-service-go`         |

6. Select **Docker** as the buildpack.
7. Enter the following details:

    | **Field**                | **Value**                        |
    |--------------------------|----------------------------------|
    | **Dockerfile**           | `/greeting-service-go/Dockerfile`|

    !!! info
        1. To successfully build your container with Choreo, explicitly define a user ID (UID) under the `USER` instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-sample-apps/blob/main/go/greeter/Dockerfile).
           - A valid User ID is a numeric value between 10000-20000 (e.g., `10001` or `10500`).
           - Usernames are invalid and should not be used (e.g., `my-custom-user-12221` or `my-custom-user`).

        2. The Dockerfile used in this guide is a multi-stage Dockerfile, which keeps the final image size small and allows building the application with specific versions of tools and libraries.

8. Provide a display name, a unique name, and a description for the service component:

    !!! info
        The **Component Name** field specifies a unique identifier for the component. This name cannot be changed after creation.

    | **Field**                 | **Value**          |
    |---------------------------|--------------------|
    | **Component Display Name**| `Greetings`        |
    | **Component Name**        | `greetings`        |
    | **Description**           | Send greetings     |

9. Click **Create**. This creates the component and takes you to the **Overview** page.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you’ve connected the source repository and configured the endpoint details, it’s time to build the service and create an image. Then, you can deploy the image and test the greeter service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service may take a while. Track the progress via the logs in the **Build Details** pane. Once complete, the build status changes to **Success**.

    You can access the following scans under **Build**:
    - **Dockerfile Scan**: Choreo checks if a non-root user ID is assigned to the Docker container for security. If no non-root user is specified, the build will fail.
    - **Container (Trivy) Vulnerability Scan**: This detects vulnerabilities in the final Docker image. If critical vulnerabilities are found, the build will fail.

    !!! info
        If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps:

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service may take a while. Once deployed, the **Development** environment card shows the **Deployment Status** as **Active**.

Once deployed, you can [test](../../testing/test-rest-endpoints-via-the-openapi-console.md), [manage](../../api-management/lifecycle-management.md), and [observe](../../monitoring-and-insights/observability-overview.md) the service like any other component in Choreo.

To view Kubernetes-level insights for detailed diagnosis of this Dockerfile-based REST API, see [Choreo's DevOps capabilities](../../devops-and-ci-cd/view-runtime-details.md).


# Develop a Service

Choreo allows you to create and deploy applications in your preferred programming language. 

In this guide, you will:

- Build a simple greeting service using a sample service implementation. The sample implementation will have a single resource named `greet` that accepts a single query parameter as input.
- Deploy the service in Choreo using a `Go` buildpack. The service will run on port 9090.
- Test the service.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample greetings service](https://github.com/wso2/choreo-samples/tree/main/greeting-service-go) implementation in `Go`.

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the greeter service:

!!! note 
    The specified file paths are relative to `<sample-repository-dir>/greeting-service-go`.

| **Filepath**             | **Description**                                                               |
|--------------------------|-------------------------------------------------------------------------------|
| `main.go`                | The Go-based greeter service code.                                            |
| `.choreo/component.yaml` | Choreo-specific configuration that provides information about how Choreo exposes the service. |
| `openapi.yaml`           | The OpenAPI contract of the greeter service. This is required to publish the service as a managed API. This `openapi.yaml` file is referenced by the `.choreo/component.yaml` file. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints. To run the greeter service on port 9090 and securely expose it through Choreo, you must provide the port and other required information in the `component.yaml` file. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

In the greeter sample, the `component.yaml` file is located in the `greeting-service-go/.choreo/` directory.

## Step 1: Create a service component

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Public Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Under **Connect a Git Repository**, enter the following details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **GitHub Repository**  | choreo-samples     |
    | **Branch**             | main               |
    | **Component Directory** | `/greeting-service-go` |

6. Select **Go** as the buildpack.
7. Enter the following details:

    | **Field**                | **Value**              |
    |--------------------------|------------------------|
    | **Language Version**     | 1.x                    |

8. Provide component display name, name and description:

    !!! info
        The **Component Name** field must be unique and cannot be changed after creation.

    | **Field**                 | **Value**          |
    |---------------------------|--------------------|
    | **Component Display Name**| Greetings          |
    | **Component Name**        | greetings          |
    | **Description**           | Send greetings     |

9. Click **Create**. This creates the component and lists it under **Component Listing** on the project home page.

You have successfully created the service. The next step is to build and deploy it.

## Step 2: Build and deploy

Now that you have connected the source repository and configured the endpoint details, it's time to build and deploy the greeter service.

### Step 2.1: Build

1. On the project home page, click on the `Greetings` component you created. This takes you to the component overview page.
2. In the left navigation menu, click **Build**.
3. On the **Build** page, click **Build Latest**.

    !!! note
        The build process may take some time. You can track progress in the **Build Details** pane. Once complete, the build status changes to **Success**.

### Step 2.2: Deploy

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take some time. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

Once you have successfully deployed the service, you can [test](../../testing/test-rest-endpoints-via-the-openapi-console.md), [manage](../../api-management/lifecycle-management.md), and [observe](../../monitoring-and-insights/observability-overview.md) it like any other component type in Choreo.


# Expose a Ballerina GraphQL Endpoint via a Service

Choreo offers the flexibility to develop and deploy applications in a language of your preference. This guide shows you how to deploy a service component that exposes a GraphQL API using the Ballerina language in Choreo. No prior knowledge of the Ballerina language is required to follow this guide. 

GraphQL API is a query language and runtime that provides a single endpoint for retrieving flexible and efficient data in a strongly-typed and self-documenting way. By following this guide, you will build a service component in Ballerina and deploy it on Choreo for any GraphQL client application to utilize it.

This guide shows how to build a simple reading list service and deploy it in Choreo using Ballerina. The GraphQL endpoint you create in this guide has two operations: **Query** and **Mutation**. The Query type operations read the data in the data source, and the Mutation operations update the data in the data source. The reading list service has two queries and three mutations as follows:

### Queries

**Retrieve the reading list**

This resource accepts an optional filter, `status`, which filters the reading list by reading status. Accepted values for status are `reading`, `read`, and `to_read`.

**Sample request**:
```
$ curl -X POST -H "Content-Type: application/json" -d '{"query": "query {allBooks (status: \"reading\") { id title author status }}"}' http://localhost:8090
```

**Sample response**
```
$ {
  "data": {
    "allBooks": [
      {
        "id": 1,
        "title": "Sample Book",
        "author": "Test Author",
        "status": "to_read"
      }
    ]
  }
}
```

**Retrieve a book item from the reading list**

This resource accepts a filter, `id`, which will select the book item from the reading list by book id.  The id is an Integer value. 

**Sample request**
```
$ curl -X POST -H "Content-Type: application/json" -d '{"query": "query {book (id: 1) { id title author status }}"}' http://localhost:8090
```

**Sample response**
```
$ {
  "data": {
    "book": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "to_read"
    }
  }
}
```

### Mutations

**Add a book item to the reading list**

This remote function accepts a book record as the input and consists of the title and the author. When you add a new book to the reading list, the method updates the reading status of the newly added book to `to_read`. This method returns the added book item upon successful execution.


**Sample request**

```
$ curl -X POST -H "Content-type: application/json" -d '{ "query": "mutation { addBook(book: {title: \"Sample Book\", author: \"Test Author\"}) { id title author status } }" }' 'http://localhost:8090'
```

**Sample response**

```
$ {
  "data": {
    "addBook": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "to_read"
    }
  }
}
```

**Update the reading status of a book**

This remote function requires `id` and `status` as inputs to update the reading status of the selected book. The `id` refers to the id of the book. It is an integer.  The `status` refers to the reading status that needs to be updated. This method returns the updated book item upon successful execution.

**Sample request**

```
$ curl -X POST -H "Content-type: application/json" -d '{ "query": "mutation { setStatus(id: 1, status: \"reading\") { id title author status } }" }' 'http://localhost:8090'
```

**Sample response**

```
$ {
  "data": {
    "setStatus": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "reading"
    }
  }
}
```

**Delete a book item from the reading list**

This remote function requires the `id` as the input to delete the book item from the reading list. This method returns the removed book item upon successful execution.

**Sample request**

```
$ curl -X POST -H "Content-type: application/json" -d '{ "query": "mutation { deleteBook(id: 1) { id title author status } }" }' 'http://localhost:8090'
```

**Sample response**
```
$ {
  "data": {
    "deleteBook": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "reading"
    }
  }
}
```

Our next step is to set up the resources that you will require to follow the guide, including the sample reading list application and the Choreo GitHub app.

## Prerequisites

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample GraphQL service](https://github.com/wso2/choreo-samples/tree/main/reading-list-graphql) implementation for this guide.

Let's get started!

## Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the reading list service.

!!! note
    The following file paths are relative to the path `<sample-repository-dir>/reading-list-graphql`.

|Filepath                 | Description                                                     |
|-------------------------|-----------------------------------------------------------------|
| `service.bal`           | The reading list service code written in the Ballerina language.|
| `Ballerina.toml`        | The Ballerina configuration file.                               |
| `.choreo/component.yaml`| The configuration file with endpoint details.                   |

## Step 1: Create a service component 

To create a Ballerina service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**| `reading-list-graphql`    |.

6. Select **Ballerina** as the buildpack.

7. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Ballerina Reading List`|
    | **Component Name**        | `ballerina-reading-list`|
    | **Description**           | Manage a reading list   |

8. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service component that exposes a GraphQL API written in the Ballerina language. Next, let's build and deploy the service.

## Step 2: Build and deploy

Now that we have connected the source repository, it's time to build and deploy the reading list service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Configurations** pane that opens, click **Next** to skip the configuration.
4. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.
To build and deploy the service, follow the steps below:

Once you have successfully deployed your service, you can test, manage, and observe it like any other component type in Choreo.

For detailed instructions, see the following sections:

- [Step 3: Test](https://wso2.com/choreo/docs/testing/test-graphql-endpoints-via-the-graphql-console/)
- [Step 4: Manage](https://wso2.com/choreo/docs/manage/api-management/)


# Expose a gRPC Endpoint via a Service

Choreo allows you to create and deploy applications in your preferred programming language. One powerful option is gRPC, a high-performance and language-agnostic remote procedure call (RPC) framework. It utilizes [Protocol Buffers](https://github.com/protocolbuffers/protobuf) to define services and generate client/server code.

In this guide, you will learn to use Choreo to create a service component that exposes a gRPC server implemented in [Go](https://go.dev/), enabling efficient and scalable communication with any gRPC client application. No prior knowledge of the Go language is necessary to follow this guide.

By following this guide, you will:

- Create a simple gRPC server using a Service component.
- Link the containerized gRPC service to the Choreo component using the Dockerfile. 
    The greeter service has a single RPC method named `sayHello`. Following is the proto file the server and the client application are using:

    ```proto
    syntax = "proto3";
    option go_package = "github.com/wso2/choreo-samples/go-grpc/pkg";

    service greeter {
      rpc SayHello (HelloRequest) returns (HelloReply) {}
    }

    message HelloRequest {
      string name = 1;
    }

    message HelloReply {
      string message = 1;
    }
    ```

- Deploy the gRPC server component in Choreo. 
- Create a gRPC client using a Manual Trigger component. 
- Deploy the gRPC client.
- Invoke the gRPC server using a gRPC client and check the response through the Choreo log view.


## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample service](https://github.com/wso2/choreo-samples/tree/main/go-grpc) implementation for this guide.

Let's get started!

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the greeter service.

!!! note 
    The following file paths are relative to the path `<sample-repository-dir>/go-grpc`.

|File Path                |Description                                                                                   |
|-------------------------|----------------------------------------------------------------------------------------------|
| `main.go`               | The greeter service code written in the Go language.                                         |
| `greeter_client/main.go`| The greeter client application written in the Go language.                                   |
| `Dockerfile.server`     | The Dockerfile to build the container image of the server application.                       |
| `Dockerfile.client`     | The Dockerfile to build the container image of the client application.                       |
| `.choreo/component.yaml`| The Choreo-specific configuration that provides information about how Choreo exposes the service.|
| `pkg/greeter.proto`     | The interface definition of the gRPC service. This is used to generate the server and client stubs for the Go application.|

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints.

Let's run the gRPC server service component on port 8080. To securely expose the service through Choreo, you must provide the port and other required information to Choreo. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

Choreo looks for an `component.yaml` file inside the `.choreo` directory to configure the endpoint details of the containerized component. Ensure the `.choreo` directory is at the root of the Docker build context path.

In the gRPC server sample, the `component.yaml` file is at `go-grpc/.choreo/component.yaml`, where the build context path is `go-grpc`.

## Step 1: Create a service component with a gRPC endpoint

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
6. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

7. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory** | `go-grpc`                  |

8. Select **Docker** as the buildpack.
9. Enter the following information:
    
    | **Field**                | **Value**                  |
    |--------------------------|----------------------------|
    | **Dockerfile**           | `go-grpc/Dockerfile.server`|

    !!! info
        1.  To successfully build your container with Choreo, it is essential to explicitly define a User ID (UID) under the USER instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-samples/blob/main/go-grpc/Dockerfile.server).
        To ensure that the defined USER instruction is valid, it must conform to the following conditions:
            - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
            - Usernames are considered invalid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

        2. The Dockerfile utilized in this guide is a multi-stage Dockerfile, which is designed to keep the final image size small and provides the ability to build the application with a specific version of tools and libraries.

4. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go gRPC Server`        |
    | **Component Name**        | `go-grpc-server`        |
    | **Description**           | Send greetings          |
    
10. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you have connected the source repository, and configured the endpoint details, it's time to build the service and create an image. Then you can deploy the image and test the greeter service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

    You can access the following scans under **Build**. 

      - **The Dockerfile scan**: Choreo performs a scan to check if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
      - **Container (Trivy) vulnerability scan**: This detects vulnerabilities in the final docker image. 
      - **Container (Trivy) vulnerability scan**: The details of the vulnerabilities open in a separate pane. If this scan detects critical vulnerabilities, the build will fail.
     
        !!! info
            If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Environment Configurations** pane that opens, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

6. Once you have successfully deployed your service, navigate to the component overview page and copy the gRPC service URL. You need to provide that URL when setting up the client application later in this guide.

You have successfully deployed the gRPC server. Currently, the gRPC service is only accessible by the components deployed within the same project.

## Step 3: Invoke the gRPC service

Let's invoke the gRPC service that you created above, using a gRPC client. 

### Step 3.1: Create a manual task for the gRPC client

To create a manual task component, follow these steps:

1. On the Choreo Console header, click the **Project** list and select the project where you created the gRPC service component. This opens the project home page.
2. Go to the **Component Listing** section and click **+ Create**.
3. Click the **Manual Task** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**       | `go/grpc`                  |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                  |
    |--------------------------|----------------------------|
    | **Dockerfile**           | `go/grpc/Dockerfile.client`|

8. Enter a display name, a unique name, and a description for the component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go gRPC Client`        |
    | **Component Name**        | `go-grpc-client`        |
    | **Description**           | `Receive greetings`     |


9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

### Step 3.2: Build the gRPC client component

To build the component, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 3.3: Setup environment variables and deploy the gRPC client

The client application, in this case, the gRPC client, requires the server URL of the gRPC server service. This is read from the client application as an environment variable. Follow the steps below to configure the environment variable for the client application:

1. On the Choreo Console left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane that opens, click **+ Add**.
4. Specify the following name and value to configure the environment variable for the client application:

    | **Field**       | **Value**               |
    |-----------------|-------------------------|
    | **Name**        | `GREETER_SERVICE`       |
    | **Value**       | Paste the URL value copied after deploying the gRPC service via [step 2.2](#step-22-deploy) above.  Make sure to **drop the `http://` or `grpc://` part and the trailing `/` from the URL when copying**. For example, if the URL is `http://go-grpc-server-3192360657:8080/`, add only `go-grpc-server-3192360657:8080`.|

5.  Click **Add** and then click **Next**.
6.  Click **Deploy**.

### Step 3.4: Execute the gRPC client component

To execute the gRPC client, follow these steps:

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the gRPC client and generates logs.
   You can trigger multiple runs to generate multiple logs.

For details on what you can monitor via the execute page, see [Monitor executions](../develop-integrations/develop-a-manual-task.md#step-7-monitor-executions). 


# Expose a Prism-Based Mock Server Using an OpenAPI Specification

Choreo supports deploying [Prism-based](https://docs.stoplight.io/docs/prism/674b27b261c3c-prism-overview) mock servers using OpenAPI specifications. With the Choreo Prism mock service component, you can serve multiple mock servers, each based on a different OpenAPI specification, as separate endpoints.

By default, these mock servers serve static content generated from the examples in the configured OpenAPI Specification (OAS). 

## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [Prism mock service](https://github.com/wso2/choreo-samples/tree/main/prism-mock-service) artifacts for this guide.

## Step 1: Create a Prism mock service component

To create a Prism mock service component, follow these steps:
    
1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, you can paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    |**Component Directory**  | `prism-mock-service`    |

6. Select **Prism Mock** as the buildpack.
7. Enter a display name, a unique name, and a description for the service component.
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

8. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

## Step 2: Build and deploy the component

Now that you have successfully created the Prism mock service, it's time to build and deploy it.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**. This builds the service from the latest commit.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

Once you have successfully deployed the service, you can [test](../../testing/test-rest-endpoints-via-the-openapi-console.md), [manage](../../api-management/lifecycle-management.md), and [observe](../../monitoring-and-insights/observability-overview.md) it like any other component type in Choreo.

## Serve dynamic content

The Prism mock service can serve dynamic content according to the schema definitions in the OpenAPI specification. To use the Prism mock service with dynamic content, clients must add the `prefer:dynamic=true` header in the request.

To generate meaningful dynamic responses, you can use the `x-faker` attribute in schema definitions of the OpenAPI specification. For more information on dynamically generated responses with the `x-faker` attribute, see the [Prism documentation](https://docs.stoplight.io/docs/prism/9528b5a8272c0-dynamic-response-generation-with-faker).


# Expose a TCP Server via a Service

Choreo offers the flexibility to design and deploy applications in the programming language of your choice. One viable choice for specific network communication needs is TCP (Transmission Control Protocol). TCP provides a reliable, stream-oriented communication mechanism that ensures data integrity and orderliness during transmission. It's the go-to option for scenarios where guaranteed data delivery and error recovery are paramount.

In this guide, you will learn to use Choreo to create a service component that exposes a TCP server implemented in [Go](https://go.dev/), enabling efficient and scalable communication with any TCP client application. No prior knowledge of the Go language is necessary to follow this guide.

By following this guide, you will:

- Setup a TCP server
    - Create a simple TCP server using a service component.
    - Link the containerized TCP service to the Choreo component using a Dockerfile. 
    - Deploy the TCP server component in Choreo. 
- Setup a TCP client
    - Create a TCP client using a manual task component. 
    - Link the containerized TCP client to the Choreo component using a Dockerfile. 
    - Deploy the TCP client component in Choreo.
- Invoke the TCP server using a TCP client and observe the response through the Choreo log view.

## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample service](https://github.com/wso2/choreo-samples/tree/main/docker-tcp-service) implementation for this guide.

Let's get started!

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the sample service.

!!! note 
    The following file paths are relative to the path `<sample-repository-dir>/docker-tcp-service`.

|File Path                 |Description                                                                                   |
|--------------------------|----------------------------------------------------------------------------------------------|
| `server/main.go`         | The greeter service code written in the Go language.                                         |
| `client/main.go`         | The greeter client application written in the Go language.                                   |
| `Dockerfile.server`      | The Dockerfile to build the container image of the server application.                       |
| `Dockerfile.client`      | The Dockerfile to build the container image of the client application.                       |
| `.choreo/component.yaml` | The Choreo-specific configuration provides information about how Choreo exposes the service. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints.

Let's run the TCP server service component on port 5050. To securely expose the service through Choreo, you must provide the port and other required information to Choreo. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

Choreo looks for an `component.yaml` file inside the `.choreo` directory to configure the endpoint details of a containerized component. Place the `.choreo` directory at the root of the Docker build context path.

In our TCP server sample, the `component.yaml` file is at `docker-tcp-service/.choreo/component.yaml`, where the build context path is `docker-tcp-service`.

## Step 1: Create a service component with a TCP endpoint

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory** | `docker-tcp-service`                  |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-tcp-service/Dockerfile.server`|

    !!! info
        1.  To successfully build your container with Choreo, it is essential to explicitly define a User ID (UID) under the USER instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-samples/blob/main/docker-tcp-service/Dockerfile.server).
        To ensure that the defined USER instruction is valid, it must conform to the following conditions:
            - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
            - Usernames are considered invalid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

        2. The Dockerfile utilized in this guide is a multi-stage Dockerfile, which is designed to keep the final image size small and provides the ability to build the application with a specific version of tools and libraries.

8. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go TCP Server`         |
    | **Component Name**        | `go-tcp-server`         |
    | **Description**           | Send greetings          |
    
9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you have connected the source repository, and configured the endpoint details, it's time to build the service and create an image. Then you can deploy the image and test the service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

    You can access the following scans under **Build**. 

      - **The Dockerfile scan**: Choreo performs a scan to check if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
      - **Container (Trivy) vulnerability scan**: This detects vulnerabilities in the final docker image. 
      - **Container (Trivy) vulnerability scan**: The details of the vulnerabilities open in a separate pane. If this scan detects critical vulnerabilities, the build will fail.
     
        !!! info
            If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Environment Configurations** pane that opens, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

6. Once you have successfully deployed your service, navigate to the component overview page and copy the TCP service address. You need to provide that address when setting up the client application later in this guide.

You have successfully deployed the TCP server. Currently, the TCP service is only accessible by the components deployed within the same project.

## Step 3: Invoke the TCP service

Now let's use a TCP client to invoke the TCP service that you created above. To do this, you can create a manual trigger component as the TCP client. This is the recommended approach because, in this example, it's more efficient to have a client that connects to the server, sends a request, and then stops. Here, a continuously executing task isn't required. Furthermore, if you use a manual trigger component, you won't need to expose an endpoint in the client for invocation, unlike with an API.

### Step 3.1: Create a manual trigger for the TCP client

To create a manual task component, follow these steps:

1. On the Choreo Console header, click the **Project** list and select the project where you created the TCP service component. This opens the project home page.
2. Go to the **Component Listing** section and click **+ Create**.
3. Click the **Manual Task** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Docker Context**      |`docker-tcp-service`     |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-tcp-service/Dockerfile.client`|

8. Enter a display name, a unique name, and a description for the component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**              |
    |---------------------------|------------------------|
    | **Component Display Name**| `Go TCP Client`        |
    | **Component Name**        | `go-tcp-client`        |
    | **Description**           | `Receive greetings`    |


9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

### Step 3.2: Build the TCP client component

To build the component, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 3.3: Setup environment variables and deploy the TCP client

The client application, in this case, the TCP client, requires the server URL of the TCP server service. This is read from the client application as an environment variable. Follow the steps below to configure the environment variable for the client application:

1. On the Choreo Console left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane that opens, click **+ Add**.
4. Specify the following name and value to configure the environment variable for the client application:

    | **Field**       | **Value**               |
    |-----------------|-------------------------|
    | **Name**        | `SERVER_ADDRESS`       |
    | **Value**       | Paste the URL value copied after deploying the TCP service via [step 2.2](#step-22-deploy) above.  Make sure to **drop the `tcp://` part and the trailing `/` from the URL when copying**. For example, add only `go-tcp-server-1097922445:8080`.|

5.  Click **Add** and then click **Next**.
6.  Click **Deploy**.

### Step 3.4: Execute the TCP client component

To execute the TCP client, follow these steps:

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the TCP client and generates logs.
   You can trigger multiple runs to generate multiple logs.

For details on what you can monitor via the execute page, see [Monitor executions](../develop-integrations/develop-a-manual-task.md#step-7-monitor-executions).


# Expose a UDP Server via a Service

Choreo offers the flexibility to design and deploy applications in the programming language of your choice. One compelling choice for certain network communication needs is UDP (User Datagram Protocol). UDP is a high-speed, connectionless protocol ideal for scenarios where lightweight, real-time data transmission is essential.

In this guide, you will learn to use Choreo to create a Service component that exposes a UDP server implemented in [Go](https://go.dev/), enabling efficient and scalable communication with any UDP client application. No prior knowledge of the Go language is necessary to follow this guide.

By following this guide, you will:

- Setup a UDP server
    - Create a simple UDP server using a Service component.
    - Link the containerized UDP service to the Choreo component using the Dockerfile. 
    - Deploy the UDP server component in Choreo. 
- Setup a UDP client
    - Create a UDP client using a manual task component. 
    - Link the containerized UDP client to the Choreo component using the Dockerfile. 
    - Deploy the UDP client component in Choreo.
- Invoke the UDP server using a UDP client and check the response through the Choreo log view.

## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample service](https://github.com/wso2/choreo-samples/tree/main/docker-udp-service) implementation for this guide.

Let's get started!

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the sample service.

!!! note 
    The following file paths are relative to the path `<sample-repository-dir>/docker-udp-service`.

|File Path                |Description                                                                                   |
|-------------------------|----------------------------------------------------------------------------------------------|
| `server/main.go`        | The greeter service code written in the Go language.                                         |
| `client/main.go`        | The greeter client application written in the Go language.                                   |
| `Dockerfile.server`     | The Dockerfile to build the container image of the server application.                       |
| `Dockerfile.client`     | The Dockerfile to build the container image of the client application.                       |
| `.choreo/component.yaml`| The Choreo-specific configuration provides information about how Choreo exposes the service. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints.

Let's run the UDP server service component on port 5050. To securely expose the service through Choreo, you must provide the port and other required information to Choreo. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

Choreo looks for an `component.yaml` file inside the `.choreo` directory to configure the endpoint details of a containerized component. Place the `.choreo` directory at the root of the Docker build context path.

In our gRPC server sample, the `component.yaml` file is at `docker-udp-service/.choreo/component.yaml`, where the build context path is `docker-udp-service`.

## Step 1: Create a service component with a UDP endpoint

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
6. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

7. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**   | `docker-udp-service`    |    

8. Select **Docker** as the buildpack.
9. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-udp-service/Dockerfile.server`|

    !!! info
        1.  To successfully build your container with Choreo, it is essential to explicitly define a User ID (UID) under the USER instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-samples/blob/main/docker-udp-service/Dockerfile.server).
        To ensure that the defined USER instruction is valid, it must conform to the following conditions:
            - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
            - Usernames are considered invalid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

        2. The Dockerfile utilized in this guide is a multi-stage Dockerfile, which is designed to keep the final image size small and provides the ability to build the application with a specific version of tools and libraries.

4. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go UDP Server`         |
    | **Component Name**        | `go-udp-server`         |
    | **Description**           | Send greetings          |

10. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you have connected the source repository, and configured the endpoint details, it's time to build the service and create an image. Then you can deploy the image and test the service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

    You can access the following scans under **Build**. 

      - **The Dockerfile scan**: Choreo performs a scan to check if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
      - **Container (Trivy) vulnerability scan**: This detects vulnerabilities in the final docker image. 
      - **Container (Trivy) vulnerability scan**: The details of the vulnerabilities open in a separate pane. If this scan detects critical vulnerabilities, the build will fail.
     
        !!! info
            If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Environment Configurations** pane that opens, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

6. Once you have successfully deployed your service, navigate to the component overview page and copy the UDP service address. You must provide that address when setting up the client application later in this guide.

You have successfully deployed the UDP server. Currently, the UDP service is only accessible by the components deployed within the same project.

## Step 3: Invoke the UDP service

Now let's use a UDP client to invoke the UDP service that you created above. To do this, you can create a manual trigger component as the UDP client. This is the recommended approach because, in this example, it's more efficient to have a client that connects to the server, sends a request, and then stops. Here, a continuously executing task isn't required. Furthermore, if you use a manual trigger component, you won't need to expose an endpoint in the client for invocation, unlike with an API.

### Step 3.1: Create a manual trigger for the UDP client

To create a manual task component, follow these steps:

1. On the Choreo Console header, click the **Project** list and select the project where you created the UDP service component. This opens the project home page.
2. Go to the **Component Listing** section and click **+ Create**.
3. Click the **Manual Task** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory** | `docker-udp-service`    |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-udp-service/Dockerfile.client`|

8. Enter a display name, a unique name, and a description for the component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**              |
    |---------------------------|------------------------|
    | **Component Display Name**| `Go UDP Client`        |
    | **Component Name**        | `go-udp-client`        |
    | **Description**           | `Receive greetings`    |


9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

### Step 3.2: Build the UDP client component

To build the component, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 3.3: Setup environment variables and deploy the UDP client

The client application, in this case, the UDP client, requires the server URL of the UDP server service. This is read from the client application as an environment variable. Follow the steps below to configure the environment variable for the client application:

1. On the Choreo Console left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane that opens, click **+ Add**.
4. Specify the following name and value to configure the environment variable for the client application:

    | **Field**       | **Value**               |
    |-----------------|-------------------------|
    | **Name**        | `SERVER_ADDRESS`       |
    | **Value**       | Paste the URL value copied after deploying the UDP service via [step 2.2](#step-22-deploy) above.  Make sure to **drop the `udp://` part and the trailing `/` from the URL when copying**. For example, add only `go-udp-server-1097922445:8080`.|

5.  Click **Add** and then click **Next**.
6.  Click **Deploy**.

### Step 3.4: Execute the UDP client component

To execute the UDP client, follow these steps:

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the UDP client and generates logs.
   You can trigger multiple runs to generate multiple logs.

For details on what you can monitor via the execute page, see [Monitor executions](../develop-integrations/develop-a-manual-task.md#step-7-monitor-executions).


# Expose a WebSocket Endpoint via a Service

Choreo allows you to create and deploy applications in your preferred programming language, offering a seamless platform for building dynamic and scalable solutions. This guide walks you through the steps to deploy a WebSocket service using the NodeJS buildpack.

WebSockets provide real-time, two-way communication between a client and server over a persistent TCP connection. This makes WebSocket APIs ideal for applications that require real-time updates.

In this guide, you will:

- Build a simple WebSocket service using a sample implementation in NodeJS.
- Deploy the service in Choreo, allowing any WebSocket client application to establish a connection and exchange real-time messages with your service.

## Prerequisites

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample WebSocket service](https://github.com/wso2/choreo-samples/tree/main/websocket-chat-app) implementation for this guide.

Let's get started!

## Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the NodeJS chat Application.

!!! note
    The following file paths are relative to the path `<sample-repository-dir>/websocket-chat-app/websocket-chat-service-nodejs`.

|Filepath                        | Description                                                     |
|--------------------------------|-----------------------------------------------------------------|
| `server.js`                    | The NodeJS chat service.                                        |
| `.choreo/component.yaml`       | The configuration file with endpoint details.                   |

!!! note
    Choreo currently supports defining WebSocket APIs using the AsyncAPI 2.0 specification.

## Step 1: Create a service component 

To create a NodeJS service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**   | `websocket-chat-app/websocket-chat-service-nodejs`  |

6. Select **NodeJS** as the buildpack and **18.x.x** as the Language Version

8. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:

    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `NodeJS Chat Service`   |
    | **Component Name**        | `nodejs-chat-service`   |
    | **Description**           | Manage a chat service   |

9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service component that provides a WebSocket API built with NodeJS. The next step is to proceed with building and deploying the service.

## Step 2: Build and deploy

Now that you have connected the source repository, it's time to build and deploy the chat service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane that opens, click **Next** to skip the configuration.
4. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

Once you have successfully deployed your service, you can [test](../../testing/test-websocket-endpoints-via-the-websocket-console.md), [manage](../../api-management/lifecycle-management.md), and observe it like any other component type in Choreo.

During testing, once the WebSocket connection is established, you can send {"type": "Connect", "username": "user1"} to the WebSocket endpoint to connect to the chat service. You can then send chat messages by using {"type": "Data", "message": "Hello, World!"}.

!!! note
     Some clients, such as certain browsers, may not support adding headers to the WebSocket handshake. In these cases, you can include the access token or test key required for WebSocket API invocation within the `sec-websocket-protocol` header, along with any specified subprotocols.

     For example: `sec-websocket-protocol: choreo-oauth2-token, {access token}, subprotocols`

     If you are using a test key, replace `choreo-oauth2-token` with `choreo-test-key`.


# Service Component Overview

Explore how to create, deploy, manage, and observe service components in Choreo.

## What is a service component?

A service component in Choreo lets you deploy and expose REST, GraphQL, gRPC, UDP, WS or TCP services. It is a fundamental building block for creating cloud-native applications in Choreo. They provide a simple and effective way to expose functionality as a service to other components within Choreo or to the outside world.

Service components encapsulate business logic and provide standardized interfaces, called endpoints, for communicating with other components or systems. You can deploy and scale services independently, which makes them highly flexible and adaptable to changing workloads.

With the help of the service component, developers can quickly create APIs and microservices, making it easier to implement and manage complex software systems. Service components can also be integrated with other Choreo components, that acts as message processors, connectors, and data sources, etc to create powerful end-to-end solutions.

You can expose a service to other components through endpoints. For details on configuring endpoints, see [Configure Endpoints](../configure-endpoints.md).


# Build and Deploy a Single-Page Web Application

A web application is an application program hosted on a server and serves ingress traffic through a browser. In Choreo, you can deploy a web application by creating a Web Application component and connecting it to a Git repository that contains the implementation of the web application. Web applications can fall into one of the following categories:

- **Single page applications (SPAs)**: Examples include React, Angular, Vue, Svelte, etc.
- **Web servers**: These serve static content or provide server-side rendering/static site generation (SSR/SSG).
- **Static content**: Examples include websites and other static resources that do not require a backend, usually comprising static HTML/JS/CSS files.

## Prerequisites

- To deploy a web application component, you must have a GitHub account with a repository containing the web application's implementation. For this guide, fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample web application implementation.

## Create a web application

You can create a web application in Choreo as follows:

### Build and deploy a SPA from source code

1. To create a web application component, connect a repository that includes the web application source code.
2. Select the relevant buildpack: Default buildpacks include **React**, **Angular**, and **Vue.js**. If you are using a different SPA framework, you can try one of these buildpacks because the configurations can be overridden to support most JavaScript-based SPAs.
3. Enter the build command: Based on your package manager (NPM, yarn, or pnpm). The relevant package manager is run based on the dependency lock file in your repository (defaults to NPM if no lock file is present).
4. Specify the build output directory.
5. Specify the NodeJS version: Choreo does not pick the Node.js version from the `package.json` engine property. The required Node version must be explicitly set in the build configuration.

Once you create the Web Application component, Choreo automatically generates a build pipeline for your single-page application and deploys it.

### Bring your Dockerfile

1. To create a web application component, connect a repository that contains the Dockerfile for your containerized web application.
2. Commit a Dockerfile to your connected Git repository to have full control over your build process.

This approach is recommended if you are deploying a web server and not just a single-page application (or a single-page application with a complex build process).

### Host static websites

1. Create a web application component and connect it to the GitHub repository that contains the required static assets.
2. Select the **Static Websites** buildpack: This buildpack does not trigger a build process. It only fetches the files from the path specified in the repository and serves them as-is.

## Build and deploy a SPA from source code

Follow the steps below to create a sample Web Application component and deploy it in Choreo:

1. Sign in to the Choreo Console at [https://console.choreo.dev/login/](https://console.choreo.dev/login/). This opens the **Project Home** page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Web Application** card.
6. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

7. Enter the following information:

    | **Field**                 | **Description**        |
    |---------------------------|------------------------|
    | **GitHub Account**        | Your account           |
    | **GitHub Repository**     | choreo-samples         |
    | **Branch**                | main                   |
    | **Component Directory**     | /react-single-page-app |

8. Select **React** as the **Buildpack**.
9. Enter the following information:

    | **Field**                 | **Description**        |
    |---------------------------|------------------------|
    | **Build Command**         | `npm run build`        |
    | **Build Path**            | `build`                |
    | **Node Version**          | `18`                   |

    !!! tip
        Managed authentication is enabled by default when you create a web application using **React**, **Angular**, or **Vue.js** buildpacks. To learn how to set up authentication for your web application with Choreo's managed authentication, see [Secure Web Applications with Managed Authentication](../../authentication-and-authorization/secure-web-applications-with-managed-authentication.md).

4. Specify a display name, a unique name and description for the component.
10. Click **Create**. Choreo initializes the component with the sample implementation and opens the **Overview** page of the component.

You have successfully created a Web Application component from the source code. Now let's build and deploy the web application.

## Build your web application

1. In the left navigation menu, click **Build**.
2. In the **Builds** pane, click **Build**. This opens the **Commits** pane, where you can see all the commits related to the component.
3. Select the latest commit and click **Build**. This triggers the build process and displays the progress in the **Build Logs** pane.

    You can access the following scans in the **Build Logs** pane:

    - **Dockerfile Scan**: Choreo checks if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
    - **Container (Trivy) Vulnerability Scan**: Detects vulnerabilities in the final Docker image. If critical vulnerabilities are detected, the build will fail.

    !!! info
        If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

    !!! note
        The build process may take some time. Once complete, the build status will be listed in the **Builds** pane. Here, you will see the build status as **Success**.

## Deploy and access your web application

1. In the left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure and Deploy**. This opens the **Configure & Deploy** pane. In this guide, you do not need to add a file mount.
3. Click **Next** to proceed to the **Authentication Settings** pane.
4. Keep the default settings and click **Deploy**.

    !!! note
        The deployment process may take a few minutes. Once complete, the **Deployment Status** will show as **Active** in the **Development** card.

5. To verify that the web application is hosted successfully, click the **Web App URL** in the **Development** card. This takes you to the web application.

## Create a short URL for your web application in production

!!! info
    This feature is only available on the Choreo cloud data plane.

When you promote your component to the Production environment, you can create a personalized short URL for your web application. The URL follows the `https://{your-short-prefix}.choreoapps.dev` structure, where you can select a name of your preference for `{your-short-prefix}`.

1. Click **Promote** in the **Development** card and promote your web application to production.
2. In the **Production** card, click **Create a short URL**.
3. Specify a **Short URL prefix** of your choice and click **Save**.

    !!! note
        Short URL names/prefixes are subject to availability, provided on a first-come-first-serve basis.

## Manage runtime configurations for web applications

For web applications with a backend server, Choreo allows you to mount runtime configurations and secrets as environment variables and/or file mounts for a specific environment. Alternatively, you can also inject them into the client application during server-side rendering or when serving static content.

For SPAs that run completely on the browser, Choreo does not support *baking-in* environment variables or other configurations. Instead, Choreo recommends the following approach (applicable to most SPA frameworks, including React):

!!! note
    - With SPAs, anything you mount as a runtime config will be available to your users in the browser.
    - **Do not include sensitive secrets that are not browser-safe**.

1. Go to your forked [Choreo samples repository](https://github.com/wso2/choreo-samples).
2. Open the `public` directory.
3. Create and commit a new file named `config.js` in the `public` directory of your React application. This file should contain the runtime configuration variables you want to expose to your application, such as API endpoints or feature flags. For example:

    ```javascript
    window.config = {
        apiUrl: 'https://api.example.com',
        featureFlags: {
            enableNewFeature: true,
            enableExperimentalFeature: false,
        },
    };
    ```

4. In your `index.html` file inside the `public` directory, add a script tag to include the `config.js` file inside the `<body>` tag:

    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>My React App</title>
    </head>
    <body>
        <div id="root"></div>
        <script src="%PUBLIC_URL%/config.js"></script>
    </body>
    </html>
    ```

5. In your React component, access the configuration variables by referencing the `window.config` object:

    ```javascript
    import React from 'react';

    function MyComponent() {
        const apiUrl = window.config.apiUrl;
        const enableNewFeature = window.config.featureFlags.enableNewFeature;
        const enableExperimentalFeature = window.config.featureFlags.enableExperimentalFeature;

        // ...
    }
    ```

6. When you deploy your component to Choreo, create a config file mount in the specified path for each environment (where your `index.html` expects the `config.js` file). For more details, see [Manage Configurations and Secrets](https://wso2.com/choreo/docs/devops-and-ci-cd/manage-configurations-and-secrets/#apply-a-file-mount-to-your-container).

## Limitations

The following limitations are specific to the Choreo cloud data plane:

- **Request size limit**: 256KB (including headers, cookies, and payloads).
- **Response body size limit**: 20MB.
- **Open ports**: Only one open port is permitted per web application. While you can have multiple ports open for project-level communication within a data plane, incoming traffic from the internet can only be directed to one port. This differs from Service-type components, which support multiple endpoints.

## Troubleshoot a web application

- **Blank page or 502 error after deployment**:
    If you encounter a blank page or a 502 error after deploying your web application, it typically indicates that the wrong directory is being served. To resolve this issue:
    1. Double-check the build output directory, especially if you are using a Dockerfile-less buildpack.
    2. Ensure that the specified output directory matches the actual output directory generated during the build process. For example, if you have erroneously entered `public/` as the output directory when it should have been `build/`.

By verifying and correcting the output directory alignment, you should be able to address the issue of encountering a blank page or experiencing a 502 error on deploying your web application.


# Develop Web Applications Locally with Choreo’s Managed Authentication

Choreo’s managed authentication capability provides a set of backend for frontend (BFF) endpoints to facilitate authentication and authorization for web applications. These endpoints are readily available for single-page web applications deployed on Choreo.

As a web application developer, you may need to run the application on your local workstation. Choreo’s local development capability ensures that authentication and authorization during local development work the same way as they do when the application is deployed to Choreo, eliminating the need for code changes.

This guide explains how to configure and use Choreo’s local development capability to streamline your workflow.

## How local development works in Choreo

Local development uses a proxy that sits in front of the locally running web application. This proxy intercepts all incoming requests:
- Requests to `/choreo-apis/*` and `/auth/*` are forwarded to Choreo.
- All other requests are forwarded to the locally running web application.

The proxy runs on HTTPS using a self-signed certificate, which is essential for secure, HTTP-only cookie-based managed authentication. Once the proxy is running, you can access the web application using the proxy's URL and start developing locally. The behavior of the web application, in terms of managed authentication, will mirror its behavior when deployed to Choreo.

## Configure local development

### Prerequisites

- Create a single-page application (SPA) with managed authentication enabled. For details, see [Secure Web Applications with Managed Authentication](../../authentication-and-authorization/secure-web-applications-with-managed-authentication.md#step-1-set-up-managed-authentication-for-your-web-application).
- Promote and deploy the application to the environment where you want to enable local development.

    !!! note
        - The locally running web application will use the same managed authentication configuration as the environment where local development is configured.
        - Local development is only allowed in non-critical environments.

### Apply configurations

1. Sign in to the Choreo Console.
2. In the **Component Listing** pane, click on the component you created and deployed.
3. In the left navigation menu, click **Deploy**.
4. Go to the respective environment card and click **Local Development**.
5. In the **Local Development** pane, toggle **Local Development** to enable it.
6. (Optional) To update the port on which the local development proxy server runs, expand **Advanced Configurations** and specify a value for **Proxy Port**.
7. Click **Apply**.

You have now configured local development. The next section explains how to access your web application for local development.

## Access your web application locally

### Prerequisites

- Ensure local development is enabled in the desired environment.
- Ensure your web application is running locally on `http://localhost` on a specific port.

### Access your web application locally

You can use either the Choreo built-in identity provider or an external identity provider to access your web application locally.

=== "Use the Choreo built-in identity provider"

    1. Sign in to the Choreo Console.
    2. In the **Component Listing** pane, click on the component you created and deployed.
    3. In the left navigation menu, click **Deploy**.
    4. Go to the respective environment card and click **Local Development**.
    5. In the **Local Development** pane, copy the command under **Step 1**.
    6. Paste the command in a terminal, replace `[APP_PORT]` with the port on which your application is running locally, and run the command.
    7. To access the application, go to the URL provided under **Step 2** in the **Local Development** pane.

        !!! note
            The local development proxy runs on HTTPS using a self-signed certificate. Your browser may warn that the certificate is not valid. Accept the risk and proceed.

=== "Use an external identity provider"

    1. Sign in to the Choreo Console.
    2. In the **Component Listing** pane, click on the component you created and deployed.
    3. In the left navigation menu, click **Deploy**.
    4. Go to the respective environment card and click **Local Development**.
    5. In the **Local Development** pane, copy the redirect URLs under **Step 1**.
    6. Go to the settings in the OAuth application in your identity provider and specify the copied URLs as allowed redirect URLs.
    7. In the **Local Development** pane, copy the command under **Step 2**.
    8. Paste the command in a terminal, replace `[APP_PORT]` with the port on which your application is running locally, and run the command.
    9. To access the application, go to the URL provided under **Step 3** in the **Local Development** pane.

        !!! note
            The local development proxy runs on HTTPS using a self-signed certificate. Your browser may warn that the certificate is not valid. Accept the risk and proceed.


# Create a Connection

Connections in Choreo provide a simple and uniform approach to seamlessly integrate components with services or resources.

Choreo allows you to create connections to services deployed in Choreo or registered as external services. It also allows you to create connections to any Choreo-managed database.

To create a connection to a service or a database, follow the step-by-step instructions in the respective tab:

=== "Create a connection to a service"

    <h2>Create a connection to a Choreo service</h2>

    Follow these steps to create a connection to a service deployed in Choreo:

    1. In the Choreo Console, go to the top navigation menu and set the visibility level as [project](../../choreo-concepts/connections.md#project-connections) or [component](../../choreo-concepts/connections.md#component-connections) as follows: 

        - **Project Connection**: Select an organization and a project in that organization. 
        - **Component Connection**: Select an organization, a project in that organization, and a component in the selected project. 

    2. In the left navigation menu, click **Dependencies**  and then **Connections**. This page lists all the existing connections.
    3. Click **+Create**. This opens the Marketplace view where you can browse and search for services or databases.
    4. Click the **Services** tab. You can search and apply filters to efficiently find a service.
    5. Click on the service you want to connect to. 
    6. Enter a name and a description for the connection.
    7. Select an **Access Mode** and **Authentication Scheme** for the connection.
    8. Click **Create**.
   
    This creates the connection and displays its details for each environment, along with an inline guide on how to use the connection in your component. 

    !!! note
        During connection creation, secret values for the lowest environment are visible, allowing you to copy them for local use if necessary. Secret values for higher environments remain hidden to ensure security
     
    <h2>Create a connection to an external service</h2>

    Follow these steps to create a connection to an external service:

    1. Follow steps 1–5 from the previous section.
    2. Expand the **Environment to Endpoint** section and verify the service endpoints assigned to the Choreo environments.
    3. Click **Create**.

      For step-by-step instructions on using a connection in your service, see [Use a Connection in Your Service](./use-a-connection-in-your-service.md).

      For step-by-step instructions on using a connection in your web application, see [Use a Connection in Your Web Application](./use-a-connection-in-your-web-application.md).


=== "Create a connection to a database"

    Prerequisites:

     - Create a Choreo-managed database. For details, see [Choreo-Managed Databases and Caches](../../manage-databases-and-caches/choreo-managed-databases-and-caches.md).
     - Add the database to the Marketplace. For details, see [Add Choreo-Managed Databases and Caches to the Marketplace](../../manage-databases-and-caches/add-choreo-managed-databases-and-caches-to-the-marketplace.md).

    Follow these steps to create a connection to a Choreo-managed database:

    1. In the Choreo Console, go to the top navigation menu and set the visibility level as [project](../../choreo-concepts/connections.md#project-connections) or [component](../../choreo-concepts/connections.md#component-connections) as follows: 

        - **Project Connection**: Select an organization and a project in that organization. 
        - **Component Connection**: Select an organization, a project in that organization, and a component in the selected project. 

    2. In the left navigation menu, click **Dependencies**  and then **Connections**. This page lists all the existing connections.
    3. Click **+Create**. This opens the Marketplace view where you can browse and search for services or databases.
    4. Click the **Databases** tab. You can search and apply filters to efficiently find a database.
    5. Click on the database you want to connect to. 
    6. To create the connection, follow these steps:

        1. Enter a name and description.
        2. Under **Environment Configuration**, select credentials for each environment.

            !!! note
                 By default, the selected database is applied to all environments. To use different databases for specific environments, select the appropriate database and provide the corresponding credentials for each environment.

        3. Click **Create**.  
    
    This creates the connection and displays the database connection details for each environment, along with an inline guide on how to use the connection in your component. 

    !!! note
        During connection creation, secret values for the lowest environment are visible, allowing you to copy them for local use if necessary. Secret values for higher environments remain hidden to ensure security
    
    For step-by-step instructions on using a database in your component, see [Use a Database Connection in Your Component](./use-a-database-connection-in-your-component.md).


# Use a Connection in Your Service

Choreo allows you to share and reuse your services, accelerating development and enhancing efficiency in building integrated applications through connections.

For step-by-step on instruction on creating a connection, see [Create a Connection](create-a-connection.md).

To learn more about Choreo Connections, see the documentation on [Connections](../../choreo-concepts/connections.md).

## Consume a service through a connection

You can consume a Choreo-deployed service within another service. Consuming connections from within Choreo services is seamless and straightforward. Follow the steps below to consume a Choreo service:

### Step 1: Add connection configurations

To integrate another service into your application, click the appropriate tab below based on your current configuration file and follow the step-by-step instructions:

=== "Component.yaml file (v1.1)"

    1. Copy and paste the snippet from the in-line developer guide into the `component.yaml` file.

        The following is a sample snippet: 

        ``` yaml

        dependencies:
            connectionReferences:
            - name: <CONNECTION_NAME>
              resourceRef: <RESOURCE_IDENTIFIER>

        ```

          | Field            | Description                                                         |
          |------------------|---------------------------------------------------------------------|
          | name             | The name given to the connection.                                   |
          | resourceRef      | A unique, readable identifier of the service being connected to.    |


    2. If you've previously added a `connectionReferences` section under `dependencies`, append this as another item under `connectionReferences`. Upon deploying the component, Choreo automatically creates a subscription if applicable and the necessary configurations to establish the connection will be injected into the Choreo-defined environment variables.
      
          The following table details the Choreo-defined environment variables:

          | Configuration Key       | Choreo-Defined Environment Variable Name                       |
          |-------------------------|----------------------------------------------------------------|
          | ServiceURL              | CHOREO_<CONNECTION_NAME\>_SERVICEURL                           |
          | ConsumerKey             | CHOREO_<CONNECTION_NAME\>_CONSUMERKEY                          |
          | ConsumerSecret          | CHOREO_<CONNECTION_NAME\>_CONSUMERSECRET                       |
          | TokenURL                | CHOREO_<CONNECTION_NAME\>_TOKENURL                             |
          | ChoreoAPIKey            | CHOREO_<CONNECTION_NAME\>CHOREOAPIKEY                          |


          If you want to use custom environment variable names instead of the Choreo-defined ones, you must define the environment configurations under the `configuration` section in the same file.
          The following is a sample snippet: 

          ``` yaml
          configuration:
            env:
              - name: HR_SERVICE_URL
                valueFrom:
                  connectionRef:
                    name: hr-connection
                    key: ServiceURL
          ```

          The following table provides details on the configuration keys associated with the connection. These keys can be referenced as `env[i].valueFrom.connectionRef.key`.

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | ServiceURL     | string     | Service URL of the Choreo service     | false         | false        |
          | ConsumerKey    | string     | Consumer key of the Choreo service    | false         | false        |
          | ConsumerSecret | string     | Consumer secret of the Choreo service | false         | true         |
          | TokenURL       | string     | Token URL of the STS                  | false         | false        |
          | ChoreoAPIKey   | string     | API key of the Choreo service         | false         | true         |

          For more details, see the instructions under the **component.yaml file (v1.1)** tab.

    ### Step 2: Read configurations within the application

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const serviceURL = process.env.CHOREO_<CONNECTION_NAME>_SERVICEURL;
    ```

=== "Component.yaml file (v1.0)"

    !!! note
        This `component.yaml v1.0` is a legacy configuration format. For new projects, we recommend using the latest version (v1.1) of `component.yaml` for improved usability and features.
  
    1. Copy and paste the snippet from the in-line developer guide into the `component.yaml` file.
      
        The following is a sample snippet:

        ``` yaml

        dependencies:
            serviceReferences:
            - name: <SERVICE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: ServiceURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerSecret
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: TokenURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ChoreoAPIKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>

        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the service you are connecting to.              |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added a service reference section under `dependencies`, append this as another item under `serviceReferences`. 

          Upon deploying the component, Choreo automatically creates a subscription if applicable and populates the specified environment variables with actual values.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | ServiceURL     | string     | Service URL of the Choreo service     | false         | false        |
          | ConsumerKey    | string     | Consumer key of the Choreo service    | false         | false        |
          | ConsumerSecret | string     | Consumer secret of the Choreo service | false         | true         |
          | TokenURL       | string     | Token URL of the STS                  | false         | false        |
          | ChoreoAPIKey   | string     | API key of the Choreo service         | false         | true         |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const serviceURL = process.env.SVC_URL;
    ```

=== "Component-config.yaml file"

    !!! note
        This `component-config.yaml` is a legacy configuration format. For new projects, we recommend using the latest version (v1.1) of `component.yaml` for improved usability and features.

    1. Copy and paste the snippet from the in-line developer guide into the `component-config` file under the `spec` section.

        The following is a sample snippet:

        ``` yaml

        outbound:
            serviceReferences:
            - name: <SERVICE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: ServiceURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerSecret
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: TokenURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ChoreoAPIKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>

        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the service you are connecting to.              |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added an outbound service reference, append this as another item under `serviceReferences`. 

          Upon deploying the component, Choreo automatically creates a subscription if applicable and populates the specified environment variables with actual values.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | ServiceURL     | string     | Service URL of the Choreo service     | false         | false        |
          | ConsumerKey    | string     | Consumer key of the Choreo service    | false         | false        |
          | ConsumerSecret | string     | Consumer secret of the Choreo service | false         | true         |
          | TokenURL       | string     | Token URL of the STS                  | false         | false        |
          | ChoreoAPIKey   | string     | API key of the Choreo service         | false         | true         |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const serviceURL = process.env.SVC_URL;
    ```

If you're using the API key security scheme for the connection, skip Step 3 and follow the instructions in [Step 4: API key security scheme](#step-4-invoke-the-service) tab.

### Step 3: Acquire an OAuth 2.0 access token

To consume a Choreo service with the visibility level set to organization or public and secured by the OAuth 2.0 security scheme, you must obtain an OAuth 2.0 token from the token endpoint. Subsequently, you can use the token to invoke the service.

- For languages with OAuth 2.0-aware HTTP clients, you must pass the OAuth 2.0-related configurations such as client id, client secret and so on, obtained when creating the connection to your HTTP client configuration. The HTTP client autonomously manages token retrieval and refreshing.

- For languages without OAuth 2.0-aware HTTP clients, you must manually initiate a call to the token endpoint. This includes fetching the token and managing token expiration and refresh directly within your application code. The following is a sample curl command to obtain a token:


    ```bash
    CONSUMER_KEY="your_consumer_key"
    CONSUMER_SECRET="your_consumer_secret"
    TOKEN_URL="your_token_url"

    # Encode client credentials as Base64
    CLIENT_CREDENTIALS=$(echo -n "$CLIENT_ID:$CLIENT_SECRET" | base64)

    curl -X POST $TOKEN_URL \
      -H "Content-Type: application/x-www-form-urlencoded" \
      -H "Authorization: Basic $CLIENT_CREDENTIALS" \
      --data-urlencode "grant_type=client_credentials"

    ```

### Step 4: Invoke the service

Click the tab that matches the security scheme of your service and follow the instructions below:

=== "API key security scheme"

     To invoke the API, use the `choreo-api-key` header with the API key value retrieved from the corresponding environment variable as described in [step 2](#step-2-read-configurations-within-the-application).

     The following is a sample code snippet in NodeJS:

     ``` java
       const response = await axios.get(serviceURL/{RESOURCE_PATH}, {
           headers: {
             'Choreo-API-Key': `${choreoApiKey}`
           }
       });
     ```

=== "OAuth 2.0 security scheme"

     To invoke the service, use the following instructions based on your programming language:

      - For languages with OAuth 2.0-aware HTTP clients, use the service URL resolved in [Step 2](#step-2-read-configurations-within-the-application). The OAuth-aware client manages authentication automatically. For sample requests and responses, see the API definition provided via the Choreo marketplace for the service.

      - For languages without OAuth 2.0-aware HTTP clients, use the token obtained in [step 3](#step-3-acquire-an-oauth-20-access-token) to make calls to the dependent service. Subsequently, add the obtained token to the HTTP authorization header with the bearer prefix. As the service URL, use the URL resolved in [step 2](#step-2-read-configurations-within-the-application). For sample requests and responses, see the API definition of the service provided via the Choreo marketplace.

       The following is a sample code snippet in NodeJS:

       ``` java
       const response = await axios.get(serviceURL/{RESOURCE_PATH}, {
           headers: {
             'Authorization': `Bearer ${accessToken}`
             'Choreo-API-Key': `${choreoApiKey}`
           }
       });
       ```

    !!! note
        If you want to consume a Choreo service at the project visibility level, you don't need to obtain a token. You can directly invoke the service using the resolved URL.


# Use a Connection in Your Web Application

Choreo simplifies the process of integrating services into your web application. The approach to connect to a service can vary based on your web application. 

To connect to a selected service, follow the step-by-step instructions given below depending on the authentication mechanism used in your web application.

=== "Managed authentication"
    
    Choreo-managed authentication allows you to seamlessly handle authentication for your web application. You can configure your web application to work with the built-in identity provider of Choreo or any external identity provider that supports OIDC/OAuth2.0

    !!! note 
         Choreo's managed authentication is currently available only for web applications created with **React**, **Angular**, or **Vue.js** buildpacks.

    Follow the steps below to use an existing connection within your web application: 

    <h2> Step 1: Add the connection configuration</h2>

    To integrate a service into your application, you must first add the connection configuration as follows: 

    1. For single page applications (SPAs), you must add the connection configuration as a file mount. You can mount a file via the **Configurations** pane on the **Deploy** page. You must mount a file (for example, `config.js`) and add the configuration provided in the inline developer documentation into it. 

        The following is a sample configuration:

        ``` yaml
             window.configs = {
                 apiUrl: '<SERVICE_URL>',        
             };

        ```

    2.  To ensure accessibility of the `config.js` file via JavaScript at runtime, add a script tag as follows in the `index.html` file to reference the `config.js` file:

        ``` html
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="utf-8" />
            <title>My React App</title>
        </head>
        <body>
            <div id="root"></div>
            <script src="/public/config.js"></script>
        </body>
        </html>
        ``` 

        !!! note
             If you use an external IdP, you must add the IdP's configuration to the same file.
    
             For more information on working with IdPs, see [Configure Asgardeo as an External Identity Provider](https://wso2.com/choreo/docs/administer/configure-an-external-idp/configure-asgardeo-as-an-external-idp/).


    <h2> Step 2: Read the configuration</h2>

    Once you add the connection configuration, you can proceed to read the configuration from your application. The steps to read depend on the programming language you use.

    The following is a sample code snippet in NodeJS:

    ``` java
         const serviceURL = window?.configs?.apiUrl ? window.configs.apiUrl : "/";
    ```

    <h2> Step 3: Invoke the service</h2>

    If you use Choreo-managed authentication, Choreo handles the security handshaking for the application during deployment. The connected service will be accessible under the same domain as your application. Therefore, you can call the configured path directly using your preferred HTTP client.

    The following is a sample code snippet in NodeJS:

    ``` java
         const response = await axios.get(serviceURL/{RESOURCE_PATH});
    ```

    !!! note
         If you are using an external IdP provider instead of Choreo-managed authentication, you must obtain an access token from your IdP and add it to the HTTP authorization header with the bearer prefix.


=== "Custom authentication or no authentication"

    If you are not using Choreo-managed authentication or your web application lacks authentication, follow the steps below to connect to a service from your web application:

    <h2> Step 1: Add the connection configuration</h2>

    1. For single-page applications (SPAs), you must add the connection configuration as a file mount. You can mount a file via the **Configurations** pane on the **Deploy** page. You must mount a file (for example, `config.js`) and add the configuration provided in the inline developer documentation into it.
 
        The following is a sample configuration:

        ``` yaml
             window.configs = {
                 apiUrl: '<SERVICE_URL>',
                 consumerKey: '<CONSUMER_KEY>',
                 consumerSecret: '<CONSUMER_SECRET>',
                 tokenUrl: '<TOKEN_URL>',
             };
        ```

    2.  To ensure accessibility of the `config.js` file via JavaScript at runtime, add a script tag as follows in the `index.html` file to reference the `config.js` file:

        ``` html
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="utf-8" />
            <title>My React App</title>
        </head>
        <body>
            <div id="root"></div>
            <script src="/public/config.js"></script>
        </body>
        </html>
        ``` 

    For other types of web applications, you must add the respective configuration into your application.

    <h2> Step 2: Read the configuration</h2>

    Once you have added the connection configuration, you can proceed to read the configuration from your application. The steps to read depend on the programming language you use.

    The following is a sample code snippet in NodeJS:

    ``` java
         const serviceURL = window?.configs?.apiUrl ? window.configs.apiUrl : "/";
    ```

    <h2> Step 3: Acquire an OAuth 2.0 access token</h2>

    - For languages with OAuth 2.0-aware HTTP clients, you must pass the OAuth 2.0-related configurations such as client id, client secret and so on, obtained when creating the connection to your HTTP client configuration. The HTTP client autonomously manages token retrieval and refreshing.
  
    - For languages without OAuth 2.0-aware HTTP clients, you must manually initiate a call to the token endpoint. This includes fetching the token and managing token expiration and refresh directly within your application code. The following is a sample curl command to obtain a token:


        ```bash
        CONSUMER_KEY="your_consumer_key"
        CONSUMER_SECRET="your_consumer_secret"
        TOKEN_URL="your_token_url"

        # Encode client credentials as Base64
        CLIENT_CREDENTIALS=$(echo -n "$CLIENT_ID:$CLIENT_SECRET" | base64)

        curl -X POST $TOKEN_URL \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -H "Authorization: Basic $CLIENT_CREDENTIALS" \
        --data-urlencode "grant_type=client_credentials"

        ```

    <h2> Step 4: Invoke the service</h2>

    You can invoke the service as follows:

    - For languages with OAuth 2.0-aware HTTP clients, you can invoke the service in a straightforward manner. The HTTP client seamlessly manages OAuth 2.0 authentication without requiring additional intervention.

        As the service URL you can use the URL that you resolved in step 2 above. For sample requests and responses, see the API definition provided via the Choreo marketplace for the service.

    - For languages without OAuth 2.0-aware HTTP clients, you can use the token obtained in step 3 above to make calls to the dependent service. Subsequently, add the obtained token to the HTTP authorization header with the bearer prefix.

        As the service URL you can use the URL that you resolved in step 2 above. For sample requests and responses, see the API definition of the service provided via the Choreo marketplace.

        The following is a sample code snippet in NodeJS:

        ```java 
            const response = await axios.get(serviceURL/{RESOURCE_PATH}, {
                headers: {
                'Authorization': `Bearer ${accessToken}`
                }
            })
        ```


# Use a Database Connection in Your Component

Choreo allows you to share and reuse Choreo-managed databases, accelerating development and enhancing efficiency in building integrated applications through connections.

For step-by-step instructions on creating a database connection, see [Create a Connection](create-a-connection.md).

To learn more about Choreo Connections, see the documentation on [Connections](../../choreo-concepts/connections.md).

## Consume a database through a connection

To consume a Choreo-managed database via a connection, follow these steps:

### Step 1: Add connection configurations

To integrate a database into your application, click the appropriate tab below based on your current configuration file and follow the step-by-step instructions:

=== "Component.yaml file (v1.1)"

    1. Copy and paste the snippet from the  developer guide into the `component.yaml` file.

        The following is a sample snippet:

        ``` yaml

        dependencies:
            connectionReferences:
            - name: <CONNECTION_NAME>
              resourceRef: <RESOURCE_IDENTIFIER>

        ```

          | Field            | Description                                                         |
          |------------------|---------------------------------------------------------------------|
          | name             | The name given to the connection.                                   |
          | resourceRef      | A unique, readable identifier of the database being connected to.    |


    2. If you've previously added a `connectionReferences` section under `dependencies`, append this as another item under `connectionReferences`. Upon deploying the component, the necessary configurations to establish the connection will be injected into Choreo-defined environment variables.

          The following table details the Choreo-defined environment variables:

          | Configuration Key       | Choreo-Defined Environment Variable Name                       |
          |-------------------------|----------------------------------------------------------------|
          | HostName                | CHOREO_<CONNECTION_NAME\>_HOSTNAME                             |
          | Port                    | CHOREO_<CONNECTION_NAME\>_PORT                                 |
          | Username                | CHOREO_<CONNECTION_NAME\>_USERNAME                             |
          | Password                | CHOREO_<CONNECTION_NAME\>_PASSWORD                             |
          | DatabaseName            | CHOREO_<CONNECTION_NAME\>DATABASENAME                          |


          If you'd like to use custom environment variable names instead of the Choreo-defined ones, add the dependency as a service reference under `dependencies` in the same file. For more details, refer to the instructions under the `component.yaml file (v1.0)` tab.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | HostName       | string     | Hostname of the database server       | false         | false        |
          | Port           | string     | Port of the database server           | false         | false        |
          | Username | string           | Username of the database server       | false         | false        |
          | Password       | string     | Password of the database server       | false         | true         |
          | DatabaseName   | string     | Name of the database                  | false         | false        |
    ### Step 2: Read configurations within the application

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const hostName = process.env.CHOREO_<CONNECTION_NAME>_HOSTNAME;
    ```

=== "Component.yaml file (v1.0)"

    !!! note
        The `component.yaml v1.0` file is considered legacy. For new components, we recommend using the latest version, `component.yaml v1.1`, which offers enhanced usability and features.

    1. Copy and paste the snippet from the  developer guide into the `component.yaml` file.

        The following is a sample snippet:

        ``` yaml

        dependencies:
            serviceReferences:
            - name: database:<DATABASE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: HostName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Port
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Username
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Password
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: DatabaseName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>


        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the database you are connecting to.             |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added a service reference section under `dependencies`, append this as another item under `serviceReferences`.

          Upon deploying the component, Choreo automatically populates the specified environment variables with actual values.

          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | HostName       | string     | Hostname of the database server       | false         | false        |
          | Port           | string     | Port of the database server           | false         | false        |
          | Username | string           | Username of the database server       | false         | false        |
          | Password       | string     | Password of the database server       | false         | true         |
          | DatabaseName   | string     | Name of the database                  | false         | false        |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const hostName = process.env.HOSTNAME;
    ```

=== "Component-config.yaml file"

    !!! note
        The `component-config.yaml` file is considered legacy. For new components, we recommend using the latest version, `component.yaml v1.1`, which offers enhanced usability and features.

    1. Copy and paste the snippet from the  developer guide into the `component-config` file under the `spec` section.

        The following is a sample snippet:

        ``` yaml

        outbound:
            serviceReferences:
            - name: database:<DATABASE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: HostName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Port
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Username
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Password
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: DatabaseName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>

        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the database you are connecting to.              |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added an outbound service reference, append this as another item under `serviceReferences`.

          Upon deploying the component, Choreo automatically populates the specified environment variables with actual values.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | HostName       | string     | Hostname of the database server       | false         | false        |
          | Port           | string     | Port of the database server           | false         | false        |
          | Username | string           | Username of the database server       | false         | false        |
          | Password       | string     | Password of the database server       | false         | true         |
          | DatabaseName   | string     | Name of the database                  | false         | false        |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const hostName = process.env.HOSTNAME;
    ```

### Step 3: Initiate a database connection

To initiate a connection to the database, follow these steps:

In this example, you will connect to a MySQL database.

#### Step 3.1: Install the required packages

For the MySQL database, install the `mysql2` package using npm:

```bash
// Install the mysql2 package
npm install mysql2

```

#### Step 3.2: Import required packages

```java

const client = require('mysql2')

```

#### Step 3.3: Establish a connection

To establish the connection, use the environment variables for `hostName`, `username`, `password`, `databaseName`, and `port` as follows:

```java

var connection = client.createConnection({
      host: hostName,
      user: username,
      password: password,
      database: databaseName,
      port: port
});

connection.connect((err) => {
      if (err) {
          return;
      }
      // Connection is successful
});

```

By following these steps, your component can interact with the Choreo-managed database seamlessly.




# Integrate Unit Tests into the Build Pipeline

Choreo allows you to integrate unit tests into the build pipeline, enabling code validation before deployment. This ensures early testing of code changes, reducing the risk of defects in production.

!!! note
        Currently, Choreo supports unit tests only for the `WSO2 MI` buildpack.

## How it works

### Step 1: Write tests

You can create unit tests in your source code using standard testing libraries. For step-by-step instructions on creating unit tests for WSO2 Micro Integrator projects, see [Creating a Unit Test Suite](https://mi.docs.wso2.com/en/latest/develop/creating-unit-test-suite/).

### Step 2: Enable unit tests

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click the component for which you want to enable unit tests.
3. In the left navigation menu, click **Build**.
4. On the **Build** page, click to edit **Build Configurations**.
5. Turn on the **Unit Test** toggle.
6. Click **Save**.

### Step 3: Trigger a new build

- On the **Build** page, click **Build Latest**.

This starts a new build with unit tests enabled. You can monitor its progress in the **Build Details** pane.

## View failed unit tests

If a unit test fails during the build, you can view its detailed logs for troubleshooting. Click **View Details** corresponding to the failed build, then expand the failed unit test step to view the logs.

## Explore a sample

To see unit tests in action within the build pipeline, try out the [WSO2 MI helloworld](https://github.com/wso2/choreo-samples/tree/main/hello-world-mi) sample. 


# Manage Component Source Configurations

In Choreo, you can configure service endpoints and connections via the `component.yaml` source configuration file. This file ensures that the configurations required to initialize endpoints and connections are defined, as they cannot be inferred from the source code. This guide provides an overview of how to configure and manage these settings effectively.

The source configuration file must be committed to your repository within the `.choreo` directory at the root of the project directory. This ensures the ability to version the configuration files alongside repository commits, enabling better tracking and management of configurations.

!!! note
    -  The `component-config.yaml` and `endpoints.yaml` files will eventually be deprecated and replaced by the `component.yaml` file. 
        - For details on how to seamlessly update to the latest `component.yaml` file`, see [Update to the latest source configuration file](#update-to-the-latest-source-configuration-file).
    - Choreo prioritizes configuration files in the following order: `component.yaml` takes the highest precedence, followed by `component-config.yaml`, and then `endpoints.yaml`.

## Overview of the `component.yaml` file 

**File location**:

```bash
<build-context-path>/.choreo/component.yaml
```

!!! note
    - For components built using **Buildpacks**, replace `build-context-path` with the `<project-directory>`. 
    For example, `<project-directory>/.choreo/component.yaml`.
    - For components built using **Docker**, replace `build-context-path` with the `<docker-context-path>`. 
    For example, `<docker-context-path>/.choreo/component.yaml`.

**Sample `component.yaml` file content**:

Click the respective tab to view the structure for your current configuration file version:

=== "Version 1.1"

    ``` yaml
    # +required The configuration file schema version
    schemaVersion: 1.1

    # +optional Incoming connection details for the component
    endpoints:
      # +required Unique name for the endpoint.
      # This name will be used when generating the managed API
      - name: greeter-sample
        # +optional Display name for the endpoint.
        displayName: Go Greeter Sample
        # +required Service section has the user service endpoint details
        service:
          # +optional Context (base path) of the API that gets exposed via the endpoint.
          basePath: /greeting-service
          # +required Numeric port value that gets exposed via the endpoint
          port: 9090
        # +required Type of traffic that the endpoint is accepting.
        # Allowed values: REST, GraphQL, WS, GRPC, TCP, UDP.
        type: REST
        # +optional Network level visibilities of the endpoint.
        # Accepted values: Project|Organization|Public(Default).
        networkVisibilities: 
          - Public
          - Organization
        # +optional Path to the schema definition file. Defaults to wild card route if not provided
        # This is only applicable to REST or WS endpoint types.
        # The path should be relative to the docker context.
        schemaFilePath: openapi.yaml
      
      # +optional Outgoing connection details for the component.
      dependencies:
        # +optional Defines the connection references from the Internal Marketplace.
        connectionReferences:
          # +required Name of the connection.
          - name: hr-connection
            # +required service identifer of the dependent component.
            resourceRef: service:/HRProject/UserComponent/v1/ad088/PUBLIC
      # +optional Defines runtime configurations
      configurations:
        # +optional List of environment variables to be injected into the component.
        env:
          # +required Name of the environment variable
          - name: HR_SERVICE_URL
            # +required value source
            # Allowed value sources: connectionRef
            valueFrom:
              # +required Choreo connection value source
              connectionRef:
                # +required Choreo connection name to refer the value from
                name: hr-connection
                # +required Choreo connection configuration key to refer the value from
                key: ServiceURL
    ```

    The descriptor-based approach of the `component.yaml` file simplifies and streamlines endpoint and connection configuration management. The use of versioned schemas ensures backward compatibility, providing a seamless transition with future updates.

    You can define the following root-level configurations via the `component.yaml` file:

    | Configuration        | Required     | Description                                                              |
    |----------------------|--------------|--------------------------------------------------------------------------|
    | **schemaVersion**    | Required     | The version of the `component.yaml` file. Defaults to the latest version.|
    | **endpoints**        | Optional     | The list of endpoint configurations.                                     |
    | **dependencies**     | Optional     | The list of dependency configurations.                                   |
    | **configurations**    | Optional     | The runtime configuration definitions.                                   |

    ### Endpoint configurations
    In the `endpoints` section of the `component.yaml` file, you can define multiple service endpoint configurations. Each endpoint must have a unique name and the required fields specified in the schema overview.

    !!! tip "Why have a unique name?"
          When you define multiple endpoints, the `endpoint.name` is appended to the Choreo-generated URL. A unique name ensures the endpoint is easily recognizable and readable within the URL.
          
    | Configuration        | Required     | Description                                                                                             |
    |----------------------|--------------|---------------------------------------------------------------------------------------------------------|
    | **name**             | Required     | A unique identifier for the endpoint within the service component. Avoid using excessively long names.  |
    | **displayName**      | Optional     | A display name for the endpoint.                                                                        |
    | **service**          | Required     | Service details for the endpoint.                                                                       |
    | **.basePath**        | Required     | The base path of the API exposed via this endpoint.                                                     |
    | **.port**            | Required     | The numeric port value exposed via this endpoint.                                                       |
    | **type**             | Required     | The type of traffic the endpoint accepts. For example, `REST`, `GraphQL`, `WS`, `gRPC`, `UDP`, or `TCP`.|
    | **networkVisibilities** | Required | The network-level visibility of the endpoint. For example, project, organization, or public.             |
    | **schemaFilePath** | Required | The file path to the swagger definition  or AsyncAPI 2.0 specification file. Defaults to the wildcard route if not specified. This field should be a relative path to the project path when using **Java**, **Python**, **NodeJS**, **Go**, **PHP**, **Ruby**, or **WSO2 MI** buildpacks. For REST or WebSocket endpoint types, when using the **Ballerina** or **Dockerfile** buildpack, the path should be relative to the component root or Docker context. |

    ### Dependency configurations

    In the `dependencies` section of the `component.yaml` file, you can define multiple connection configurations under `dependencies.connectionReferences`. You can use the connection reference generated in the inline developer guide when creating a connection. For instructions on copying [connection configurations](https://wso2.com/choreo/docs/develop-components/sharing-and-reusing/use-a-connection-in-your-service/), see the inline developer guide displayed during connection creation.

    You must include the following configurations in the `dependencies.connectionReferences` schema:

    | Configuration        | Required     | Description                                                                      |
    |----------------------|--------------|----------------------------------------------------------------------------------|
    | **name**             | Required     | The name given to the connection.                                                |
    | **resourceRef**      | Required     | A unique, human-readable identifier for the service you are connecting.          |


    !!! note
        Choreo automatically generates connection configurations when you create a connection. The properties such as **name** and **resourceRef** are automatically generated. The configurations required to establish the connection will be injected into Choreo-defined environment variables.

        To use custom environment variable names instead of Choreo's default ones, add the dependency as a `serviceReference` in your `component.yaml v1.1` file. You can copy the `serviceReference` section from the `component.yaml v1.0` tab and paste it under `dependencies` in your `component.yaml v1.1` file, which maintains backward compatibility with the v1.0 format.

    ### Runtime configurations
    In the `configurations` section of the `component.yaml` file, you can define runtime configurations for the component. These configurations currently support environment variable injection related to dependencies.
    
    | Configuration                 | Required     | Description                                                                       |
    |-------------------------------|--------------|-----------------------------------------------------------------------------------|
    | **env**                       | Optional     | An array of env variable configurations.                                          |
    | **name**                      | Required     | A unique name for the environment variable, starting with a letter or an underscore, and containing only letters, numbers, or underscores. |
    | **valueFrom**                 | Required     | The source of the environment variable value.                                     |
    | **connectionRef**             | Required     | Connection reference value source definition.                                     |
    | **name**                      | Required     | The name of the Choreo connection to reference the value from.                    |
    | **key**                       | Required     | The Choreo connection configuration key to reference the value from. For details on available keys, see [connection configurations](https://wso2.com/choreo/docs/develop-components/sharing-and-reusing/use-a-connection-in-your-service/) or the inline developer guide. |

    !!! note
        Runtime configurations are supported starting from `component.yaml v1.1`.

        When an environment variable value is specified using `connectionRef`, the connection's environment variable is renamed to the environment variable name defined in the `configurations` section. For example, in the sample `component.yaml` file given above, the `CHOREO_HR_CONNECTION_SERVICEURL` variable in the `hr-connection` is renamed to `HR_SERVICE_URL`.

=== "Version 1.0"

    ``` yaml
    # +required The configuration file schema version
    schemaVersion: 1.0

    # +optional Incoming connection details for the component
    endpoints:
      # +required Unique name for the endpoint.
      # This name will be used when generating the managed API
      - name: greeter-sample
        # +optional Display name for the endpoint.
        displayName: Go Greeter Sample
        # +required Service section has the user service endpoint details
        service:
          # +optional Context (base path) of the API that gets exposed via the endpoint.
          basePath: /greeting-service
          # +required Numeric port value that gets exposed via the endpoint
          port: 9090
        # +required Type of traffic that the endpoint is accepting.
        # Allowed values: REST, GraphQL, WS, GRPC, TCP, UDP.
        type: REST
        # +optional Network level visibilities of the endpoint.
        # Accepted values: Project|Organization|Public(Default).
        networkVisibilities: 
          - Public
          - Organization
        # +optional Path to the schema definition file. Defaults to wild card route if not provided
        # This is only applicable to REST or WS endpoint types.
        # The path should be relative to the docker context.
        schemaFilePath: openapi.yaml
      
    # +optional Outgoing connection details for the component.
    dependencies:
      # +optional Defines the service references from the Internal Marketplace.
      serviceReferences:
        # +required Name of the service reference.
        - name: choreo:///apifirst/HRProject/UserComponent/ad088/v1/PUBLIC
          # +required Name of the connection instance.
          connectionConfig: 19d2648b-d29c-4452-afdd-1b9311e81412
          # +required Environment variables injected into the component for connection configuration.
          env:
            # +required Key name of the connection configuration.
            - from: ServiceURL
              # +required Environment variable injected into the container.
              to: SERVICE_URL
    ```

    The descriptor-based approach of the `component.yaml` file simplifies and streamlines endpoint and connection configuration management. The use of versioned schemas ensures backward compatibility, providing a seamless transition with future updates.

    You can define the following root-level configurations via the `component.yaml` file:

    | Configuration        | Required     | Description                                                              |
    |----------------------|--------------|--------------------------------------------------------------------------|
    | **schemaVersion**    | Required     | The version of the `component.yaml` file. Defaults to the latest version.|
    | **endpoints**        | Optional     | The list of endpoint configurations.                                     |
    | **dependencies**     | Optional     | The list of dependency configurations.                                   |

    <h3> Endpoint configurations </h3>
    In the `endpoints` section of the `component.yaml` file, you can define multiple service endpoint configurations. Each endpoint must have a unique name and the required fields specified in the schema overview.

    !!! tip "Why have a unique name?"
          When you define multiple endpoints, the `endpoint.name` is appended to the Choreo-generated URL. A unique name ensures the endpoint is easily recognizable and readable within the URL.
          
    | Configuration           | Required     | Description                                                                                             |
    |-------------------------|--------------|---------------------------------------------------------------------------------------------------------|
    | **name**                | Required     | A unique identifier for the endpoint within the service component. Avoid using excessively long names.  |
    | **displayName**         | Optional     | A display name for the endpoint.                                                                        |
    | **service**             | Required     | Service details for the endpoint.                                                                       |
    | **.basePath**           | Required     | The base path of the API exposed via this endpoint.                                                     |
    | **.port**               | Required     | The numeric port value exposed via this endpoint.                                                       |
    | **type**                | Required     | The type of traffic the endpoint accepts. For example, `REST`, `GraphQL`, `gRPC`, `WS`, `UDP`, or `TCP`.|
    | **networkVisibilities** | Required     | The network-level visibility of the endpoint. For example, project, organization, or public.            |
    | **schemaFilePath**      | Required     | The file path to the swagger definition or AsyncAPI 2.0 specification file. Defaults to the wildcard route if not specified. This field should be a relative path to the project path when using **Java**, **Python**, **NodeJS**, **Go**, **PHP**, **Ruby**, or **WSO2 MI** buildpacks. For REST or WebSocket endpoint types, when using the **Ballerina** or **Dockerfile** buildpack, the path should be relative to the component root or Docker context. |

    <h3> Dependency configurations </h3>

    In the `dependencies` section of the `component.yaml` file, you can define multiple service connection configurations under `dependencies.serviceReferences`. You can use the service references generated in the inline developer guide when creating a service connection. For instructions on copying [connection configurations](https://wso2.com/choreo/docs/develop-components/sharing-and-reusing/use-a-connection-in-your-service/), see the inline developer guide displayed during connection creation.

    You must include the following configurations in the `dependencies.serviceReferences` schema:

    | Configuration        | Required     | Description                                                                      |
    |----------------------|--------------|----------------------------------------------------------------------------------|
    | **name**             | Required     | A unique name for the service reference.                                         |
    | **connectionConfig** | Required     | A unique name for the connection instance.                                       |
    | **env**              | Required     | The list of environment variable mappings to inject into the container.          |
    | **.from**            | Required     | The key name of the connection configuration.                                    |
    | **.to**              | Required     | The environment variable to inject into the container.                           |

    !!! note
        Choreo automatically generates connection configurations when you create a connection. The properties such as **name**, **connectionConfig**, and **env.from** are automatically generated. However, you must manually set the **env.to** value.

## Overview of the `component-config.yaml` file 

**File location**:

```bash
<build-context-path>/.choreo/component-config.yaml
```

**Sample `component-config.yaml` file content**:

```yaml
apiVersion: core.choreo.dev/v1beta1
kind: ComponentConfig
spec:
  # +optional Incoming connection details for the component (AKA endpoints).
  inbound:
    # +required Unique name for the endpoint.
    # This name will be used when generating the managed API
    - name: Greeting Service
      # +required Numeric port value that gets exposed via the endpoint
      port: 9090
      # +required Type of traffic that the endpoint is accepting.
      # Allowed values: REST, GraphQL, GRPC, TCP, UDP, WS.
      type: REST
      # +optional Network level visibility of the endpoint. Defaults to Public
      # Accepted values: Project|Organization|Public.
      networkVisibility: Public
      # +optional Context (base path) of the API that gets exposed via the endpoint.
      # This is mandatory if the endpoint type is set to REST, GraphQL or WS.
      context: /greeting
      # +optional The path to the schema definition file. Defaults to wildcard route if not specified.
      # This is only applicable to REST and WS endpoint types.
      # The path should be relative to the Docker context.
      schemaFilePath: greeting_openapi.yaml
  # +optional Outgoing connection details for the component.
  outbound:
    # +optional Defines the service references from the Internal Marketplace.
    serviceReferences:
      # +required Name of the service reference.
      - name: choreo:///apifirst/mttm/mmvhxd/ad088/v1.0/PUBLIC
        # +required Name of the connection instance.
        connectionConfig: 19d2648b-d29c-4452-afdd-1b9311e81412
        # +required Environment variables injected to the component for connection configuration.
        env:
          # +required Key name of the connection configuration.
          - from: ServiceURL
            # +required Environment variable injected to the container.
            to: SERVICE_URL
```

The `component-config.yaml` file complements and enhances the existing endpoint configuration process. It allows you to define how the endpoints (inbound connections) in your service are exposed and how your service connects to external services or components (outbound connections).

You can define the following root-level configurations via the `component-config.yaml` file:

| Configuration        | Required     | Description                                                                           |
|----------------------|--------------|---------------------------------------------------------------------------------------|
| **apiVersion**       | Required     | The version of the `component-config.yaml` file defaults to `core.choreo.dev/v1beta1`.|
| **kind**             | Required     | The resource type of the file defaults to `ComponentConfig`.                          |
| **spec.inbound**     | Optional     | The list of inbound connection configurations.                                        |
| **spec.outbound**    | Optional     | The list of outbound connection configurations.                                       |

#### Inbound connection configurations (`spec.inbound`)

In the `spec.inbound` configuration section, you can specify endpoints to set up inbound connections. To specify endpoints, you can follow the existing endpoints schema structure. For details on the endpoints schema structure, see the [endpoints schema documentation](#overview-of-the-endpointsyaml-file).

#### Outbound connection configurations (`spec.outbound`)

In the `spec.outbound` section, you can define `serviceReferences`. To define `serviceReferences`, you can use the service references generated in the Internal Marketplace when creating a service connection. To copy the [outbound connection configurations](../sharing-and-reusing/use-a-connection-in-your-service/#use-a-connection-in-your-service), see the inline developer guide displayed when you create a connection.

You must include the following configurations in the `serviceReferences` schema:

| Configuration        | Required     | Description                                                                      |
|----------------------|--------------|----------------------------------------------------------------------------------|
| **name**             | Required     | A unique name for the service reference.                                         |
| **connectionConfig** | Required     | A unique name for the connection instance.                                       |
| **env**              | Optional     | The list of environment variable mappings to inject into the container.          |
| **env.from**         | Required     | The key name of the connection configuration.                                    |
| **env.to**           | Required     | The environment variable to inject into the container.                           |

## Overview of the `endpoints.yaml` file

**File location**:

```bash
<build-context-path>/.choreo/endpoints.yaml
```

**Sample `endpoints.yaml` file content**:

```yaml
# +required Version of the endpoint configuration YAML
version: 0.1

# +required List of endpoints to create
endpoints:
  # +required Unique name for the endpoint.
  # This name will be used when generating the managed API
- name: Greeting Service
  # +required Numeric port value that gets exposed via this endpoint
  port: 9090
  # +required Type of the traffic this endpoint is accepting.
  # Allowed values: REST, GraphQL, GRPC, UDP, TCP, WS.
  type: REST
  # +optional Network level visibility of this endpoint. Defaults to Public
  # Accepted values: Project|Organization|Public.
  networkVisibility: Project
  # +optional Context (base path) of the API that is exposed via this endpoint.
  # This is mandatory if the endpoint type is set to REST, GraphQL or WS.
  context: /greeting
  # +optional Path to the schema definition file. Defaults to wild card route if not provided
  # This is only applicable to REST and WS endpoint types.
  # The path should be relative to the docker context.
  schemaFilePath: greeting_openapi.yaml
```

The `endpoints.yaml` configuration file allows you to define configurations for multiple endpoints necessary for Choreo service components. This schema is essential to identify the context, port binding, network exposure level, and other attributes required to generate a Choreo endpoint.

You can define the following root-level configurations via the `endpoints.yaml` file:

| Configuration        | Required     | Description                                                                       |
|----------------------|--------------|-----------------------------------------------------------------------------------|
| **version**          | Required     | The version of the `endpoints.yaml` file.                                         |
| **name**             | Required     | A unique name for the endpoint, which Choreo will use to generate the managed API.|
| **port**             | Required     | The numeric port value that gets exposed via this endpoint.                       |
| **type**             | Required     | The type of traffic this endpoint accepts, such as `REST`, `GraphQL`, `gRPC`, `WS`, `UDP`, or `TCP`. Currently, the MI preset supports only the `REST` type.                                         |
| **networkVisibility**| Required     | The network level visibility of this endpoint, which defaults to `Public` if not specified. Accepted values are `Project`, `Organization`, or `Public`.|
| **context**          | Required     | The context (base path) of the API that Choreo exposes via this endpoint.         |
| **schemaFilePath**   | Required     | The swagger definition file path. Defaults to the wildcard route if not provided. This field should be a relative path to the project path when using the **Java**, **Python**, **NodeJS**, **Go**, **PHP**, **Ruby**, and **WSO2 MI** buildpacks. For REST endpoint types, when using the **Ballerina** or **Dockerfile** buildpack, this field should be a relative path to the component root or Docker context.|

## Update to the latest source configuration file

With the upcoming deprecation of the `component-config.yaml` file and the `endpoints.yaml` file, Choreo provides a seamless process to move to the latest `component.yaml`  version of the `component.yaml` file. Follow these steps to transition seamlessly:

### Step 1: Identify whether your current source configuration file is outdated

You can determine whether you’re using an outdated configuration file in the following ways:

- **During a build:**
     - On the **Build** page, after triggering a build, a warning will appear if your source configuration file is outdated. Click **View Details** in the **Initialization** -> **Source Config Validation** step. You will see an information banner with an option to update the file.

- **In existing deployments:**
     - If an existing deployment uses a build with an outdated source configuration file, you will see a warning icon on the build card of the relevant environment card.


### Step 2: Generate the latest `component.yaml` file

- In either of the scenarios above, click **Update** to initiate the process of generating the latest `component.yaml` file. The updated file will retain your existing configurations to ensure a smooth update process.


### Step 3: Add the generated configuration file to your repository

1. Download the generated `component.yaml` file.
2. Replace the existing source configuration file in the `.choreo` folder within your source repository.
    - Ensure the file name is `component.yaml`.


### Step 4: Trigger a new build

1. Commit the new `component.yaml` file to your repository. Push changes to the remote Git repository.
2. Trigger a build using the latest commit.


### Step 5: Verify the update

Once the build is complete:

  - Deploy the build.
  - Confirm that the warning messages no longer appear.

You can benefit from the latest features and enhancements provided by the updated source configuration file.


# Manage Deployment Tracks for Choreo Components

Choreo allows you to create and manage dedicated [deployment tracks](../choreo-concepts/deployment-tracks.md) for components, facilitating independent version control and deployment. This capability also allows you to unlink deployment tracks from associated branches or relink them to different branches so that you can align with your preferred Git workflows, such as the feature branch workflow or GitFlow workflow.

!!! info
     Deployment track creation and management does not apply to API Proxy and [BYOI components](../develop-components/bring-your-own-image.md).

## Create a deployment track

**Prerequisites**:

 - Create a component in Choreo.

Follow the steps below to create a deployment track for a component:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to create a deployment track for.
3. On the header of the component overview page, click the **Deployment Track** drop-down list.
4. Click **+ Create New** to open the **Create Deployment Track** dialog.
5. In the **Create Deployment Track** dialog, do the following:
    1. Select a branch to associate with the deployment track.
    2. Optionally, specify a description for the deployment track. 
    3. To create a deployment track for a service component, specify a unique API version indicating the major and minor version numbers.
6. Click **Create**.

## Unlink a deployment track

If you want to detach a branch reference from a deployment track, you must unlink the branch.

!!! info
     When you unlink the branch of a deployment track, the active deployments are unaffected. However, while you can redeploy the existing deployment, you cannot perform a new deployment.

Follow the steps below to unlink a deployment track of a component:
  
1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to unlink a deployment track.
3. On the header of the component overview page, click the **Deployment Track** drop-down list and then click **View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
4. Click the edit icon corresponding to the deployment track you want to unlink.
5. In the **Edit Branch** dialog that opens, click the **Branch Name** list and select **None**.
6. Click **Save**.

## Link a deployment track

To associate a branch reference to an unlinked deployment track, you must link a branch.

!!! info
    To build and deploy the contents of the linked branch,  you must perform a manual build and deploy.

**Prerequisites**:

 - A minimum of two branches in your GitHub repository.

Follow the steps below to link a branch to an unlinked deployment track:
  
1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to associate a branch reference for.
3. On the header of the component overview page, click the **Deployment Track** drop-down list and then click **View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
4. Click **+ Link Branch** corresponding to the unlinked deployment track for which you want to associate a branch.
5. In the **Link Branch** dialog that opens, click the **Branch Name** list and select the branch you want to relink.
6. Click **Save**.

## Relink a deployment track

To switch the branch reference of a linked deployment track, you must relink to an appropriate branch.

!!! info
      If you unlink the existing branch of a deployment track and link a different branch, you must perform a manual build and deploy to build and deploy the contents of the recently linked branch.

**Prerequisites**:

 - A minimum of two branches in your GitHub repository.

Follow the steps below to switch the branch reference of a linked deployment track:
  
1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to relink a deployment track for.
3. On the header of the component overview page,  click the **Deployment Track** drop-down list and then click **View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
4. Click the **Edit Branch** icon corresponding to the deployment track you want to relink.
5. In the **Edit Branch** dialog that opens, click the **Branch Name** list and select the branch you want to relink.
6. Click **Save**.

Now that you understand how to create and manage deployment tracks for components, let’s explore a sample scenario to see how a developer can use deployment tracks to manage version releases in Choreo.

## Sample Scenario: Manage version releases with deployment tracks

Let’s consider the following version release scenario: 

- To initiate work on a new feature, a developer creates a new branch, named `feature-x` from either the `main` or `dev` branch.
- Once development is complete, the developer proceeds to merge the `feature-x` branch into the `dev` branch for testing.
- Upon successful testing in the `dev` branch, the developer proceeds to merge all the changes into the `main` branch for production deployment.

Following are the actions you need to take from a deployment track perspective to manage the version release:

1. To prepare for the new version release, unlink the `main` branch from the associated deployment track (let’s consider this as the deployment track 1).
2. Proceed to merge the `dev` branch containing the tested changes into the `main` branch.
3. Unlink the `dev` branch from the associated deployment track (let’s consider this as deployment track 2).
4. Link deployment track 2 containing the latest version of the service to the `main` branch for deployment.
5. To facilitate ongoing development and testing, create another deployment track (let’s consider this as deployment track 3) and link it to the `dev` branch.

!!! tip
     - As a developer, you can strategically unlink and relink deployment tracks to effectively manage different versions of your services within Choreo.
     - You can create new deployment tracks for ongoing development branches like `dev` to ensure a continuous development and release cycle.

## Delete a deployment track

If you no longer need a deployment track, you can delete it.

!!! note
    If the component exposes an endpoint or proxy and you want to delete the last version in the major version range, the recommended approach is to retire that version first. This allows consumers to transition to the next major version and prevents a sudden break in their experience.
    For example, if you have deployment tracks for v1.0 and v2.0, notify consumers to switch to v2.0 before deleting v1.0. Then, retire the APIs in v1.0 and proceed to delete the associated deployment track.




**Prerequisites**:

- At least 2 deployment tracks in a component.

Follow the steps below to delete a deployment track:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to delete a deployment track.
3. On the header of the component overview page, click the **Deployment Track** drop-down list.
4. Click **+ View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
5. Click the **Delete** icon corresponding to the deployment track you want to delete.
6. Click **Delete** to confirm the deletion.

# Manage the Micro Integrator Runtime Version in Your Integration Project

Choreo allows you to use a preferred WSO2 Micro Integrator (MI) runtime version in your integration project. Currently, Choreo supports MI product versions 4.1.0 and 4.2.0. You have the flexibility to deploy WSO2 updates within these specified versions. 

When you create an integration project, you can specify a required runtime version to gain control over the environment in which your integration runs. This version management capability empowers you to tailor your projects depending on your runtime requirements, enhancing the customization and adaptability of your integration workflows.

## Understand the version string

WSO2 Micro Integrator (MI) utilizes a versioning system consisting of three-digit numbers, such as `4.1.0` and `4.2.0`, following semantic versioning principles. The product remains committed to receiving updates from WSO2, including security fixes, bug resolutions, and enhancements. Within the Choreo platform, the MI runtime version is constructed by combining the product release version with its corresponding update level.

In Choreo, the MI runtime version is structured as a four-digit number, for example, `4.1.0.14` or `4.2.0.17`. The first three digits represent the product release version, while the last digit signifies the update level of the product. The fourth digit is optional and can be omitted.

![Version string](../assets/img/develop-components/micro-integrator/version-string.png)

## Version management in WSO2 Integration Studio

If you are using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/) to build and deploy integration artifacts in WSO2 Micro Integrator, you can create multiple runtime environments and execute projects on any selected environment. WSO2 Integration Studio also allows you to configure multiple Micro Integrator runtime environments, offering flexibility and customization in the execution of integration processes.

You can specify the Runtime version when you create an integration project in WSO2 Integration Studio. In the project creation wizard, specify the runtime version in the **Runtime version** field, as shown below.
![Specify Runtime version](../assets/img/develop-components/micro-integrator/specify_runtime_version.png)


An integration project is structured as a Maven project with multiple sub-modules. The root `pom.xml` file holds crucial information about the target runtime. The runtime version you configure when you create a new project is saved within the root `pom.xml` file. The version information is stored in the <project.runtime.version> element under the <properties> in the `pom.xml` file. If there is a need to update the runtime version, you have the flexibility to modify the value to a valid runtime version and ensure that the project runs in the required runtime environment.

![project runtime version](../assets/img/develop-components/micro-integrator/project-runtime-version.png)

You can establish multiple runtime environments by utilizing updated MI instances. With a valid WSO2 subscription, you can also access and download updates to set up an updated MI server locally. This update process allows you to select a preferred update level as the runtime version. Consequently, you can run your integration on a runtime with the latest updates, ensuring optimal performance and access to new features.

### Configure a Micro Integrator runtime environment in Integration Studio

If you are using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), follow these steps to set up a remote server instance with a Micro Integrator runtime environment to execute your integration project:

!!! info "Note"
    If you have not downloaded and installed WSO2 Integration Studio, you can follow the [installation instructions](https://apim.docs.wso2.com/en/latest/integrate/develop/installing-wso2-integration-studio/) in the WSO2 API Manager documentation.

1. Launch WSO2 Integration Studio and click **Add Server** in the **Getting Started** view.
   ![Add server](../assets/img/develop-components/micro-integrator/add-server.png)
2. In the **Define a New Server** dialog, click to expand the `WSO2` directory and select **WSO2 Remote Server**.
   ![Define a remote server instance](../assets/img/develop-components/micro-integrator/define-a-remote-server-instance.png)
3. Enter the WSO2 Micro Integrator Management API URL in the **Server URL** field and click **Test Connection**.

    !!! info "Note"
        The Management API of WSO2 Micro Integrator is an internal REST API introduced to substitute MI admin services. The default HTTPS port of the Management API of WSO2 Micro Integrator is `9164`. If you have not manually changed the default port, you must set the Management API URL as `https://localhost:9164/management`.  If you have changed the default HTTPS port, you must set the port number appropriately when specifying the **Server URL**. For more information on the default ports of WSO2 Micro Integrator, see [WSO2 Micro Integrator default ports](https://apim.docs.wso2.com/en/latest/install-and-setup/setup/reference/default-product-ports/#micro-integrator-ports) in the WSO2 API Manager documentation.

    ![Set server URL](../assets/img/develop-components/micro-integrator/set-server-url.png)
    
4. Click **Finish**.
5. In the **Add and Remove** dialog, select the integration components to move from the left side to the right side.
6. Click **Add >**.
7. Click **Finish**. 

Your integration project is now running in a remote server instance with the Micro Integrator runtime environment you require.
If you need to make changes to the integration project, expand the remote server instance, right-click on the deployed exporter project, and select **Redeploy** to apply the changes.

![Redeploy project](../assets/img/develop-components/micro-integrator/redeploy-project.png)

## Convention for version interpretation in Choreo deployments

You can use the following convention to indicate the required MI runtime version in your integration project:


| **Version format**           | **Example**       | **Description**   |
|------------------------------|-------------------|-------------------|
| Product version              | `4.1.0`, `4.2.0`  | Deploy on the latest update level of the mentioned product version.                 |
| Product version with update level  | `4.1.0.15`, `4.2.0.17` |  Deploy on the exact update level of the mentioned product version.    |
| GA version                   | `4.1.0.0`, `4.2.0.0` | Deploy on the exact GA version without any update.                  |
| Default version            | Empty value         | Deploy on the latest update level of the default product version.                  |


Choreo utilizes Alpine images for configuring and deploying the Micro Integrator runtime. This includes automated configuration of the JRE/JDK, customized to the compatibility of the chosen runtime version, simplifying the setup procedure.

## Migrate between runtime versions

Changing the runtime version in an integration project may become necessary during product version upgrades or when you want to apply updates. 

To change the runtime version of a MI Integration, follow the below steps.

### Update the runtime version in the integration project
    
To change the runtime version in the integration project, follow the steps below:
1. Open the project in Integration Studio.
2. Right-click on the project and select **Change Runtime MI Version**.
    ![Update Runtime version](../assets/img/develop-components/micro-integrator/click_change_runtime.png)
3.  Specify the new runtime version as shown below:
    ![Update Runtime version](../assets/img/develop-components/micro-integrator/update_runtime_version.png)
4. Alternatively, you can manually update the version by opening the root `pom.xml` file.  Open pom.xml and change the required runtime version in `<project.runtime.version>` element under `<properties>` section.

To test the changes locally, you must download and set up the runtime environment locally. Then, you must [configure the Integration Studio runtime environment](#configure-a-micro-integrator-runtime-environment-in-integration-studio) by directing it to the locally installed MI runtime. Once the setup is complete, you can deploy your integrations on the MI runtime environment and proceed to the testing phase.

After completing the tests to ensure everything works as expected, you can follow below steps to deploy the project in Choreo:

1. Commit and push the changes to your repository.
2. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
3. Select your project from the **Project** list in the header.
4. Select your MI integration component from the **Component** list in the header.
5. In the left navigation menu, click **Build**.
6. Select the latest commit and click **Build**.
7. In the left navigation menu, click **Deploy**.
8. Click on the **Configure and Deploy** and deploy the component.
9. Verify the Runtime version by checking the logs by selecting the **Runtime Logs** under the **Observability** section.

  You will see the runtime version in the logs as shown below:
  ![Runtime version in logs](../assets/img/develop-components/micro-integrator/runtime_version_in_logs.png)

Next, you must conduct additional testing in the development environment on Choreo before you promote the integration to production environments.

## Troubleshoot errors

The following error codes can help you troubleshoot errors that occur during the integration component build:

| **Error code** | **Description**            |
|----------------|----------------------------|
| 110 - 119      | Internal server error.     |
| 121            | Malformed runtime version. |
| 122            | The specified runtime version is not available. Either the product or update level is not available.    |
| 123            | Trivy security vulnerabilities found in the `libs` directory. |
| 124            | Trivy security vulnerabilities found in the `dropins` directory. |
| 125            | Trivy security vulnerabilities found in the `libs` or `dropins` directory. |
| 126            | Error building integration project. |


# Submit and Manage Workflow Approval Requests

In Choreo, if an administrator [configures a workflow to require approval](../administer/configure-approvals-for-choreo-workflows.md), you must submit a request to obtain approval to perform the task.

Upon submitting a workflow approval request, Choreo notifies all authorized assignees via email about the [review request](../administer/review-workflow-approval-requests.md). When an authorized assignee approves or rejects the request, you will receive an email with details of the decision.

The approach to request approval can vary depending on the workflow. 

## Request approval for environment promotion

**Prerequisites**:

- Ensure you have a component created, built, and deployed to the development environment.
- Ensure that an approval workflow is configured for environment promotion.
- Ensure you are promoting the component to a critical environment, such as production.

To request approval to promote a component from the development environment to production, follow these steps:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to deploy. This takes you to the **Overview** page of the component.
3. In the left navigation menu, click **Deploy**.
4. Go to the **Development** card and click **Request to Promote**.
5. In the **Request Approval** pane that opens, enter your request details and click **Submit**. This creates a request and notifies all authorized assignees via email about the request.

    !!! note
         When an environment promotion request for a specific component is pending review, Choreo restricts other developers from making the same request until the pending request is either approved or rejected.

When an authorized assignee approves the request, you will receive a confirmation email and can proceed to promote the component to production.

## Cancel a workflow approval request

If you want to cancel a workflow approval request that is already submitted, you can do so before the request is approved or rejected. 

When you submit a workflow approval request, the **Request to Promote** button changes to **Cancel Request**. To cancel an approval request, click **Cancel Request**. Upon confirming the cancellation, all configured approvers are notified immediately, and the request will no longer be pending.


# Work with the Micro Integrator Runtime in Choreo

WSO2 Micro Integrator (WSO2 MI) is a lightweight, high-performance integration runtime. It allows you to run integrations developed using WSO2 Integration Studio within Choreo. 

The topics on this page walk you through the key aspects you need to understand to use the WSO2 MI runtime effectively in Choreo.

## Integration types

Choreo supports the following WSO2 MI integrations that cater to different use cases and requirements. Each integration type serves a specific purpose. Therefore, it is essential to understand their differences to easily choose the most appropriate integration for your use case.

- **Service**: Exposes an integration as an API via HTTP, making it possible to create a RESTful interface for your integration services. This type is ideal for scenarios where you need to provide an API for external systems or clients to interact with your integration.
- **Event Handler**: Triggers an integration based on external events such as messages arriving on a queue or updates in a database. This type is well-suited for implementing event-driven architectures or responding to changes in your system's environment.
- **Scheduled Task**: Runs an integration automatically at predefined time intervals, ensuring that specific integration tasks occur at regular intervals. This type is ideal for batch processing, data synchronization, or periodic maintenance tasks.
- **Manual Task**: Initiates an integration via user action, giving you full control over when the integration executes. This type is useful for on-demand tasks, testing, or debugging purposes.

## Develop integrations with WSO2 Integration Studio

[WSO2 Integration Studio](https://wso2.com/integration/integration-studio/) is a powerful, Eclipse-based graphical development environment that enables you to build and deploy integration artifacts in WSO2 Micro Integrator. This comprehensive IDE offers a robust set of tools for designing and testing integration flows and crafting integration artifacts. By utilizing the visual, drag-and-drop capabilities of WSO2 Integration Studio, developers can significantly reduce the time and effort needed to construct and deploy integration flows.

In addition to streamlining the development process, Integration Studio offers features such as debugging, testing, and version control to ensure the quality and reliability of integration flows. By creating an Integration project and Composite Exporter project in WSO2 Integration Studio, developers can export their integration projects as a single deployment artifact, known as a composite application. This composite application encompasses all the components and configurations necessary for deploying the integration project to WSO2 Micro Integrator.

The Composite Exporter project simplifies the deployment process by allowing developers to package their integration projects as a single, self-contained artifact that can be easily deployed and managed. This approach enhances the consistency and reliability of integration projects while streamlining the overall deployment process.

To start developing integrations with WSO2 Micro Integrator, see [WSO2 Micro Integrator documentation - Developing Integration Solutions](https://mi.docs.wso2.com/en/latest/develop/intro-integration-development/).

## Integration project directory structure

An Integration Project in WSO2 Integration Studio is a multi-module Maven project that can contain multiple modules with WSO2 Synapse configurations and a composite application module to export all the configurations as a single deployable artifact.

An integration project directory structure includes the following key components:

 - WSO2 Synapse configurations: These modules contain the essential configurations for the integration project.
 - Composite Application module: This module is responsible for exporting all the Synapse configurations as a single deployable artifact.

Optionally, you can include the following components in your integration project:

 - OpenAPI definition file: You can add the OpenAPI definition file to any location within the project. When creating a component, you'll need to define the path to this file. Choreo will automatically generate an OpenAPI definition for you based on your integration project, if you don't provide one.
 - Java libraries: If your integration project requires additional Java libraries, you can add them to the libs directory located in the project root.
 - deployment.toml file: This optional configuration file allows you to customize the preconfigured settings of WSO2 MI instances running on Choreo. By including this file, you can tailor the behavior of your WSO2 MI instances to better suit your project's specific requirements.

Understanding the Integration Project directory structure is crucial for organizing your project and ensuring that all necessary components are included in the final deployable artifact.

## OpenAPI support

OpenAPI Support plays a crucial role in enhancing the functionality of integrations exposed as APIs. By providing an OpenAPI definition for your exposed integration, you can streamline testing and management processes, ensuring a more efficient and user-friendly experience. Choreo will automatically generate an OpenAPI definition for you based on your integration project, if you don't provide one, saving you time and effort.

To incorporate OpenAPI support, store the OpenAPI definition file within the repository hosting your Integration Studio project. When creating the project, simply point to the file's location in the repository. If needed, you can change the location of the OpenAPI definition file later via the deploy page.

![Open API file](../assets/img/develop-components/micro-integrator/openapi_file.png)

By leveraging OpenAPI Support, you can optimize the way you test and manage your integrations, resulting in a more efficient development process and a smoother user experience.

## Work with third-party libraries

The use of third-party libraries in your Micro Integrator project can offer several advantages, such as enhanced functionality, improved integration capabilities, optimized performance, and reduced development time.

Here are some of the benefits of adding third-party JARs to the Micro Integrator:

 - Increased functionality: Third-party libraries can extend the core Micro Integrator distribution, allowing for greater flexibility and customization of integration solutions.
 - Enhanced integration capabilities: Third-party libraries enable the Micro Integrator to interact with existing systems such as databases or other APIs, improving overall integration capabilities.
 - Optimized performance: By offering optimized implementations of common functions, third-party libraries can improve the performance of the Micro Integrator.
 - Efficient development: Developers can avoid re-implementing commonly used functions, reducing development time and increasing efficiency.

To incorporate third-party libraries into your Micro Integrator project, create a new directory called `libs` at the
root of your project. If your project root and GitHub repository root are not the same, place the `libs` directory in
the project root. After adding the required JAR files to the `libs` directory, the Micro Integrator runtime will
automatically include them when deploying the component. This process ensures that any dependencies needed by your
integration flow are available at runtime.

In addition to `jar` libraries, you may also need to incorporate OSGi bundle JARs into your project. To do this,
create another directory called `dropins` at the root of your project. Similarly, if the project root and GitHub
repository root differ, place the `dropins` directory in the project root. Within the `dropins` directory, add the OSGi
bundle JAR files. The OSGI runtime will pick up these bundles during deployment, enabling you to utilize their
functionality within your Micro Integrator project.

![Libs directory](../assets/img/develop-components/micro-integrator/libs_dir.png)

## Importing custom certificates to MI

The feature enables Choreo MI users to import certificates into the MI `client-truststore.jks` file. This functionality
proves valuable when users need to establish connections with servers or services utilizing SSL/TLS encryption and
possessing self-signed certificates or certificates issued by private certificate authorities (CAs) that are not
automatically trusted. Importing the certificate to the MI `client-truststore.jks` file enables MI clients to establish secure connections with
the server or service seamlessly, eliminating SSL/TLS errors or warnings.

Before importing the certificate, it is necessary to obtain the certificate file, which can be in PEM or DER format. You
can get the certificate from the server or service provider or export it from a web browser. Certificates should be
added to the `/wso2mi/certs/` folder. Users need to verify that the mount path for the certificate file aligns with this
specific path.

1. In the Choreo console, select the component you wish to add a certificate to.
2. From the left navigation click **Deploy**.
3. Click on the **Configs and Secrets** tab.
4. Click **Create**.
5. Select **ConfigMap** as the **Config Type** and **File Mount** as the **Mount Type**.
6. Click **Next**.
7. Specify the following values as mount configurations:

    | **Field**       | **Value**                                              |                                    
    |-----------------|--------------------------------------------------------|
    | **Config Name** | An appropriate name for the certificate.             |
    | **Mount path**  | `/wso2mi/certs/<filename>`. For example, `/wso2mi/certs/certificate.crt` |

8. Click **Upload File** and attach the certificate.
9. Click **Create**.

## Working with sensitive data using MI Secure Vault

MI Secure Vault is a feature that allows users to securely store sensitive data, such as passwords and tokens, and
provide access to that data to MI Integrations. This feature provides an added layer of security to your integrations by
reducing the risk of accidental exposure of sensitive data.

To use MI Secure Vault to work with sensitive data, follow these steps:

1. Select the component from the Choreo Console.
2. From the left navigation, click Deploy.
3. Click on the **Configure and Deploy**.
4. Click on the **Add Environment Configurations**
5. Specify the following values as configurations:

    | **Field**       | **Value**                                 |                                    
    |-------------------------------------------|--------------------------------------------------------|
    | **Name** | An appropriate name for the secret/alias. |
    | **Value**       | Value for the secret                      |

6. Select **Mark as a Secret**.
7. Click **Add**.
8. Click **Deploy**.
9. Once the secret has been created, you can access it in your integration code using the following syntax:

```xml
<property name="secret_value_1" expression="wso2:vault-lookup('user_pass')" scope="default" type="STRING"/>
```
This code retrieves the secret named "user_pass" from the MI Secure Vault and stores it in the property named "
secret_value_1". You can then use this property in your integration code to access the secret value.

For more information on these features, see the [Accessing secrets](https://mi.docs.wso2.com/en/latest/install-and-setup/setup/security/encrypting-plain-text/#step-3-accessing-secrets) section of the MI Secure Vault documentation. By using MI
Secure Vault to store and access sensitive data in your integrations, you can ensure that your integrations
remain secure and protect sensitive data from unauthorized access.


## Scan third-party libraries to identify security vulnerabilities

Scanning third-party libraries for security vulnerabilities is essential for identifying potential weaknesses in an application that could be exploited by attackers. Taking a proactive approach to security helps organizations detect and mitigate risks before they can be exploited, preventing data breaches, system compromises, and other security incidents.

Choreo incorporates a security vulnerability scanning process during deployment. It uses Trivy to scan and detect critical vulnerabilities in third-party libraries added to the integration component. If the scan uncovers any critical vulnerabilities, the deployment process is halted. The deployment pane displays the Trivy scan status and any security failures in the Library (Trivy) vulnerable scan step, which can be accessed by clicking on it. Once the vulnerability has been addressed, you can redeploy the component.

## Customize WSO2 Micro Integrator preconfigured settings

Customizing WSO2 Micro Integrator Preconfigured Settings is essential for ensuring that the integration solution works optimally within the specific context of your organization. While WSO2 MI comes with preconfigured settings designed for general use, these settings may not be suitable for every organization's unique requirements. Customizing these settings can help optimize performance and ensure compatibility with your organization's systems and applications.

To customize the preconfigured settings of WSO2 MI instances running on Choreo, define a `deployment.toml` file in the GitHub repository subpath of your Micro Integrator project:

![deployment.toml](../assets/img/develop-components/micro-integrator/config_file.png)

!!! note
    If you change critical configuration parameters such as port offset and hostname, it can break internal communication.
    Therefore, the recommended approach is to update only the necessary configuration parameters.

Given below is a sample `deployment.toml` file that can be used to configure the JMS transport. For more information on WSO2 MI
configuration parameters, see the [MI Configuration Catalog](https://mi.docs.wso2.com/en/latest/reference/config-catalog-mi/).

```
[[transport.jms.sender]]
name = "myQueueSender"
parameter.initial_naming_factory = "org.apache.activemq.jndi.ActiveMQInitialContextFactory"
parameter.provider_url = "$env{JMS_PROVIDER_URL}"
parameter.connection_factory_name = "QueueConnectionFactory"
parameter.connection_factory_type = "queue"
parameter.cache_level = "producer"

[[transport.jms.listener]]
name = "myQueueListener"
parameter.initial_naming_factory = "org.apache.activemq.jndi.ActiveMQInitialContextFactory"
parameter.provider_url = "$env{JMS_PROVIDER_URL}"
parameter.connection_factory_name = "QueueConnectionFactory"
parameter.connection_factory_type = "queue"
parameter.cache_level = "consumer"
```

## Environment variables

Using environment variables is a recommended practice when developing integration artifacts with WSO2 Integration Studio, as it improves configuration management, security, portability, and manageability. By leveraging environment variables, organizations can streamline the management and maintenance of their integrations, ensuring that updates can be implemented quickly and efficiently.

The component's Deploy page provides a user-friendly interface to manage environment variables across different environments. For information on managing environment variables for complex use cases, see [Configurations and secrets](../devops-and-ci-cd/manage-configurations-and-secrets.md).

![Environment variables](../assets/img/develop-components/micro-integrator/env_variables.png)

Environment variables offer several benefits:

 - Configuration management: They simplify the process of managing and updating configuration settings, making it easier to maintain consistency across different environments.
 - Security: Environment variables help protect sensitive information by storing it securely and separating it from the main codebase.
 - Portability: By using environment variables, you can ensure that your integration artifacts can be easily migrated and deployed across various environments with minimal changes.
 - Manageability: Environment variables offer a centralized way to manage configuration settings, making it easier to update and maintain your integrations over time.

For a comprehensive list of parameters that can be configured as environment variables, see [WSO2 Micro Integrator documentation - Injecting Parameters - Supported parameters](https://mi.docs.wso2.com/en/latest/develop/injecting-parameters/#supported-parameters).

## Configure logging

Configuring logging is crucial when developing and maintaining a software system, as it can significantly improve efficiency during the development, testing, and maintenance phases of the software development process. Logging captures events and messages that occur during an application's execution, providing valuable insights for troubleshooting and debugging issues.

With Micro Integrator instances, you can configure and customize logging according to your requirements. Logging configurations can be added to each MI instance's environment, allowing you to fine-tune logging depending on the specific environment or deployment scenario.

To configure logging in MI instances, follow the steps given below: 

!!! tip
     You can use environment variables with specific naming conventions.

1. Start the variable name with `logging_level_` followed by the package or class name.
2. Replace the dot character in the package name with an underscore.
3. Set the variable value to the required logging level for the corresponding package or class.

    For example, to enable wire logs, change the logging level of the `org.apache.synapse.transport.http.wire` package to `debug`. 

To configure logging, set the environment variable as follows:

1. In the left navigation menu, click **Deploy** and then click **Configs & Secrets**. 
2. Click **+ Create**. 
3. Select **ConfigMap** as the **Config Type** and **Environment Variables** as the **Mount Type**. 
4. Click **Next**. 
5. Specify the following values as mount configurations:

    | **Field**       | **Value**                                              |                                    
    |-----------------|--------------------------------------------------------|
    | **Config Name** | An appropriate name for the configuration.             |
    | **Name**        | `logging_level_org_apache_synapse_transport_http_wire` |
    | **Value**       | `debug`                                                |

6. Click **Create**.

## Connectors

WSO2 Micro Integrator (MI) Connectors are prebuilt connectors designed to simplify integration between WSO2 MI and various other systems. They enable seamless connections to databases, message brokers, REST APIs, and more, allowing you to perform actions such as sending messages, executing queries, or retrieving data. These connectors are easy to use, making it straightforward to incorporate them into your WSO2 MI integration flows. Micro Integrator connectors are versatile and can be utilized in various integration scenarios, including data integration, service-oriented architecture (SOA) integration, and event-driven architecture (EDA) integration.

WSO2 Integration Studio is a comprehensive development environment that facilitates the creation of integration flows using WSO2 Micro Integrator Connectors. With Integration Studio, you can design and implement integration flows that connect diverse systems and execute various actions, such as sending messages, executing queries, or retrieving data. You can build integration flows using either prebuilt connectors provided by WSO2 MI or custom connectors developed using the Connector Development Toolkit. Integration Studio offers a graphical user interface that simplifies the process of building and testing integration flows while also providing a set of tools for managing and deploying these flows in a WSO2 MI runtime environment.

For more information, see the following topics in the WSO2 Micro Integrator documentation.

- [Connectors Overview](https://mi.docs.wso2.com/en/latest/reference/connectors/connectors-overview/)
- [Adding Connectors](https://mi.docs.wso2.com/en/latest/develop/creating-artifacts/adding-connectors/)

## Deploying integrations in Choreo 

WSO2 MI buildpack is where you can deploy integrations developed with WSO2 Micro Integrator as an API. In this preset, you have three different ways to define endpoints. Choreo gives priory to the definition of endpoints in the below-mentioned order. 

1. **Using component.yaml file**
This is the most flexible method to define endpoints. You can configure the endpoint details with the `component.yaml` configuration file. Place this file in the `.choreo` directory in the project path of the component. 
If the Micro Integrator project has inbound endpoints, you can expose them via different endpoints using the `component.yaml`file.

    To learn about the `component.yaml` file, see [Overview of the component.yaml file](../develop-components/manage-component-source-configurations.md#overview-of-the-componentyaml-file).

3. **Auto generating endpoints**
If `component.yaml` is not provided and if the source Micro Integrator project has APIs, Choreo scans the project and generates the API endpoints. If the project has few APIs, an endpoint will be generated for each API. The visibility of this auto-generated endpoint is set to `Public` by default. You can change the visibility in the deployment flow.

4. **Provide default endpoints**
If `component.yaml` is not provided and if the source Micro Integrator project doesn't have APIs, Choreo generates a default endpoint which will expose the default micro integrator port (8290) with `Public` visibility and wildcard context.

!!! note
    If you are currently using `component-config.yaml` or `endpoints.yaml` configuration files, see the respective [migration guide](../develop-components/manage-component-source-configurations.md#migration-guide) for instructions on migrating to the recommended `component.yaml` configuration file.

## Explore Choreo examples on GitHub

For a hands-on experience with MI-based integrations in Choreo, we recommend exploring our samples in Choreo Console. You can filter out the samples based on the buildpack `WSO2 MI`. This will point you to the samples in the [Choreo samples GitHub repository](https://github.com/wso2/choreo-samples)

### [Choreo samples - GitHub Repository](https://github.com/wso2/choreo-samples)

- **Fork the Repository**: Start by forking the repository to your account.

- **Explore & run**: Navigate through the different integration scenarios. Each example has a README.md with setup and execution instructions.



# Develop a Manual Task

This guide walks you through the steps to develop, deploy, test, and observe a manual task using Choreo.

In this guide, you will:

- Develop a manual task to fetch the weather forecast for a specified location for the next 24 hours from the [OpenWeatherMap](https://openweathermap.org) API.
- Process the weather data into a specific format.
- Send the formatted data to a specified email address.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

    !!! info "Repository File Structure"
        The sample code for this guide is in the `<sample-repository-dir>/weather-to-email-integration` directory. The following table describes the key files in the repository:

        | **File Path**         | **File Content**                                                     |
        | --------------------- | -------------------------------------------------------------------- |
        | **Ballerina.toml**    | Contains metadata about the project                                  |
        | **Dependencies.toml** | Lists the dependencies required for the project                      |
        | **main.bal**          | Contains the entry point of the project, including the main function |
        | **types.bal**         | Contains custom data types used in the project                       |
        | **utils.bal**         | Contains utility functions and helper functions used in the project  |

3. Go to [OpenWeatherMap](https://openweathermap.org/) and sign up to obtain an API key. For details, see the [OpenWeatherMap documentation](https://openweathermap.org/appid#signup).

## Step 1: Create a manual task component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Manual Task** card.
6. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:

        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

7. Enter the following information:

    | **Field**             | **Description**                                      |
    | ----------------------| -----------------------------------------------------|
    | **Organization**      | Your GitHub account                                  |
    | **Repository**        | `choreo-samples`                                     |
    | **Branch**            | `main`                                               |
    | **Component Directory** | `weather-to-email-integration`                       |

8. Select **Ballerina** as the **Build Pack**.

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Component Directory** specifies the location of the project to build the component.

4. Enter a unique name and description for the component. You can use the following values:

    | **Field**          | **Value**                        |
    | ------------------ | -------------------------------- |
    | **Component Name** | `WeatherToEmail`                 |
    | **Description**    | `My first manual task`           |


8. Click **Create**. Choreo initializes the component with the sample implementation and opens the **Overview** page of the component.

## Step 2: Build the manual task

1. In the left navigation menu, click **Build**.
2. In the **Builds** pane, click **Build**. This opens the **Commits** pane, where you can see all the commits related to the component.
3. Select the latest commit and click **Build**. This triggers the build process and displays the build progress in the **Build Logs** pane.

    !!! info
        The build process may take some time. Once complete, the build status will be listed in the **Builds** pane. Here, you will see the build status as **Success**.

## Step 3: Deploy the manual task

1. In the left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane, specify values for the configurable variables:

    !!! tip
        The configurable variables populated here are defined in the sample Ballerina project used in this guide. To learn how to declare configurable variables in Ballerina, see the [Ballerina documentation on declaring configurable variables](https://ballerina.io/learn/by-example/configurable-variables/).

    | **Field**     | **Value**                                                               |
    | ------------- | ----------------------------------------------------------------------- |
    | **apiKey**    | The API key you obtained in the prerequisites section                   |
    | **latitude**  | Latitude of the location to get the weather forecast                    |
    | **longitude** | Longitude of the location to get the weather forecast                   |
    | **email**     | The email address to receive the formatted weather forecast information |

    !!! note
        If you use **Ballerina** as the buildpack and want to set a configurable variable as a secret, click the lock icon corresponding to the configurable variable. This marks it as a secret and conceals the input value.

        For example, if you set the **apiKey** as a secret, its input value will be concealed. To update the input value later, click **Update Secret Content** and specify a new value.

4. Click **Deploy**.

## Step 4: Execute the manual task

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the task.

    !!! info "Inject Dynamic Values into Your Application as Command-Line Arguments"
        If you want to inject dynamic values into your application as command-line arguments when you run a manual task, follow these steps:
        1. Click the drop-down icon next to **Run Now** and then click **Run with Arguments**.
        2. In the **Runtime Arguments** pane, enter the arguments you want to pass to your application.
        3. Click **Execute**. This triggers the task with the specified arguments.

        The capability to run a manual task with arguments is supported for the following buildpacks:

        === "Dockerfile"
            To explore a Dockerfile-based manual task with arguments, try out the [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/docker-hello-world-manual-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on Docker projects, the **Run with Arguments** capability is not supported if the Dockerfile contains `CMD`. In such scenarios, use `ENTRYPOINT` to define your default commands.

        === "Go"
            To explore a Go-based manual task with arguments, try out the [Hello World Go Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-go-task) sample. For instructions, see the `readme.md` file in the sample repository.

        === "Java"
            To explore a Java-based manual task with arguments, try out the [Hello World Java Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-java-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on Java projects:
                - The **Run with Arguments** capability is not supported if `Procfile` is available in the project.
                - The `Main` class should be defined in the `manifest` file.
                - If Maven files such as `mvn.cmd` exist in the project without the `.mvn` directory, the build will fail. To ensure a successful build, either commit the `.mvn` directory along with any Maven files or exclude Maven files if you choose not to commit the `.mvn` directory.

        === "NodeJS"
            To explore a NodeJS-based manual task with arguments, try out the [Hello World NodeJS Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-nodejs-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on NodeJS projects:
                - The **Run with Arguments** capability is not supported if `Procfile` is available in the project.
                - The project root must contain the `package.json` file with the `main` attribute defined.

        === "WSO2 MI"
            To explore a WSO2 MI-based manual task with arguments, try out the [Weather to Logs Task](https://github.com/wso2/choreo-samples/tree/main/weather-to-logs-mi-manual-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on WSO2 MI projects and deploying a WSO2 MI integration as a manual task in Choreo, use the WSO2 MI automation mode. For details, see [Running the Micro Integrator in Automation Mode](https://apim.docs.wso2.com/en/latest/install-and-setup/install/running-the-mi-in-automation-mode/).

        === "Ballerina"
            To explore a Ballerina manual task with arguments, try out the [Weather to Email Task](https://github.com/wso2/choreo-samples/tree/main/weather-to-email-integration) sample. For instructions, see the README.md file in the sample repository.

            !!! info
                If you want to pass arguments to Ballerina main functions, use the **Run with Arguments** capability. For details on the arguments you can pass, see the [Ballerina documentation](https://ballerina.io/learn/by-example/main-function/). You can also override configurable values in the same manner. For more information, see [Provide values to configurable variables](https://ballerina.io/learn/provide-values-to-configurable-variables/#provide-via-command-line-arguments).

## Step 5: Test the manual task

Once the task is triggered, an email with the subject `[WSO2 Choreo Demo] Next 24H Weather Forecast` is sent from `choreo.demo@gmail.com` to the email address specified as the **email** configurable variable value in [Step 3](#step-3-deploy-the-manual-task).

If the manual task ran successfully, you should receive an email similar to the following:

![Received email](../../assets/img/develop-components/develop-a-scheduled-integration/Received-email.png)

## Step 6: Observe the manual task

The observability view in Choreo displays graphs that depict details such as throughput, latency, diagnostic data, and logs to identify and troubleshoot anomalies in components you deploy.

1. In the left navigation menu, click **Observability**.
2. Observe the following:
    - The throughput and latencies of requests served over a given period.
    - The logs generated over a given period.
    - The flame graph (Diagnostics View) generated over a given period.
    - The low-code diagram.

To learn more about the observability details you can view via Choreo observability, see [Observability Overview](../../monitoring-and-insights/observability-overview.md).

## Step 7: Monitor executions

To track and monitor executions associated with the deployed manual task, go to the left navigation menu and click **Execute**.

!!! tip
    The **Execute** view is applicable to both scheduled and manual tasks.

You can view the following information:

- **Total executions**: The total number of executions within the past 30 days.

    ![Total Execution](../../assets/img/develop-components/develop-a-scheduled-integration/total_executions.png)

- **Execution history**: The currently active executions and those that are already complete. You can view information such as the execution ID, the revision of the execution, and the time it was triggered.

    ![Execution History](../../assets/img/develop-components/develop-a-scheduled-integration/execution_history.png)

- **Detailed execution logs**: Click on an execution to view detailed logs related to it.

    !!! info
        It may take a few minutes for the logs to appear. You may need to manually refresh to view the latest logs.

    ![Execution Logs](../../assets/img/develop-components/develop-a-scheduled-integration/execution_logs.png)


# Develop a Scheduled Task

Choreo is a versatile integration platform that allows you to create various types of integrations depending on your requirements. If you need to automatically run a specific integration at regular intervals, you can use Choreo to develop a scheduled task. This type of integration can automate the synchronization of data between different systems at specified intervals, reducing errors and improving productivity by eliminating the need for manual intervention.

This guide walks you through the steps to develop, deploy, test, and observe a scheduled task using Choreo.

In this guide, you will:

- Develop a scheduled task to fetch the weather forecast for a specified location for the next 24 hours from the [OpenWeatherMap](https://openweathermap.org) API.
- Process the weather data into a specific format.
- Send the formatted data to a specified email address at a specific time every day.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

    !!! info "Repository File Structure"
        The sample code for this guide is in the `<sample-repository-dir>/weather-to-email-scheduled-task` directory. The following table describes the key files in the repository:

        | **File Path**         | **File Content**                                                     |
        | --------------------- | -------------------------------------------------------------------- |
        | **Ballerina.toml**    | Contains metadata about the project                                  |
        | **Dependencies.toml** | Lists the dependencies required for the project                      |
        | **main.bal**          | Contains the entry point of the project, including the main function |
        | **types.bal**         | Contains custom data types used in the project                       |
        | **utils.bal**         | Contains utility functions and helper functions used in the project  |

3. Go to [OpenWeatherMap](https://openweathermap.org/) and sign up to obtain an API key. For details, see the [OpenWeatherMap documentation](https://openweathermap.org/appid#signup).

## Step 1: Create a scheduled task component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Scheduled Task** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following information:

    | **Field**             | **Description**                                |
    | --------------------- | ---------------------------------------------- |
    | **Organization**      | Your GitHub account                            |
    | **Repository**        | `choreo-samples`                               |
    | **Branch**            | `main`                                         |
    | **Component Directory** | `weather-to-email-scheduled-task`              |

6. Select **Ballerina** as the build pack.

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Component Directory** specifies the location of the project to build the component.

7. Enter a unique name and description for the component. You can use the following values:

    | **Field**          | **Value**                        |
    | ------------------ | -------------------------------- |
    | **Component Name** | `WeatherToEmail`                 |
    | **Description**    | `My first scheduled task`        |

8. Click **Create**. Choreo initializes the component with the sample implementation and opens the **Overview** page of the component.

Now you can proceed to build and deploy the scheduled task.

## Step 2: Build the scheduled task

1. In the left navigation menu, click **Build**.
2. In the **Builds** pane, click **Build**. This opens the **Commits** pane, where you can see all the commits related to the component.
3. Select the latest commit and click **Build**. This triggers the build process and displays the build progress in the **Build Logs** pane.

    !!! info
        The build process may take some time. Once complete, the build status will be listed in the **Builds** pane. Here, you will see the build status as **Success**.

## Step 3: Deploy the scheduled task

1. In the left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane, specify values for the configurable variables:

    !!! tip
        The configurable variables populated here are defined in the sample Ballerina project used in this guide. To learn how to declare configurable variables in Ballerina, see the [Ballerina documentation on declaring configurable variables](https://ballerina.io/learn/by-example/configurable-variables/).

    | **Field**     | **Value**                                                               |
    | ------------- | ----------------------------------------------------------------------- |
    | **apiKey**    | The API key you obtained in the prerequisites section                   |
    | **latitude**  | Latitude of the location to get the weather forecast                    |
    | **longitude** | Longitude of the location to get the weather forecast                   |
    | **email**     | The email address to receive the formatted weather forecast information |

    !!! note
        If you use **Ballerina** as the buildpack and want to set a configurable variable as a secret, click the lock icon corresponding to the configurable variable. This marks it as a secret and conceals the input value.

        For example, if you set the **apiKey** as a secret, its input value will be concealed. To update the input value later, click **Update Secret Content** and specify a new value.

4. Click **Next**.
5. Define a schedule to run the task. In this guide, set the schedule to receive the weather information daily at 8:00 AM UTC. Enter the following values:

    | **Field**            | **Value**                                             |
    | -------------------- | ----------------------------------------------------- |
    | **Select Time Zone** | Select a time zone to schedule the task               |
    | **Select Range**     | **Day**                                               |
    | **Every**            | `1`                                                   |
    | **At**               | `08:00`                                               |

    !!! tip
        To test and verify the task immediately, you can schedule the deployment to run in just a few minutes after you create it. However, to avoid unnecessary expenses, reschedule or stop the deployment once you test and verify.

6. Click **Deploy**. This deploys the scheduled task to the development environment and indicates the **Scheduled Status** as **Active** in the **Development** card.

You can test the scheduled task when it runs at the configured time.

## Step 4: Test the scheduled task

When the scheduled task runs at the configured time, an email with the subject `[WSO2 Choreo Demo] Next 24H Weather Forecast` is sent from `choreo.demo@gmail.com` to the email address specified as the **email** configurable variable value in [Step 3](#step-3-deploy-the-scheduled-task).

If the scheduled task ran successfully, you should receive an email similar to the following:

![Received email](../../assets/img/develop-components/develop-a-scheduled-integration/Received-email.png)

## Step 5: Observe the scheduled task

The observability view in Choreo displays graphs that depict details such as throughput, latency, diagnostic data, and logs to identify and troubleshoot anomalies in components you deploy.

1. In the left navigation menu, click **Observability**.
2. Observe the following:
    - The throughput and latencies of requests served over a given period.
    - The logs generated over a given period.
    - The flame graph (Diagnostics View) generated over a given period.
    - The low-code diagram.

To learn more about the observability details you can view via Choreo observability, see [Observability Overview](../../monitoring-and-insights/observability-overview.md).

## Step 6: Monitor executions

To track and monitor executions associated with the deployed scheduled task, go to the left navigation menu and click **Execute**.

!!! tip
    The **Execute** view is applicable to both scheduled and manual tasks.

You can view the following information:

- **Total executions**: The total number of executions within the past 30 days.

    ![Total Execution](../../assets/img/develop-components/develop-a-scheduled-integration/total_executions.png)

- **Execution history**: The currently active executions and those that are already complete. You can view information such as the execution ID, the revision of the execution, and the time it was triggered.

    ![Execution History](../../assets/img/develop-components/develop-a-scheduled-integration/execution_history.png)

- **Detailed execution logs**: Click on an execution to view detailed logs related to it.

    !!! info
        It may take a few minutes for the logs to appear. You may need to manually refresh to view the latest logs.

    ![Execution Logs](../../assets/img/develop-components/develop-a-scheduled-integration/execution_logs.png)


# Develop an Event Handler

An event handler executes predefined actions in response to specific events. Choreo simplifies the process of creating and deploying such integrations.

This guide walks you through the steps to create and deploy an Event Handler using WSO2 MI and Choreo.

In this guide, you will build a simple event handler that monitors RabbitMQ for new messages and displays them once they become available.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Set up RabbitMQ:
    - Use an existing RabbitMQ instance or start a new [RabbitMQ](https://www.rabbitmq.com/download.html) instance on a server that can be accessed via the internet.
    - Obtain the `username`, `hostname`, `password`, and `vhost` from the RabbitMQ instance to use later as environment variables.

3. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

## Step 1: Create an event handler component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Event Handler** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following information:

    | **Field**             | **Description**              |
    |-----------------------|----------------------------- |
    | **Organization**      | Your GitHub account          |
    | **Repository**        | `choreo-samples`             |
    | **Branch**            | `main`                       |
    | **Component Directory** | `mi-rabbitmq-listener`       |

6. Select **WSO2 MI** as the build pack. (since you are creating the REST API from a [WSO2 Integration Studio](https://wso2.com/micro-integrator/) project)

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Component Directory** specifies the location of the project to build the component.

7. Enter a unique name and description for the component. You can use the following values:

    | **Field**          | **Value**              |
    |--------------------|------------------------|
    | **Component Name** | `SalesOrderListener`   |
    | **Description**    | `RabbitMQ integration` |

8. Click **Create**.

## Step 2: Deploy the integration

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**.
3. In the **Configurations** pane, click **+ Add** corresponding to **Environment Variables** and add the following environment variables:

    !!! tip
        Use the values from your RabbitMQ instance as per the [Prerequisites](#prerequisites) section for the environment variables.

    | **Name**     | **Value**                                         |
    | ------------- |--------------------------------------------------|
    | **HOSTNAME**  | Hostname of your RabbitMQ server                 |
    | **VHOST**     | Virtual hostname of your RabbitMQ server         |
    | **USERNAME**  | Username for connecting to RabbitMQ              |
    | **PASSWORD**  | Password associated with the RabbitMQ username   |

4. Click **Deploy**. This deploys the event handler to the development environment and indicates the **Deployment Status** as **Active** in the **Development** card.

## Step 3: Test the integration

1. Send a sales order message to the **SalesOrderQueue** on the RabbitMQ server. You can send a sample sales order message similar to the following:

    ```json
    {
        "order_id": "12345",
        "customer_name": "John Doe",
        "product": "Widget",
        "quantity": 10,
        "total_amount": 100.00
    }
    ```

2. Observe the logs:
    - In the left navigation menu, click **Logs** and then click **Runtime Logs**. You will see the order message in the logs.

Now you have gained hands-on experience in creating, configuring, and deploying an event handler.


# Develop an Integration with Integration Studio

Choreo simplifies the process of building, deploying, and managing integration components, making it easy to expose integrations as APIs. This guide walks you through the steps to expose an integration created in WSO2 Integration Studio as an API in Choreo.

In this guide, you will:
- Create a component to expose a sample integration from the [Choreo samples repository](https://github.com/wso2/choreo-samples) as an API.
- Deploy, test, and observe the integration component.
- Publish the integration component as an API to the Choreo Developer Portal.

!!! note
    - To develop integrations for **Manual Task** and **Schedule Task** components in Choreo, use the **automation mode** in the WSO2 Micro Integrator. See [Running MI in Automation Mode](https://apim.docs.wso2.com/en/4.2.0/install-and-setup/install/running-the-mi-in-automation-mode/).
    - For other component types (Service, webhook, event-handler, etc.), use the **server mode**.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    - Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    - Enter a unique organization name. For example, `Stark Industries`.
    - Read and accept the privacy policy and terms of use.
    - Click **Create**. This creates the organization and opens the **Project Home** page.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

## Step 1: Create the integration component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the **Project Home** page.

2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following repository details:

    | **Field**             | **Description**              |
    |-----------------------|----------------------------- |
    | **Organization**      | Your GitHub account          |
    | **Repository**        | `choreo-samples`            |
    | **Branch**            | **`main`**                   |
    | **Component Directory** | `hello-world-mi`             |

6. Select WSO2 MI as the build pack (since you're creating the REST API from a [WSO2 Integration Studio](https://wso2.com/micro-integrator/) project).

7. Provide a unique name and description for the component:

    | **Field**          | **Value**              |
    |--------------------|------------------------|
    | **Component Name** | `Hello World`          |
    | **Description**    | `Hello World REST API` |

8. Click **Create**. Choreo initializes the component with the sample integration.

## Step 2: Deploy the integration component

1. In the Choreo Console left navigation menu, click **Deploy**.

2. Configure and deploy:
   - In the **Build Area** card, click **Configure & Deploy**.
   - In the **Configurations** pane, click **Next**. This displays the endpoint details ready for deployment.
   - Click **Deploy**. This deploys the integration component to the development environment.

    !!! tip
        - Choreo uses [endpoints](../../choreo-concepts/endpoint.md) to expose **Service** components to the network. Learn more about configuring endpoints in [Configure Endpoints](../configure-endpoints.md).
        - Automatic deployment is enabled by default, so only the first deployment needs to be done manually.

   The **Development** card shows the **Deployment Status** as **Active** when the integration is successfully deployed.

## Step 3: Test the integration

1. In the Choreo Console left navigation menu, click **Test** and then click **Console**.
2. In the OpenAPI Console, select **Development** from the environment drop-down list.
3. Expand the **GET /integration** operation.
4. Click **Try it out**, then click **Execute**. This sends a request to your deployed integration.
5. Check the response:
    - In the **Response body** section, observe the response. If the integration works as expected, you should see:
     
     ```json
     {"Hello" : "Integration"}
     ```

## Step 4: Observe the integration

1. Click **Observability** in the left navigation menu to monitor the performance of the integration component.

2. View metrics:
   - Observe throughput and latencies of requests over time.
   - View logs generated during a specific period.
   - Analyze the flame graph (Diagnostics View) for performance insights.

   For more details, see [Observability Overview](../../monitoring-and-insights/observability-overview.md).

## Step 5: Publish the integration component

1. In the Choreo Console left navigation menu, click **Manage** and then click **Lifecycle**.
2. The **Lifecycle Management** pane shows the current lifecycle stage as **Created**.
3. Click **Publish**. This changes the lifecycle stage to **Published** and exposes the integration as an API in the Choreo Developer Portal.
   - To view the published API, click **Go to Devportal**. In the Developer Portal, you can manage subscriptions and generate access tokens for testing.

Now you have successfully exposed an integration designed in WSO2 Integration Studio as a REST API in Choreo!


# Develop an API Proxy from a GitHub Repository Source

An API proxy acts as an intermediary between an existing API and Choreo, intercepting all requests made to the API. It also functions as a managed API, allowing you to apply essential API management features such as security policies and rate limiting.

In this guide, you will:

- Create an API proxy component to expose an existing API.
- Deploy the API proxy.
- Test the API proxy to verify its functionality.
- Manage the API.
- Consume the API.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample proxy source](https://github.com/wso2/choreo-samples/tree/main/department-api-proxy-from-github).  

## Step 1: Create an API proxy

You can create an API proxy either by selecting the source from a GitHub repository, uploading an OpenAPI specification file, or providing an OpenAPI specification URL. This guide demonstrates how to create an API proxy using a GitHub repository as the source.

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **API Proxy** card. This opens the **Create an API Proxy** pane.

4. Click on **Authorize With GitHub** card under **Connect a Git Repository** section to connect your GitHub account.
    - If you haven’t connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
         - Read and write access to code and pull requests.
         - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.    

5. Enter the following repository details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **Repository**         | choreo-samples     |
    | **Branch**             | **`main`**         |
    | **API Directory**      | /department-api-proxy-from-github |

    !!! note
        To select the relevant directory, click on the **Edit** action next to the **API Directory** input field. Then, enter `department-api-proxy-from-github` as the directory name to quickly search and locate the correct directory.

6. Specify the following values as Proxy Metadata:

    !!! info
        The **Context** field must be unique and cannot be changed after creation.**Version** and **Target** are mandatory fields. **Target** can be changed at any time after the creation.

    | **Field**       | **Value**                                  |
    |-----------------|--------------------------------------------|
    | **Context**     | `department-service`                                   |
    | **Version**     | `v1.0`                                      |
    | **Target**      | `https://samples.choreoapps.dev/company/hr`|

7. Specify the following values as Component Details:

    !!! info
        The **Component Name** field must be unique and cannot be changed after creation. This value is automatically generated, but you can edit it if necessary.
        **Component Display Name** is a required field.

    | **Field**       | **Value**                                  |
    |-----------------|--------------------------------------------|
    | **Component Display Name**| `Department Service`                    |
    | **Component Name**        | `department-service`                    |
    | **Description**           | `This is a sample proxy for department service`     |    

8. Click **Create**. This creates the API proxy component and takes you to the **Build** page.

!!! note
    When you create an API proxy from a GitHub repository source, the GitHub source serves as the single source of truth. Therefore, any modifications, such as adding or deleting resources, must be made through the GitHub repository.

## Step 2: Build

!!! info
    The initial build starts automatically when you create the API proxy, and you will be redirected to the **Build** page. In this case, you can skip the steps below. If you need to manually trigger a build later, follow these steps.

1. On the project home page, click on the `Department Service` component you created. This takes you to the component overview page.
2. In the left navigation menu, click **Build**.
3. On the **Build** page, click **Build Latest**.

!!! note
    The build process may take some time. You can track progress in the **Build Details** pane. Once complete, the build status changes to **Success**.

## Step 3: Deploy the API proxy

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**. This opens the **Configure & Deploy** pane.
3. Select **External** as the **API Access Mode** and click **Deploy**. The **Development** card indicates the **Deployment Status** as **Active** when the API proxy is successfully deployed.

Now you are ready to test the API proxy.

## Step 4: Test the API proxy

Choreo allows you to test your API proxy using either the [integrated OpenAPI Console](../../testing/test-rest-endpoints-via-the-openapi-console.md) or [cURL](../../testing/test-apis-with-curl.md). In this guide, you will use the OpenAPI Console.

!!! tip
    Choreo enables OAuth 2.0 to secure APIs by default. Therefore, you need an access token to invoke an API.

    - Choreo automatically generates a key to test the API via the OpenAPI Console. To view the key, click the show key icon in the **Security Header** field.
    - To disable security for the entire API or a specific resource:
        1. In the left navigation menu, click **Deploy**.
        2. Go to the **Build Area** card and click **Security Settings**.
        3. In the **Security Settings** pane:
            - To disable security for the entire API, clear the **OAuth2** checkbox.
            - To disable security for a specific resource, expand the relevant resource and turn off the **Security** toggle.
        4. Click **Apply**.

1. In the left navigation menu, click **Test** and then click **OpenAPI Console**.
2. Select **Development** from the environment drop-down list.
3. Expand the `GET /department/{departmentId}` resource and click **Try it Out**.
4. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

    ![API proxy response](../../assets/img/develop-components/develop-a-rest-api-proxy/rest-api-proxy-response.png){.cInlineImage-full}

    This indicates that your API proxy is working as expected.

## Step 5: Manage the API proxy

Now that you have a tested API proxy, you can publish it and make it available for application developers to consume. In this guide, you will apply rate limiting to the API and publish it.

### Step 5.1: Apply rate limiting to the API proxy

1. In the left navigation menu, click **Deploy**.
2. Go to the required environment card and click the settings icon corresponding to **API Configuration**.
3. In the **CORS, Rate Limiting and Resiliency** pane, click **Rate Limiting** to expand the section.
4. Select **API Level** as the **Rate Limiting Level**.
5. Specify appropriate values for the **Request Limit** and **Time Unit** fields. You can proceed with the default values.
6. Click **Apply**. This applies the rate limiting level to the API proxy and redeploys it.

### Step 5.2: Publish the API proxy

1. In the left navigation menu, click **Lifecycle** under **Manage**. This takes you to the **Lifecycle** page.
2. Click **Publish**.
3. In the **Publish API** dialog, click **Confirm** to proceed with publishing the API. If you want to change the display name, make the necessary changes and then click **Confirm**. This changes the API lifecycle state to **Published**.

## Step 6: Invoke the API

To generate credentials for the published API and invoke it via the Choreo Developer Portal, follow these steps:

1. In the **Lifecycle** page, click **Go to Devportal**. This takes you to the `Department Service` in the Choreo Developer Portal.

2. **Invoke the API**:
    1. In the Developer Portal left navigation menu, click **Try Out**.
    2. In the **Endpoint** list, select **Development** as the environment to try out the API.
    3. Click **Get Test Key** to generate an access token.
    4. Expand the `GET /department/{departmentId}` resource and click **Try it out**.
    5. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

        ![Try out response](../../assets/img/develop-components/develop-a-rest-api-proxy/try-out-response.png){.cInlineImage-full}

Now, you have gained hands-on experience creating, deploying, testing, and publishing an API proxy using Choreo.


# Develop an API Proxy from Scratch

An API proxy acts as an intermediary between an existing API and Choreo, intercepting all requests made to the API. It also functions as a managed API, allowing you to apply essential API management features such as security policies and rate limiting.

In this guide, you will:

- Create an API proxy component to expose an existing API.
- Deploy the API proxy.
- Test the API proxy to verify its functionality.
- Manage the API.
- Consume the API.

## Prerequisites

- If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

## Step 1: Create an API proxy

To create an API proxy, you can either upload an OpenAPI specification or provide an OpenAPI specification URL. In this guide, you will specify a URL to an OpenAPI definition of a sample API.

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **API Proxy** card. This opens the **Create an API Proxy** pane.
4. Select **Creare from Scratch** option. 
5. Specify the following values as Proxy Metadata:

    | **Field**       | **Value**                                  |
    |-----------------|--------------------------------------------|
    | **Context**     | `department-service`                                   |
    | **Version**     | `v1.0`                                      |
    | **Target**      | `https://samples.choreoapps.dev/company/hr` |

6. Enter following details for the Component Details:

    !!! info
        The **Component Name** field must be unique and cannot be changed after creation.

    | **Field**                 | **Value**          |
    |---------------------------|--------------------|
    | **Component Display Name**| `Department Service`          |
    | **Component Name**        | `department-service`          |
    | **Description**           | `Sample proxy for department service`     |

7. Click **Create**. This creates the API proxy component and takes you to the **Deploy** page.

## Step 2: Define resources for the API proxy

To add a new resource that retrieves a department by the department ID, follow these steps:

1. In the left navigation menu, click **Develop** and then click **Resources**.
2. Select **GET** as the **HTTP Verb** and enter `/department/{departmentId}` as the **URI Pattern**.
3. Click **+** to add the resource.
4. Expand the added resource and specify the following values:

    | **Field**        | **Value**                            |
    |------------------|--------------------------------------|
    | **Operation ID** | `findDepartment`                     |
    | **Description**  | `Find a department by department ID` |

5. Remove the five default resources that start with `/*` by clicking the delete icon corresponding to each resource.
6. Click **Save**.

## Step 3: Deploy the API proxy

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**. This opens the **Configure & Deploy** pane.
3. Select **External** as the API access mode and click **Deploy**. The **Development** card indicates the **Deployment Status** as **Active** when the API proxy is successfully deployed.

Now you are ready to test the API proxy.

## Step 4: Test the API proxy

Choreo allows you to test your API proxy using either the [integrated OpenAPI Console](../../testing/test-rest-endpoints-via-the-openapi-console.md) or [cURL](../testing/test-apis-with-curl.md). In this guide, you will use the OpenAPI Console.

!!! tip
    Choreo enables OAuth 2.0 to secure APIs by default. Therefore, you need an access token to invoke an API.

    - Choreo automatically generates a key to test the API via the OpenAPI Console. To view the key, click the show key icon in the **Security Header** field.
    - To disable security for the entire API or a specific resource:
        1. In the left navigation menu, click **Deploy**.
        2. Go to the **Build Area** card and click **Security Settings**.
        3. In the **Security Settings** pane:
            - To disable security for the entire API, clear the **OAuth2** checkbox.
            - To disable security for a specific resource, expand the relevant resource and turn off the **Security** toggle.
        4. Click **Apply**.

1. In the left navigation menu, click **Test** and then click **OpenAPI Console**.
2. Select **Development** from the environment drop-down list.
3. Expand the `GET /department/{departmentId}` resource and click **Try it Out**.
4. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

    ![API proxy response](../../assets/img/develop-components/develop-a-rest-api-proxy/rest-api-proxy-response.png){.cInlineImage-full}

    This indicates that your API proxy is working as expected.

## Step 5: Manage the API proxy

Now that you have a tested API proxy, you can publish it and make it available for application developers to consume. In this guide, you will apply rate limiting to the API and publish it.

### Step 5.1: Apply rate limiting to the API proxy

1. In the left navigation menu, click **Deploy**.
2. Go to the required environment card and click the settings icon corresponding to **CORS, Rate Limiting and Resiliency**.
3. In the **CORS, Rate Limiting and Resiliency** pane, click **Rate Limiting** to expand the section.
4. Select **API Level** as the **Rate Limiting Level**.
5. Specify appropriate values for the **Request Limit** and **Time Unit** fields. You can proceed with the default values.
6. Click **Apply**. This applies the rate limiting level to the API proxy and redeploys it.

### Step 5.2: Publish the API proxy

1. In the left navigation menu, click **Lifecycle** under **Manage**. This takes you to the **Lifecycle** page.
2. Click **Publish**.
3. In the **Publish API** dialog, click **Confirm** to proceed with publishing the API. If you want to change the display name, make the necessary changes and then click **Confirm**. This changes the API lifecycle state to **Published**.

## Step 6: Invoke the API

To generate credentials for the published API and invoke it via the Choreo Developer Portal, follow these steps:

1. In the **Lifecycle** page, click **Go to Devportal**. This takes you to the `Department Service` in the Choreo Developer Portal.

2. **Invoke the API**:
    1. In the Developer Portal left navigation menu, click **Try Out**.
    2. In the **Endpoint** list, select **Development** as the environment to try out the API.
    3. Click **Get Test Key** to generate an access token.
    4. Expand the `GET /department/{departmentId}` resource and click **Try it out**.
    5. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

        ![Try out response](../../assets/img/develop-components/develop-a-rest-api-proxy/try-out-response.png){.cInlineImage-full}

Now, you have gained hands-on experience creating, deploying, testing, and publishing an API proxy using Choreo.

# Develop a Ballerina Service

Choreo allows you to develop and deploy applications using your preferred programming language. This guide demonstrates how to deploy a service component that exposes a REST API using the [Ballerina language](https://ballerina.io/). No prior knowledge of Ballerina is required to follow this guide.

A REST API is a web service that adheres to Representational State Transfer (REST) principles, using HTTP methods to access and manage resources. This guide walks you through building a Ballerina service component, deploying it on Choreo, and testing it with an HTTP client application.

In this guide, you will:

 - Build a simple greeting service using a sample implementation. The service has a single resource named `greet` that accepts a query parameter as input.
 - Deploy the service in Choreo.
 - Test the service.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    - Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    - Enter a unique organization name. For example, `Stark Industries`.
    - Read and accept the privacy policy and terms of use.
    - Click **Create**. This creates the organization and opens the **Project Home** page.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample greetings service](https://github.com/wso2/choreo-samples/tree/main/greeting-service) implementation in Ballerina.

### Learn the repository file structure

It’s important to understand the purpose of key files in the sample service. The table below provides an overview of each file in the greeter service:

!!! note
    The file paths are relative to `<sample-repository-dir>/greeting-service`.

| **Filepath**              | **Description**                                                |
|---------------------------|---------------------------------------------------------------|
| `service.bal`             | The greetings service code written in Ballerina.               |
| `tests/service_test.bal`  | Test files related to the `service.bal` file.                  |
| `Ballerina.toml`          | The Ballerina configuration file.                              |

Let’s get started!

## Step 1: Create a service component

To create a Ballerina service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the **Project Home** page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect your GitHub account. If you haven’t connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Provide the following repository details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **Repository**         | choreo-samples     |
    | **Branch**             | **`main`**         |
    |**Component Directory** | `/greeting-service` |

6. Select **Ballerina** as the buildpack.

7. Provide a display name, a unique name, and a description for the service component:

    !!! info
        The **Component Name** field specifies a unique identifier for the component. This name cannot be changed after creation.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Ballerina Greetings`   |
    | **Component Name**        | `ballerina-greetings`   |
    | **Description**           | Send greetings          |

8. Click **Create**. This creates the component and takes you to the **Overview** page.

You have successfully created a service that exposes a REST API written in Ballerina. Next, let’s build and deploy the service.

## Step 2: Build and deploy

Now that you’ve connected the source repository and configured the endpoint details, it’s time to build and deploy the service.

!!! note
    If you’re rebuilding the Ballerina service component after changing the Ballerina version, ensure that the version in the `Ballerina.toml` file matches the version in the `Dependencies.toml` file.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service may take a while. Track the progress via the logs in the **Build Details** pane. Once complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps:

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane, click **Next** to skip the configuration.
4. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service may take a while. Once deployed, the **Development** environment card shows the **Deployment Status** as **Active**.

Once deployed, you can test, manage, and observe the service like any other component in Choreo.

For detailed instructions, see the following sections:
- [Step 3: Test](../../testing/test-rest-endpoints-via-the-openapi-console.md)
- [Step 4: Manage](../../api-management/lifecycle-management.md)

## Manage the deployment

To view Kubernetes-level insights for detailed diagnosis of this Ballerina REST API, see Choreo’s [DevOps capabilities](../../devops-and-ci-cd/view-runtime-details.md).


# Develop a Service with Docker

Choreo allows you to create and deploy applications in any language. This guide demonstrates how to develop and deploy a containerized service component using a Dockerfile.

In this guide, you will:

 - Create a containerized service component using a sample service implementation. The sample service has a single resource named `greet` that accepts a query parameter as input.
 - Deploy the service in Choreo using a Dockerfile. The service will run on port 9090.
 - Test the service.

If you want to create a service component that exposes a Ballerina service, see [Develop a Ballerina Service](develop-a-ballerina-service.md).

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    - Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    - Enter a unique organization name. For example, `Stark Industries`.
    - Read and accept the privacy policy and terms of use.
    - Click **Create**. This creates the organization and opens the **Project Home** page.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample greetings service](https://github.com/wso2/choreo-samples/tree/main/greeting-service-go) implementation with the Dockerfile.

### Learn the repository file structure

It’s important to understand the purpose of key files in the sample service. The table below provides an overview of each file in the greeter service:

!!! note
    The file paths are relative to `<sample-repository-dir>/greeting-service-go`.

| **Filepath**               | **Description**                                                              |
|----------------------------|------------------------------------------------------------------------------|
| `main.go`                  | The Go-based greeter service code.                                           |
| `Dockerfile`               | The Dockerfile to build the container image of the application.              |
| `.choreo/component.yaml`   | Choreo-specific configuration that provides information about how Choreo exposes the service. |
| `openapi.yaml`             | The OpenAPI contract of the greeter service. This is required to publish the service as a managed API. This file is referenced by the `.choreo/component.yaml` file. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints. The greeter service runs on port 9090. To securely expose the service through Choreo, you must provide the port and other required information in the `component.yaml` file. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

In the greeter sample, the `component.yaml` file is located in the `greeting-service-go/.choreo/` directory.

## Step 1: Create a service component from a Dockerfile

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/cloud-native-app-developer) and sign in. This opens the **Project Home** page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect your GitHub account. If you haven’t connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
         - Read and write access to code and pull requests.
         - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following repository details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **Repository**         | choreo-samples     |
    | **Branch**             | `main`         |
    | **Component Directory** | `/greeting-service-go`         |

6. Select **Docker** as the buildpack.
7. Enter the following details:

    | **Field**                | **Value**                        |
    |--------------------------|----------------------------------|
    | **Dockerfile**           | `/greeting-service-go/Dockerfile`|

    !!! info
        1. To successfully build your container with Choreo, explicitly define a user ID (UID) under the `USER` instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-sample-apps/blob/main/go/greeter/Dockerfile).
           - A valid User ID is a numeric value between 10000-20000 (e.g., `10001` or `10500`).
           - Usernames are invalid and should not be used (e.g., `my-custom-user-12221` or `my-custom-user`).

        2. The Dockerfile used in this guide is a multi-stage Dockerfile, which keeps the final image size small and allows building the application with specific versions of tools and libraries.

8. Provide a display name, a unique name, and a description for the service component:

    !!! info
        The **Component Name** field specifies a unique identifier for the component. This name cannot be changed after creation.

    | **Field**                 | **Value**          |
    |---------------------------|--------------------|
    | **Component Display Name**| `Greetings`        |
    | **Component Name**        | `greetings`        |
    | **Description**           | Send greetings     |

9. Click **Create**. This creates the component and takes you to the **Overview** page.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you’ve connected the source repository and configured the endpoint details, it’s time to build the service and create an image. Then, you can deploy the image and test the greeter service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service may take a while. Track the progress via the logs in the **Build Details** pane. Once complete, the build status changes to **Success**.

    You can access the following scans under **Build**:
    - **Dockerfile Scan**: Choreo checks if a non-root user ID is assigned to the Docker container for security. If no non-root user is specified, the build will fail.
    - **Container (Trivy) Vulnerability Scan**: This detects vulnerabilities in the final Docker image. If critical vulnerabilities are found, the build will fail.

    !!! info
        If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps:

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service may take a while. Once deployed, the **Development** environment card shows the **Deployment Status** as **Active**.

Once deployed, you can [test](../../testing/test-rest-endpoints-via-the-openapi-console.md), [manage](../../api-management/lifecycle-management.md), and [observe](../../monitoring-and-insights/observability-overview.md) the service like any other component in Choreo.

To view Kubernetes-level insights for detailed diagnosis of this Dockerfile-based REST API, see [Choreo's DevOps capabilities](../../devops-and-ci-cd/view-runtime-details.md).


# Develop a Service

Choreo allows you to create and deploy applications in your preferred programming language. 

In this guide, you will:

- Build a simple greeting service using a sample service implementation. The sample implementation will have a single resource named `greet` that accepts a single query parameter as input.
- Deploy the service in Choreo using a `Go` buildpack. The service will run on port 9090.
- Test the service.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample greetings service](https://github.com/wso2/choreo-samples/tree/main/greeting-service-go) implementation in `Go`.

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the greeter service:

!!! note 
    The specified file paths are relative to `<sample-repository-dir>/greeting-service-go`.

| **Filepath**             | **Description**                                                               |
|--------------------------|-------------------------------------------------------------------------------|
| `main.go`                | The Go-based greeter service code.                                            |
| `.choreo/component.yaml` | Choreo-specific configuration that provides information about how Choreo exposes the service. |
| `openapi.yaml`           | The OpenAPI contract of the greeter service. This is required to publish the service as a managed API. This `openapi.yaml` file is referenced by the `.choreo/component.yaml` file. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints. To run the greeter service on port 9090 and securely expose it through Choreo, you must provide the port and other required information in the `component.yaml` file. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

In the greeter sample, the `component.yaml` file is located in the `greeting-service-go/.choreo/` directory.

## Step 1: Create a service component

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Public Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Under **Connect a Git Repository**, enter the following details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **GitHub Repository**  | choreo-samples     |
    | **Branch**             | main               |
    | **Component Directory** | `/greeting-service-go` |

6. Select **Go** as the buildpack.
7. Enter the following details:

    | **Field**                | **Value**              |
    |--------------------------|------------------------|
    | **Language Version**     | 1.x                    |

8. Provide component display name, name and description:

    !!! info
        The **Component Name** field must be unique and cannot be changed after creation.

    | **Field**                 | **Value**          |
    |---------------------------|--------------------|
    | **Component Display Name**| Greetings          |
    | **Component Name**        | greetings          |
    | **Description**           | Send greetings     |

9. Click **Create**. This creates the component and lists it under **Component Listing** on the project home page.

You have successfully created the service. The next step is to build and deploy it.

## Step 2: Build and deploy

Now that you have connected the source repository and configured the endpoint details, it's time to build and deploy the greeter service.

### Step 2.1: Build

1. On the project home page, click on the `Greetings` component you created. This takes you to the component overview page.
2. In the left navigation menu, click **Build**.
3. On the **Build** page, click **Build Latest**.

    !!! note
        The build process may take some time. You can track progress in the **Build Details** pane. Once complete, the build status changes to **Success**.

### Step 2.2: Deploy

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take some time. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

Once you have successfully deployed the service, you can [test](../../testing/test-rest-endpoints-via-the-openapi-console.md), [manage](../../api-management/lifecycle-management.md), and [observe](../../monitoring-and-insights/observability-overview.md) it like any other component type in Choreo.


# Expose a Ballerina GraphQL Endpoint via a Service

Choreo offers the flexibility to develop and deploy applications in a language of your preference. This guide shows you how to deploy a service component that exposes a GraphQL API using the Ballerina language in Choreo. No prior knowledge of the Ballerina language is required to follow this guide. 

GraphQL API is a query language and runtime that provides a single endpoint for retrieving flexible and efficient data in a strongly-typed and self-documenting way. By following this guide, you will build a service component in Ballerina and deploy it on Choreo for any GraphQL client application to utilize it.

This guide shows how to build a simple reading list service and deploy it in Choreo using Ballerina. The GraphQL endpoint you create in this guide has two operations: **Query** and **Mutation**. The Query type operations read the data in the data source, and the Mutation operations update the data in the data source. The reading list service has two queries and three mutations as follows:

### Queries

**Retrieve the reading list**

This resource accepts an optional filter, `status`, which filters the reading list by reading status. Accepted values for status are `reading`, `read`, and `to_read`.

**Sample request**:
```
$ curl -X POST -H "Content-Type: application/json" -d '{"query": "query {allBooks (status: \"reading\") { id title author status }}"}' http://localhost:8090
```

**Sample response**
```
$ {
  "data": {
    "allBooks": [
      {
        "id": 1,
        "title": "Sample Book",
        "author": "Test Author",
        "status": "to_read"
      }
    ]
  }
}
```

**Retrieve a book item from the reading list**

This resource accepts a filter, `id`, which will select the book item from the reading list by book id.  The id is an Integer value. 

**Sample request**
```
$ curl -X POST -H "Content-Type: application/json" -d '{"query": "query {book (id: 1) { id title author status }}"}' http://localhost:8090
```

**Sample response**
```
$ {
  "data": {
    "book": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "to_read"
    }
  }
}
```

### Mutations

**Add a book item to the reading list**

This remote function accepts a book record as the input and consists of the title and the author. When you add a new book to the reading list, the method updates the reading status of the newly added book to `to_read`. This method returns the added book item upon successful execution.


**Sample request**

```
$ curl -X POST -H "Content-type: application/json" -d '{ "query": "mutation { addBook(book: {title: \"Sample Book\", author: \"Test Author\"}) { id title author status } }" }' 'http://localhost:8090'
```

**Sample response**

```
$ {
  "data": {
    "addBook": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "to_read"
    }
  }
}
```

**Update the reading status of a book**

This remote function requires `id` and `status` as inputs to update the reading status of the selected book. The `id` refers to the id of the book. It is an integer.  The `status` refers to the reading status that needs to be updated. This method returns the updated book item upon successful execution.

**Sample request**

```
$ curl -X POST -H "Content-type: application/json" -d '{ "query": "mutation { setStatus(id: 1, status: \"reading\") { id title author status } }" }' 'http://localhost:8090'
```

**Sample response**

```
$ {
  "data": {
    "setStatus": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "reading"
    }
  }
}
```

**Delete a book item from the reading list**

This remote function requires the `id` as the input to delete the book item from the reading list. This method returns the removed book item upon successful execution.

**Sample request**

```
$ curl -X POST -H "Content-type: application/json" -d '{ "query": "mutation { deleteBook(id: 1) { id title author status } }" }' 'http://localhost:8090'
```

**Sample response**
```
$ {
  "data": {
    "deleteBook": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "reading"
    }
  }
}
```

Our next step is to set up the resources that you will require to follow the guide, including the sample reading list application and the Choreo GitHub app.

## Prerequisites

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample GraphQL service](https://github.com/wso2/choreo-samples/tree/main/reading-list-graphql) implementation for this guide.

Let's get started!

## Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the reading list service.

!!! note
    The following file paths are relative to the path `<sample-repository-dir>/reading-list-graphql`.

|Filepath                 | Description                                                     |
|-------------------------|-----------------------------------------------------------------|
| `service.bal`           | The reading list service code written in the Ballerina language.|
| `Ballerina.toml`        | The Ballerina configuration file.                               |
| `.choreo/component.yaml`| The configuration file with endpoint details.                   |

## Step 1: Create a service component 

To create a Ballerina service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**| `reading-list-graphql`    |.

6. Select **Ballerina** as the buildpack.

7. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Ballerina Reading List`|
    | **Component Name**        | `ballerina-reading-list`|
    | **Description**           | Manage a reading list   |

8. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service component that exposes a GraphQL API written in the Ballerina language. Next, let's build and deploy the service.

## Step 2: Build and deploy

Now that we have connected the source repository, it's time to build and deploy the reading list service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Configurations** pane that opens, click **Next** to skip the configuration.
4. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.
To build and deploy the service, follow the steps below:

Once you have successfully deployed your service, you can test, manage, and observe it like any other component type in Choreo.

For detailed instructions, see the following sections:

- [Step 3: Test](https://wso2.com/choreo/docs/testing/test-graphql-endpoints-via-the-graphql-console/)
- [Step 4: Manage](https://wso2.com/choreo/docs/manage/api-management/)


# Expose a gRPC Endpoint via a Service

Choreo allows you to create and deploy applications in your preferred programming language. One powerful option is gRPC, a high-performance and language-agnostic remote procedure call (RPC) framework. It utilizes [Protocol Buffers](https://github.com/protocolbuffers/protobuf) to define services and generate client/server code.

In this guide, you will learn to use Choreo to create a service component that exposes a gRPC server implemented in [Go](https://go.dev/), enabling efficient and scalable communication with any gRPC client application. No prior knowledge of the Go language is necessary to follow this guide.

By following this guide, you will:

- Create a simple gRPC server using a Service component.
- Link the containerized gRPC service to the Choreo component using the Dockerfile. 
    The greeter service has a single RPC method named `sayHello`. Following is the proto file the server and the client application are using:

    ```proto
    syntax = "proto3";
    option go_package = "github.com/wso2/choreo-samples/go-grpc/pkg";

    service greeter {
      rpc SayHello (HelloRequest) returns (HelloReply) {}
    }

    message HelloRequest {
      string name = 1;
    }

    message HelloReply {
      string message = 1;
    }
    ```

- Deploy the gRPC server component in Choreo. 
- Create a gRPC client using a Manual Trigger component. 
- Deploy the gRPC client.
- Invoke the gRPC server using a gRPC client and check the response through the Choreo log view.


## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample service](https://github.com/wso2/choreo-samples/tree/main/go-grpc) implementation for this guide.

Let's get started!

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the greeter service.

!!! note 
    The following file paths are relative to the path `<sample-repository-dir>/go-grpc`.

|File Path                |Description                                                                                   |
|-------------------------|----------------------------------------------------------------------------------------------|
| `main.go`               | The greeter service code written in the Go language.                                         |
| `greeter_client/main.go`| The greeter client application written in the Go language.                                   |
| `Dockerfile.server`     | The Dockerfile to build the container image of the server application.                       |
| `Dockerfile.client`     | The Dockerfile to build the container image of the client application.                       |
| `.choreo/component.yaml`| The Choreo-specific configuration that provides information about how Choreo exposes the service.|
| `pkg/greeter.proto`     | The interface definition of the gRPC service. This is used to generate the server and client stubs for the Go application.|

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints.

Let's run the gRPC server service component on port 8080. To securely expose the service through Choreo, you must provide the port and other required information to Choreo. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

Choreo looks for an `component.yaml` file inside the `.choreo` directory to configure the endpoint details of the containerized component. Ensure the `.choreo` directory is at the root of the Docker build context path.

In the gRPC server sample, the `component.yaml` file is at `go-grpc/.choreo/component.yaml`, where the build context path is `go-grpc`.

## Step 1: Create a service component with a gRPC endpoint

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
6. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

7. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory** | `go-grpc`                  |

8. Select **Docker** as the buildpack.
9. Enter the following information:
    
    | **Field**                | **Value**                  |
    |--------------------------|----------------------------|
    | **Dockerfile**           | `go-grpc/Dockerfile.server`|

    !!! info
        1.  To successfully build your container with Choreo, it is essential to explicitly define a User ID (UID) under the USER instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-samples/blob/main/go-grpc/Dockerfile.server).
        To ensure that the defined USER instruction is valid, it must conform to the following conditions:
            - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
            - Usernames are considered invalid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

        2. The Dockerfile utilized in this guide is a multi-stage Dockerfile, which is designed to keep the final image size small and provides the ability to build the application with a specific version of tools and libraries.

4. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go gRPC Server`        |
    | **Component Name**        | `go-grpc-server`        |
    | **Description**           | Send greetings          |
    
10. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you have connected the source repository, and configured the endpoint details, it's time to build the service and create an image. Then you can deploy the image and test the greeter service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

    You can access the following scans under **Build**. 

      - **The Dockerfile scan**: Choreo performs a scan to check if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
      - **Container (Trivy) vulnerability scan**: This detects vulnerabilities in the final docker image. 
      - **Container (Trivy) vulnerability scan**: The details of the vulnerabilities open in a separate pane. If this scan detects critical vulnerabilities, the build will fail.
     
        !!! info
            If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Environment Configurations** pane that opens, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

6. Once you have successfully deployed your service, navigate to the component overview page and copy the gRPC service URL. You need to provide that URL when setting up the client application later in this guide.

You have successfully deployed the gRPC server. Currently, the gRPC service is only accessible by the components deployed within the same project.

## Step 3: Invoke the gRPC service

Let's invoke the gRPC service that you created above, using a gRPC client. 

### Step 3.1: Create a manual task for the gRPC client

To create a manual task component, follow these steps:

1. On the Choreo Console header, click the **Project** list and select the project where you created the gRPC service component. This opens the project home page.
2. Go to the **Component Listing** section and click **+ Create**.
3. Click the **Manual Task** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**       | `go/grpc`                  |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                  |
    |--------------------------|----------------------------|
    | **Dockerfile**           | `go/grpc/Dockerfile.client`|

8. Enter a display name, a unique name, and a description for the component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go gRPC Client`        |
    | **Component Name**        | `go-grpc-client`        |
    | **Description**           | `Receive greetings`     |


9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

### Step 3.2: Build the gRPC client component

To build the component, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 3.3: Setup environment variables and deploy the gRPC client

The client application, in this case, the gRPC client, requires the server URL of the gRPC server service. This is read from the client application as an environment variable. Follow the steps below to configure the environment variable for the client application:

1. On the Choreo Console left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane that opens, click **+ Add**.
4. Specify the following name and value to configure the environment variable for the client application:

    | **Field**       | **Value**               |
    |-----------------|-------------------------|
    | **Name**        | `GREETER_SERVICE`       |
    | **Value**       | Paste the URL value copied after deploying the gRPC service via [step 2.2](#step-22-deploy) above.  Make sure to **drop the `http://` or `grpc://` part and the trailing `/` from the URL when copying**. For example, if the URL is `http://go-grpc-server-3192360657:8080/`, add only `go-grpc-server-3192360657:8080`.|

5.  Click **Add** and then click **Next**.
6.  Click **Deploy**.

### Step 3.4: Execute the gRPC client component

To execute the gRPC client, follow these steps:

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the gRPC client and generates logs.
   You can trigger multiple runs to generate multiple logs.

For details on what you can monitor via the execute page, see [Monitor executions](../develop-integrations/develop-a-manual-task.md#step-7-monitor-executions). 


# Expose a Prism-Based Mock Server Using an OpenAPI Specification

Choreo supports deploying [Prism-based](https://docs.stoplight.io/docs/prism/674b27b261c3c-prism-overview) mock servers using OpenAPI specifications. With the Choreo Prism mock service component, you can serve multiple mock servers, each based on a different OpenAPI specification, as separate endpoints.

By default, these mock servers serve static content generated from the examples in the configured OpenAPI Specification (OAS). 

## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [Prism mock service](https://github.com/wso2/choreo-samples/tree/main/prism-mock-service) artifacts for this guide.

## Step 1: Create a Prism mock service component

To create a Prism mock service component, follow these steps:
    
1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, you can paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    |**Component Directory**  | `prism-mock-service`    |

6. Select **Prism Mock** as the buildpack.
7. Enter a display name, a unique name, and a description for the service component.
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

8. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

## Step 2: Build and deploy the component

Now that you have successfully created the Prism mock service, it's time to build and deploy it.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**. This builds the service from the latest commit.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

Once you have successfully deployed the service, you can [test](../../testing/test-rest-endpoints-via-the-openapi-console.md), [manage](../../api-management/lifecycle-management.md), and [observe](../../monitoring-and-insights/observability-overview.md) it like any other component type in Choreo.

## Serve dynamic content

The Prism mock service can serve dynamic content according to the schema definitions in the OpenAPI specification. To use the Prism mock service with dynamic content, clients must add the `prefer:dynamic=true` header in the request.

To generate meaningful dynamic responses, you can use the `x-faker` attribute in schema definitions of the OpenAPI specification. For more information on dynamically generated responses with the `x-faker` attribute, see the [Prism documentation](https://docs.stoplight.io/docs/prism/9528b5a8272c0-dynamic-response-generation-with-faker).


# Expose a TCP Server via a Service

Choreo offers the flexibility to design and deploy applications in the programming language of your choice. One viable choice for specific network communication needs is TCP (Transmission Control Protocol). TCP provides a reliable, stream-oriented communication mechanism that ensures data integrity and orderliness during transmission. It's the go-to option for scenarios where guaranteed data delivery and error recovery are paramount.

In this guide, you will learn to use Choreo to create a service component that exposes a TCP server implemented in [Go](https://go.dev/), enabling efficient and scalable communication with any TCP client application. No prior knowledge of the Go language is necessary to follow this guide.

By following this guide, you will:

- Setup a TCP server
    - Create a simple TCP server using a service component.
    - Link the containerized TCP service to the Choreo component using a Dockerfile. 
    - Deploy the TCP server component in Choreo. 
- Setup a TCP client
    - Create a TCP client using a manual task component. 
    - Link the containerized TCP client to the Choreo component using a Dockerfile. 
    - Deploy the TCP client component in Choreo.
- Invoke the TCP server using a TCP client and observe the response through the Choreo log view.

## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample service](https://github.com/wso2/choreo-samples/tree/main/docker-tcp-service) implementation for this guide.

Let's get started!

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the sample service.

!!! note 
    The following file paths are relative to the path `<sample-repository-dir>/docker-tcp-service`.

|File Path                 |Description                                                                                   |
|--------------------------|----------------------------------------------------------------------------------------------|
| `server/main.go`         | The greeter service code written in the Go language.                                         |
| `client/main.go`         | The greeter client application written in the Go language.                                   |
| `Dockerfile.server`      | The Dockerfile to build the container image of the server application.                       |
| `Dockerfile.client`      | The Dockerfile to build the container image of the client application.                       |
| `.choreo/component.yaml` | The Choreo-specific configuration provides information about how Choreo exposes the service. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints.

Let's run the TCP server service component on port 5050. To securely expose the service through Choreo, you must provide the port and other required information to Choreo. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

Choreo looks for an `component.yaml` file inside the `.choreo` directory to configure the endpoint details of a containerized component. Place the `.choreo` directory at the root of the Docker build context path.

In our TCP server sample, the `component.yaml` file is at `docker-tcp-service/.choreo/component.yaml`, where the build context path is `docker-tcp-service`.

## Step 1: Create a service component with a TCP endpoint

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory** | `docker-tcp-service`                  |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-tcp-service/Dockerfile.server`|

    !!! info
        1.  To successfully build your container with Choreo, it is essential to explicitly define a User ID (UID) under the USER instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-samples/blob/main/docker-tcp-service/Dockerfile.server).
        To ensure that the defined USER instruction is valid, it must conform to the following conditions:
            - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
            - Usernames are considered invalid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

        2. The Dockerfile utilized in this guide is a multi-stage Dockerfile, which is designed to keep the final image size small and provides the ability to build the application with a specific version of tools and libraries.

8. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go TCP Server`         |
    | **Component Name**        | `go-tcp-server`         |
    | **Description**           | Send greetings          |
    
9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you have connected the source repository, and configured the endpoint details, it's time to build the service and create an image. Then you can deploy the image and test the service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

    You can access the following scans under **Build**. 

      - **The Dockerfile scan**: Choreo performs a scan to check if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
      - **Container (Trivy) vulnerability scan**: This detects vulnerabilities in the final docker image. 
      - **Container (Trivy) vulnerability scan**: The details of the vulnerabilities open in a separate pane. If this scan detects critical vulnerabilities, the build will fail.
     
        !!! info
            If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Environment Configurations** pane that opens, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

6. Once you have successfully deployed your service, navigate to the component overview page and copy the TCP service address. You need to provide that address when setting up the client application later in this guide.

You have successfully deployed the TCP server. Currently, the TCP service is only accessible by the components deployed within the same project.

## Step 3: Invoke the TCP service

Now let's use a TCP client to invoke the TCP service that you created above. To do this, you can create a manual trigger component as the TCP client. This is the recommended approach because, in this example, it's more efficient to have a client that connects to the server, sends a request, and then stops. Here, a continuously executing task isn't required. Furthermore, if you use a manual trigger component, you won't need to expose an endpoint in the client for invocation, unlike with an API.

### Step 3.1: Create a manual trigger for the TCP client

To create a manual task component, follow these steps:

1. On the Choreo Console header, click the **Project** list and select the project where you created the TCP service component. This opens the project home page.
2. Go to the **Component Listing** section and click **+ Create**.
3. Click the **Manual Task** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Docker Context**      |`docker-tcp-service`     |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-tcp-service/Dockerfile.client`|

8. Enter a display name, a unique name, and a description for the component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**              |
    |---------------------------|------------------------|
    | **Component Display Name**| `Go TCP Client`        |
    | **Component Name**        | `go-tcp-client`        |
    | **Description**           | `Receive greetings`    |


9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

### Step 3.2: Build the TCP client component

To build the component, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 3.3: Setup environment variables and deploy the TCP client

The client application, in this case, the TCP client, requires the server URL of the TCP server service. This is read from the client application as an environment variable. Follow the steps below to configure the environment variable for the client application:

1. On the Choreo Console left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane that opens, click **+ Add**.
4. Specify the following name and value to configure the environment variable for the client application:

    | **Field**       | **Value**               |
    |-----------------|-------------------------|
    | **Name**        | `SERVER_ADDRESS`       |
    | **Value**       | Paste the URL value copied after deploying the TCP service via [step 2.2](#step-22-deploy) above.  Make sure to **drop the `tcp://` part and the trailing `/` from the URL when copying**. For example, add only `go-tcp-server-1097922445:8080`.|

5.  Click **Add** and then click **Next**.
6.  Click **Deploy**.

### Step 3.4: Execute the TCP client component

To execute the TCP client, follow these steps:

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the TCP client and generates logs.
   You can trigger multiple runs to generate multiple logs.

For details on what you can monitor via the execute page, see [Monitor executions](../develop-integrations/develop-a-manual-task.md#step-7-monitor-executions).


# Expose a UDP Server via a Service

Choreo offers the flexibility to design and deploy applications in the programming language of your choice. One compelling choice for certain network communication needs is UDP (User Datagram Protocol). UDP is a high-speed, connectionless protocol ideal for scenarios where lightweight, real-time data transmission is essential.

In this guide, you will learn to use Choreo to create a Service component that exposes a UDP server implemented in [Go](https://go.dev/), enabling efficient and scalable communication with any UDP client application. No prior knowledge of the Go language is necessary to follow this guide.

By following this guide, you will:

- Setup a UDP server
    - Create a simple UDP server using a Service component.
    - Link the containerized UDP service to the Choreo component using the Dockerfile. 
    - Deploy the UDP server component in Choreo. 
- Setup a UDP client
    - Create a UDP client using a manual task component. 
    - Link the containerized UDP client to the Choreo component using the Dockerfile. 
    - Deploy the UDP client component in Choreo.
- Invoke the UDP server using a UDP client and check the response through the Choreo log view.

## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample service](https://github.com/wso2/choreo-samples/tree/main/docker-udp-service) implementation for this guide.

Let's get started!

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the sample service.

!!! note 
    The following file paths are relative to the path `<sample-repository-dir>/docker-udp-service`.

|File Path                |Description                                                                                   |
|-------------------------|----------------------------------------------------------------------------------------------|
| `server/main.go`        | The greeter service code written in the Go language.                                         |
| `client/main.go`        | The greeter client application written in the Go language.                                   |
| `Dockerfile.server`     | The Dockerfile to build the container image of the server application.                       |
| `Dockerfile.client`     | The Dockerfile to build the container image of the client application.                       |
| `.choreo/component.yaml`| The Choreo-specific configuration provides information about how Choreo exposes the service. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints.

Let's run the UDP server service component on port 5050. To securely expose the service through Choreo, you must provide the port and other required information to Choreo. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

Choreo looks for an `component.yaml` file inside the `.choreo` directory to configure the endpoint details of a containerized component. Place the `.choreo` directory at the root of the Docker build context path.

In our gRPC server sample, the `component.yaml` file is at `docker-udp-service/.choreo/component.yaml`, where the build context path is `docker-udp-service`.

## Step 1: Create a service component with a UDP endpoint

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
6. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

7. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**   | `docker-udp-service`    |    

8. Select **Docker** as the buildpack.
9. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-udp-service/Dockerfile.server`|

    !!! info
        1.  To successfully build your container with Choreo, it is essential to explicitly define a User ID (UID) under the USER instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-samples/blob/main/docker-udp-service/Dockerfile.server).
        To ensure that the defined USER instruction is valid, it must conform to the following conditions:
            - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
            - Usernames are considered invalid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

        2. The Dockerfile utilized in this guide is a multi-stage Dockerfile, which is designed to keep the final image size small and provides the ability to build the application with a specific version of tools and libraries.

4. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go UDP Server`         |
    | **Component Name**        | `go-udp-server`         |
    | **Description**           | Send greetings          |

10. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you have connected the source repository, and configured the endpoint details, it's time to build the service and create an image. Then you can deploy the image and test the service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

    You can access the following scans under **Build**. 

      - **The Dockerfile scan**: Choreo performs a scan to check if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
      - **Container (Trivy) vulnerability scan**: This detects vulnerabilities in the final docker image. 
      - **Container (Trivy) vulnerability scan**: The details of the vulnerabilities open in a separate pane. If this scan detects critical vulnerabilities, the build will fail.
     
        !!! info
            If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Environment Configurations** pane that opens, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

6. Once you have successfully deployed your service, navigate to the component overview page and copy the UDP service address. You must provide that address when setting up the client application later in this guide.

You have successfully deployed the UDP server. Currently, the UDP service is only accessible by the components deployed within the same project.

## Step 3: Invoke the UDP service

Now let's use a UDP client to invoke the UDP service that you created above. To do this, you can create a manual trigger component as the UDP client. This is the recommended approach because, in this example, it's more efficient to have a client that connects to the server, sends a request, and then stops. Here, a continuously executing task isn't required. Furthermore, if you use a manual trigger component, you won't need to expose an endpoint in the client for invocation, unlike with an API.

### Step 3.1: Create a manual trigger for the UDP client

To create a manual task component, follow these steps:

1. On the Choreo Console header, click the **Project** list and select the project where you created the UDP service component. This opens the project home page.
2. Go to the **Component Listing** section and click **+ Create**.
3. Click the **Manual Task** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory** | `docker-udp-service`    |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-udp-service/Dockerfile.client`|

8. Enter a display name, a unique name, and a description for the component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**              |
    |---------------------------|------------------------|
    | **Component Display Name**| `Go UDP Client`        |
    | **Component Name**        | `go-udp-client`        |
    | **Description**           | `Receive greetings`    |


9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

### Step 3.2: Build the UDP client component

To build the component, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 3.3: Setup environment variables and deploy the UDP client

The client application, in this case, the UDP client, requires the server URL of the UDP server service. This is read from the client application as an environment variable. Follow the steps below to configure the environment variable for the client application:

1. On the Choreo Console left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane that opens, click **+ Add**.
4. Specify the following name and value to configure the environment variable for the client application:

    | **Field**       | **Value**               |
    |-----------------|-------------------------|
    | **Name**        | `SERVER_ADDRESS`       |
    | **Value**       | Paste the URL value copied after deploying the UDP service via [step 2.2](#step-22-deploy) above.  Make sure to **drop the `udp://` part and the trailing `/` from the URL when copying**. For example, add only `go-udp-server-1097922445:8080`.|

5.  Click **Add** and then click **Next**.
6.  Click **Deploy**.

### Step 3.4: Execute the UDP client component

To execute the UDP client, follow these steps:

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the UDP client and generates logs.
   You can trigger multiple runs to generate multiple logs.

For details on what you can monitor via the execute page, see [Monitor executions](../develop-integrations/develop-a-manual-task.md#step-7-monitor-executions).


# Expose a WebSocket Endpoint via a Service

Choreo allows you to create and deploy applications in your preferred programming language, offering a seamless platform for building dynamic and scalable solutions. This guide walks you through the steps to deploy a WebSocket service using the NodeJS buildpack.

WebSockets provide real-time, two-way communication between a client and server over a persistent TCP connection. This makes WebSocket APIs ideal for applications that require real-time updates.

In this guide, you will:

- Build a simple WebSocket service using a sample implementation in NodeJS.
- Deploy the service in Choreo, allowing any WebSocket client application to establish a connection and exchange real-time messages with your service.

## Prerequisites

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample WebSocket service](https://github.com/wso2/choreo-samples/tree/main/websocket-chat-app) implementation for this guide.

Let's get started!

## Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the NodeJS chat Application.

!!! note
    The following file paths are relative to the path `<sample-repository-dir>/websocket-chat-app/websocket-chat-service-nodejs`.

|Filepath                        | Description                                                     |
|--------------------------------|-----------------------------------------------------------------|
| `server.js`                    | The NodeJS chat service.                                        |
| `.choreo/component.yaml`       | The configuration file with endpoint details.                   |

!!! note
    Choreo currently supports defining WebSocket APIs using the AsyncAPI 2.0 specification.

## Step 1: Create a service component 

To create a NodeJS service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**   | `websocket-chat-app/websocket-chat-service-nodejs`  |

6. Select **NodeJS** as the buildpack and **18.x.x** as the Language Version

8. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:

    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `NodeJS Chat Service`   |
    | **Component Name**        | `nodejs-chat-service`   |
    | **Description**           | Manage a chat service   |

9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service component that provides a WebSocket API built with NodeJS. The next step is to proceed with building and deploying the service.

## Step 2: Build and deploy

Now that you have connected the source repository, it's time to build and deploy the chat service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane that opens, click **Next** to skip the configuration.
4. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

Once you have successfully deployed your service, you can [test](../../testing/test-websocket-endpoints-via-the-websocket-console.md), [manage](../../api-management/lifecycle-management.md), and observe it like any other component type in Choreo.

During testing, once the WebSocket connection is established, you can send {"type": "Connect", "username": "user1"} to the WebSocket endpoint to connect to the chat service. You can then send chat messages by using {"type": "Data", "message": "Hello, World!"}.

!!! note
     Some clients, such as certain browsers, may not support adding headers to the WebSocket handshake. In these cases, you can include the access token or test key required for WebSocket API invocation within the `sec-websocket-protocol` header, along with any specified subprotocols.

     For example: `sec-websocket-protocol: choreo-oauth2-token, {access token}, subprotocols`

     If you are using a test key, replace `choreo-oauth2-token` with `choreo-test-key`.


# Service Component Overview

Explore how to create, deploy, manage, and observe service components in Choreo.

## What is a service component?

A service component in Choreo lets you deploy and expose REST, GraphQL, gRPC, UDP, WS or TCP services. It is a fundamental building block for creating cloud-native applications in Choreo. They provide a simple and effective way to expose functionality as a service to other components within Choreo or to the outside world.

Service components encapsulate business logic and provide standardized interfaces, called endpoints, for communicating with other components or systems. You can deploy and scale services independently, which makes them highly flexible and adaptable to changing workloads.

With the help of the service component, developers can quickly create APIs and microservices, making it easier to implement and manage complex software systems. Service components can also be integrated with other Choreo components, that acts as message processors, connectors, and data sources, etc to create powerful end-to-end solutions.

You can expose a service to other components through endpoints. For details on configuring endpoints, see [Configure Endpoints](../configure-endpoints.md).


# Build and Deploy a Single-Page Web Application

A web application is an application program hosted on a server and serves ingress traffic through a browser. In Choreo, you can deploy a web application by creating a Web Application component and connecting it to a Git repository that contains the implementation of the web application. Web applications can fall into one of the following categories:

- **Single page applications (SPAs)**: Examples include React, Angular, Vue, Svelte, etc.
- **Web servers**: These serve static content or provide server-side rendering/static site generation (SSR/SSG).
- **Static content**: Examples include websites and other static resources that do not require a backend, usually comprising static HTML/JS/CSS files.

## Prerequisites

- To deploy a web application component, you must have a GitHub account with a repository containing the web application's implementation. For this guide, fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample web application implementation.

## Create a web application

You can create a web application in Choreo as follows:

### Build and deploy a SPA from source code

1. To create a web application component, connect a repository that includes the web application source code.
2. Select the relevant buildpack: Default buildpacks include **React**, **Angular**, and **Vue.js**. If you are using a different SPA framework, you can try one of these buildpacks because the configurations can be overridden to support most JavaScript-based SPAs.
3. Enter the build command: Based on your package manager (NPM, yarn, or pnpm). The relevant package manager is run based on the dependency lock file in your repository (defaults to NPM if no lock file is present).
4. Specify the build output directory.
5. Specify the NodeJS version: Choreo does not pick the Node.js version from the `package.json` engine property. The required Node version must be explicitly set in the build configuration.

Once you create the Web Application component, Choreo automatically generates a build pipeline for your single-page application and deploys it.

### Bring your Dockerfile

1. To create a web application component, connect a repository that contains the Dockerfile for your containerized web application.
2. Commit a Dockerfile to your connected Git repository to have full control over your build process.

This approach is recommended if you are deploying a web server and not just a single-page application (or a single-page application with a complex build process).

### Host static websites

1. Create a web application component and connect it to the GitHub repository that contains the required static assets.
2. Select the **Static Websites** buildpack: This buildpack does not trigger a build process. It only fetches the files from the path specified in the repository and serves them as-is.

## Build and deploy a SPA from source code

Follow the steps below to create a sample Web Application component and deploy it in Choreo:

1. Sign in to the Choreo Console at [https://console.choreo.dev/login/](https://console.choreo.dev/login/). This opens the **Project Home** page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Web Application** card.
6. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

7. Enter the following information:

    | **Field**                 | **Description**        |
    |---------------------------|------------------------|
    | **GitHub Account**        | Your account           |
    | **GitHub Repository**     | choreo-samples         |
    | **Branch**                | main                   |
    | **Component Directory**     | /react-single-page-app |

8. Select **React** as the **Buildpack**.
9. Enter the following information:

    | **Field**                 | **Description**        |
    |---------------------------|------------------------|
    | **Build Command**         | `npm run build`        |
    | **Build Path**            | `build`                |
    | **Node Version**          | `18`                   |

    !!! tip
        Managed authentication is enabled by default when you create a web application using **React**, **Angular**, or **Vue.js** buildpacks. To learn how to set up authentication for your web application with Choreo's managed authentication, see [Secure Web Applications with Managed Authentication](../../authentication-and-authorization/secure-web-applications-with-managed-authentication.md).

4. Specify a display name, a unique name and description for the component.
10. Click **Create**. Choreo initializes the component with the sample implementation and opens the **Overview** page of the component.

You have successfully created a Web Application component from the source code. Now let's build and deploy the web application.

## Build your web application

1. In the left navigation menu, click **Build**.
2. In the **Builds** pane, click **Build**. This opens the **Commits** pane, where you can see all the commits related to the component.
3. Select the latest commit and click **Build**. This triggers the build process and displays the progress in the **Build Logs** pane.

    You can access the following scans in the **Build Logs** pane:

    - **Dockerfile Scan**: Choreo checks if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
    - **Container (Trivy) Vulnerability Scan**: Detects vulnerabilities in the final Docker image. If critical vulnerabilities are detected, the build will fail.

    !!! info
        If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

    !!! note
        The build process may take some time. Once complete, the build status will be listed in the **Builds** pane. Here, you will see the build status as **Success**.

## Deploy and access your web application

1. In the left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure and Deploy**. This opens the **Configure & Deploy** pane. In this guide, you do not need to add a file mount.
3. Click **Next** to proceed to the **Authentication Settings** pane.
4. Keep the default settings and click **Deploy**.

    !!! note
        The deployment process may take a few minutes. Once complete, the **Deployment Status** will show as **Active** in the **Development** card.

5. To verify that the web application is hosted successfully, click the **Web App URL** in the **Development** card. This takes you to the web application.

## Create a short URL for your web application in production

!!! info
    This feature is only available on the Choreo cloud data plane.

When you promote your component to the Production environment, you can create a personalized short URL for your web application. The URL follows the `https://{your-short-prefix}.choreoapps.dev` structure, where you can select a name of your preference for `{your-short-prefix}`.

1. Click **Promote** in the **Development** card and promote your web application to production.
2. In the **Production** card, click **Create a short URL**.
3. Specify a **Short URL prefix** of your choice and click **Save**.

    !!! note
        Short URL names/prefixes are subject to availability, provided on a first-come-first-serve basis.

## Manage runtime configurations for web applications

For web applications with a backend server, Choreo allows you to mount runtime configurations and secrets as environment variables and/or file mounts for a specific environment. Alternatively, you can also inject them into the client application during server-side rendering or when serving static content.

For SPAs that run completely on the browser, Choreo does not support *baking-in* environment variables or other configurations. Instead, Choreo recommends the following approach (applicable to most SPA frameworks, including React):

!!! note
    - With SPAs, anything you mount as a runtime config will be available to your users in the browser.
    - **Do not include sensitive secrets that are not browser-safe**.

1. Go to your forked [Choreo samples repository](https://github.com/wso2/choreo-samples).
2. Open the `public` directory.
3. Create and commit a new file named `config.js` in the `public` directory of your React application. This file should contain the runtime configuration variables you want to expose to your application, such as API endpoints or feature flags. For example:

    ```javascript
    window.config = {
        apiUrl: 'https://api.example.com',
        featureFlags: {
            enableNewFeature: true,
            enableExperimentalFeature: false,
        },
    };
    ```

4. In your `index.html` file inside the `public` directory, add a script tag to include the `config.js` file inside the `<body>` tag:

    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>My React App</title>
    </head>
    <body>
        <div id="root"></div>
        <script src="%PUBLIC_URL%/config.js"></script>
    </body>
    </html>
    ```

5. In your React component, access the configuration variables by referencing the `window.config` object:

    ```javascript
    import React from 'react';

    function MyComponent() {
        const apiUrl = window.config.apiUrl;
        const enableNewFeature = window.config.featureFlags.enableNewFeature;
        const enableExperimentalFeature = window.config.featureFlags.enableExperimentalFeature;

        // ...
    }
    ```

6. When you deploy your component to Choreo, create a config file mount in the specified path for each environment (where your `index.html` expects the `config.js` file). For more details, see [Manage Configurations and Secrets](https://wso2.com/choreo/docs/devops-and-ci-cd/manage-configurations-and-secrets/#apply-a-file-mount-to-your-container).

## Limitations

The following limitations are specific to the Choreo cloud data plane:

- **Request size limit**: 256KB (including headers, cookies, and payloads).
- **Response body size limit**: 20MB.
- **Open ports**: Only one open port is permitted per web application. While you can have multiple ports open for project-level communication within a data plane, incoming traffic from the internet can only be directed to one port. This differs from Service-type components, which support multiple endpoints.

## Troubleshoot a web application

- **Blank page or 502 error after deployment**:
    If you encounter a blank page or a 502 error after deploying your web application, it typically indicates that the wrong directory is being served. To resolve this issue:
    1. Double-check the build output directory, especially if you are using a Dockerfile-less buildpack.
    2. Ensure that the specified output directory matches the actual output directory generated during the build process. For example, if you have erroneously entered `public/` as the output directory when it should have been `build/`.

By verifying and correcting the output directory alignment, you should be able to address the issue of encountering a blank page or experiencing a 502 error on deploying your web application.


# Develop Web Applications Locally with Choreo’s Managed Authentication

Choreo’s managed authentication capability provides a set of backend for frontend (BFF) endpoints to facilitate authentication and authorization for web applications. These endpoints are readily available for single-page web applications deployed on Choreo.

As a web application developer, you may need to run the application on your local workstation. Choreo’s local development capability ensures that authentication and authorization during local development work the same way as they do when the application is deployed to Choreo, eliminating the need for code changes.

This guide explains how to configure and use Choreo’s local development capability to streamline your workflow.

## How local development works in Choreo

Local development uses a proxy that sits in front of the locally running web application. This proxy intercepts all incoming requests:
- Requests to `/choreo-apis/*` and `/auth/*` are forwarded to Choreo.
- All other requests are forwarded to the locally running web application.

The proxy runs on HTTPS using a self-signed certificate, which is essential for secure, HTTP-only cookie-based managed authentication. Once the proxy is running, you can access the web application using the proxy's URL and start developing locally. The behavior of the web application, in terms of managed authentication, will mirror its behavior when deployed to Choreo.

## Configure local development

### Prerequisites

- Create a single-page application (SPA) with managed authentication enabled. For details, see [Secure Web Applications with Managed Authentication](../../authentication-and-authorization/secure-web-applications-with-managed-authentication.md#step-1-set-up-managed-authentication-for-your-web-application).
- Promote and deploy the application to the environment where you want to enable local development.

    !!! note
        - The locally running web application will use the same managed authentication configuration as the environment where local development is configured.
        - Local development is only allowed in non-critical environments.

### Apply configurations

1. Sign in to the Choreo Console.
2. In the **Component Listing** pane, click on the component you created and deployed.
3. In the left navigation menu, click **Deploy**.
4. Go to the respective environment card and click **Local Development**.
5. In the **Local Development** pane, toggle **Local Development** to enable it.
6. (Optional) To update the port on which the local development proxy server runs, expand **Advanced Configurations** and specify a value for **Proxy Port**.
7. Click **Apply**.

You have now configured local development. The next section explains how to access your web application for local development.

## Access your web application locally

### Prerequisites

- Ensure local development is enabled in the desired environment.
- Ensure your web application is running locally on `http://localhost` on a specific port.

### Access your web application locally

You can use either the Choreo built-in identity provider or an external identity provider to access your web application locally.

=== "Use the Choreo built-in identity provider"

    1. Sign in to the Choreo Console.
    2. In the **Component Listing** pane, click on the component you created and deployed.
    3. In the left navigation menu, click **Deploy**.
    4. Go to the respective environment card and click **Local Development**.
    5. In the **Local Development** pane, copy the command under **Step 1**.
    6. Paste the command in a terminal, replace `[APP_PORT]` with the port on which your application is running locally, and run the command.
    7. To access the application, go to the URL provided under **Step 2** in the **Local Development** pane.

        !!! note
            The local development proxy runs on HTTPS using a self-signed certificate. Your browser may warn that the certificate is not valid. Accept the risk and proceed.

=== "Use an external identity provider"

    1. Sign in to the Choreo Console.
    2. In the **Component Listing** pane, click on the component you created and deployed.
    3. In the left navigation menu, click **Deploy**.
    4. Go to the respective environment card and click **Local Development**.
    5. In the **Local Development** pane, copy the redirect URLs under **Step 1**.
    6. Go to the settings in the OAuth application in your identity provider and specify the copied URLs as allowed redirect URLs.
    7. In the **Local Development** pane, copy the command under **Step 2**.
    8. Paste the command in a terminal, replace `[APP_PORT]` with the port on which your application is running locally, and run the command.
    9. To access the application, go to the URL provided under **Step 3** in the **Local Development** pane.

        !!! note
            The local development proxy runs on HTTPS using a self-signed certificate. Your browser may warn that the certificate is not valid. Accept the risk and proceed.


# Create a Connection

Connections in Choreo provide a simple and uniform approach to seamlessly integrate components with services or resources.

Choreo allows you to create connections to services deployed in Choreo or registered as external services. It also allows you to create connections to any Choreo-managed database.

To create a connection to a service or a database, follow the step-by-step instructions in the respective tab:

=== "Create a connection to a service"

    <h2>Create a connection to a Choreo service</h2>

    Follow these steps to create a connection to a service deployed in Choreo:

    1. In the Choreo Console, go to the top navigation menu and set the visibility level as [project](../../choreo-concepts/connections.md#project-connections) or [component](../../choreo-concepts/connections.md#component-connections) as follows: 

        - **Project Connection**: Select an organization and a project in that organization. 
        - **Component Connection**: Select an organization, a project in that organization, and a component in the selected project. 

    2. In the left navigation menu, click **Dependencies**  and then **Connections**. This page lists all the existing connections.
    3. Click **+Create**. This opens the Marketplace view where you can browse and search for services or databases.
    4. Click the **Services** tab. You can search and apply filters to efficiently find a service.
    5. Click on the service you want to connect to. 
    6. Enter a name and a description for the connection.
    7. Select an **Access Mode** and **Authentication Scheme** for the connection.
    8. Click **Create**.
   
    This creates the connection and displays its details for each environment, along with an inline guide on how to use the connection in your component. 

    !!! note
        During connection creation, secret values for the lowest environment are visible, allowing you to copy them for local use if necessary. Secret values for higher environments remain hidden to ensure security
     
    <h2>Create a connection to an external service</h2>

    Follow these steps to create a connection to an external service:

    1. Follow steps 1–5 from the previous section.
    2. Expand the **Environment to Endpoint** section and verify the service endpoints assigned to the Choreo environments.
    3. Click **Create**.

      For step-by-step instructions on using a connection in your service, see [Use a Connection in Your Service](./use-a-connection-in-your-service.md).

      For step-by-step instructions on using a connection in your web application, see [Use a Connection in Your Web Application](./use-a-connection-in-your-web-application.md).


=== "Create a connection to a database"

    Prerequisites:

     - Create a Choreo-managed database. For details, see [Choreo-Managed Databases and Caches](../../manage-databases-and-caches/choreo-managed-databases-and-caches.md).
     - Add the database to the Marketplace. For details, see [Add Choreo-Managed Databases and Caches to the Marketplace](../../manage-databases-and-caches/add-choreo-managed-databases-and-caches-to-the-marketplace.md).

    Follow these steps to create a connection to a Choreo-managed database:

    1. In the Choreo Console, go to the top navigation menu and set the visibility level as [project](../../choreo-concepts/connections.md#project-connections) or [component](../../choreo-concepts/connections.md#component-connections) as follows: 

        - **Project Connection**: Select an organization and a project in that organization. 
        - **Component Connection**: Select an organization, a project in that organization, and a component in the selected project. 

    2. In the left navigation menu, click **Dependencies**  and then **Connections**. This page lists all the existing connections.
    3. Click **+Create**. This opens the Marketplace view where you can browse and search for services or databases.
    4. Click the **Databases** tab. You can search and apply filters to efficiently find a database.
    5. Click on the database you want to connect to. 
    6. To create the connection, follow these steps:

        1. Enter a name and description.
        2. Under **Environment Configuration**, select credentials for each environment.

            !!! note
                 By default, the selected database is applied to all environments. To use different databases for specific environments, select the appropriate database and provide the corresponding credentials for each environment.

        3. Click **Create**.  
    
    This creates the connection and displays the database connection details for each environment, along with an inline guide on how to use the connection in your component. 

    !!! note
        During connection creation, secret values for the lowest environment are visible, allowing you to copy them for local use if necessary. Secret values for higher environments remain hidden to ensure security
    
    For step-by-step instructions on using a database in your component, see [Use a Database Connection in Your Component](./use-a-database-connection-in-your-component.md).


# Use a Connection in Your Service

Choreo allows you to share and reuse your services, accelerating development and enhancing efficiency in building integrated applications through connections.

For step-by-step on instruction on creating a connection, see [Create a Connection](create-a-connection.md).

To learn more about Choreo Connections, see the documentation on [Connections](../../choreo-concepts/connections.md).

## Consume a service through a connection

You can consume a Choreo-deployed service within another service. Consuming connections from within Choreo services is seamless and straightforward. Follow the steps below to consume a Choreo service:

### Step 1: Add connection configurations

To integrate another service into your application, click the appropriate tab below based on your current configuration file and follow the step-by-step instructions:

=== "Component.yaml file (v1.1)"

    1. Copy and paste the snippet from the in-line developer guide into the `component.yaml` file.

        The following is a sample snippet: 

        ``` yaml

        dependencies:
            connectionReferences:
            - name: <CONNECTION_NAME>
              resourceRef: <RESOURCE_IDENTIFIER>

        ```

          | Field            | Description                                                         |
          |------------------|---------------------------------------------------------------------|
          | name             | The name given to the connection.                                   |
          | resourceRef      | A unique, readable identifier of the service being connected to.    |


    2. If you've previously added a `connectionReferences` section under `dependencies`, append this as another item under `connectionReferences`. Upon deploying the component, Choreo automatically creates a subscription if applicable and the necessary configurations to establish the connection will be injected into the Choreo-defined environment variables.
      
          The following table details the Choreo-defined environment variables:

          | Configuration Key       | Choreo-Defined Environment Variable Name                       |
          |-------------------------|----------------------------------------------------------------|
          | ServiceURL              | CHOREO_<CONNECTION_NAME\>_SERVICEURL                           |
          | ConsumerKey             | CHOREO_<CONNECTION_NAME\>_CONSUMERKEY                          |
          | ConsumerSecret          | CHOREO_<CONNECTION_NAME\>_CONSUMERSECRET                       |
          | TokenURL                | CHOREO_<CONNECTION_NAME\>_TOKENURL                             |
          | ChoreoAPIKey            | CHOREO_<CONNECTION_NAME\>CHOREOAPIKEY                          |


          If you want to use custom environment variable names instead of the Choreo-defined ones, you must define the environment configurations under the `configuration` section in the same file.
          The following is a sample snippet: 

          ``` yaml
          configuration:
            env:
              - name: HR_SERVICE_URL
                valueFrom:
                  connectionRef:
                    name: hr-connection
                    key: ServiceURL
          ```

          The following table provides details on the configuration keys associated with the connection. These keys can be referenced as `env[i].valueFrom.connectionRef.key`.

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | ServiceURL     | string     | Service URL of the Choreo service     | false         | false        |
          | ConsumerKey    | string     | Consumer key of the Choreo service    | false         | false        |
          | ConsumerSecret | string     | Consumer secret of the Choreo service | false         | true         |
          | TokenURL       | string     | Token URL of the STS                  | false         | false        |
          | ChoreoAPIKey   | string     | API key of the Choreo service         | false         | true         |

          For more details, see the instructions under the **component.yaml file (v1.1)** tab.

    ### Step 2: Read configurations within the application

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const serviceURL = process.env.CHOREO_<CONNECTION_NAME>_SERVICEURL;
    ```

=== "Component.yaml file (v1.0)"

    !!! note
        This `component.yaml v1.0` is a legacy configuration format. For new projects, we recommend using the latest version (v1.1) of `component.yaml` for improved usability and features.
  
    1. Copy and paste the snippet from the in-line developer guide into the `component.yaml` file.
      
        The following is a sample snippet:

        ``` yaml

        dependencies:
            serviceReferences:
            - name: <SERVICE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: ServiceURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerSecret
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: TokenURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ChoreoAPIKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>

        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the service you are connecting to.              |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added a service reference section under `dependencies`, append this as another item under `serviceReferences`. 

          Upon deploying the component, Choreo automatically creates a subscription if applicable and populates the specified environment variables with actual values.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | ServiceURL     | string     | Service URL of the Choreo service     | false         | false        |
          | ConsumerKey    | string     | Consumer key of the Choreo service    | false         | false        |
          | ConsumerSecret | string     | Consumer secret of the Choreo service | false         | true         |
          | TokenURL       | string     | Token URL of the STS                  | false         | false        |
          | ChoreoAPIKey   | string     | API key of the Choreo service         | false         | true         |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const serviceURL = process.env.SVC_URL;
    ```

=== "Component-config.yaml file"

    !!! note
        This `component-config.yaml` is a legacy configuration format. For new projects, we recommend using the latest version (v1.1) of `component.yaml` for improved usability and features.

    1. Copy and paste the snippet from the in-line developer guide into the `component-config` file under the `spec` section.

        The following is a sample snippet:

        ``` yaml

        outbound:
            serviceReferences:
            - name: <SERVICE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: ServiceURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerSecret
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: TokenURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ChoreoAPIKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>

        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the service you are connecting to.              |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added an outbound service reference, append this as another item under `serviceReferences`. 

          Upon deploying the component, Choreo automatically creates a subscription if applicable and populates the specified environment variables with actual values.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | ServiceURL     | string     | Service URL of the Choreo service     | false         | false        |
          | ConsumerKey    | string     | Consumer key of the Choreo service    | false         | false        |
          | ConsumerSecret | string     | Consumer secret of the Choreo service | false         | true         |
          | TokenURL       | string     | Token URL of the STS                  | false         | false        |
          | ChoreoAPIKey   | string     | API key of the Choreo service         | false         | true         |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const serviceURL = process.env.SVC_URL;
    ```

If you're using the API key security scheme for the connection, skip Step 3 and follow the instructions in [Step 4: API key security scheme](#step-4-invoke-the-service) tab.

### Step 3: Acquire an OAuth 2.0 access token

To consume a Choreo service with the visibility level set to organization or public and secured by the OAuth 2.0 security scheme, you must obtain an OAuth 2.0 token from the token endpoint. Subsequently, you can use the token to invoke the service.

- For languages with OAuth 2.0-aware HTTP clients, you must pass the OAuth 2.0-related configurations such as client id, client secret and so on, obtained when creating the connection to your HTTP client configuration. The HTTP client autonomously manages token retrieval and refreshing.

- For languages without OAuth 2.0-aware HTTP clients, you must manually initiate a call to the token endpoint. This includes fetching the token and managing token expiration and refresh directly within your application code. The following is a sample curl command to obtain a token:


    ```bash
    CONSUMER_KEY="your_consumer_key"
    CONSUMER_SECRET="your_consumer_secret"
    TOKEN_URL="your_token_url"

    # Encode client credentials as Base64
    CLIENT_CREDENTIALS=$(echo -n "$CLIENT_ID:$CLIENT_SECRET" | base64)

    curl -X POST $TOKEN_URL \
      -H "Content-Type: application/x-www-form-urlencoded" \
      -H "Authorization: Basic $CLIENT_CREDENTIALS" \
      --data-urlencode "grant_type=client_credentials"

    ```

### Step 4: Invoke the service

Click the tab that matches the security scheme of your service and follow the instructions below:

=== "API key security scheme"

     To invoke the API, use the `choreo-api-key` header with the API key value retrieved from the corresponding environment variable as described in [step 2](#step-2-read-configurations-within-the-application).

     The following is a sample code snippet in NodeJS:

     ``` java
       const response = await axios.get(serviceURL/{RESOURCE_PATH}, {
           headers: {
             'Choreo-API-Key': `${choreoApiKey}`
           }
       });
     ```

=== "OAuth 2.0 security scheme"

     To invoke the service, use the following instructions based on your programming language:

      - For languages with OAuth 2.0-aware HTTP clients, use the service URL resolved in [Step 2](#step-2-read-configurations-within-the-application). The OAuth-aware client manages authentication automatically. For sample requests and responses, see the API definition provided via the Choreo marketplace for the service.

      - For languages without OAuth 2.0-aware HTTP clients, use the token obtained in [step 3](#step-3-acquire-an-oauth-20-access-token) to make calls to the dependent service. Subsequently, add the obtained token to the HTTP authorization header with the bearer prefix. As the service URL, use the URL resolved in [step 2](#step-2-read-configurations-within-the-application). For sample requests and responses, see the API definition of the service provided via the Choreo marketplace.

       The following is a sample code snippet in NodeJS:

       ``` java
       const response = await axios.get(serviceURL/{RESOURCE_PATH}, {
           headers: {
             'Authorization': `Bearer ${accessToken}`
             'Choreo-API-Key': `${choreoApiKey}`
           }
       });
       ```

    !!! note
        If you want to consume a Choreo service at the project visibility level, you don't need to obtain a token. You can directly invoke the service using the resolved URL.


# Use a Connection in Your Web Application

Choreo simplifies the process of integrating services into your web application. The approach to connect to a service can vary based on your web application. 

To connect to a selected service, follow the step-by-step instructions given below depending on the authentication mechanism used in your web application.

=== "Managed authentication"
    
    Choreo-managed authentication allows you to seamlessly handle authentication for your web application. You can configure your web application to work with the built-in identity provider of Choreo or any external identity provider that supports OIDC/OAuth2.0

    !!! note 
         Choreo's managed authentication is currently available only for web applications created with **React**, **Angular**, or **Vue.js** buildpacks.

    Follow the steps below to use an existing connection within your web application: 

    <h2> Step 1: Add the connection configuration</h2>

    To integrate a service into your application, you must first add the connection configuration as follows: 

    1. For single page applications (SPAs), you must add the connection configuration as a file mount. You can mount a file via the **Configurations** pane on the **Deploy** page. You must mount a file (for example, `config.js`) and add the configuration provided in the inline developer documentation into it. 

        The following is a sample configuration:

        ``` yaml
             window.configs = {
                 apiUrl: '<SERVICE_URL>',        
             };

        ```

    2.  To ensure accessibility of the `config.js` file via JavaScript at runtime, add a script tag as follows in the `index.html` file to reference the `config.js` file:

        ``` html
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="utf-8" />
            <title>My React App</title>
        </head>
        <body>
            <div id="root"></div>
            <script src="/public/config.js"></script>
        </body>
        </html>
        ``` 

        !!! note
             If you use an external IdP, you must add the IdP's configuration to the same file.
    
             For more information on working with IdPs, see [Configure Asgardeo as an External Identity Provider](https://wso2.com/choreo/docs/administer/configure-an-external-idp/configure-asgardeo-as-an-external-idp/).


    <h2> Step 2: Read the configuration</h2>

    Once you add the connection configuration, you can proceed to read the configuration from your application. The steps to read depend on the programming language you use.

    The following is a sample code snippet in NodeJS:

    ``` java
         const serviceURL = window?.configs?.apiUrl ? window.configs.apiUrl : "/";
    ```

    <h2> Step 3: Invoke the service</h2>

    If you use Choreo-managed authentication, Choreo handles the security handshaking for the application during deployment. The connected service will be accessible under the same domain as your application. Therefore, you can call the configured path directly using your preferred HTTP client.

    The following is a sample code snippet in NodeJS:

    ``` java
         const response = await axios.get(serviceURL/{RESOURCE_PATH});
    ```

    !!! note
         If you are using an external IdP provider instead of Choreo-managed authentication, you must obtain an access token from your IdP and add it to the HTTP authorization header with the bearer prefix.


=== "Custom authentication or no authentication"

    If you are not using Choreo-managed authentication or your web application lacks authentication, follow the steps below to connect to a service from your web application:

    <h2> Step 1: Add the connection configuration</h2>

    1. For single-page applications (SPAs), you must add the connection configuration as a file mount. You can mount a file via the **Configurations** pane on the **Deploy** page. You must mount a file (for example, `config.js`) and add the configuration provided in the inline developer documentation into it.
 
        The following is a sample configuration:

        ``` yaml
             window.configs = {
                 apiUrl: '<SERVICE_URL>',
                 consumerKey: '<CONSUMER_KEY>',
                 consumerSecret: '<CONSUMER_SECRET>',
                 tokenUrl: '<TOKEN_URL>',
             };
        ```

    2.  To ensure accessibility of the `config.js` file via JavaScript at runtime, add a script tag as follows in the `index.html` file to reference the `config.js` file:

        ``` html
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="utf-8" />
            <title>My React App</title>
        </head>
        <body>
            <div id="root"></div>
            <script src="/public/config.js"></script>
        </body>
        </html>
        ``` 

    For other types of web applications, you must add the respective configuration into your application.

    <h2> Step 2: Read the configuration</h2>

    Once you have added the connection configuration, you can proceed to read the configuration from your application. The steps to read depend on the programming language you use.

    The following is a sample code snippet in NodeJS:

    ``` java
         const serviceURL = window?.configs?.apiUrl ? window.configs.apiUrl : "/";
    ```

    <h2> Step 3: Acquire an OAuth 2.0 access token</h2>

    - For languages with OAuth 2.0-aware HTTP clients, you must pass the OAuth 2.0-related configurations such as client id, client secret and so on, obtained when creating the connection to your HTTP client configuration. The HTTP client autonomously manages token retrieval and refreshing.
  
    - For languages without OAuth 2.0-aware HTTP clients, you must manually initiate a call to the token endpoint. This includes fetching the token and managing token expiration and refresh directly within your application code. The following is a sample curl command to obtain a token:


        ```bash
        CONSUMER_KEY="your_consumer_key"
        CONSUMER_SECRET="your_consumer_secret"
        TOKEN_URL="your_token_url"

        # Encode client credentials as Base64
        CLIENT_CREDENTIALS=$(echo -n "$CLIENT_ID:$CLIENT_SECRET" | base64)

        curl -X POST $TOKEN_URL \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -H "Authorization: Basic $CLIENT_CREDENTIALS" \
        --data-urlencode "grant_type=client_credentials"

        ```

    <h2> Step 4: Invoke the service</h2>

    You can invoke the service as follows:

    - For languages with OAuth 2.0-aware HTTP clients, you can invoke the service in a straightforward manner. The HTTP client seamlessly manages OAuth 2.0 authentication without requiring additional intervention.

        As the service URL you can use the URL that you resolved in step 2 above. For sample requests and responses, see the API definition provided via the Choreo marketplace for the service.

    - For languages without OAuth 2.0-aware HTTP clients, you can use the token obtained in step 3 above to make calls to the dependent service. Subsequently, add the obtained token to the HTTP authorization header with the bearer prefix.

        As the service URL you can use the URL that you resolved in step 2 above. For sample requests and responses, see the API definition of the service provided via the Choreo marketplace.

        The following is a sample code snippet in NodeJS:

        ```java 
            const response = await axios.get(serviceURL/{RESOURCE_PATH}, {
                headers: {
                'Authorization': `Bearer ${accessToken}`
                }
            })
        ```


# Use a Database Connection in Your Component

Choreo allows you to share and reuse Choreo-managed databases, accelerating development and enhancing efficiency in building integrated applications through connections.

For step-by-step instructions on creating a database connection, see [Create a Connection](create-a-connection.md).

To learn more about Choreo Connections, see the documentation on [Connections](../../choreo-concepts/connections.md).

## Consume a database through a connection

To consume a Choreo-managed database via a connection, follow these steps:

### Step 1: Add connection configurations

To integrate a database into your application, click the appropriate tab below based on your current configuration file and follow the step-by-step instructions:

=== "Component.yaml file (v1.1)"

    1. Copy and paste the snippet from the  developer guide into the `component.yaml` file.

        The following is a sample snippet:

        ``` yaml

        dependencies:
            connectionReferences:
            - name: <CONNECTION_NAME>
              resourceRef: <RESOURCE_IDENTIFIER>

        ```

          | Field            | Description                                                         |
          |------------------|---------------------------------------------------------------------|
          | name             | The name given to the connection.                                   |
          | resourceRef      | A unique, readable identifier of the database being connected to.    |


    2. If you've previously added a `connectionReferences` section under `dependencies`, append this as another item under `connectionReferences`. Upon deploying the component, the necessary configurations to establish the connection will be injected into Choreo-defined environment variables.

          The following table details the Choreo-defined environment variables:

          | Configuration Key       | Choreo-Defined Environment Variable Name                       |
          |-------------------------|----------------------------------------------------------------|
          | HostName                | CHOREO_<CONNECTION_NAME\>_HOSTNAME                             |
          | Port                    | CHOREO_<CONNECTION_NAME\>_PORT                                 |
          | Username                | CHOREO_<CONNECTION_NAME\>_USERNAME                             |
          | Password                | CHOREO_<CONNECTION_NAME\>_PASSWORD                             |
          | DatabaseName            | CHOREO_<CONNECTION_NAME\>DATABASENAME                          |


          If you'd like to use custom environment variable names instead of the Choreo-defined ones, add the dependency as a service reference under `dependencies` in the same file. For more details, refer to the instructions under the `component.yaml file (v1.0)` tab.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | HostName       | string     | Hostname of the database server       | false         | false        |
          | Port           | string     | Port of the database server           | false         | false        |
          | Username | string           | Username of the database server       | false         | false        |
          | Password       | string     | Password of the database server       | false         | true         |
          | DatabaseName   | string     | Name of the database                  | false         | false        |
    ### Step 2: Read configurations within the application

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const hostName = process.env.CHOREO_<CONNECTION_NAME>_HOSTNAME;
    ```

=== "Component.yaml file (v1.0)"

    !!! note
        The `component.yaml v1.0` file is considered legacy. For new components, we recommend using the latest version, `component.yaml v1.1`, which offers enhanced usability and features.

    1. Copy and paste the snippet from the  developer guide into the `component.yaml` file.

        The following is a sample snippet:

        ``` yaml

        dependencies:
            serviceReferences:
            - name: database:<DATABASE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: HostName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Port
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Username
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Password
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: DatabaseName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>


        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the database you are connecting to.             |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added a service reference section under `dependencies`, append this as another item under `serviceReferences`.

          Upon deploying the component, Choreo automatically populates the specified environment variables with actual values.

          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | HostName       | string     | Hostname of the database server       | false         | false        |
          | Port           | string     | Port of the database server           | false         | false        |
          | Username | string           | Username of the database server       | false         | false        |
          | Password       | string     | Password of the database server       | false         | true         |
          | DatabaseName   | string     | Name of the database                  | false         | false        |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const hostName = process.env.HOSTNAME;
    ```

=== "Component-config.yaml file"

    !!! note
        The `component-config.yaml` file is considered legacy. For new components, we recommend using the latest version, `component.yaml v1.1`, which offers enhanced usability and features.

    1. Copy and paste the snippet from the  developer guide into the `component-config` file under the `spec` section.

        The following is a sample snippet:

        ``` yaml

        outbound:
            serviceReferences:
            - name: database:<DATABASE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: HostName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Port
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Username
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Password
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: DatabaseName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>

        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the database you are connecting to.              |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added an outbound service reference, append this as another item under `serviceReferences`.

          Upon deploying the component, Choreo automatically populates the specified environment variables with actual values.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | HostName       | string     | Hostname of the database server       | false         | false        |
          | Port           | string     | Port of the database server           | false         | false        |
          | Username | string           | Username of the database server       | false         | false        |
          | Password       | string     | Password of the database server       | false         | true         |
          | DatabaseName   | string     | Name of the database                  | false         | false        |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const hostName = process.env.HOSTNAME;
    ```

### Step 3: Initiate a database connection

To initiate a connection to the database, follow these steps:

In this example, you will connect to a MySQL database.

#### Step 3.1: Install the required packages

For the MySQL database, install the `mysql2` package using npm:

```bash
// Install the mysql2 package
npm install mysql2

```

#### Step 3.2: Import required packages

```java

const client = require('mysql2')

```

#### Step 3.3: Establish a connection

To establish the connection, use the environment variables for `hostName`, `username`, `password`, `databaseName`, and `port` as follows:

```java

var connection = client.createConnection({
      host: hostName,
      user: username,
      password: password,
      database: databaseName,
      port: port
});

connection.connect((err) => {
      if (err) {
          return;
      }
      // Connection is successful
});

```

By following these steps, your component can interact with the Choreo-managed database seamlessly.




# Integrate Unit Tests into the Build Pipeline

Choreo allows you to integrate unit tests into the build pipeline, enabling code validation before deployment. This ensures early testing of code changes, reducing the risk of defects in production.

!!! note
        Currently, Choreo supports unit tests only for the `WSO2 MI` buildpack.

## How it works

### Step 1: Write tests

You can create unit tests in your source code using standard testing libraries. For step-by-step instructions on creating unit tests for WSO2 Micro Integrator projects, see [Creating a Unit Test Suite](https://mi.docs.wso2.com/en/latest/develop/creating-unit-test-suite/).

### Step 2: Enable unit tests

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click the component for which you want to enable unit tests.
3. In the left navigation menu, click **Build**.
4. On the **Build** page, click to edit **Build Configurations**.
5. Turn on the **Unit Test** toggle.
6. Click **Save**.

### Step 3: Trigger a new build

- On the **Build** page, click **Build Latest**.

This starts a new build with unit tests enabled. You can monitor its progress in the **Build Details** pane.

## View failed unit tests

If a unit test fails during the build, you can view its detailed logs for troubleshooting. Click **View Details** corresponding to the failed build, then expand the failed unit test step to view the logs.

## Explore a sample

To see unit tests in action within the build pipeline, try out the [WSO2 MI helloworld](https://github.com/wso2/choreo-samples/tree/main/hello-world-mi) sample. 


# Manage Component Source Configurations

In Choreo, you can configure service endpoints and connections via the `component.yaml` source configuration file. This file ensures that the configurations required to initialize endpoints and connections are defined, as they cannot be inferred from the source code. This guide provides an overview of how to configure and manage these settings effectively.

The source configuration file must be committed to your repository within the `.choreo` directory at the root of the project directory. This ensures the ability to version the configuration files alongside repository commits, enabling better tracking and management of configurations.

!!! note
    -  The `component-config.yaml` and `endpoints.yaml` files will eventually be deprecated and replaced by the `component.yaml` file. 
        - For details on how to seamlessly update to the latest `component.yaml` file`, see [Update to the latest source configuration file](#update-to-the-latest-source-configuration-file).
    - Choreo prioritizes configuration files in the following order: `component.yaml` takes the highest precedence, followed by `component-config.yaml`, and then `endpoints.yaml`.

## Overview of the `component.yaml` file 

**File location**:

```bash
<build-context-path>/.choreo/component.yaml
```

!!! note
    - For components built using **Buildpacks**, replace `build-context-path` with the `<project-directory>`. 
    For example, `<project-directory>/.choreo/component.yaml`.
    - For components built using **Docker**, replace `build-context-path` with the `<docker-context-path>`. 
    For example, `<docker-context-path>/.choreo/component.yaml`.

**Sample `component.yaml` file content**:

Click the respective tab to view the structure for your current configuration file version:

=== "Version 1.1"

    ``` yaml
    # +required The configuration file schema version
    schemaVersion: 1.1

    # +optional Incoming connection details for the component
    endpoints:
      # +required Unique name for the endpoint.
      # This name will be used when generating the managed API
      - name: greeter-sample
        # +optional Display name for the endpoint.
        displayName: Go Greeter Sample
        # +required Service section has the user service endpoint details
        service:
          # +optional Context (base path) of the API that gets exposed via the endpoint.
          basePath: /greeting-service
          # +required Numeric port value that gets exposed via the endpoint
          port: 9090
        # +required Type of traffic that the endpoint is accepting.
        # Allowed values: REST, GraphQL, WS, GRPC, TCP, UDP.
        type: REST
        # +optional Network level visibilities of the endpoint.
        # Accepted values: Project|Organization|Public(Default).
        networkVisibilities: 
          - Public
          - Organization
        # +optional Path to the schema definition file. Defaults to wild card route if not provided
        # This is only applicable to REST or WS endpoint types.
        # The path should be relative to the docker context.
        schemaFilePath: openapi.yaml
      
      # +optional Outgoing connection details for the component.
      dependencies:
        # +optional Defines the connection references from the Internal Marketplace.
        connectionReferences:
          # +required Name of the connection.
          - name: hr-connection
            # +required service identifer of the dependent component.
            resourceRef: service:/HRProject/UserComponent/v1/ad088/PUBLIC
      # +optional Defines runtime configurations
      configurations:
        # +optional List of environment variables to be injected into the component.
        env:
          # +required Name of the environment variable
          - name: HR_SERVICE_URL
            # +required value source
            # Allowed value sources: connectionRef
            valueFrom:
              # +required Choreo connection value source
              connectionRef:
                # +required Choreo connection name to refer the value from
                name: hr-connection
                # +required Choreo connection configuration key to refer the value from
                key: ServiceURL
    ```

    The descriptor-based approach of the `component.yaml` file simplifies and streamlines endpoint and connection configuration management. The use of versioned schemas ensures backward compatibility, providing a seamless transition with future updates.

    You can define the following root-level configurations via the `component.yaml` file:

    | Configuration        | Required     | Description                                                              |
    |----------------------|--------------|--------------------------------------------------------------------------|
    | **schemaVersion**    | Required     | The version of the `component.yaml` file. Defaults to the latest version.|
    | **endpoints**        | Optional     | The list of endpoint configurations.                                     |
    | **dependencies**     | Optional     | The list of dependency configurations.                                   |
    | **configurations**    | Optional     | The runtime configuration definitions.                                   |

    ### Endpoint configurations
    In the `endpoints` section of the `component.yaml` file, you can define multiple service endpoint configurations. Each endpoint must have a unique name and the required fields specified in the schema overview.

    !!! tip "Why have a unique name?"
          When you define multiple endpoints, the `endpoint.name` is appended to the Choreo-generated URL. A unique name ensures the endpoint is easily recognizable and readable within the URL.
          
    | Configuration        | Required     | Description                                                                                             |
    |----------------------|--------------|---------------------------------------------------------------------------------------------------------|
    | **name**             | Required     | A unique identifier for the endpoint within the service component. Avoid using excessively long names.  |
    | **displayName**      | Optional     | A display name for the endpoint.                                                                        |
    | **service**          | Required     | Service details for the endpoint.                                                                       |
    | **.basePath**        | Required     | The base path of the API exposed via this endpoint.                                                     |
    | **.port**            | Required     | The numeric port value exposed via this endpoint.                                                       |
    | **type**             | Required     | The type of traffic the endpoint accepts. For example, `REST`, `GraphQL`, `WS`, `gRPC`, `UDP`, or `TCP`.|
    | **networkVisibilities** | Required | The network-level visibility of the endpoint. For example, project, organization, or public.             |
    | **schemaFilePath** | Required | The file path to the swagger definition  or AsyncAPI 2.0 specification file. Defaults to the wildcard route if not specified. This field should be a relative path to the project path when using **Java**, **Python**, **NodeJS**, **Go**, **PHP**, **Ruby**, or **WSO2 MI** buildpacks. For REST or WebSocket endpoint types, when using the **Ballerina** or **Dockerfile** buildpack, the path should be relative to the component root or Docker context. |

    ### Dependency configurations

    In the `dependencies` section of the `component.yaml` file, you can define multiple connection configurations under `dependencies.connectionReferences`. You can use the connection reference generated in the inline developer guide when creating a connection. For instructions on copying [connection configurations](https://wso2.com/choreo/docs/develop-components/sharing-and-reusing/use-a-connection-in-your-service/), see the inline developer guide displayed during connection creation.

    You must include the following configurations in the `dependencies.connectionReferences` schema:

    | Configuration        | Required     | Description                                                                      |
    |----------------------|--------------|----------------------------------------------------------------------------------|
    | **name**             | Required     | The name given to the connection.                                                |
    | **resourceRef**      | Required     | A unique, human-readable identifier for the service you are connecting.          |


    !!! note
        Choreo automatically generates connection configurations when you create a connection. The properties such as **name** and **resourceRef** are automatically generated. The configurations required to establish the connection will be injected into Choreo-defined environment variables.

        To use custom environment variable names instead of Choreo's default ones, add the dependency as a `serviceReference` in your `component.yaml v1.1` file. You can copy the `serviceReference` section from the `component.yaml v1.0` tab and paste it under `dependencies` in your `component.yaml v1.1` file, which maintains backward compatibility with the v1.0 format.

    ### Runtime configurations
    In the `configurations` section of the `component.yaml` file, you can define runtime configurations for the component. These configurations currently support environment variable injection related to dependencies.
    
    | Configuration                 | Required     | Description                                                                       |
    |-------------------------------|--------------|-----------------------------------------------------------------------------------|
    | **env**                       | Optional     | An array of env variable configurations.                                          |
    | **name**                      | Required     | A unique name for the environment variable, starting with a letter or an underscore, and containing only letters, numbers, or underscores. |
    | **valueFrom**                 | Required     | The source of the environment variable value.                                     |
    | **connectionRef**             | Required     | Connection reference value source definition.                                     |
    | **name**                      | Required     | The name of the Choreo connection to reference the value from.                    |
    | **key**                       | Required     | The Choreo connection configuration key to reference the value from. For details on available keys, see [connection configurations](https://wso2.com/choreo/docs/develop-components/sharing-and-reusing/use-a-connection-in-your-service/) or the inline developer guide. |

    !!! note
        Runtime configurations are supported starting from `component.yaml v1.1`.

        When an environment variable value is specified using `connectionRef`, the connection's environment variable is renamed to the environment variable name defined in the `configurations` section. For example, in the sample `component.yaml` file given above, the `CHOREO_HR_CONNECTION_SERVICEURL` variable in the `hr-connection` is renamed to `HR_SERVICE_URL`.

=== "Version 1.0"

    ``` yaml
    # +required The configuration file schema version
    schemaVersion: 1.0

    # +optional Incoming connection details for the component
    endpoints:
      # +required Unique name for the endpoint.
      # This name will be used when generating the managed API
      - name: greeter-sample
        # +optional Display name for the endpoint.
        displayName: Go Greeter Sample
        # +required Service section has the user service endpoint details
        service:
          # +optional Context (base path) of the API that gets exposed via the endpoint.
          basePath: /greeting-service
          # +required Numeric port value that gets exposed via the endpoint
          port: 9090
        # +required Type of traffic that the endpoint is accepting.
        # Allowed values: REST, GraphQL, WS, GRPC, TCP, UDP.
        type: REST
        # +optional Network level visibilities of the endpoint.
        # Accepted values: Project|Organization|Public(Default).
        networkVisibilities: 
          - Public
          - Organization
        # +optional Path to the schema definition file. Defaults to wild card route if not provided
        # This is only applicable to REST or WS endpoint types.
        # The path should be relative to the docker context.
        schemaFilePath: openapi.yaml
      
    # +optional Outgoing connection details for the component.
    dependencies:
      # +optional Defines the service references from the Internal Marketplace.
      serviceReferences:
        # +required Name of the service reference.
        - name: choreo:///apifirst/HRProject/UserComponent/ad088/v1/PUBLIC
          # +required Name of the connection instance.
          connectionConfig: 19d2648b-d29c-4452-afdd-1b9311e81412
          # +required Environment variables injected into the component for connection configuration.
          env:
            # +required Key name of the connection configuration.
            - from: ServiceURL
              # +required Environment variable injected into the container.
              to: SERVICE_URL
    ```

    The descriptor-based approach of the `component.yaml` file simplifies and streamlines endpoint and connection configuration management. The use of versioned schemas ensures backward compatibility, providing a seamless transition with future updates.

    You can define the following root-level configurations via the `component.yaml` file:

    | Configuration        | Required     | Description                                                              |
    |----------------------|--------------|--------------------------------------------------------------------------|
    | **schemaVersion**    | Required     | The version of the `component.yaml` file. Defaults to the latest version.|
    | **endpoints**        | Optional     | The list of endpoint configurations.                                     |
    | **dependencies**     | Optional     | The list of dependency configurations.                                   |

    <h3> Endpoint configurations </h3>
    In the `endpoints` section of the `component.yaml` file, you can define multiple service endpoint configurations. Each endpoint must have a unique name and the required fields specified in the schema overview.

    !!! tip "Why have a unique name?"
          When you define multiple endpoints, the `endpoint.name` is appended to the Choreo-generated URL. A unique name ensures the endpoint is easily recognizable and readable within the URL.
          
    | Configuration           | Required     | Description                                                                                             |
    |-------------------------|--------------|---------------------------------------------------------------------------------------------------------|
    | **name**                | Required     | A unique identifier for the endpoint within the service component. Avoid using excessively long names.  |
    | **displayName**         | Optional     | A display name for the endpoint.                                                                        |
    | **service**             | Required     | Service details for the endpoint.                                                                       |
    | **.basePath**           | Required     | The base path of the API exposed via this endpoint.                                                     |
    | **.port**               | Required     | The numeric port value exposed via this endpoint.                                                       |
    | **type**                | Required     | The type of traffic the endpoint accepts. For example, `REST`, `GraphQL`, `gRPC`, `WS`, `UDP`, or `TCP`.|
    | **networkVisibilities** | Required     | The network-level visibility of the endpoint. For example, project, organization, or public.            |
    | **schemaFilePath**      | Required     | The file path to the swagger definition or AsyncAPI 2.0 specification file. Defaults to the wildcard route if not specified. This field should be a relative path to the project path when using **Java**, **Python**, **NodeJS**, **Go**, **PHP**, **Ruby**, or **WSO2 MI** buildpacks. For REST or WebSocket endpoint types, when using the **Ballerina** or **Dockerfile** buildpack, the path should be relative to the component root or Docker context. |

    <h3> Dependency configurations </h3>

    In the `dependencies` section of the `component.yaml` file, you can define multiple service connection configurations under `dependencies.serviceReferences`. You can use the service references generated in the inline developer guide when creating a service connection. For instructions on copying [connection configurations](https://wso2.com/choreo/docs/develop-components/sharing-and-reusing/use-a-connection-in-your-service/), see the inline developer guide displayed during connection creation.

    You must include the following configurations in the `dependencies.serviceReferences` schema:

    | Configuration        | Required     | Description                                                                      |
    |----------------------|--------------|----------------------------------------------------------------------------------|
    | **name**             | Required     | A unique name for the service reference.                                         |
    | **connectionConfig** | Required     | A unique name for the connection instance.                                       |
    | **env**              | Required     | The list of environment variable mappings to inject into the container.          |
    | **.from**            | Required     | The key name of the connection configuration.                                    |
    | **.to**              | Required     | The environment variable to inject into the container.                           |

    !!! note
        Choreo automatically generates connection configurations when you create a connection. The properties such as **name**, **connectionConfig**, and **env.from** are automatically generated. However, you must manually set the **env.to** value.

## Overview of the `component-config.yaml` file 

**File location**:

```bash
<build-context-path>/.choreo/component-config.yaml
```

**Sample `component-config.yaml` file content**:

```yaml
apiVersion: core.choreo.dev/v1beta1
kind: ComponentConfig
spec:
  # +optional Incoming connection details for the component (AKA endpoints).
  inbound:
    # +required Unique name for the endpoint.
    # This name will be used when generating the managed API
    - name: Greeting Service
      # +required Numeric port value that gets exposed via the endpoint
      port: 9090
      # +required Type of traffic that the endpoint is accepting.
      # Allowed values: REST, GraphQL, GRPC, TCP, UDP, WS.
      type: REST
      # +optional Network level visibility of the endpoint. Defaults to Public
      # Accepted values: Project|Organization|Public.
      networkVisibility: Public
      # +optional Context (base path) of the API that gets exposed via the endpoint.
      # This is mandatory if the endpoint type is set to REST, GraphQL or WS.
      context: /greeting
      # +optional The path to the schema definition file. Defaults to wildcard route if not specified.
      # This is only applicable to REST and WS endpoint types.
      # The path should be relative to the Docker context.
      schemaFilePath: greeting_openapi.yaml
  # +optional Outgoing connection details for the component.
  outbound:
    # +optional Defines the service references from the Internal Marketplace.
    serviceReferences:
      # +required Name of the service reference.
      - name: choreo:///apifirst/mttm/mmvhxd/ad088/v1.0/PUBLIC
        # +required Name of the connection instance.
        connectionConfig: 19d2648b-d29c-4452-afdd-1b9311e81412
        # +required Environment variables injected to the component for connection configuration.
        env:
          # +required Key name of the connection configuration.
          - from: ServiceURL
            # +required Environment variable injected to the container.
            to: SERVICE_URL
```

The `component-config.yaml` file complements and enhances the existing endpoint configuration process. It allows you to define how the endpoints (inbound connections) in your service are exposed and how your service connects to external services or components (outbound connections).

You can define the following root-level configurations via the `component-config.yaml` file:

| Configuration        | Required     | Description                                                                           |
|----------------------|--------------|---------------------------------------------------------------------------------------|
| **apiVersion**       | Required     | The version of the `component-config.yaml` file defaults to `core.choreo.dev/v1beta1`.|
| **kind**             | Required     | The resource type of the file defaults to `ComponentConfig`.                          |
| **spec.inbound**     | Optional     | The list of inbound connection configurations.                                        |
| **spec.outbound**    | Optional     | The list of outbound connection configurations.                                       |

#### Inbound connection configurations (`spec.inbound`)

In the `spec.inbound` configuration section, you can specify endpoints to set up inbound connections. To specify endpoints, you can follow the existing endpoints schema structure. For details on the endpoints schema structure, see the [endpoints schema documentation](#overview-of-the-endpointsyaml-file).

#### Outbound connection configurations (`spec.outbound`)

In the `spec.outbound` section, you can define `serviceReferences`. To define `serviceReferences`, you can use the service references generated in the Internal Marketplace when creating a service connection. To copy the [outbound connection configurations](../sharing-and-reusing/use-a-connection-in-your-service/#use-a-connection-in-your-service), see the inline developer guide displayed when you create a connection.

You must include the following configurations in the `serviceReferences` schema:

| Configuration        | Required     | Description                                                                      |
|----------------------|--------------|----------------------------------------------------------------------------------|
| **name**             | Required     | A unique name for the service reference.                                         |
| **connectionConfig** | Required     | A unique name for the connection instance.                                       |
| **env**              | Optional     | The list of environment variable mappings to inject into the container.          |
| **env.from**         | Required     | The key name of the connection configuration.                                    |
| **env.to**           | Required     | The environment variable to inject into the container.                           |

## Overview of the `endpoints.yaml` file

**File location**:

```bash
<build-context-path>/.choreo/endpoints.yaml
```

**Sample `endpoints.yaml` file content**:

```yaml
# +required Version of the endpoint configuration YAML
version: 0.1

# +required List of endpoints to create
endpoints:
  # +required Unique name for the endpoint.
  # This name will be used when generating the managed API
- name: Greeting Service
  # +required Numeric port value that gets exposed via this endpoint
  port: 9090
  # +required Type of the traffic this endpoint is accepting.
  # Allowed values: REST, GraphQL, GRPC, UDP, TCP, WS.
  type: REST
  # +optional Network level visibility of this endpoint. Defaults to Public
  # Accepted values: Project|Organization|Public.
  networkVisibility: Project
  # +optional Context (base path) of the API that is exposed via this endpoint.
  # This is mandatory if the endpoint type is set to REST, GraphQL or WS.
  context: /greeting
  # +optional Path to the schema definition file. Defaults to wild card route if not provided
  # This is only applicable to REST and WS endpoint types.
  # The path should be relative to the docker context.
  schemaFilePath: greeting_openapi.yaml
```

The `endpoints.yaml` configuration file allows you to define configurations for multiple endpoints necessary for Choreo service components. This schema is essential to identify the context, port binding, network exposure level, and other attributes required to generate a Choreo endpoint.

You can define the following root-level configurations via the `endpoints.yaml` file:

| Configuration        | Required     | Description                                                                       |
|----------------------|--------------|-----------------------------------------------------------------------------------|
| **version**          | Required     | The version of the `endpoints.yaml` file.                                         |
| **name**             | Required     | A unique name for the endpoint, which Choreo will use to generate the managed API.|
| **port**             | Required     | The numeric port value that gets exposed via this endpoint.                       |
| **type**             | Required     | The type of traffic this endpoint accepts, such as `REST`, `GraphQL`, `gRPC`, `WS`, `UDP`, or `TCP`. Currently, the MI preset supports only the `REST` type.                                         |
| **networkVisibility**| Required     | The network level visibility of this endpoint, which defaults to `Public` if not specified. Accepted values are `Project`, `Organization`, or `Public`.|
| **context**          | Required     | The context (base path) of the API that Choreo exposes via this endpoint.         |
| **schemaFilePath**   | Required     | The swagger definition file path. Defaults to the wildcard route if not provided. This field should be a relative path to the project path when using the **Java**, **Python**, **NodeJS**, **Go**, **PHP**, **Ruby**, and **WSO2 MI** buildpacks. For REST endpoint types, when using the **Ballerina** or **Dockerfile** buildpack, this field should be a relative path to the component root or Docker context.|

## Update to the latest source configuration file

With the upcoming deprecation of the `component-config.yaml` file and the `endpoints.yaml` file, Choreo provides a seamless process to move to the latest `component.yaml`  version of the `component.yaml` file. Follow these steps to transition seamlessly:

### Step 1: Identify whether your current source configuration file is outdated

You can determine whether you’re using an outdated configuration file in the following ways:

- **During a build:**
     - On the **Build** page, after triggering a build, a warning will appear if your source configuration file is outdated. Click **View Details** in the **Initialization** -> **Source Config Validation** step. You will see an information banner with an option to update the file.

- **In existing deployments:**
     - If an existing deployment uses a build with an outdated source configuration file, you will see a warning icon on the build card of the relevant environment card.


### Step 2: Generate the latest `component.yaml` file

- In either of the scenarios above, click **Update** to initiate the process of generating the latest `component.yaml` file. The updated file will retain your existing configurations to ensure a smooth update process.


### Step 3: Add the generated configuration file to your repository

1. Download the generated `component.yaml` file.
2. Replace the existing source configuration file in the `.choreo` folder within your source repository.
    - Ensure the file name is `component.yaml`.


### Step 4: Trigger a new build

1. Commit the new `component.yaml` file to your repository. Push changes to the remote Git repository.
2. Trigger a build using the latest commit.


### Step 5: Verify the update

Once the build is complete:

  - Deploy the build.
  - Confirm that the warning messages no longer appear.

You can benefit from the latest features and enhancements provided by the updated source configuration file.


# Manage Deployment Tracks for Choreo Components

Choreo allows you to create and manage dedicated [deployment tracks](../choreo-concepts/deployment-tracks.md) for components, facilitating independent version control and deployment. This capability also allows you to unlink deployment tracks from associated branches or relink them to different branches so that you can align with your preferred Git workflows, such as the feature branch workflow or GitFlow workflow.

!!! info
     Deployment track creation and management does not apply to API Proxy and [BYOI components](../develop-components/bring-your-own-image.md).

## Create a deployment track

**Prerequisites**:

 - Create a component in Choreo.

Follow the steps below to create a deployment track for a component:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to create a deployment track for.
3. On the header of the component overview page, click the **Deployment Track** drop-down list.
4. Click **+ Create New** to open the **Create Deployment Track** dialog.
5. In the **Create Deployment Track** dialog, do the following:
    1. Select a branch to associate with the deployment track.
    2. Optionally, specify a description for the deployment track. 
    3. To create a deployment track for a service component, specify a unique API version indicating the major and minor version numbers.
6. Click **Create**.

## Unlink a deployment track

If you want to detach a branch reference from a deployment track, you must unlink the branch.

!!! info
     When you unlink the branch of a deployment track, the active deployments are unaffected. However, while you can redeploy the existing deployment, you cannot perform a new deployment.

Follow the steps below to unlink a deployment track of a component:
  
1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to unlink a deployment track.
3. On the header of the component overview page, click the **Deployment Track** drop-down list and then click **View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
4. Click the edit icon corresponding to the deployment track you want to unlink.
5. In the **Edit Branch** dialog that opens, click the **Branch Name** list and select **None**.
6. Click **Save**.

## Link a deployment track

To associate a branch reference to an unlinked deployment track, you must link a branch.

!!! info
    To build and deploy the contents of the linked branch,  you must perform a manual build and deploy.

**Prerequisites**:

 - A minimum of two branches in your GitHub repository.

Follow the steps below to link a branch to an unlinked deployment track:
  
1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to associate a branch reference for.
3. On the header of the component overview page, click the **Deployment Track** drop-down list and then click **View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
4. Click **+ Link Branch** corresponding to the unlinked deployment track for which you want to associate a branch.
5. In the **Link Branch** dialog that opens, click the **Branch Name** list and select the branch you want to relink.
6. Click **Save**.

## Relink a deployment track

To switch the branch reference of a linked deployment track, you must relink to an appropriate branch.

!!! info
      If you unlink the existing branch of a deployment track and link a different branch, you must perform a manual build and deploy to build and deploy the contents of the recently linked branch.

**Prerequisites**:

 - A minimum of two branches in your GitHub repository.

Follow the steps below to switch the branch reference of a linked deployment track:
  
1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to relink a deployment track for.
3. On the header of the component overview page,  click the **Deployment Track** drop-down list and then click **View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
4. Click the **Edit Branch** icon corresponding to the deployment track you want to relink.
5. In the **Edit Branch** dialog that opens, click the **Branch Name** list and select the branch you want to relink.
6. Click **Save**.

Now that you understand how to create and manage deployment tracks for components, let’s explore a sample scenario to see how a developer can use deployment tracks to manage version releases in Choreo.

## Sample Scenario: Manage version releases with deployment tracks

Let’s consider the following version release scenario: 

- To initiate work on a new feature, a developer creates a new branch, named `feature-x` from either the `main` or `dev` branch.
- Once development is complete, the developer proceeds to merge the `feature-x` branch into the `dev` branch for testing.
- Upon successful testing in the `dev` branch, the developer proceeds to merge all the changes into the `main` branch for production deployment.

Following are the actions you need to take from a deployment track perspective to manage the version release:

1. To prepare for the new version release, unlink the `main` branch from the associated deployment track (let’s consider this as the deployment track 1).
2. Proceed to merge the `dev` branch containing the tested changes into the `main` branch.
3. Unlink the `dev` branch from the associated deployment track (let’s consider this as deployment track 2).
4. Link deployment track 2 containing the latest version of the service to the `main` branch for deployment.
5. To facilitate ongoing development and testing, create another deployment track (let’s consider this as deployment track 3) and link it to the `dev` branch.

!!! tip
     - As a developer, you can strategically unlink and relink deployment tracks to effectively manage different versions of your services within Choreo.
     - You can create new deployment tracks for ongoing development branches like `dev` to ensure a continuous development and release cycle.

## Delete a deployment track

If you no longer need a deployment track, you can delete it.

!!! note
    If the component exposes an endpoint or proxy and you want to delete the last version in the major version range, the recommended approach is to retire that version first. This allows consumers to transition to the next major version and prevents a sudden break in their experience.
    For example, if you have deployment tracks for v1.0 and v2.0, notify consumers to switch to v2.0 before deleting v1.0. Then, retire the APIs in v1.0 and proceed to delete the associated deployment track.




**Prerequisites**:

- At least 2 deployment tracks in a component.

Follow the steps below to delete a deployment track:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component for which you want to delete a deployment track.
3. On the header of the component overview page, click the **Deployment Track** drop-down list.
4. Click **+ View All**. This takes you to the component settings page where you can see all the deployment tracks linked to the component.
5. Click the **Delete** icon corresponding to the deployment track you want to delete.
6. Click **Delete** to confirm the deletion.

# Manage the Micro Integrator Runtime Version in Your Integration Project

Choreo allows you to use a preferred WSO2 Micro Integrator (MI) runtime version in your integration project. Currently, Choreo supports MI product versions 4.1.0 and 4.2.0. You have the flexibility to deploy WSO2 updates within these specified versions. 

When you create an integration project, you can specify a required runtime version to gain control over the environment in which your integration runs. This version management capability empowers you to tailor your projects depending on your runtime requirements, enhancing the customization and adaptability of your integration workflows.

## Understand the version string

WSO2 Micro Integrator (MI) utilizes a versioning system consisting of three-digit numbers, such as `4.1.0` and `4.2.0`, following semantic versioning principles. The product remains committed to receiving updates from WSO2, including security fixes, bug resolutions, and enhancements. Within the Choreo platform, the MI runtime version is constructed by combining the product release version with its corresponding update level.

In Choreo, the MI runtime version is structured as a four-digit number, for example, `4.1.0.14` or `4.2.0.17`. The first three digits represent the product release version, while the last digit signifies the update level of the product. The fourth digit is optional and can be omitted.

![Version string](../assets/img/develop-components/micro-integrator/version-string.png)

## Version management in WSO2 Integration Studio

If you are using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/) to build and deploy integration artifacts in WSO2 Micro Integrator, you can create multiple runtime environments and execute projects on any selected environment. WSO2 Integration Studio also allows you to configure multiple Micro Integrator runtime environments, offering flexibility and customization in the execution of integration processes.

You can specify the Runtime version when you create an integration project in WSO2 Integration Studio. In the project creation wizard, specify the runtime version in the **Runtime version** field, as shown below.
![Specify Runtime version](../assets/img/develop-components/micro-integrator/specify_runtime_version.png)


An integration project is structured as a Maven project with multiple sub-modules. The root `pom.xml` file holds crucial information about the target runtime. The runtime version you configure when you create a new project is saved within the root `pom.xml` file. The version information is stored in the <project.runtime.version> element under the <properties> in the `pom.xml` file. If there is a need to update the runtime version, you have the flexibility to modify the value to a valid runtime version and ensure that the project runs in the required runtime environment.

![project runtime version](../assets/img/develop-components/micro-integrator/project-runtime-version.png)

You can establish multiple runtime environments by utilizing updated MI instances. With a valid WSO2 subscription, you can also access and download updates to set up an updated MI server locally. This update process allows you to select a preferred update level as the runtime version. Consequently, you can run your integration on a runtime with the latest updates, ensuring optimal performance and access to new features.

### Configure a Micro Integrator runtime environment in Integration Studio

If you are using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), follow these steps to set up a remote server instance with a Micro Integrator runtime environment to execute your integration project:

!!! info "Note"
    If you have not downloaded and installed WSO2 Integration Studio, you can follow the [installation instructions](https://apim.docs.wso2.com/en/latest/integrate/develop/installing-wso2-integration-studio/) in the WSO2 API Manager documentation.

1. Launch WSO2 Integration Studio and click **Add Server** in the **Getting Started** view.
   ![Add server](../assets/img/develop-components/micro-integrator/add-server.png)
2. In the **Define a New Server** dialog, click to expand the `WSO2` directory and select **WSO2 Remote Server**.
   ![Define a remote server instance](../assets/img/develop-components/micro-integrator/define-a-remote-server-instance.png)
3. Enter the WSO2 Micro Integrator Management API URL in the **Server URL** field and click **Test Connection**.

    !!! info "Note"
        The Management API of WSO2 Micro Integrator is an internal REST API introduced to substitute MI admin services. The default HTTPS port of the Management API of WSO2 Micro Integrator is `9164`. If you have not manually changed the default port, you must set the Management API URL as `https://localhost:9164/management`.  If you have changed the default HTTPS port, you must set the port number appropriately when specifying the **Server URL**. For more information on the default ports of WSO2 Micro Integrator, see [WSO2 Micro Integrator default ports](https://apim.docs.wso2.com/en/latest/install-and-setup/setup/reference/default-product-ports/#micro-integrator-ports) in the WSO2 API Manager documentation.

    ![Set server URL](../assets/img/develop-components/micro-integrator/set-server-url.png)
    
4. Click **Finish**.
5. In the **Add and Remove** dialog, select the integration components to move from the left side to the right side.
6. Click **Add >**.
7. Click **Finish**. 

Your integration project is now running in a remote server instance with the Micro Integrator runtime environment you require.
If you need to make changes to the integration project, expand the remote server instance, right-click on the deployed exporter project, and select **Redeploy** to apply the changes.

![Redeploy project](../assets/img/develop-components/micro-integrator/redeploy-project.png)

## Convention for version interpretation in Choreo deployments

You can use the following convention to indicate the required MI runtime version in your integration project:


| **Version format**           | **Example**       | **Description**   |
|------------------------------|-------------------|-------------------|
| Product version              | `4.1.0`, `4.2.0`  | Deploy on the latest update level of the mentioned product version.                 |
| Product version with update level  | `4.1.0.15`, `4.2.0.17` |  Deploy on the exact update level of the mentioned product version.    |
| GA version                   | `4.1.0.0`, `4.2.0.0` | Deploy on the exact GA version without any update.                  |
| Default version            | Empty value         | Deploy on the latest update level of the default product version.                  |


Choreo utilizes Alpine images for configuring and deploying the Micro Integrator runtime. This includes automated configuration of the JRE/JDK, customized to the compatibility of the chosen runtime version, simplifying the setup procedure.

## Migrate between runtime versions

Changing the runtime version in an integration project may become necessary during product version upgrades or when you want to apply updates. 

To change the runtime version of a MI Integration, follow the below steps.

### Update the runtime version in the integration project
    
To change the runtime version in the integration project, follow the steps below:
1. Open the project in Integration Studio.
2. Right-click on the project and select **Change Runtime MI Version**.
    ![Update Runtime version](../assets/img/develop-components/micro-integrator/click_change_runtime.png)
3.  Specify the new runtime version as shown below:
    ![Update Runtime version](../assets/img/develop-components/micro-integrator/update_runtime_version.png)
4. Alternatively, you can manually update the version by opening the root `pom.xml` file.  Open pom.xml and change the required runtime version in `<project.runtime.version>` element under `<properties>` section.

To test the changes locally, you must download and set up the runtime environment locally. Then, you must [configure the Integration Studio runtime environment](#configure-a-micro-integrator-runtime-environment-in-integration-studio) by directing it to the locally installed MI runtime. Once the setup is complete, you can deploy your integrations on the MI runtime environment and proceed to the testing phase.

After completing the tests to ensure everything works as expected, you can follow below steps to deploy the project in Choreo:

1. Commit and push the changes to your repository.
2. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
3. Select your project from the **Project** list in the header.
4. Select your MI integration component from the **Component** list in the header.
5. In the left navigation menu, click **Build**.
6. Select the latest commit and click **Build**.
7. In the left navigation menu, click **Deploy**.
8. Click on the **Configure and Deploy** and deploy the component.
9. Verify the Runtime version by checking the logs by selecting the **Runtime Logs** under the **Observability** section.

  You will see the runtime version in the logs as shown below:
  ![Runtime version in logs](../assets/img/develop-components/micro-integrator/runtime_version_in_logs.png)

Next, you must conduct additional testing in the development environment on Choreo before you promote the integration to production environments.

## Troubleshoot errors

The following error codes can help you troubleshoot errors that occur during the integration component build:

| **Error code** | **Description**            |
|----------------|----------------------------|
| 110 - 119      | Internal server error.     |
| 121            | Malformed runtime version. |
| 122            | The specified runtime version is not available. Either the product or update level is not available.    |
| 123            | Trivy security vulnerabilities found in the `libs` directory. |
| 124            | Trivy security vulnerabilities found in the `dropins` directory. |
| 125            | Trivy security vulnerabilities found in the `libs` or `dropins` directory. |
| 126            | Error building integration project. |


# Submit and Manage Workflow Approval Requests

In Choreo, if an administrator [configures a workflow to require approval](../administer/configure-approvals-for-choreo-workflows.md), you must submit a request to obtain approval to perform the task.

Upon submitting a workflow approval request, Choreo notifies all authorized assignees via email about the [review request](../administer/review-workflow-approval-requests.md). When an authorized assignee approves or rejects the request, you will receive an email with details of the decision.

The approach to request approval can vary depending on the workflow. 

## Request approval for environment promotion

**Prerequisites**:

- Ensure you have a component created, built, and deployed to the development environment.
- Ensure that an approval workflow is configured for environment promotion.
- Ensure you are promoting the component to a critical environment, such as production.

To request approval to promote a component from the development environment to production, follow these steps:

1. Sign in to the [Choreo Console](https://console.choreo.dev/).
2. In the **Component Listing** pane, click on the component you want to deploy. This takes you to the **Overview** page of the component.
3. In the left navigation menu, click **Deploy**.
4. Go to the **Development** card and click **Request to Promote**.
5. In the **Request Approval** pane that opens, enter your request details and click **Submit**. This creates a request and notifies all authorized assignees via email about the request.

    !!! note
         When an environment promotion request for a specific component is pending review, Choreo restricts other developers from making the same request until the pending request is either approved or rejected.

When an authorized assignee approves the request, you will receive a confirmation email and can proceed to promote the component to production.

## Cancel a workflow approval request

If you want to cancel a workflow approval request that is already submitted, you can do so before the request is approved or rejected. 

When you submit a workflow approval request, the **Request to Promote** button changes to **Cancel Request**. To cancel an approval request, click **Cancel Request**. Upon confirming the cancellation, all configured approvers are notified immediately, and the request will no longer be pending.


# Work with the Micro Integrator Runtime in Choreo

WSO2 Micro Integrator (WSO2 MI) is a lightweight, high-performance integration runtime. It allows you to run integrations developed using WSO2 Integration Studio within Choreo. 

The topics on this page walk you through the key aspects you need to understand to use the WSO2 MI runtime effectively in Choreo.

## Integration types

Choreo supports the following WSO2 MI integrations that cater to different use cases and requirements. Each integration type serves a specific purpose. Therefore, it is essential to understand their differences to easily choose the most appropriate integration for your use case.

- **Service**: Exposes an integration as an API via HTTP, making it possible to create a RESTful interface for your integration services. This type is ideal for scenarios where you need to provide an API for external systems or clients to interact with your integration.
- **Event Handler**: Triggers an integration based on external events such as messages arriving on a queue or updates in a database. This type is well-suited for implementing event-driven architectures or responding to changes in your system's environment.
- **Scheduled Task**: Runs an integration automatically at predefined time intervals, ensuring that specific integration tasks occur at regular intervals. This type is ideal for batch processing, data synchronization, or periodic maintenance tasks.
- **Manual Task**: Initiates an integration via user action, giving you full control over when the integration executes. This type is useful for on-demand tasks, testing, or debugging purposes.

## Develop integrations with WSO2 Integration Studio

[WSO2 Integration Studio](https://wso2.com/integration/integration-studio/) is a powerful, Eclipse-based graphical development environment that enables you to build and deploy integration artifacts in WSO2 Micro Integrator. This comprehensive IDE offers a robust set of tools for designing and testing integration flows and crafting integration artifacts. By utilizing the visual, drag-and-drop capabilities of WSO2 Integration Studio, developers can significantly reduce the time and effort needed to construct and deploy integration flows.

In addition to streamlining the development process, Integration Studio offers features such as debugging, testing, and version control to ensure the quality and reliability of integration flows. By creating an Integration project and Composite Exporter project in WSO2 Integration Studio, developers can export their integration projects as a single deployment artifact, known as a composite application. This composite application encompasses all the components and configurations necessary for deploying the integration project to WSO2 Micro Integrator.

The Composite Exporter project simplifies the deployment process by allowing developers to package their integration projects as a single, self-contained artifact that can be easily deployed and managed. This approach enhances the consistency and reliability of integration projects while streamlining the overall deployment process.

To start developing integrations with WSO2 Micro Integrator, see [WSO2 Micro Integrator documentation - Developing Integration Solutions](https://mi.docs.wso2.com/en/latest/develop/intro-integration-development/).

## Integration project directory structure

An Integration Project in WSO2 Integration Studio is a multi-module Maven project that can contain multiple modules with WSO2 Synapse configurations and a composite application module to export all the configurations as a single deployable artifact.

An integration project directory structure includes the following key components:

 - WSO2 Synapse configurations: These modules contain the essential configurations for the integration project.
 - Composite Application module: This module is responsible for exporting all the Synapse configurations as a single deployable artifact.

Optionally, you can include the following components in your integration project:

 - OpenAPI definition file: You can add the OpenAPI definition file to any location within the project. When creating a component, you'll need to define the path to this file. Choreo will automatically generate an OpenAPI definition for you based on your integration project, if you don't provide one.
 - Java libraries: If your integration project requires additional Java libraries, you can add them to the libs directory located in the project root.
 - deployment.toml file: This optional configuration file allows you to customize the preconfigured settings of WSO2 MI instances running on Choreo. By including this file, you can tailor the behavior of your WSO2 MI instances to better suit your project's specific requirements.

Understanding the Integration Project directory structure is crucial for organizing your project and ensuring that all necessary components are included in the final deployable artifact.

## OpenAPI support

OpenAPI Support plays a crucial role in enhancing the functionality of integrations exposed as APIs. By providing an OpenAPI definition for your exposed integration, you can streamline testing and management processes, ensuring a more efficient and user-friendly experience. Choreo will automatically generate an OpenAPI definition for you based on your integration project, if you don't provide one, saving you time and effort.

To incorporate OpenAPI support, store the OpenAPI definition file within the repository hosting your Integration Studio project. When creating the project, simply point to the file's location in the repository. If needed, you can change the location of the OpenAPI definition file later via the deploy page.

![Open API file](../assets/img/develop-components/micro-integrator/openapi_file.png)

By leveraging OpenAPI Support, you can optimize the way you test and manage your integrations, resulting in a more efficient development process and a smoother user experience.

## Work with third-party libraries

The use of third-party libraries in your Micro Integrator project can offer several advantages, such as enhanced functionality, improved integration capabilities, optimized performance, and reduced development time.

Here are some of the benefits of adding third-party JARs to the Micro Integrator:

 - Increased functionality: Third-party libraries can extend the core Micro Integrator distribution, allowing for greater flexibility and customization of integration solutions.
 - Enhanced integration capabilities: Third-party libraries enable the Micro Integrator to interact with existing systems such as databases or other APIs, improving overall integration capabilities.
 - Optimized performance: By offering optimized implementations of common functions, third-party libraries can improve the performance of the Micro Integrator.
 - Efficient development: Developers can avoid re-implementing commonly used functions, reducing development time and increasing efficiency.

To incorporate third-party libraries into your Micro Integrator project, create a new directory called `libs` at the
root of your project. If your project root and GitHub repository root are not the same, place the `libs` directory in
the project root. After adding the required JAR files to the `libs` directory, the Micro Integrator runtime will
automatically include them when deploying the component. This process ensures that any dependencies needed by your
integration flow are available at runtime.

In addition to `jar` libraries, you may also need to incorporate OSGi bundle JARs into your project. To do this,
create another directory called `dropins` at the root of your project. Similarly, if the project root and GitHub
repository root differ, place the `dropins` directory in the project root. Within the `dropins` directory, add the OSGi
bundle JAR files. The OSGI runtime will pick up these bundles during deployment, enabling you to utilize their
functionality within your Micro Integrator project.

![Libs directory](../assets/img/develop-components/micro-integrator/libs_dir.png)

## Importing custom certificates to MI

The feature enables Choreo MI users to import certificates into the MI `client-truststore.jks` file. This functionality
proves valuable when users need to establish connections with servers or services utilizing SSL/TLS encryption and
possessing self-signed certificates or certificates issued by private certificate authorities (CAs) that are not
automatically trusted. Importing the certificate to the MI `client-truststore.jks` file enables MI clients to establish secure connections with
the server or service seamlessly, eliminating SSL/TLS errors or warnings.

Before importing the certificate, it is necessary to obtain the certificate file, which can be in PEM or DER format. You
can get the certificate from the server or service provider or export it from a web browser. Certificates should be
added to the `/wso2mi/certs/` folder. Users need to verify that the mount path for the certificate file aligns with this
specific path.

1. In the Choreo console, select the component you wish to add a certificate to.
2. From the left navigation click **Deploy**.
3. Click on the **Configs and Secrets** tab.
4. Click **Create**.
5. Select **ConfigMap** as the **Config Type** and **File Mount** as the **Mount Type**.
6. Click **Next**.
7. Specify the following values as mount configurations:

    | **Field**       | **Value**                                              |                                    
    |-----------------|--------------------------------------------------------|
    | **Config Name** | An appropriate name for the certificate.             |
    | **Mount path**  | `/wso2mi/certs/<filename>`. For example, `/wso2mi/certs/certificate.crt` |

8. Click **Upload File** and attach the certificate.
9. Click **Create**.

## Working with sensitive data using MI Secure Vault

MI Secure Vault is a feature that allows users to securely store sensitive data, such as passwords and tokens, and
provide access to that data to MI Integrations. This feature provides an added layer of security to your integrations by
reducing the risk of accidental exposure of sensitive data.

To use MI Secure Vault to work with sensitive data, follow these steps:

1. Select the component from the Choreo Console.
2. From the left navigation, click Deploy.
3. Click on the **Configure and Deploy**.
4. Click on the **Add Environment Configurations**
5. Specify the following values as configurations:

    | **Field**       | **Value**                                 |                                    
    |-------------------------------------------|--------------------------------------------------------|
    | **Name** | An appropriate name for the secret/alias. |
    | **Value**       | Value for the secret                      |

6. Select **Mark as a Secret**.
7. Click **Add**.
8. Click **Deploy**.
9. Once the secret has been created, you can access it in your integration code using the following syntax:

```xml
<property name="secret_value_1" expression="wso2:vault-lookup('user_pass')" scope="default" type="STRING"/>
```
This code retrieves the secret named "user_pass" from the MI Secure Vault and stores it in the property named "
secret_value_1". You can then use this property in your integration code to access the secret value.

For more information on these features, see the [Accessing secrets](https://mi.docs.wso2.com/en/latest/install-and-setup/setup/security/encrypting-plain-text/#step-3-accessing-secrets) section of the MI Secure Vault documentation. By using MI
Secure Vault to store and access sensitive data in your integrations, you can ensure that your integrations
remain secure and protect sensitive data from unauthorized access.


## Scan third-party libraries to identify security vulnerabilities

Scanning third-party libraries for security vulnerabilities is essential for identifying potential weaknesses in an application that could be exploited by attackers. Taking a proactive approach to security helps organizations detect and mitigate risks before they can be exploited, preventing data breaches, system compromises, and other security incidents.

Choreo incorporates a security vulnerability scanning process during deployment. It uses Trivy to scan and detect critical vulnerabilities in third-party libraries added to the integration component. If the scan uncovers any critical vulnerabilities, the deployment process is halted. The deployment pane displays the Trivy scan status and any security failures in the Library (Trivy) vulnerable scan step, which can be accessed by clicking on it. Once the vulnerability has been addressed, you can redeploy the component.

## Customize WSO2 Micro Integrator preconfigured settings

Customizing WSO2 Micro Integrator Preconfigured Settings is essential for ensuring that the integration solution works optimally within the specific context of your organization. While WSO2 MI comes with preconfigured settings designed for general use, these settings may not be suitable for every organization's unique requirements. Customizing these settings can help optimize performance and ensure compatibility with your organization's systems and applications.

To customize the preconfigured settings of WSO2 MI instances running on Choreo, define a `deployment.toml` file in the GitHub repository subpath of your Micro Integrator project:

![deployment.toml](../assets/img/develop-components/micro-integrator/config_file.png)

!!! note
    If you change critical configuration parameters such as port offset and hostname, it can break internal communication.
    Therefore, the recommended approach is to update only the necessary configuration parameters.

Given below is a sample `deployment.toml` file that can be used to configure the JMS transport. For more information on WSO2 MI
configuration parameters, see the [MI Configuration Catalog](https://mi.docs.wso2.com/en/latest/reference/config-catalog-mi/).

```
[[transport.jms.sender]]
name = "myQueueSender"
parameter.initial_naming_factory = "org.apache.activemq.jndi.ActiveMQInitialContextFactory"
parameter.provider_url = "$env{JMS_PROVIDER_URL}"
parameter.connection_factory_name = "QueueConnectionFactory"
parameter.connection_factory_type = "queue"
parameter.cache_level = "producer"

[[transport.jms.listener]]
name = "myQueueListener"
parameter.initial_naming_factory = "org.apache.activemq.jndi.ActiveMQInitialContextFactory"
parameter.provider_url = "$env{JMS_PROVIDER_URL}"
parameter.connection_factory_name = "QueueConnectionFactory"
parameter.connection_factory_type = "queue"
parameter.cache_level = "consumer"
```

## Environment variables

Using environment variables is a recommended practice when developing integration artifacts with WSO2 Integration Studio, as it improves configuration management, security, portability, and manageability. By leveraging environment variables, organizations can streamline the management and maintenance of their integrations, ensuring that updates can be implemented quickly and efficiently.

The component's Deploy page provides a user-friendly interface to manage environment variables across different environments. For information on managing environment variables for complex use cases, see [Configurations and secrets](../devops-and-ci-cd/manage-configurations-and-secrets.md).

![Environment variables](../assets/img/develop-components/micro-integrator/env_variables.png)

Environment variables offer several benefits:

 - Configuration management: They simplify the process of managing and updating configuration settings, making it easier to maintain consistency across different environments.
 - Security: Environment variables help protect sensitive information by storing it securely and separating it from the main codebase.
 - Portability: By using environment variables, you can ensure that your integration artifacts can be easily migrated and deployed across various environments with minimal changes.
 - Manageability: Environment variables offer a centralized way to manage configuration settings, making it easier to update and maintain your integrations over time.

For a comprehensive list of parameters that can be configured as environment variables, see [WSO2 Micro Integrator documentation - Injecting Parameters - Supported parameters](https://mi.docs.wso2.com/en/latest/develop/injecting-parameters/#supported-parameters).

## Configure logging

Configuring logging is crucial when developing and maintaining a software system, as it can significantly improve efficiency during the development, testing, and maintenance phases of the software development process. Logging captures events and messages that occur during an application's execution, providing valuable insights for troubleshooting and debugging issues.

With Micro Integrator instances, you can configure and customize logging according to your requirements. Logging configurations can be added to each MI instance's environment, allowing you to fine-tune logging depending on the specific environment or deployment scenario.

To configure logging in MI instances, follow the steps given below: 

!!! tip
     You can use environment variables with specific naming conventions.

1. Start the variable name with `logging_level_` followed by the package or class name.
2. Replace the dot character in the package name with an underscore.
3. Set the variable value to the required logging level for the corresponding package or class.

    For example, to enable wire logs, change the logging level of the `org.apache.synapse.transport.http.wire` package to `debug`. 

To configure logging, set the environment variable as follows:

1. In the left navigation menu, click **Deploy** and then click **Configs & Secrets**. 
2. Click **+ Create**. 
3. Select **ConfigMap** as the **Config Type** and **Environment Variables** as the **Mount Type**. 
4. Click **Next**. 
5. Specify the following values as mount configurations:

    | **Field**       | **Value**                                              |                                    
    |-----------------|--------------------------------------------------------|
    | **Config Name** | An appropriate name for the configuration.             |
    | **Name**        | `logging_level_org_apache_synapse_transport_http_wire` |
    | **Value**       | `debug`                                                |

6. Click **Create**.

## Connectors

WSO2 Micro Integrator (MI) Connectors are prebuilt connectors designed to simplify integration between WSO2 MI and various other systems. They enable seamless connections to databases, message brokers, REST APIs, and more, allowing you to perform actions such as sending messages, executing queries, or retrieving data. These connectors are easy to use, making it straightforward to incorporate them into your WSO2 MI integration flows. Micro Integrator connectors are versatile and can be utilized in various integration scenarios, including data integration, service-oriented architecture (SOA) integration, and event-driven architecture (EDA) integration.

WSO2 Integration Studio is a comprehensive development environment that facilitates the creation of integration flows using WSO2 Micro Integrator Connectors. With Integration Studio, you can design and implement integration flows that connect diverse systems and execute various actions, such as sending messages, executing queries, or retrieving data. You can build integration flows using either prebuilt connectors provided by WSO2 MI or custom connectors developed using the Connector Development Toolkit. Integration Studio offers a graphical user interface that simplifies the process of building and testing integration flows while also providing a set of tools for managing and deploying these flows in a WSO2 MI runtime environment.

For more information, see the following topics in the WSO2 Micro Integrator documentation.

- [Connectors Overview](https://mi.docs.wso2.com/en/latest/reference/connectors/connectors-overview/)
- [Adding Connectors](https://mi.docs.wso2.com/en/latest/develop/creating-artifacts/adding-connectors/)

## Deploying integrations in Choreo 

WSO2 MI buildpack is where you can deploy integrations developed with WSO2 Micro Integrator as an API. In this preset, you have three different ways to define endpoints. Choreo gives priory to the definition of endpoints in the below-mentioned order. 

1. **Using component.yaml file**
This is the most flexible method to define endpoints. You can configure the endpoint details with the `component.yaml` configuration file. Place this file in the `.choreo` directory in the project path of the component. 
If the Micro Integrator project has inbound endpoints, you can expose them via different endpoints using the `component.yaml`file.

    To learn about the `component.yaml` file, see [Overview of the component.yaml file](../develop-components/manage-component-source-configurations.md#overview-of-the-componentyaml-file).

3. **Auto generating endpoints**
If `component.yaml` is not provided and if the source Micro Integrator project has APIs, Choreo scans the project and generates the API endpoints. If the project has few APIs, an endpoint will be generated for each API. The visibility of this auto-generated endpoint is set to `Public` by default. You can change the visibility in the deployment flow.

4. **Provide default endpoints**
If `component.yaml` is not provided and if the source Micro Integrator project doesn't have APIs, Choreo generates a default endpoint which will expose the default micro integrator port (8290) with `Public` visibility and wildcard context.

!!! note
    If you are currently using `component-config.yaml` or `endpoints.yaml` configuration files, see the respective [migration guide](../develop-components/manage-component-source-configurations.md#migration-guide) for instructions on migrating to the recommended `component.yaml` configuration file.

## Explore Choreo examples on GitHub

For a hands-on experience with MI-based integrations in Choreo, we recommend exploring our samples in Choreo Console. You can filter out the samples based on the buildpack `WSO2 MI`. This will point you to the samples in the [Choreo samples GitHub repository](https://github.com/wso2/choreo-samples)

### [Choreo samples - GitHub Repository](https://github.com/wso2/choreo-samples)

- **Fork the Repository**: Start by forking the repository to your account.

- **Explore & run**: Navigate through the different integration scenarios. Each example has a README.md with setup and execution instructions.



# Develop a Manual Task

This guide walks you through the steps to develop, deploy, test, and observe a manual task using Choreo.

In this guide, you will:

- Develop a manual task to fetch the weather forecast for a specified location for the next 24 hours from the [OpenWeatherMap](https://openweathermap.org) API.
- Process the weather data into a specific format.
- Send the formatted data to a specified email address.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

    !!! info "Repository File Structure"
        The sample code for this guide is in the `<sample-repository-dir>/weather-to-email-integration` directory. The following table describes the key files in the repository:

        | **File Path**         | **File Content**                                                     |
        | --------------------- | -------------------------------------------------------------------- |
        | **Ballerina.toml**    | Contains metadata about the project                                  |
        | **Dependencies.toml** | Lists the dependencies required for the project                      |
        | **main.bal**          | Contains the entry point of the project, including the main function |
        | **types.bal**         | Contains custom data types used in the project                       |
        | **utils.bal**         | Contains utility functions and helper functions used in the project  |

3. Go to [OpenWeatherMap](https://openweathermap.org/) and sign up to obtain an API key. For details, see the [OpenWeatherMap documentation](https://openweathermap.org/appid#signup).

## Step 1: Create a manual task component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Manual Task** card.
6. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:

        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

7. Enter the following information:

    | **Field**             | **Description**                                      |
    | ----------------------| -----------------------------------------------------|
    | **Organization**      | Your GitHub account                                  |
    | **Repository**        | `choreo-samples`                                     |
    | **Branch**            | `main`                                               |
    | **Component Directory** | `weather-to-email-integration`                       |

8. Select **Ballerina** as the **Build Pack**.

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Component Directory** specifies the location of the project to build the component.

4. Enter a unique name and description for the component. You can use the following values:

    | **Field**          | **Value**                        |
    | ------------------ | -------------------------------- |
    | **Component Name** | `WeatherToEmail`                 |
    | **Description**    | `My first manual task`           |


8. Click **Create**. Choreo initializes the component with the sample implementation and opens the **Overview** page of the component.

## Step 2: Build the manual task

1. In the left navigation menu, click **Build**.
2. In the **Builds** pane, click **Build**. This opens the **Commits** pane, where you can see all the commits related to the component.
3. Select the latest commit and click **Build**. This triggers the build process and displays the build progress in the **Build Logs** pane.

    !!! info
        The build process may take some time. Once complete, the build status will be listed in the **Builds** pane. Here, you will see the build status as **Success**.

## Step 3: Deploy the manual task

1. In the left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane, specify values for the configurable variables:

    !!! tip
        The configurable variables populated here are defined in the sample Ballerina project used in this guide. To learn how to declare configurable variables in Ballerina, see the [Ballerina documentation on declaring configurable variables](https://ballerina.io/learn/by-example/configurable-variables/).

    | **Field**     | **Value**                                                               |
    | ------------- | ----------------------------------------------------------------------- |
    | **apiKey**    | The API key you obtained in the prerequisites section                   |
    | **latitude**  | Latitude of the location to get the weather forecast                    |
    | **longitude** | Longitude of the location to get the weather forecast                   |
    | **email**     | The email address to receive the formatted weather forecast information |

    !!! note
        If you use **Ballerina** as the buildpack and want to set a configurable variable as a secret, click the lock icon corresponding to the configurable variable. This marks it as a secret and conceals the input value.

        For example, if you set the **apiKey** as a secret, its input value will be concealed. To update the input value later, click **Update Secret Content** and specify a new value.

4. Click **Deploy**.

## Step 4: Execute the manual task

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the task.

    !!! info "Inject Dynamic Values into Your Application as Command-Line Arguments"
        If you want to inject dynamic values into your application as command-line arguments when you run a manual task, follow these steps:
        1. Click the drop-down icon next to **Run Now** and then click **Run with Arguments**.
        2. In the **Runtime Arguments** pane, enter the arguments you want to pass to your application.
        3. Click **Execute**. This triggers the task with the specified arguments.

        The capability to run a manual task with arguments is supported for the following buildpacks:

        === "Dockerfile"
            To explore a Dockerfile-based manual task with arguments, try out the [Hello World Task](https://github.com/wso2/choreo-samples/tree/main/docker-hello-world-manual-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on Docker projects, the **Run with Arguments** capability is not supported if the Dockerfile contains `CMD`. In such scenarios, use `ENTRYPOINT` to define your default commands.

        === "Go"
            To explore a Go-based manual task with arguments, try out the [Hello World Go Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-go-task) sample. For instructions, see the `readme.md` file in the sample repository.

        === "Java"
            To explore a Java-based manual task with arguments, try out the [Hello World Java Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-java-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on Java projects:
                - The **Run with Arguments** capability is not supported if `Procfile` is available in the project.
                - The `Main` class should be defined in the `manifest` file.
                - If Maven files such as `mvn.cmd` exist in the project without the `.mvn` directory, the build will fail. To ensure a successful build, either commit the `.mvn` directory along with any Maven files or exclude Maven files if you choose not to commit the `.mvn` directory.

        === "NodeJS"
            To explore a NodeJS-based manual task with arguments, try out the [Hello World NodeJS Task](https://github.com/wso2/choreo-samples/tree/main/hello-world-nodejs-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on NodeJS projects:
                - The **Run with Arguments** capability is not supported if `Procfile` is available in the project.
                - The project root must contain the `package.json` file with the `main` attribute defined.

        === "WSO2 MI"
            To explore a WSO2 MI-based manual task with arguments, try out the [Weather to Logs Task](https://github.com/wso2/choreo-samples/tree/main/weather-to-logs-mi-manual-task) sample. For instructions, see the `readme.md` file in the sample repository.

            !!! info
                When working on WSO2 MI projects and deploying a WSO2 MI integration as a manual task in Choreo, use the WSO2 MI automation mode. For details, see [Running the Micro Integrator in Automation Mode](https://apim.docs.wso2.com/en/latest/install-and-setup/install/running-the-mi-in-automation-mode/).

        === "Ballerina"
            To explore a Ballerina manual task with arguments, try out the [Weather to Email Task](https://github.com/wso2/choreo-samples/tree/main/weather-to-email-integration) sample. For instructions, see the README.md file in the sample repository.

            !!! info
                If you want to pass arguments to Ballerina main functions, use the **Run with Arguments** capability. For details on the arguments you can pass, see the [Ballerina documentation](https://ballerina.io/learn/by-example/main-function/). You can also override configurable values in the same manner. For more information, see [Provide values to configurable variables](https://ballerina.io/learn/provide-values-to-configurable-variables/#provide-via-command-line-arguments).

## Step 5: Test the manual task

Once the task is triggered, an email with the subject `[WSO2 Choreo Demo] Next 24H Weather Forecast` is sent from `choreo.demo@gmail.com` to the email address specified as the **email** configurable variable value in [Step 3](#step-3-deploy-the-manual-task).

If the manual task ran successfully, you should receive an email similar to the following:

![Received email](../../assets/img/develop-components/develop-a-scheduled-integration/Received-email.png)

## Step 6: Observe the manual task

The observability view in Choreo displays graphs that depict details such as throughput, latency, diagnostic data, and logs to identify and troubleshoot anomalies in components you deploy.

1. In the left navigation menu, click **Observability**.
2. Observe the following:
    - The throughput and latencies of requests served over a given period.
    - The logs generated over a given period.
    - The flame graph (Diagnostics View) generated over a given period.
    - The low-code diagram.

To learn more about the observability details you can view via Choreo observability, see [Observability Overview](../../monitoring-and-insights/observability-overview.md).

## Step 7: Monitor executions

To track and monitor executions associated with the deployed manual task, go to the left navigation menu and click **Execute**.

!!! tip
    The **Execute** view is applicable to both scheduled and manual tasks.

You can view the following information:

- **Total executions**: The total number of executions within the past 30 days.

    ![Total Execution](../../assets/img/develop-components/develop-a-scheduled-integration/total_executions.png)

- **Execution history**: The currently active executions and those that are already complete. You can view information such as the execution ID, the revision of the execution, and the time it was triggered.

    ![Execution History](../../assets/img/develop-components/develop-a-scheduled-integration/execution_history.png)

- **Detailed execution logs**: Click on an execution to view detailed logs related to it.

    !!! info
        It may take a few minutes for the logs to appear. You may need to manually refresh to view the latest logs.

    ![Execution Logs](../../assets/img/develop-components/develop-a-scheduled-integration/execution_logs.png)


# Develop a Scheduled Task

Choreo is a versatile integration platform that allows you to create various types of integrations depending on your requirements. If you need to automatically run a specific integration at regular intervals, you can use Choreo to develop a scheduled task. This type of integration can automate the synchronization of data between different systems at specified intervals, reducing errors and improving productivity by eliminating the need for manual intervention.

This guide walks you through the steps to develop, deploy, test, and observe a scheduled task using Choreo.

In this guide, you will:

- Develop a scheduled task to fetch the weather forecast for a specified location for the next 24 hours from the [OpenWeatherMap](https://openweathermap.org) API.
- Process the weather data into a specific format.
- Send the formatted data to a specified email address at a specific time every day.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

    !!! info "Repository File Structure"
        The sample code for this guide is in the `<sample-repository-dir>/weather-to-email-scheduled-task` directory. The following table describes the key files in the repository:

        | **File Path**         | **File Content**                                                     |
        | --------------------- | -------------------------------------------------------------------- |
        | **Ballerina.toml**    | Contains metadata about the project                                  |
        | **Dependencies.toml** | Lists the dependencies required for the project                      |
        | **main.bal**          | Contains the entry point of the project, including the main function |
        | **types.bal**         | Contains custom data types used in the project                       |
        | **utils.bal**         | Contains utility functions and helper functions used in the project  |

3. Go to [OpenWeatherMap](https://openweathermap.org/) and sign up to obtain an API key. For details, see the [OpenWeatherMap documentation](https://openweathermap.org/appid#signup).

## Step 1: Create a scheduled task component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Scheduled Task** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following information:

    | **Field**             | **Description**                                |
    | --------------------- | ---------------------------------------------- |
    | **Organization**      | Your GitHub account                            |
    | **Repository**        | `choreo-samples`                               |
    | **Branch**            | `main`                                         |
    | **Component Directory** | `weather-to-email-scheduled-task`              |

6. Select **Ballerina** as the build pack.

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Component Directory** specifies the location of the project to build the component.

7. Enter a unique name and description for the component. You can use the following values:

    | **Field**          | **Value**                        |
    | ------------------ | -------------------------------- |
    | **Component Name** | `WeatherToEmail`                 |
    | **Description**    | `My first scheduled task`        |

8. Click **Create**. Choreo initializes the component with the sample implementation and opens the **Overview** page of the component.

Now you can proceed to build and deploy the scheduled task.

## Step 2: Build the scheduled task

1. In the left navigation menu, click **Build**.
2. In the **Builds** pane, click **Build**. This opens the **Commits** pane, where you can see all the commits related to the component.
3. Select the latest commit and click **Build**. This triggers the build process and displays the build progress in the **Build Logs** pane.

    !!! info
        The build process may take some time. Once complete, the build status will be listed in the **Builds** pane. Here, you will see the build status as **Success**.

## Step 3: Deploy the scheduled task

1. In the left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane, specify values for the configurable variables:

    !!! tip
        The configurable variables populated here are defined in the sample Ballerina project used in this guide. To learn how to declare configurable variables in Ballerina, see the [Ballerina documentation on declaring configurable variables](https://ballerina.io/learn/by-example/configurable-variables/).

    | **Field**     | **Value**                                                               |
    | ------------- | ----------------------------------------------------------------------- |
    | **apiKey**    | The API key you obtained in the prerequisites section                   |
    | **latitude**  | Latitude of the location to get the weather forecast                    |
    | **longitude** | Longitude of the location to get the weather forecast                   |
    | **email**     | The email address to receive the formatted weather forecast information |

    !!! note
        If you use **Ballerina** as the buildpack and want to set a configurable variable as a secret, click the lock icon corresponding to the configurable variable. This marks it as a secret and conceals the input value.

        For example, if you set the **apiKey** as a secret, its input value will be concealed. To update the input value later, click **Update Secret Content** and specify a new value.

4. Click **Next**.
5. Define a schedule to run the task. In this guide, set the schedule to receive the weather information daily at 8:00 AM UTC. Enter the following values:

    | **Field**            | **Value**                                             |
    | -------------------- | ----------------------------------------------------- |
    | **Select Time Zone** | Select a time zone to schedule the task               |
    | **Select Range**     | **Day**                                               |
    | **Every**            | `1`                                                   |
    | **At**               | `08:00`                                               |

    !!! tip
        To test and verify the task immediately, you can schedule the deployment to run in just a few minutes after you create it. However, to avoid unnecessary expenses, reschedule or stop the deployment once you test and verify.

6. Click **Deploy**. This deploys the scheduled task to the development environment and indicates the **Scheduled Status** as **Active** in the **Development** card.

You can test the scheduled task when it runs at the configured time.

## Step 4: Test the scheduled task

When the scheduled task runs at the configured time, an email with the subject `[WSO2 Choreo Demo] Next 24H Weather Forecast` is sent from `choreo.demo@gmail.com` to the email address specified as the **email** configurable variable value in [Step 3](#step-3-deploy-the-scheduled-task).

If the scheduled task ran successfully, you should receive an email similar to the following:

![Received email](../../assets/img/develop-components/develop-a-scheduled-integration/Received-email.png)

## Step 5: Observe the scheduled task

The observability view in Choreo displays graphs that depict details such as throughput, latency, diagnostic data, and logs to identify and troubleshoot anomalies in components you deploy.

1. In the left navigation menu, click **Observability**.
2. Observe the following:
    - The throughput and latencies of requests served over a given period.
    - The logs generated over a given period.
    - The flame graph (Diagnostics View) generated over a given period.
    - The low-code diagram.

To learn more about the observability details you can view via Choreo observability, see [Observability Overview](../../monitoring-and-insights/observability-overview.md).

## Step 6: Monitor executions

To track and monitor executions associated with the deployed scheduled task, go to the left navigation menu and click **Execute**.

!!! tip
    The **Execute** view is applicable to both scheduled and manual tasks.

You can view the following information:

- **Total executions**: The total number of executions within the past 30 days.

    ![Total Execution](../../assets/img/develop-components/develop-a-scheduled-integration/total_executions.png)

- **Execution history**: The currently active executions and those that are already complete. You can view information such as the execution ID, the revision of the execution, and the time it was triggered.

    ![Execution History](../../assets/img/develop-components/develop-a-scheduled-integration/execution_history.png)

- **Detailed execution logs**: Click on an execution to view detailed logs related to it.

    !!! info
        It may take a few minutes for the logs to appear. You may need to manually refresh to view the latest logs.

    ![Execution Logs](../../assets/img/develop-components/develop-a-scheduled-integration/execution_logs.png)


# Develop an Event Handler

An event handler executes predefined actions in response to specific events. Choreo simplifies the process of creating and deploying such integrations.

This guide walks you through the steps to create and deploy an Event Handler using WSO2 MI and Choreo.

In this guide, you will build a simple event handler that monitors RabbitMQ for new messages and displays them once they become available.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Set up RabbitMQ:
    - Use an existing RabbitMQ instance or start a new [RabbitMQ](https://www.rabbitmq.com/download.html) instance on a server that can be accessed via the internet.
    - Obtain the `username`, `hostname`, `password`, and `vhost` from the RabbitMQ instance to use later as environment variables.

3. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

## Step 1: Create an event handler component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Event Handler** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following information:

    | **Field**             | **Description**              |
    |-----------------------|----------------------------- |
    | **Organization**      | Your GitHub account          |
    | **Repository**        | `choreo-samples`             |
    | **Branch**            | `main`                       |
    | **Component Directory** | `mi-rabbitmq-listener`       |

6. Select **WSO2 MI** as the build pack. (since you are creating the REST API from a [WSO2 Integration Studio](https://wso2.com/micro-integrator/) project)

    !!! tip
        - **Buildpack** specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using [WSO2 Integration Studio](https://wso2.com/integration/integration-studio/), select **Micro Integrator** as the buildpack. If an integration is developed using the [Ballerina language](https://ballerina.io), select **Ballerina** as the buildpack.
        - **Component Directory** specifies the location of the project to build the component.

7. Enter a unique name and description for the component. You can use the following values:

    | **Field**          | **Value**              |
    |--------------------|------------------------|
    | **Component Name** | `SalesOrderListener`   |
    | **Description**    | `RabbitMQ integration` |

8. Click **Create**.

## Step 2: Deploy the integration

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**.
3. In the **Configurations** pane, click **+ Add** corresponding to **Environment Variables** and add the following environment variables:

    !!! tip
        Use the values from your RabbitMQ instance as per the [Prerequisites](#prerequisites) section for the environment variables.

    | **Name**     | **Value**                                         |
    | ------------- |--------------------------------------------------|
    | **HOSTNAME**  | Hostname of your RabbitMQ server                 |
    | **VHOST**     | Virtual hostname of your RabbitMQ server         |
    | **USERNAME**  | Username for connecting to RabbitMQ              |
    | **PASSWORD**  | Password associated with the RabbitMQ username   |

4. Click **Deploy**. This deploys the event handler to the development environment and indicates the **Deployment Status** as **Active** in the **Development** card.

## Step 3: Test the integration

1. Send a sales order message to the **SalesOrderQueue** on the RabbitMQ server. You can send a sample sales order message similar to the following:

    ```json
    {
        "order_id": "12345",
        "customer_name": "John Doe",
        "product": "Widget",
        "quantity": 10,
        "total_amount": 100.00
    }
    ```

2. Observe the logs:
    - In the left navigation menu, click **Logs** and then click **Runtime Logs**. You will see the order message in the logs.

Now you have gained hands-on experience in creating, configuring, and deploying an event handler.


# Develop an Integration with Integration Studio

Choreo simplifies the process of building, deploying, and managing integration components, making it easy to expose integrations as APIs. This guide walks you through the steps to expose an integration created in WSO2 Integration Studio as an API in Choreo.

In this guide, you will:
- Create a component to expose a sample integration from the [Choreo samples repository](https://github.com/wso2/choreo-samples) as an API.
- Deploy, test, and observe the integration component.
- Publish the integration component as an API to the Choreo Developer Portal.

!!! note
    - To develop integrations for **Manual Task** and **Schedule Task** components in Choreo, use the **automation mode** in the WSO2 Micro Integrator. See [Running MI in Automation Mode](https://apim.docs.wso2.com/en/4.2.0/install-and-setup/install/running-the-mi-in-automation-mode/).
    - For other component types (Service, webhook, event-handler, etc.), use the **server mode**.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    - Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    - Enter a unique organization name. For example, `Stark Industries`.
    - Read and accept the privacy policy and terms of use.
    - Click **Create**. This creates the organization and opens the **Project Home** page.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample integration for this guide.

## Step 1: Create the integration component

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the **Project Home** page.

2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following repository details:

    | **Field**             | **Description**              |
    |-----------------------|----------------------------- |
    | **Organization**      | Your GitHub account          |
    | **Repository**        | `choreo-samples`            |
    | **Branch**            | **`main`**                   |
    | **Component Directory** | `hello-world-mi`             |

6. Select WSO2 MI as the build pack (since you're creating the REST API from a [WSO2 Integration Studio](https://wso2.com/micro-integrator/) project).

7. Provide a unique name and description for the component:

    | **Field**          | **Value**              |
    |--------------------|------------------------|
    | **Component Name** | `Hello World`          |
    | **Description**    | `Hello World REST API` |

8. Click **Create**. Choreo initializes the component with the sample integration.

## Step 2: Deploy the integration component

1. In the Choreo Console left navigation menu, click **Deploy**.

2. Configure and deploy:
   - In the **Build Area** card, click **Configure & Deploy**.
   - In the **Configurations** pane, click **Next**. This displays the endpoint details ready for deployment.
   - Click **Deploy**. This deploys the integration component to the development environment.

    !!! tip
        - Choreo uses [endpoints](../../choreo-concepts/endpoint.md) to expose **Service** components to the network. Learn more about configuring endpoints in [Configure Endpoints](../configure-endpoints.md).
        - Automatic deployment is enabled by default, so only the first deployment needs to be done manually.

   The **Development** card shows the **Deployment Status** as **Active** when the integration is successfully deployed.

## Step 3: Test the integration

1. In the Choreo Console left navigation menu, click **Test** and then click **Console**.
2. In the OpenAPI Console, select **Development** from the environment drop-down list.
3. Expand the **GET /integration** operation.
4. Click **Try it out**, then click **Execute**. This sends a request to your deployed integration.
5. Check the response:
    - In the **Response body** section, observe the response. If the integration works as expected, you should see:
     
     ```json
     {"Hello" : "Integration"}
     ```

## Step 4: Observe the integration

1. Click **Observability** in the left navigation menu to monitor the performance of the integration component.

2. View metrics:
   - Observe throughput and latencies of requests over time.
   - View logs generated during a specific period.
   - Analyze the flame graph (Diagnostics View) for performance insights.

   For more details, see [Observability Overview](../../monitoring-and-insights/observability-overview.md).

## Step 5: Publish the integration component

1. In the Choreo Console left navigation menu, click **Manage** and then click **Lifecycle**.
2. The **Lifecycle Management** pane shows the current lifecycle stage as **Created**.
3. Click **Publish**. This changes the lifecycle stage to **Published** and exposes the integration as an API in the Choreo Developer Portal.
   - To view the published API, click **Go to Devportal**. In the Developer Portal, you can manage subscriptions and generate access tokens for testing.

Now you have successfully exposed an integration designed in WSO2 Integration Studio as a REST API in Choreo!


# Develop an API Proxy from a GitHub Repository Source

An API proxy acts as an intermediary between an existing API and Choreo, intercepting all requests made to the API. It also functions as a managed API, allowing you to apply essential API management features such as security policies and rate limiting.

In this guide, you will:

- Create an API proxy component to expose an existing API.
- Deploy the API proxy.
- Test the API proxy to verify its functionality.
- Manage the API.
- Consume the API.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample proxy source](https://github.com/wso2/choreo-samples/tree/main/department-api-proxy-from-github).  

## Step 1: Create an API proxy

You can create an API proxy either by selecting the source from a GitHub repository, uploading an OpenAPI specification file, or providing an OpenAPI specification URL. This guide demonstrates how to create an API proxy using a GitHub repository as the source.

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **API Proxy** card. This opens the **Create an API Proxy** pane.

4. Click on **Authorize With GitHub** card under **Connect a Git Repository** section to connect your GitHub account.
    - If you haven’t connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
         - Read and write access to code and pull requests.
         - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.    

5. Enter the following repository details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **Repository**         | choreo-samples     |
    | **Branch**             | **`main`**         |
    | **API Directory**      | /department-api-proxy-from-github |

    !!! note
        To select the relevant directory, click on the **Edit** action next to the **API Directory** input field. Then, enter `department-api-proxy-from-github` as the directory name to quickly search and locate the correct directory.

6. Specify the following values as Proxy Metadata:

    !!! info
        The **Context** field must be unique and cannot be changed after creation.**Version** and **Target** are mandatory fields. **Target** can be changed at any time after the creation.

    | **Field**       | **Value**                                  |
    |-----------------|--------------------------------------------|
    | **Context**     | `department-service`                                   |
    | **Version**     | `v1.0`                                      |
    | **Target**      | `https://samples.choreoapps.dev/company/hr`|

7. Specify the following values as Component Details:

    !!! info
        The **Component Name** field must be unique and cannot be changed after creation. This value is automatically generated, but you can edit it if necessary.
        **Component Display Name** is a required field.

    | **Field**       | **Value**                                  |
    |-----------------|--------------------------------------------|
    | **Component Display Name**| `Department Service`                    |
    | **Component Name**        | `department-service`                    |
    | **Description**           | `This is a sample proxy for department service`     |    

8. Click **Create**. This creates the API proxy component and takes you to the **Build** page.

!!! note
    When you create an API proxy from a GitHub repository source, the GitHub source serves as the single source of truth. Therefore, any modifications, such as adding or deleting resources, must be made through the GitHub repository.

## Step 2: Build

!!! info
    The initial build starts automatically when you create the API proxy, and you will be redirected to the **Build** page. In this case, you can skip the steps below. If you need to manually trigger a build later, follow these steps.

1. On the project home page, click on the `Department Service` component you created. This takes you to the component overview page.
2. In the left navigation menu, click **Build**.
3. On the **Build** page, click **Build Latest**.

!!! note
    The build process may take some time. You can track progress in the **Build Details** pane. Once complete, the build status changes to **Success**.

## Step 3: Deploy the API proxy

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**. This opens the **Configure & Deploy** pane.
3. Select **External** as the **API Access Mode** and click **Deploy**. The **Development** card indicates the **Deployment Status** as **Active** when the API proxy is successfully deployed.

Now you are ready to test the API proxy.

## Step 4: Test the API proxy

Choreo allows you to test your API proxy using either the [integrated OpenAPI Console](../../testing/test-rest-endpoints-via-the-openapi-console.md) or [cURL](../../testing/test-apis-with-curl.md). In this guide, you will use the OpenAPI Console.

!!! tip
    Choreo enables OAuth 2.0 to secure APIs by default. Therefore, you need an access token to invoke an API.

    - Choreo automatically generates a key to test the API via the OpenAPI Console. To view the key, click the show key icon in the **Security Header** field.
    - To disable security for the entire API or a specific resource:
        1. In the left navigation menu, click **Deploy**.
        2. Go to the **Build Area** card and click **Security Settings**.
        3. In the **Security Settings** pane:
            - To disable security for the entire API, clear the **OAuth2** checkbox.
            - To disable security for a specific resource, expand the relevant resource and turn off the **Security** toggle.
        4. Click **Apply**.

1. In the left navigation menu, click **Test** and then click **OpenAPI Console**.
2. Select **Development** from the environment drop-down list.
3. Expand the `GET /department/{departmentId}` resource and click **Try it Out**.
4. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

    ![API proxy response](../../assets/img/develop-components/develop-a-rest-api-proxy/rest-api-proxy-response.png){.cInlineImage-full}

    This indicates that your API proxy is working as expected.

## Step 5: Manage the API proxy

Now that you have a tested API proxy, you can publish it and make it available for application developers to consume. In this guide, you will apply rate limiting to the API and publish it.

### Step 5.1: Apply rate limiting to the API proxy

1. In the left navigation menu, click **Deploy**.
2. Go to the required environment card and click the settings icon corresponding to **API Configuration**.
3. In the **CORS, Rate Limiting and Resiliency** pane, click **Rate Limiting** to expand the section.
4. Select **API Level** as the **Rate Limiting Level**.
5. Specify appropriate values for the **Request Limit** and **Time Unit** fields. You can proceed with the default values.
6. Click **Apply**. This applies the rate limiting level to the API proxy and redeploys it.

### Step 5.2: Publish the API proxy

1. In the left navigation menu, click **Lifecycle** under **Manage**. This takes you to the **Lifecycle** page.
2. Click **Publish**.
3. In the **Publish API** dialog, click **Confirm** to proceed with publishing the API. If you want to change the display name, make the necessary changes and then click **Confirm**. This changes the API lifecycle state to **Published**.

## Step 6: Invoke the API

To generate credentials for the published API and invoke it via the Choreo Developer Portal, follow these steps:

1. In the **Lifecycle** page, click **Go to Devportal**. This takes you to the `Department Service` in the Choreo Developer Portal.

2. **Invoke the API**:
    1. In the Developer Portal left navigation menu, click **Try Out**.
    2. In the **Endpoint** list, select **Development** as the environment to try out the API.
    3. Click **Get Test Key** to generate an access token.
    4. Expand the `GET /department/{departmentId}` resource and click **Try it out**.
    5. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

        ![Try out response](../../assets/img/develop-components/develop-a-rest-api-proxy/try-out-response.png){.cInlineImage-full}

Now, you have gained hands-on experience creating, deploying, testing, and publishing an API proxy using Choreo.


# Develop an API Proxy from Scratch

An API proxy acts as an intermediary between an existing API and Choreo, intercepting all requests made to the API. It also functions as a managed API, allowing you to apply essential API management features such as security policies and rate limiting.

In this guide, you will:

- Create an API proxy component to expose an existing API.
- Deploy the API proxy.
- Test the API proxy to verify its functionality.
- Manage the API.
- Consume the API.

## Prerequisites

- If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

## Step 1: Create an API proxy

To create an API proxy, you can either upload an OpenAPI specification or provide an OpenAPI specification URL. In this guide, you will specify a URL to an OpenAPI definition of a sample API.

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **API Proxy** card. This opens the **Create an API Proxy** pane.
4. Select **Creare from Scratch** option. 
5. Specify the following values as Proxy Metadata:

    | **Field**       | **Value**                                  |
    |-----------------|--------------------------------------------|
    | **Context**     | `department-service`                                   |
    | **Version**     | `v1.0`                                      |
    | **Target**      | `https://samples.choreoapps.dev/company/hr` |

6. Enter following details for the Component Details:

    !!! info
        The **Component Name** field must be unique and cannot be changed after creation.

    | **Field**                 | **Value**          |
    |---------------------------|--------------------|
    | **Component Display Name**| `Department Service`          |
    | **Component Name**        | `department-service`          |
    | **Description**           | `Sample proxy for department service`     |

7. Click **Create**. This creates the API proxy component and takes you to the **Deploy** page.

## Step 2: Define resources for the API proxy

To add a new resource that retrieves a department by the department ID, follow these steps:

1. In the left navigation menu, click **Develop** and then click **Resources**.
2. Select **GET** as the **HTTP Verb** and enter `/department/{departmentId}` as the **URI Pattern**.
3. Click **+** to add the resource.
4. Expand the added resource and specify the following values:

    | **Field**        | **Value**                            |
    |------------------|--------------------------------------|
    | **Operation ID** | `findDepartment`                     |
    | **Description**  | `Find a department by department ID` |

5. Remove the five default resources that start with `/*` by clicking the delete icon corresponding to each resource.
6. Click **Save**.

## Step 3: Deploy the API proxy

1. In the left navigation menu, click **Deploy**.
2. In the **Build Area** card, click **Configure & Deploy**. This opens the **Configure & Deploy** pane.
3. Select **External** as the API access mode and click **Deploy**. The **Development** card indicates the **Deployment Status** as **Active** when the API proxy is successfully deployed.

Now you are ready to test the API proxy.

## Step 4: Test the API proxy

Choreo allows you to test your API proxy using either the [integrated OpenAPI Console](../../testing/test-rest-endpoints-via-the-openapi-console.md) or [cURL](../testing/test-apis-with-curl.md). In this guide, you will use the OpenAPI Console.

!!! tip
    Choreo enables OAuth 2.0 to secure APIs by default. Therefore, you need an access token to invoke an API.

    - Choreo automatically generates a key to test the API via the OpenAPI Console. To view the key, click the show key icon in the **Security Header** field.
    - To disable security for the entire API or a specific resource:
        1. In the left navigation menu, click **Deploy**.
        2. Go to the **Build Area** card and click **Security Settings**.
        3. In the **Security Settings** pane:
            - To disable security for the entire API, clear the **OAuth2** checkbox.
            - To disable security for a specific resource, expand the relevant resource and turn off the **Security** toggle.
        4. Click **Apply**.

1. In the left navigation menu, click **Test** and then click **OpenAPI Console**.
2. Select **Development** from the environment drop-down list.
3. Expand the `GET /department/{departmentId}` resource and click **Try it Out**.
4. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

    ![API proxy response](../../assets/img/develop-components/develop-a-rest-api-proxy/rest-api-proxy-response.png){.cInlineImage-full}

    This indicates that your API proxy is working as expected.

## Step 5: Manage the API proxy

Now that you have a tested API proxy, you can publish it and make it available for application developers to consume. In this guide, you will apply rate limiting to the API and publish it.

### Step 5.1: Apply rate limiting to the API proxy

1. In the left navigation menu, click **Deploy**.
2. Go to the required environment card and click the settings icon corresponding to **CORS, Rate Limiting and Resiliency**.
3. In the **CORS, Rate Limiting and Resiliency** pane, click **Rate Limiting** to expand the section.
4. Select **API Level** as the **Rate Limiting Level**.
5. Specify appropriate values for the **Request Limit** and **Time Unit** fields. You can proceed with the default values.
6. Click **Apply**. This applies the rate limiting level to the API proxy and redeploys it.

### Step 5.2: Publish the API proxy

1. In the left navigation menu, click **Lifecycle** under **Manage**. This takes you to the **Lifecycle** page.
2. Click **Publish**.
3. In the **Publish API** dialog, click **Confirm** to proceed with publishing the API. If you want to change the display name, make the necessary changes and then click **Confirm**. This changes the API lifecycle state to **Published**.

## Step 6: Invoke the API

To generate credentials for the published API and invoke it via the Choreo Developer Portal, follow these steps:

1. In the **Lifecycle** page, click **Go to Devportal**. This takes you to the `Department Service` in the Choreo Developer Portal.

2. **Invoke the API**:
    1. In the Developer Portal left navigation menu, click **Try Out**.
    2. In the **Endpoint** list, select **Development** as the environment to try out the API.
    3. Click **Get Test Key** to generate an access token.
    4. Expand the `GET /department/{departmentId}` resource and click **Try it out**.
    5. Enter `1` as the **departmentId** and click **Execute**. You will see a response similar to the following:

        ![Try out response](../../assets/img/develop-components/develop-a-rest-api-proxy/try-out-response.png){.cInlineImage-full}

Now, you have gained hands-on experience creating, deploying, testing, and publishing an API proxy using Choreo.

# Develop a Ballerina Service

Choreo allows you to develop and deploy applications using your preferred programming language. This guide demonstrates how to deploy a service component that exposes a REST API using the [Ballerina language](https://ballerina.io/). No prior knowledge of Ballerina is required to follow this guide.

A REST API is a web service that adheres to Representational State Transfer (REST) principles, using HTTP methods to access and manage resources. This guide walks you through building a Ballerina service component, deploying it on Choreo, and testing it with an HTTP client application.

In this guide, you will:

 - Build a simple greeting service using a sample implementation. The service has a single resource named `greet` that accepts a query parameter as input.
 - Deploy the service in Choreo.
 - Test the service.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    - Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    - Enter a unique organization name. For example, `Stark Industries`.
    - Read and accept the privacy policy and terms of use.
    - Click **Create**. This creates the organization and opens the **Project Home** page.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample greetings service](https://github.com/wso2/choreo-samples/tree/main/greeting-service) implementation in Ballerina.

### Learn the repository file structure

It’s important to understand the purpose of key files in the sample service. The table below provides an overview of each file in the greeter service:

!!! note
    The file paths are relative to `<sample-repository-dir>/greeting-service`.

| **Filepath**              | **Description**                                                |
|---------------------------|---------------------------------------------------------------|
| `service.bal`             | The greetings service code written in Ballerina.               |
| `tests/service_test.bal`  | Test files related to the `service.bal` file.                  |
| `Ballerina.toml`          | The Ballerina configuration file.                              |

Let’s get started!

## Step 1: Create a service component

To create a Ballerina service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the **Project Home** page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect your GitHub account. If you haven’t connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Provide the following repository details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **Repository**         | choreo-samples     |
    | **Branch**             | **`main`**         |
    |**Component Directory** | `/greeting-service` |

6. Select **Ballerina** as the buildpack.

7. Provide a display name, a unique name, and a description for the service component:

    !!! info
        The **Component Name** field specifies a unique identifier for the component. This name cannot be changed after creation.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Ballerina Greetings`   |
    | **Component Name**        | `ballerina-greetings`   |
    | **Description**           | Send greetings          |

8. Click **Create**. This creates the component and takes you to the **Overview** page.

You have successfully created a service that exposes a REST API written in Ballerina. Next, let’s build and deploy the service.

## Step 2: Build and deploy

Now that you’ve connected the source repository and configured the endpoint details, it’s time to build and deploy the service.

!!! note
    If you’re rebuilding the Ballerina service component after changing the Ballerina version, ensure that the version in the `Ballerina.toml` file matches the version in the `Dependencies.toml` file.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service may take a while. Track the progress via the logs in the **Build Details** pane. Once complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps:

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane, click **Next** to skip the configuration.
4. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service may take a while. Once deployed, the **Development** environment card shows the **Deployment Status** as **Active**.

Once deployed, you can test, manage, and observe the service like any other component in Choreo.

For detailed instructions, see the following sections:
- [Step 3: Test](../../testing/test-rest-endpoints-via-the-openapi-console.md)
- [Step 4: Manage](../../api-management/lifecycle-management.md)

## Manage the deployment

To view Kubernetes-level insights for detailed diagnosis of this Ballerina REST API, see Choreo’s [DevOps capabilities](../../devops-and-ci-cd/view-runtime-details.md).


# Develop a Service with Docker

Choreo allows you to create and deploy applications in any language. This guide demonstrates how to develop and deploy a containerized service component using a Dockerfile.

In this guide, you will:

 - Create a containerized service component using a sample service implementation. The sample service has a single resource named `greet` that accepts a query parameter as input.
 - Deploy the service in Choreo using a Dockerfile. The service will run on port 9090.
 - Test the service.

If you want to create a service component that exposes a Ballerina service, see [Develop a Ballerina Service](develop-a-ballerina-service.md).

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    - Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in.
    - Enter a unique organization name. For example, `Stark Industries`.
    - Read and accept the privacy policy and terms of use.
    - Click **Create**. This creates the organization and opens the **Project Home** page.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample greetings service](https://github.com/wso2/choreo-samples/tree/main/greeting-service-go) implementation with the Dockerfile.

### Learn the repository file structure

It’s important to understand the purpose of key files in the sample service. The table below provides an overview of each file in the greeter service:

!!! note
    The file paths are relative to `<sample-repository-dir>/greeting-service-go`.

| **Filepath**               | **Description**                                                              |
|----------------------------|------------------------------------------------------------------------------|
| `main.go`                  | The Go-based greeter service code.                                           |
| `Dockerfile`               | The Dockerfile to build the container image of the application.              |
| `.choreo/component.yaml`   | Choreo-specific configuration that provides information about how Choreo exposes the service. |
| `openapi.yaml`             | The OpenAPI contract of the greeter service. This is required to publish the service as a managed API. This file is referenced by the `.choreo/component.yaml` file. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints. The greeter service runs on port 9090. To securely expose the service through Choreo, you must provide the port and other required information in the `component.yaml` file. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

In the greeter sample, the `component.yaml` file is located in the `greeting-service-go/.choreo/` directory.

## Step 1: Create a service component from a Dockerfile

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/cloud-native-app-developer) and sign in. This opens the **Project Home** page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect your GitHub account. If you haven’t connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you forked in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires the following permissions:
         - Read and write access to code and pull requests.
         - Read access to issues and metadata.
        
        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if needed. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Enter the following repository details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **Repository**         | choreo-samples     |
    | **Branch**             | `main`         |
    | **Component Directory** | `/greeting-service-go`         |

6. Select **Docker** as the buildpack.
7. Enter the following details:

    | **Field**                | **Value**                        |
    |--------------------------|----------------------------------|
    | **Dockerfile**           | `/greeting-service-go/Dockerfile`|

    !!! info
        1. To successfully build your container with Choreo, explicitly define a user ID (UID) under the `USER` instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-sample-apps/blob/main/go/greeter/Dockerfile).
           - A valid User ID is a numeric value between 10000-20000 (e.g., `10001` or `10500`).
           - Usernames are invalid and should not be used (e.g., `my-custom-user-12221` or `my-custom-user`).

        2. The Dockerfile used in this guide is a multi-stage Dockerfile, which keeps the final image size small and allows building the application with specific versions of tools and libraries.

8. Provide a display name, a unique name, and a description for the service component:

    !!! info
        The **Component Name** field specifies a unique identifier for the component. This name cannot be changed after creation.

    | **Field**                 | **Value**          |
    |---------------------------|--------------------|
    | **Component Display Name**| `Greetings`        |
    | **Component Name**        | `greetings`        |
    | **Description**           | Send greetings     |

9. Click **Create**. This creates the component and takes you to the **Overview** page.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you’ve connected the source repository and configured the endpoint details, it’s time to build the service and create an image. Then, you can deploy the image and test the greeter service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service may take a while. Track the progress via the logs in the **Build Details** pane. Once complete, the build status changes to **Success**.

    You can access the following scans under **Build**:
    - **Dockerfile Scan**: Choreo checks if a non-root user ID is assigned to the Docker container for security. If no non-root user is specified, the build will fail.
    - **Container (Trivy) Vulnerability Scan**: This detects vulnerabilities in the final Docker image. If critical vulnerabilities are found, the build will fail.

    !!! info
        If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps:

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service may take a while. Once deployed, the **Development** environment card shows the **Deployment Status** as **Active**.

Once deployed, you can [test](../../testing/test-rest-endpoints-via-the-openapi-console.md), [manage](../../api-management/lifecycle-management.md), and [observe](../../monitoring-and-insights/observability-overview.md) the service like any other component in Choreo.

To view Kubernetes-level insights for detailed diagnosis of this Dockerfile-based REST API, see [Choreo's DevOps capabilities](../../devops-and-ci-cd/view-runtime-details.md).


# Develop a Service

Choreo allows you to create and deploy applications in your preferred programming language. 

In this guide, you will:

- Build a simple greeting service using a sample service implementation. The sample implementation will have a single resource named `greet` that accepts a single query parameter as input.
- Deploy the service in Choreo using a `Go` buildpack. The service will run on port 9090.
- Test the service.

## Prerequisites

1. If you're signing in to the Choreo Console for the first time, create an organization:
    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

2. Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample greetings service](https://github.com/wso2/choreo-samples/tree/main/greeting-service-go) implementation in `Go`.

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the greeter service:

!!! note 
    The specified file paths are relative to `<sample-repository-dir>/greeting-service-go`.

| **Filepath**             | **Description**                                                               |
|--------------------------|-------------------------------------------------------------------------------|
| `main.go`                | The Go-based greeter service code.                                            |
| `.choreo/component.yaml` | Choreo-specific configuration that provides information about how Choreo exposes the service. |
| `openapi.yaml`           | The OpenAPI contract of the greeter service. This is required to publish the service as a managed API. This `openapi.yaml` file is referenced by the `.choreo/component.yaml` file. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints. To run the greeter service on port 9090 and securely expose it through Choreo, you must provide the port and other required information in the `component.yaml` file. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

In the greeter sample, the `component.yaml` file is located in the `greeting-service-go/.choreo/` directory.

## Step 1: Create a service component

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Public Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

5. Under **Connect a Git Repository**, enter the following details:

    | **Field**              | **Value**          |
    |------------------------|--------------------|
    | **Organization**       | Your GitHub account|
    | **GitHub Repository**  | choreo-samples     |
    | **Branch**             | main               |
    | **Component Directory** | `/greeting-service-go` |

6. Select **Go** as the buildpack.
7. Enter the following details:

    | **Field**                | **Value**              |
    |--------------------------|------------------------|
    | **Language Version**     | 1.x                    |

8. Provide component display name, name and description:

    !!! info
        The **Component Name** field must be unique and cannot be changed after creation.

    | **Field**                 | **Value**          |
    |---------------------------|--------------------|
    | **Component Display Name**| Greetings          |
    | **Component Name**        | greetings          |
    | **Description**           | Send greetings     |

9. Click **Create**. This creates the component and lists it under **Component Listing** on the project home page.

You have successfully created the service. The next step is to build and deploy it.

## Step 2: Build and deploy

Now that you have connected the source repository and configured the endpoint details, it's time to build and deploy the greeter service.

### Step 2.1: Build

1. On the project home page, click on the `Greetings` component you created. This takes you to the component overview page.
2. In the left navigation menu, click **Build**.
3. On the **Build** page, click **Build Latest**.

    !!! note
        The build process may take some time. You can track progress in the **Build Details** pane. Once complete, the build status changes to **Success**.

### Step 2.2: Deploy

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take some time. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

Once you have successfully deployed the service, you can [test](../../testing/test-rest-endpoints-via-the-openapi-console.md), [manage](../../api-management/lifecycle-management.md), and [observe](../../monitoring-and-insights/observability-overview.md) it like any other component type in Choreo.


# Expose a Ballerina GraphQL Endpoint via a Service

Choreo offers the flexibility to develop and deploy applications in a language of your preference. This guide shows you how to deploy a service component that exposes a GraphQL API using the Ballerina language in Choreo. No prior knowledge of the Ballerina language is required to follow this guide. 

GraphQL API is a query language and runtime that provides a single endpoint for retrieving flexible and efficient data in a strongly-typed and self-documenting way. By following this guide, you will build a service component in Ballerina and deploy it on Choreo for any GraphQL client application to utilize it.

This guide shows how to build a simple reading list service and deploy it in Choreo using Ballerina. The GraphQL endpoint you create in this guide has two operations: **Query** and **Mutation**. The Query type operations read the data in the data source, and the Mutation operations update the data in the data source. The reading list service has two queries and three mutations as follows:

### Queries

**Retrieve the reading list**

This resource accepts an optional filter, `status`, which filters the reading list by reading status. Accepted values for status are `reading`, `read`, and `to_read`.

**Sample request**:
```
$ curl -X POST -H "Content-Type: application/json" -d '{"query": "query {allBooks (status: \"reading\") { id title author status }}"}' http://localhost:8090
```

**Sample response**
```
$ {
  "data": {
    "allBooks": [
      {
        "id": 1,
        "title": "Sample Book",
        "author": "Test Author",
        "status": "to_read"
      }
    ]
  }
}
```

**Retrieve a book item from the reading list**

This resource accepts a filter, `id`, which will select the book item from the reading list by book id.  The id is an Integer value. 

**Sample request**
```
$ curl -X POST -H "Content-Type: application/json" -d '{"query": "query {book (id: 1) { id title author status }}"}' http://localhost:8090
```

**Sample response**
```
$ {
  "data": {
    "book": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "to_read"
    }
  }
}
```

### Mutations

**Add a book item to the reading list**

This remote function accepts a book record as the input and consists of the title and the author. When you add a new book to the reading list, the method updates the reading status of the newly added book to `to_read`. This method returns the added book item upon successful execution.


**Sample request**

```
$ curl -X POST -H "Content-type: application/json" -d '{ "query": "mutation { addBook(book: {title: \"Sample Book\", author: \"Test Author\"}) { id title author status } }" }' 'http://localhost:8090'
```

**Sample response**

```
$ {
  "data": {
    "addBook": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "to_read"
    }
  }
}
```

**Update the reading status of a book**

This remote function requires `id` and `status` as inputs to update the reading status of the selected book. The `id` refers to the id of the book. It is an integer.  The `status` refers to the reading status that needs to be updated. This method returns the updated book item upon successful execution.

**Sample request**

```
$ curl -X POST -H "Content-type: application/json" -d '{ "query": "mutation { setStatus(id: 1, status: \"reading\") { id title author status } }" }' 'http://localhost:8090'
```

**Sample response**

```
$ {
  "data": {
    "setStatus": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "reading"
    }
  }
}
```

**Delete a book item from the reading list**

This remote function requires the `id` as the input to delete the book item from the reading list. This method returns the removed book item upon successful execution.

**Sample request**

```
$ curl -X POST -H "Content-type: application/json" -d '{ "query": "mutation { deleteBook(id: 1) { id title author status } }" }' 'http://localhost:8090'
```

**Sample response**
```
$ {
  "data": {
    "deleteBook": {
      "id": 1,
      "title": "Sample Book",
      "author": "Test Author",
      "status": "reading"
    }
  }
}
```

Our next step is to set up the resources that you will require to follow the guide, including the sample reading list application and the Choreo GitHub app.

## Prerequisites

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample GraphQL service](https://github.com/wso2/choreo-samples/tree/main/reading-list-graphql) implementation for this guide.

Let's get started!

## Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the reading list service.

!!! note
    The following file paths are relative to the path `<sample-repository-dir>/reading-list-graphql`.

|Filepath                 | Description                                                     |
|-------------------------|-----------------------------------------------------------------|
| `service.bal`           | The reading list service code written in the Ballerina language.|
| `Ballerina.toml`        | The Ballerina configuration file.                               |
| `.choreo/component.yaml`| The configuration file with endpoint details.                   |

## Step 1: Create a service component 

To create a Ballerina service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**| `reading-list-graphql`    |.

6. Select **Ballerina** as the buildpack.

7. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Ballerina Reading List`|
    | **Component Name**        | `ballerina-reading-list`|
    | **Description**           | Manage a reading list   |

8. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service component that exposes a GraphQL API written in the Ballerina language. Next, let's build and deploy the service.

## Step 2: Build and deploy

Now that we have connected the source repository, it's time to build and deploy the reading list service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Configurations** pane that opens, click **Next** to skip the configuration.
4. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.
To build and deploy the service, follow the steps below:

Once you have successfully deployed your service, you can test, manage, and observe it like any other component type in Choreo.

For detailed instructions, see the following sections:

- [Step 3: Test](https://wso2.com/choreo/docs/testing/test-graphql-endpoints-via-the-graphql-console/)
- [Step 4: Manage](https://wso2.com/choreo/docs/manage/api-management/)


# Expose a gRPC Endpoint via a Service

Choreo allows you to create and deploy applications in your preferred programming language. One powerful option is gRPC, a high-performance and language-agnostic remote procedure call (RPC) framework. It utilizes [Protocol Buffers](https://github.com/protocolbuffers/protobuf) to define services and generate client/server code.

In this guide, you will learn to use Choreo to create a service component that exposes a gRPC server implemented in [Go](https://go.dev/), enabling efficient and scalable communication with any gRPC client application. No prior knowledge of the Go language is necessary to follow this guide.

By following this guide, you will:

- Create a simple gRPC server using a Service component.
- Link the containerized gRPC service to the Choreo component using the Dockerfile. 
    The greeter service has a single RPC method named `sayHello`. Following is the proto file the server and the client application are using:

    ```proto
    syntax = "proto3";
    option go_package = "github.com/wso2/choreo-samples/go-grpc/pkg";

    service greeter {
      rpc SayHello (HelloRequest) returns (HelloReply) {}
    }

    message HelloRequest {
      string name = 1;
    }

    message HelloReply {
      string message = 1;
    }
    ```

- Deploy the gRPC server component in Choreo. 
- Create a gRPC client using a Manual Trigger component. 
- Deploy the gRPC client.
- Invoke the gRPC server using a gRPC client and check the response through the Choreo log view.


## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample service](https://github.com/wso2/choreo-samples/tree/main/go-grpc) implementation for this guide.

Let's get started!

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the greeter service.

!!! note 
    The following file paths are relative to the path `<sample-repository-dir>/go-grpc`.

|File Path                |Description                                                                                   |
|-------------------------|----------------------------------------------------------------------------------------------|
| `main.go`               | The greeter service code written in the Go language.                                         |
| `greeter_client/main.go`| The greeter client application written in the Go language.                                   |
| `Dockerfile.server`     | The Dockerfile to build the container image of the server application.                       |
| `Dockerfile.client`     | The Dockerfile to build the container image of the client application.                       |
| `.choreo/component.yaml`| The Choreo-specific configuration that provides information about how Choreo exposes the service.|
| `pkg/greeter.proto`     | The interface definition of the gRPC service. This is used to generate the server and client stubs for the Go application.|

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints.

Let's run the gRPC server service component on port 8080. To securely expose the service through Choreo, you must provide the port and other required information to Choreo. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

Choreo looks for an `component.yaml` file inside the `.choreo` directory to configure the endpoint details of the containerized component. Ensure the `.choreo` directory is at the root of the Docker build context path.

In the gRPC server sample, the `component.yaml` file is at `go-grpc/.choreo/component.yaml`, where the build context path is `go-grpc`.

## Step 1: Create a service component with a gRPC endpoint

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
6. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

7. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory** | `go-grpc`                  |

8. Select **Docker** as the buildpack.
9. Enter the following information:
    
    | **Field**                | **Value**                  |
    |--------------------------|----------------------------|
    | **Dockerfile**           | `go-grpc/Dockerfile.server`|

    !!! info
        1.  To successfully build your container with Choreo, it is essential to explicitly define a User ID (UID) under the USER instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-samples/blob/main/go-grpc/Dockerfile.server).
        To ensure that the defined USER instruction is valid, it must conform to the following conditions:
            - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
            - Usernames are considered invalid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

        2. The Dockerfile utilized in this guide is a multi-stage Dockerfile, which is designed to keep the final image size small and provides the ability to build the application with a specific version of tools and libraries.

4. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go gRPC Server`        |
    | **Component Name**        | `go-grpc-server`        |
    | **Description**           | Send greetings          |
    
10. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you have connected the source repository, and configured the endpoint details, it's time to build the service and create an image. Then you can deploy the image and test the greeter service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

    You can access the following scans under **Build**. 

      - **The Dockerfile scan**: Choreo performs a scan to check if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
      - **Container (Trivy) vulnerability scan**: This detects vulnerabilities in the final docker image. 
      - **Container (Trivy) vulnerability scan**: The details of the vulnerabilities open in a separate pane. If this scan detects critical vulnerabilities, the build will fail.
     
        !!! info
            If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Environment Configurations** pane that opens, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

6. Once you have successfully deployed your service, navigate to the component overview page and copy the gRPC service URL. You need to provide that URL when setting up the client application later in this guide.

You have successfully deployed the gRPC server. Currently, the gRPC service is only accessible by the components deployed within the same project.

## Step 3: Invoke the gRPC service

Let's invoke the gRPC service that you created above, using a gRPC client. 

### Step 3.1: Create a manual task for the gRPC client

To create a manual task component, follow these steps:

1. On the Choreo Console header, click the **Project** list and select the project where you created the gRPC service component. This opens the project home page.
2. Go to the **Component Listing** section and click **+ Create**.
3. Click the **Manual Task** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**       | `go/grpc`                  |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                  |
    |--------------------------|----------------------------|
    | **Dockerfile**           | `go/grpc/Dockerfile.client`|

8. Enter a display name, a unique name, and a description for the component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go gRPC Client`        |
    | **Component Name**        | `go-grpc-client`        |
    | **Description**           | `Receive greetings`     |


9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

### Step 3.2: Build the gRPC client component

To build the component, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 3.3: Setup environment variables and deploy the gRPC client

The client application, in this case, the gRPC client, requires the server URL of the gRPC server service. This is read from the client application as an environment variable. Follow the steps below to configure the environment variable for the client application:

1. On the Choreo Console left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane that opens, click **+ Add**.
4. Specify the following name and value to configure the environment variable for the client application:

    | **Field**       | **Value**               |
    |-----------------|-------------------------|
    | **Name**        | `GREETER_SERVICE`       |
    | **Value**       | Paste the URL value copied after deploying the gRPC service via [step 2.2](#step-22-deploy) above.  Make sure to **drop the `http://` or `grpc://` part and the trailing `/` from the URL when copying**. For example, if the URL is `http://go-grpc-server-3192360657:8080/`, add only `go-grpc-server-3192360657:8080`.|

5.  Click **Add** and then click **Next**.
6.  Click **Deploy**.

### Step 3.4: Execute the gRPC client component

To execute the gRPC client, follow these steps:

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the gRPC client and generates logs.
   You can trigger multiple runs to generate multiple logs.

For details on what you can monitor via the execute page, see [Monitor executions](../develop-integrations/develop-a-manual-task.md#step-7-monitor-executions). 


# Expose a Prism-Based Mock Server Using an OpenAPI Specification

Choreo supports deploying [Prism-based](https://docs.stoplight.io/docs/prism/674b27b261c3c-prism-overview) mock servers using OpenAPI specifications. With the Choreo Prism mock service component, you can serve multiple mock servers, each based on a different OpenAPI specification, as separate endpoints.

By default, these mock servers serve static content generated from the examples in the configured OpenAPI Specification (OAS). 

## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [Prism mock service](https://github.com/wso2/choreo-samples/tree/main/prism-mock-service) artifacts for this guide.

## Step 1: Create a Prism mock service component

To create a Prism mock service component, follow these steps:
    
1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, you can paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    |**Component Directory**  | `prism-mock-service`    |

6. Select **Prism Mock** as the buildpack.
7. Enter a display name, a unique name, and a description for the service component.
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

8. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

## Step 2: Build and deploy the component

Now that you have successfully created the Prism mock service, it's time to build and deploy it.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**. This builds the service from the latest commit.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

Once you have successfully deployed the service, you can [test](../../testing/test-rest-endpoints-via-the-openapi-console.md), [manage](../../api-management/lifecycle-management.md), and [observe](../../monitoring-and-insights/observability-overview.md) it like any other component type in Choreo.

## Serve dynamic content

The Prism mock service can serve dynamic content according to the schema definitions in the OpenAPI specification. To use the Prism mock service with dynamic content, clients must add the `prefer:dynamic=true` header in the request.

To generate meaningful dynamic responses, you can use the `x-faker` attribute in schema definitions of the OpenAPI specification. For more information on dynamically generated responses with the `x-faker` attribute, see the [Prism documentation](https://docs.stoplight.io/docs/prism/9528b5a8272c0-dynamic-response-generation-with-faker).


# Expose a TCP Server via a Service

Choreo offers the flexibility to design and deploy applications in the programming language of your choice. One viable choice for specific network communication needs is TCP (Transmission Control Protocol). TCP provides a reliable, stream-oriented communication mechanism that ensures data integrity and orderliness during transmission. It's the go-to option for scenarios where guaranteed data delivery and error recovery are paramount.

In this guide, you will learn to use Choreo to create a service component that exposes a TCP server implemented in [Go](https://go.dev/), enabling efficient and scalable communication with any TCP client application. No prior knowledge of the Go language is necessary to follow this guide.

By following this guide, you will:

- Setup a TCP server
    - Create a simple TCP server using a service component.
    - Link the containerized TCP service to the Choreo component using a Dockerfile. 
    - Deploy the TCP server component in Choreo. 
- Setup a TCP client
    - Create a TCP client using a manual task component. 
    - Link the containerized TCP client to the Choreo component using a Dockerfile. 
    - Deploy the TCP client component in Choreo.
- Invoke the TCP server using a TCP client and observe the response through the Choreo log view.

## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample service](https://github.com/wso2/choreo-samples/tree/main/docker-tcp-service) implementation for this guide.

Let's get started!

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the sample service.

!!! note 
    The following file paths are relative to the path `<sample-repository-dir>/docker-tcp-service`.

|File Path                 |Description                                                                                   |
|--------------------------|----------------------------------------------------------------------------------------------|
| `server/main.go`         | The greeter service code written in the Go language.                                         |
| `client/main.go`         | The greeter client application written in the Go language.                                   |
| `Dockerfile.server`      | The Dockerfile to build the container image of the server application.                       |
| `Dockerfile.client`      | The Dockerfile to build the container image of the client application.                       |
| `.choreo/component.yaml` | The Choreo-specific configuration provides information about how Choreo exposes the service. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints.

Let's run the TCP server service component on port 5050. To securely expose the service through Choreo, you must provide the port and other required information to Choreo. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

Choreo looks for an `component.yaml` file inside the `.choreo` directory to configure the endpoint details of a containerized component. Place the `.choreo` directory at the root of the Docker build context path.

In our TCP server sample, the `component.yaml` file is at `docker-tcp-service/.choreo/component.yaml`, where the build context path is `docker-tcp-service`.

## Step 1: Create a service component with a TCP endpoint

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory** | `docker-tcp-service`                  |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-tcp-service/Dockerfile.server`|

    !!! info
        1.  To successfully build your container with Choreo, it is essential to explicitly define a User ID (UID) under the USER instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-samples/blob/main/docker-tcp-service/Dockerfile.server).
        To ensure that the defined USER instruction is valid, it must conform to the following conditions:
            - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
            - Usernames are considered invalid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

        2. The Dockerfile utilized in this guide is a multi-stage Dockerfile, which is designed to keep the final image size small and provides the ability to build the application with a specific version of tools and libraries.

8. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go TCP Server`         |
    | **Component Name**        | `go-tcp-server`         |
    | **Description**           | Send greetings          |
    
9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you have connected the source repository, and configured the endpoint details, it's time to build the service and create an image. Then you can deploy the image and test the service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

    You can access the following scans under **Build**. 

      - **The Dockerfile scan**: Choreo performs a scan to check if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
      - **Container (Trivy) vulnerability scan**: This detects vulnerabilities in the final docker image. 
      - **Container (Trivy) vulnerability scan**: The details of the vulnerabilities open in a separate pane. If this scan detects critical vulnerabilities, the build will fail.
     
        !!! info
            If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Environment Configurations** pane that opens, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

6. Once you have successfully deployed your service, navigate to the component overview page and copy the TCP service address. You need to provide that address when setting up the client application later in this guide.

You have successfully deployed the TCP server. Currently, the TCP service is only accessible by the components deployed within the same project.

## Step 3: Invoke the TCP service

Now let's use a TCP client to invoke the TCP service that you created above. To do this, you can create a manual trigger component as the TCP client. This is the recommended approach because, in this example, it's more efficient to have a client that connects to the server, sends a request, and then stops. Here, a continuously executing task isn't required. Furthermore, if you use a manual trigger component, you won't need to expose an endpoint in the client for invocation, unlike with an API.

### Step 3.1: Create a manual trigger for the TCP client

To create a manual task component, follow these steps:

1. On the Choreo Console header, click the **Project** list and select the project where you created the TCP service component. This opens the project home page.
2. Go to the **Component Listing** section and click **+ Create**.
3. Click the **Manual Task** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Docker Context**      |`docker-tcp-service`     |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-tcp-service/Dockerfile.client`|

8. Enter a display name, a unique name, and a description for the component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**              |
    |---------------------------|------------------------|
    | **Component Display Name**| `Go TCP Client`        |
    | **Component Name**        | `go-tcp-client`        |
    | **Description**           | `Receive greetings`    |


9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

### Step 3.2: Build the TCP client component

To build the component, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 3.3: Setup environment variables and deploy the TCP client

The client application, in this case, the TCP client, requires the server URL of the TCP server service. This is read from the client application as an environment variable. Follow the steps below to configure the environment variable for the client application:

1. On the Choreo Console left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane that opens, click **+ Add**.
4. Specify the following name and value to configure the environment variable for the client application:

    | **Field**       | **Value**               |
    |-----------------|-------------------------|
    | **Name**        | `SERVER_ADDRESS`       |
    | **Value**       | Paste the URL value copied after deploying the TCP service via [step 2.2](#step-22-deploy) above.  Make sure to **drop the `tcp://` part and the trailing `/` from the URL when copying**. For example, add only `go-tcp-server-1097922445:8080`.|

5.  Click **Add** and then click **Next**.
6.  Click **Deploy**.

### Step 3.4: Execute the TCP client component

To execute the TCP client, follow these steps:

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the TCP client and generates logs.
   You can trigger multiple runs to generate multiple logs.

For details on what you can monitor via the execute page, see [Monitor executions](../develop-integrations/develop-a-manual-task.md#step-7-monitor-executions).


# Expose a UDP Server via a Service

Choreo offers the flexibility to design and deploy applications in the programming language of your choice. One compelling choice for certain network communication needs is UDP (User Datagram Protocol). UDP is a high-speed, connectionless protocol ideal for scenarios where lightweight, real-time data transmission is essential.

In this guide, you will learn to use Choreo to create a Service component that exposes a UDP server implemented in [Go](https://go.dev/), enabling efficient and scalable communication with any UDP client application. No prior knowledge of the Go language is necessary to follow this guide.

By following this guide, you will:

- Setup a UDP server
    - Create a simple UDP server using a Service component.
    - Link the containerized UDP service to the Choreo component using the Dockerfile. 
    - Deploy the UDP server component in Choreo. 
- Setup a UDP client
    - Create a UDP client using a manual task component. 
    - Link the containerized UDP client to the Choreo component using the Dockerfile. 
    - Deploy the UDP client component in Choreo.
- Invoke the UDP server using a UDP client and check the response through the Choreo log view.

## Prerequisites

Before you try out this guide, complete the following:

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample service](https://github.com/wso2/choreo-samples/tree/main/docker-udp-service) implementation for this guide.

Let's get started!

### Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the sample service.

!!! note 
    The following file paths are relative to the path `<sample-repository-dir>/docker-udp-service`.

|File Path                |Description                                                                                   |
|-------------------------|----------------------------------------------------------------------------------------------|
| `server/main.go`        | The greeter service code written in the Go language.                                         |
| `client/main.go`        | The greeter client application written in the Go language.                                   |
| `Dockerfile.server`     | The Dockerfile to build the container image of the server application.                       |
| `Dockerfile.client`     | The Dockerfile to build the container image of the client application.                       |
| `.choreo/component.yaml`| The Choreo-specific configuration provides information about how Choreo exposes the service. |

### Configure the service port with endpoints

In Choreo, you can expose your services via endpoints.

Let's run the UDP server service component on port 5050. To securely expose the service through Choreo, you must provide the port and other required information to Choreo. For detailed information on each attribute of an endpoint, see [Configure Endpoints](../configure-endpoints.md).

Choreo looks for an `component.yaml` file inside the `.choreo` directory to configure the endpoint details of a containerized component. Place the `.choreo` directory at the root of the Docker build context path.

In our gRPC server sample, the `component.yaml` file is at `docker-udp-service/.choreo/component.yaml`, where the build context path is `docker-udp-service`.

## Step 1: Create a service component with a UDP endpoint

To create a containerized service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
6. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

7. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**   | `docker-udp-service`    |    

8. Select **Docker** as the buildpack.
9. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-udp-service/Dockerfile.server`|

    !!! info
        1.  To successfully build your container with Choreo, it is essential to explicitly define a User ID (UID) under the USER instruction in your Dockerfile. For reference, see the [sample Dockerfile](https://github.com/wso2/choreo-samples/blob/main/docker-udp-service/Dockerfile.server).
        To ensure that the defined USER instruction is valid, it must conform to the following conditions:
            - A valid User ID is a numeric value between 10000-20000, such as `10001` or `10500`.
            - Usernames are considered invalid and should not be used. For example, `my-custom-user-12221` or `my-custom-user` are invalid User IDs.

        2. The Dockerfile utilized in this guide is a multi-stage Dockerfile, which is designed to keep the final image size small and provides the ability to build the application with a specific version of tools and libraries.

4. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `Go UDP Server`         |
    | **Component Name**        | `go-udp-server`         |
    | **Description**           | Send greetings          |

10. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service from a Dockerfile. Next, you can build and deploy the service.

## Step 2: Build and deploy

Now that you have connected the source repository, and configured the endpoint details, it's time to build the service and create an image. Then you can deploy the image and test the service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

    You can access the following scans under **Build**. 

      - **The Dockerfile scan**: Choreo performs a scan to check if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
      - **Container (Trivy) vulnerability scan**: This detects vulnerabilities in the final docker image. 
      - **Container (Trivy) vulnerability scan**: The details of the vulnerabilities open in a separate pane. If this scan detects critical vulnerabilities, the build will fail.
     
        !!! info
            If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure &  Deploy**.
3. In the **Environment Configurations** pane that opens, click **Next** to skip the configuration.
4. In the **File Mount** pane, click **Next** to skip the configuration.
5. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

6. Once you have successfully deployed your service, navigate to the component overview page and copy the UDP service address. You must provide that address when setting up the client application later in this guide.

You have successfully deployed the UDP server. Currently, the UDP service is only accessible by the components deployed within the same project.

## Step 3: Invoke the UDP service

Now let's use a UDP client to invoke the UDP service that you created above. To do this, you can create a manual trigger component as the UDP client. This is the recommended approach because, in this example, it's more efficient to have a client that connects to the server, sends a request, and then stops. Here, a continuously executing task isn't required. Furthermore, if you use a manual trigger component, you won't need to expose an endpoint in the client for invocation, unlike with an API.

### Step 3.1: Create a manual trigger for the UDP client

To create a manual task component, follow these steps:

1. On the Choreo Console header, click the **Project** list and select the project where you created the UDP service component. This opens the project home page.
2. Go to the **Component Listing** section and click **+ Create**.
3. Click the **Manual Task** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory** | `docker-udp-service`    |

6. Select **Docker** as the buildpack.
7. Enter the following information:
    
    | **Field**                | **Value**                             |
    |--------------------------|---------------------------------------|
    | **Dockerfile**           | `docker-udp-service/Dockerfile.client`|

8. Enter a display name, a unique name, and a description for the component. You can enter the values given below:
    
    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**              |
    |---------------------------|------------------------|
    | **Component Display Name**| `Go UDP Client`        |
    | **Component Name**        | `go-udp-client`        |
    | **Description**           | `Receive greetings`    |


9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

### Step 3.2: Build the UDP client component

To build the component, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 3.3: Setup environment variables and deploy the UDP client

The client application, in this case, the UDP client, requires the server URL of the UDP server service. This is read from the client application as an environment variable. Follow the steps below to configure the environment variable for the client application:

1. On the Choreo Console left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure & Deploy**.
3. In the **Environment Configurations** pane that opens, click **+ Add**.
4. Specify the following name and value to configure the environment variable for the client application:

    | **Field**       | **Value**               |
    |-----------------|-------------------------|
    | **Name**        | `SERVER_ADDRESS`       |
    | **Value**       | Paste the URL value copied after deploying the UDP service via [step 2.2](#step-22-deploy) above.  Make sure to **drop the `udp://` part and the trailing `/` from the URL when copying**. For example, add only `go-udp-server-1097922445:8080`.|

5.  Click **Add** and then click **Next**.
6.  Click **Deploy**.

### Step 3.4: Execute the UDP client component

To execute the UDP client, follow these steps:

1. In the left navigation menu, click **Execute**.
2. Click **Run Now**. This triggers the UDP client and generates logs.
   You can trigger multiple runs to generate multiple logs.

For details on what you can monitor via the execute page, see [Monitor executions](../develop-integrations/develop-a-manual-task.md#step-7-monitor-executions).


# Expose a WebSocket Endpoint via a Service

Choreo allows you to create and deploy applications in your preferred programming language, offering a seamless platform for building dynamic and scalable solutions. This guide walks you through the steps to deploy a WebSocket service using the NodeJS buildpack.

WebSockets provide real-time, two-way communication between a client and server over a persistent TCP connection. This makes WebSocket APIs ideal for applications that require real-time updates.

In this guide, you will:

- Build a simple WebSocket service using a sample implementation in NodeJS.
- Deploy the service in Choreo, allowing any WebSocket client application to establish a connection and exchange real-time messages with your service.

## Prerequisites

- If you are signing in to the Choreo Console for the first time, create an organization as follows:

    1. Go to [https://console.choreo.dev/](https://console.choreo.dev/), and sign in using your preferred method.
    2. Enter a unique organization name. For example, `Stark Industries`.
    3. Read and accept the privacy policy and terms of use.
    4. Click **Create**.

    This creates the organization and opens the **Project Home** page of the default project created for you.

- Fork the [Choreo samples repository](https://github.com/wso2/choreo-samples/), which contains the [sample WebSocket service](https://github.com/wso2/choreo-samples/tree/main/websocket-chat-app) implementation for this guide.

Let's get started!

## Learn the repository file structure

It is important to understand the purpose of the key files in the sample service. The following table provides a brief overview of each file in the NodeJS chat Application.

!!! note
    The following file paths are relative to the path `<sample-repository-dir>/websocket-chat-app/websocket-chat-service-nodejs`.

|Filepath                        | Description                                                     |
|--------------------------------|-----------------------------------------------------------------|
| `server.js`                    | The NodeJS chat service.                                        |
| `.choreo/component.yaml`       | The configuration file with endpoint details.                   |

!!! note
    Choreo currently supports defining WebSocket APIs using the AsyncAPI 2.0 specification.

## Step 1: Create a service component 

To create a NodeJS service component, follow these steps:

1. Go to [https://console.choreo.dev/](https://console.choreo.dev/) and sign in. This opens the project home page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Service** card.
4. To allow Choreo to connect to your GitHub account, click **Authorize with GitHub**. If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials and select the repository you created in the prerequisites section to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field to connect to it without requiring authorization from the [Choreo Apps](https://github.com/marketplace/choreo-apps) GitHub application. However, authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps) is necessary if you want to enable [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) for the component.

    !!! note
           The **Choreo GitHub App** requires the following permissions:

           - Read and write access to code and pull requests.
           - Read access to issues and metadata.
             
           You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) if you do not want Choreo to have access to your GitHub account. However, write access is exclusively utilized for sending pull requests to a user repository. Choreo will not directly push any changes to a repository.

5. Under **Connect a Git Repository**, enter the following information:

    | **Field**               | **Value**               |
    |-------------------------|-------------------------|
    | **Organization**        | Your GitHub account     |
    | **GitHub Repository**   | **`choreo-samples`**    |
    | **Branch**              | **`main`**              |
    | **Component Directory**   | `websocket-chat-app/websocket-chat-service-nodejs`  |

6. Select **NodeJS** as the buildpack and **18.x.x** as the Language Version

8. Enter a display name, a unique name, and a description for the service component. You can enter the values given below:

    !!! info
         In the **Component Name** field, you must specify a name to uniquely identify the component in various contexts. The value is editable only at the time you create the component. You cannot change the name after you create the component.

    | **Field**                 | **Value**               |
    |---------------------------|-------------------------|
    | **Component Display Name**| `NodeJS Chat Service`   |
    | **Component Name**        | `nodejs-chat-service`   |
    | **Description**           | Manage a chat service   |

9. Click **Create**. This creates the component and takes you to the **Overview** page of the component.

You have successfully created a service component that provides a WebSocket API built with NodeJS. The next step is to proceed with building and deploying the service.

## Step 2: Build and deploy

Now that you have connected the source repository, it's time to build and deploy the chat service.

### Step 2.1: Build

To build the service, follow these steps:

1. In the left navigation menu, click **Build**.
2. On the **Build** page, click **Build Latest**.

    !!! note
        Building the service component may take a while. You can track the progress via the logs in the **Build Details** pane. Once the build process is complete, the build status changes to **Success**.

### Step 2.2: Deploy

To deploy the service, follow these steps: 

1. In the left navigation menu, click **Deploy**.
2. On the **Set Up** card, click **Configure & Deploy**.
3. In the **Configurations** pane that opens, click **Next** to skip the configuration.
4. Review the **Endpoint Details** and click **Deploy**.

    !!! note
        Deploying the service component may take a while. Once deployed, the **Development** environment card indicates the **Deployment Status** as **Active**.

Once you have successfully deployed your service, you can [test](../../testing/test-websocket-endpoints-via-the-websocket-console.md), [manage](../../api-management/lifecycle-management.md), and observe it like any other component type in Choreo.

During testing, once the WebSocket connection is established, you can send {"type": "Connect", "username": "user1"} to the WebSocket endpoint to connect to the chat service. You can then send chat messages by using {"type": "Data", "message": "Hello, World!"}.

!!! note
     Some clients, such as certain browsers, may not support adding headers to the WebSocket handshake. In these cases, you can include the access token or test key required for WebSocket API invocation within the `sec-websocket-protocol` header, along with any specified subprotocols.

     For example: `sec-websocket-protocol: choreo-oauth2-token, {access token}, subprotocols`

     If you are using a test key, replace `choreo-oauth2-token` with `choreo-test-key`.


# Service Component Overview

Explore how to create, deploy, manage, and observe service components in Choreo.

## What is a service component?

A service component in Choreo lets you deploy and expose REST, GraphQL, gRPC, UDP, WS or TCP services. It is a fundamental building block for creating cloud-native applications in Choreo. They provide a simple and effective way to expose functionality as a service to other components within Choreo or to the outside world.

Service components encapsulate business logic and provide standardized interfaces, called endpoints, for communicating with other components or systems. You can deploy and scale services independently, which makes them highly flexible and adaptable to changing workloads.

With the help of the service component, developers can quickly create APIs and microservices, making it easier to implement and manage complex software systems. Service components can also be integrated with other Choreo components, that acts as message processors, connectors, and data sources, etc to create powerful end-to-end solutions.

You can expose a service to other components through endpoints. For details on configuring endpoints, see [Configure Endpoints](../configure-endpoints.md).


# Build and Deploy a Single-Page Web Application

A web application is an application program hosted on a server and serves ingress traffic through a browser. In Choreo, you can deploy a web application by creating a Web Application component and connecting it to a Git repository that contains the implementation of the web application. Web applications can fall into one of the following categories:

- **Single page applications (SPAs)**: Examples include React, Angular, Vue, Svelte, etc.
- **Web servers**: These serve static content or provide server-side rendering/static site generation (SSR/SSG).
- **Static content**: Examples include websites and other static resources that do not require a backend, usually comprising static HTML/JS/CSS files.

## Prerequisites

- To deploy a web application component, you must have a GitHub account with a repository containing the web application's implementation. For this guide, fork the [Choreo samples repository](https://github.com/wso2/choreo-samples), which contains the sample web application implementation.

## Create a web application

You can create a web application in Choreo as follows:

### Build and deploy a SPA from source code

1. To create a web application component, connect a repository that includes the web application source code.
2. Select the relevant buildpack: Default buildpacks include **React**, **Angular**, and **Vue.js**. If you are using a different SPA framework, you can try one of these buildpacks because the configurations can be overridden to support most JavaScript-based SPAs.
3. Enter the build command: Based on your package manager (NPM, yarn, or pnpm). The relevant package manager is run based on the dependency lock file in your repository (defaults to NPM if no lock file is present).
4. Specify the build output directory.
5. Specify the NodeJS version: Choreo does not pick the Node.js version from the `package.json` engine property. The required Node version must be explicitly set in the build configuration.

Once you create the Web Application component, Choreo automatically generates a build pipeline for your single-page application and deploys it.

### Bring your Dockerfile

1. To create a web application component, connect a repository that contains the Dockerfile for your containerized web application.
2. Commit a Dockerfile to your connected Git repository to have full control over your build process.

This approach is recommended if you are deploying a web server and not just a single-page application (or a single-page application with a complex build process).

### Host static websites

1. Create a web application component and connect it to the GitHub repository that contains the required static assets.
2. Select the **Static Websites** buildpack: This buildpack does not trigger a build process. It only fetches the files from the path specified in the repository and serves them as-is.

## Build and deploy a SPA from source code

Follow the steps below to create a sample Web Application component and deploy it in Choreo:

1. Sign in to the Choreo Console at [https://console.choreo.dev/login/](https://console.choreo.dev/login/). This opens the **Project Home** page.
2. If you already have one or more components in your project, click **+ Create**. Otherwise, proceed to the next step.
3. Click the **Web Application** card.
6. Click **Authorize with GitHub** to connect Choreo to your GitHub account. If you haven't connected your GitHub repository to Choreo, enter your credentials and select the repository you forked earlier to install the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    Alternatively, select the **Use Public GitHub Repository** option and paste the [Choreo samples repository](https://github.com/wso2/choreo-samples) URL in the **Provide Repository URL** field. However, enabling [**Auto Deploy**](https://wso2.com/choreo/docs/choreo-concepts/ci-cd/#deploy) requires authorizing the repository with the [Choreo GitHub App](https://github.com/marketplace/choreo-apps).

    !!! note
        The **Choreo GitHub App** requires:
        - Read and write access to code and pull requests.
        - Read access to issues and metadata.

        You can [revoke access](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/reviewing-your-authorized-integrations#reviewing-your-authorized-github-apps) at any time. Write access is only used for sending pull requests; Choreo will not push changes directly to your repository.

7. Enter the following information:

    | **Field**                 | **Description**        |
    |---------------------------|------------------------|
    | **GitHub Account**        | Your account           |
    | **GitHub Repository**     | choreo-samples         |
    | **Branch**                | main                   |
    | **Component Directory**     | /react-single-page-app |

8. Select **React** as the **Buildpack**.
9. Enter the following information:

    | **Field**                 | **Description**        |
    |---------------------------|------------------------|
    | **Build Command**         | `npm run build`        |
    | **Build Path**            | `build`                |
    | **Node Version**          | `18`                   |

    !!! tip
        Managed authentication is enabled by default when you create a web application using **React**, **Angular**, or **Vue.js** buildpacks. To learn how to set up authentication for your web application with Choreo's managed authentication, see [Secure Web Applications with Managed Authentication](../../authentication-and-authorization/secure-web-applications-with-managed-authentication.md).

4. Specify a display name, a unique name and description for the component.
10. Click **Create**. Choreo initializes the component with the sample implementation and opens the **Overview** page of the component.

You have successfully created a Web Application component from the source code. Now let's build and deploy the web application.

## Build your web application

1. In the left navigation menu, click **Build**.
2. In the **Builds** pane, click **Build**. This opens the **Commits** pane, where you can see all the commits related to the component.
3. Select the latest commit and click **Build**. This triggers the build process and displays the progress in the **Build Logs** pane.

    You can access the following scans in the **Build Logs** pane:

    - **Dockerfile Scan**: Choreo checks if a non-root user ID is assigned to the Docker container to ensure security. If no non-root user is specified, the build will fail.
    - **Container (Trivy) Vulnerability Scan**: Detects vulnerabilities in the final Docker image. If critical vulnerabilities are detected, the build will fail.

    !!! info
        If you have Choreo environments on a private data plane, you can ignore these vulnerabilities and proceed with the deployment.

    !!! note
        The build process may take some time. Once complete, the build status will be listed in the **Builds** pane. Here, you will see the build status as **Success**.

## Deploy and access your web application

1. In the left navigation menu, click **Deploy**.
2. In the **Set Up** card, click **Configure and Deploy**. This opens the **Configure & Deploy** pane. In this guide, you do not need to add a file mount.
3. Click **Next** to proceed to the **Authentication Settings** pane.
4. Keep the default settings and click **Deploy**.

    !!! note
        The deployment process may take a few minutes. Once complete, the **Deployment Status** will show as **Active** in the **Development** card.

5. To verify that the web application is hosted successfully, click the **Web App URL** in the **Development** card. This takes you to the web application.

## Create a short URL for your web application in production

!!! info
    This feature is only available on the Choreo cloud data plane.

When you promote your component to the Production environment, you can create a personalized short URL for your web application. The URL follows the `https://{your-short-prefix}.choreoapps.dev` structure, where you can select a name of your preference for `{your-short-prefix}`.

1. Click **Promote** in the **Development** card and promote your web application to production.
2. In the **Production** card, click **Create a short URL**.
3. Specify a **Short URL prefix** of your choice and click **Save**.

    !!! note
        Short URL names/prefixes are subject to availability, provided on a first-come-first-serve basis.

## Manage runtime configurations for web applications

For web applications with a backend server, Choreo allows you to mount runtime configurations and secrets as environment variables and/or file mounts for a specific environment. Alternatively, you can also inject them into the client application during server-side rendering or when serving static content.

For SPAs that run completely on the browser, Choreo does not support *baking-in* environment variables or other configurations. Instead, Choreo recommends the following approach (applicable to most SPA frameworks, including React):

!!! note
    - With SPAs, anything you mount as a runtime config will be available to your users in the browser.
    - **Do not include sensitive secrets that are not browser-safe**.

1. Go to your forked [Choreo samples repository](https://github.com/wso2/choreo-samples).
2. Open the `public` directory.
3. Create and commit a new file named `config.js` in the `public` directory of your React application. This file should contain the runtime configuration variables you want to expose to your application, such as API endpoints or feature flags. For example:

    ```javascript
    window.config = {
        apiUrl: 'https://api.example.com',
        featureFlags: {
            enableNewFeature: true,
            enableExperimentalFeature: false,
        },
    };
    ```

4. In your `index.html` file inside the `public` directory, add a script tag to include the `config.js` file inside the `<body>` tag:

    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>My React App</title>
    </head>
    <body>
        <div id="root"></div>
        <script src="%PUBLIC_URL%/config.js"></script>
    </body>
    </html>
    ```

5. In your React component, access the configuration variables by referencing the `window.config` object:

    ```javascript
    import React from 'react';

    function MyComponent() {
        const apiUrl = window.config.apiUrl;
        const enableNewFeature = window.config.featureFlags.enableNewFeature;
        const enableExperimentalFeature = window.config.featureFlags.enableExperimentalFeature;

        // ...
    }
    ```

6. When you deploy your component to Choreo, create a config file mount in the specified path for each environment (where your `index.html` expects the `config.js` file). For more details, see [Manage Configurations and Secrets](https://wso2.com/choreo/docs/devops-and-ci-cd/manage-configurations-and-secrets/#apply-a-file-mount-to-your-container).

## Limitations

The following limitations are specific to the Choreo cloud data plane:

- **Request size limit**: 256KB (including headers, cookies, and payloads).
- **Response body size limit**: 20MB.
- **Open ports**: Only one open port is permitted per web application. While you can have multiple ports open for project-level communication within a data plane, incoming traffic from the internet can only be directed to one port. This differs from Service-type components, which support multiple endpoints.

## Troubleshoot a web application

- **Blank page or 502 error after deployment**:
    If you encounter a blank page or a 502 error after deploying your web application, it typically indicates that the wrong directory is being served. To resolve this issue:
    1. Double-check the build output directory, especially if you are using a Dockerfile-less buildpack.
    2. Ensure that the specified output directory matches the actual output directory generated during the build process. For example, if you have erroneously entered `public/` as the output directory when it should have been `build/`.

By verifying and correcting the output directory alignment, you should be able to address the issue of encountering a blank page or experiencing a 502 error on deploying your web application.


# Develop Web Applications Locally with Choreo’s Managed Authentication

Choreo’s managed authentication capability provides a set of backend for frontend (BFF) endpoints to facilitate authentication and authorization for web applications. These endpoints are readily available for single-page web applications deployed on Choreo.

As a web application developer, you may need to run the application on your local workstation. Choreo’s local development capability ensures that authentication and authorization during local development work the same way as they do when the application is deployed to Choreo, eliminating the need for code changes.

This guide explains how to configure and use Choreo’s local development capability to streamline your workflow.

## How local development works in Choreo

Local development uses a proxy that sits in front of the locally running web application. This proxy intercepts all incoming requests:
- Requests to `/choreo-apis/*` and `/auth/*` are forwarded to Choreo.
- All other requests are forwarded to the locally running web application.

The proxy runs on HTTPS using a self-signed certificate, which is essential for secure, HTTP-only cookie-based managed authentication. Once the proxy is running, you can access the web application using the proxy's URL and start developing locally. The behavior of the web application, in terms of managed authentication, will mirror its behavior when deployed to Choreo.

## Configure local development

### Prerequisites

- Create a single-page application (SPA) with managed authentication enabled. For details, see [Secure Web Applications with Managed Authentication](../../authentication-and-authorization/secure-web-applications-with-managed-authentication.md#step-1-set-up-managed-authentication-for-your-web-application).
- Promote and deploy the application to the environment where you want to enable local development.

    !!! note
        - The locally running web application will use the same managed authentication configuration as the environment where local development is configured.
        - Local development is only allowed in non-critical environments.

### Apply configurations

1. Sign in to the Choreo Console.
2. In the **Component Listing** pane, click on the component you created and deployed.
3. In the left navigation menu, click **Deploy**.
4. Go to the respective environment card and click **Local Development**.
5. In the **Local Development** pane, toggle **Local Development** to enable it.
6. (Optional) To update the port on which the local development proxy server runs, expand **Advanced Configurations** and specify a value for **Proxy Port**.
7. Click **Apply**.

You have now configured local development. The next section explains how to access your web application for local development.

## Access your web application locally

### Prerequisites

- Ensure local development is enabled in the desired environment.
- Ensure your web application is running locally on `http://localhost` on a specific port.

### Access your web application locally

You can use either the Choreo built-in identity provider or an external identity provider to access your web application locally.

=== "Use the Choreo built-in identity provider"

    1. Sign in to the Choreo Console.
    2. In the **Component Listing** pane, click on the component you created and deployed.
    3. In the left navigation menu, click **Deploy**.
    4. Go to the respective environment card and click **Local Development**.
    5. In the **Local Development** pane, copy the command under **Step 1**.
    6. Paste the command in a terminal, replace `[APP_PORT]` with the port on which your application is running locally, and run the command.
    7. To access the application, go to the URL provided under **Step 2** in the **Local Development** pane.

        !!! note
            The local development proxy runs on HTTPS using a self-signed certificate. Your browser may warn that the certificate is not valid. Accept the risk and proceed.

=== "Use an external identity provider"

    1. Sign in to the Choreo Console.
    2. In the **Component Listing** pane, click on the component you created and deployed.
    3. In the left navigation menu, click **Deploy**.
    4. Go to the respective environment card and click **Local Development**.
    5. In the **Local Development** pane, copy the redirect URLs under **Step 1**.
    6. Go to the settings in the OAuth application in your identity provider and specify the copied URLs as allowed redirect URLs.
    7. In the **Local Development** pane, copy the command under **Step 2**.
    8. Paste the command in a terminal, replace `[APP_PORT]` with the port on which your application is running locally, and run the command.
    9. To access the application, go to the URL provided under **Step 3** in the **Local Development** pane.

        !!! note
            The local development proxy runs on HTTPS using a self-signed certificate. Your browser may warn that the certificate is not valid. Accept the risk and proceed.


# Create a Connection

Connections in Choreo provide a simple and uniform approach to seamlessly integrate components with services or resources.

Choreo allows you to create connections to services deployed in Choreo or registered as external services. It also allows you to create connections to any Choreo-managed database.

To create a connection to a service or a database, follow the step-by-step instructions in the respective tab:

=== "Create a connection to a service"

    <h2>Create a connection to a Choreo service</h2>

    Follow these steps to create a connection to a service deployed in Choreo:

    1. In the Choreo Console, go to the top navigation menu and set the visibility level as [project](../../choreo-concepts/connections.md#project-connections) or [component](../../choreo-concepts/connections.md#component-connections) as follows: 

        - **Project Connection**: Select an organization and a project in that organization. 
        - **Component Connection**: Select an organization, a project in that organization, and a component in the selected project. 

    2. In the left navigation menu, click **Dependencies**  and then **Connections**. This page lists all the existing connections.
    3. Click **+Create**. This opens the Marketplace view where you can browse and search for services or databases.
    4. Click the **Services** tab. You can search and apply filters to efficiently find a service.
    5. Click on the service you want to connect to. 
    6. Enter a name and a description for the connection.
    7. Select an **Access Mode** and **Authentication Scheme** for the connection.
    8. Click **Create**.
   
    This creates the connection and displays its details for each environment, along with an inline guide on how to use the connection in your component. 

    !!! note
        During connection creation, secret values for the lowest environment are visible, allowing you to copy them for local use if necessary. Secret values for higher environments remain hidden to ensure security
     
    <h2>Create a connection to an external service</h2>

    Follow these steps to create a connection to an external service:

    1. Follow steps 1–5 from the previous section.
    2. Expand the **Environment to Endpoint** section and verify the service endpoints assigned to the Choreo environments.
    3. Click **Create**.

      For step-by-step instructions on using a connection in your service, see [Use a Connection in Your Service](./use-a-connection-in-your-service.md).

      For step-by-step instructions on using a connection in your web application, see [Use a Connection in Your Web Application](./use-a-connection-in-your-web-application.md).


=== "Create a connection to a database"

    Prerequisites:

     - Create a Choreo-managed database. For details, see [Choreo-Managed Databases and Caches](../../manage-databases-and-caches/choreo-managed-databases-and-caches.md).
     - Add the database to the Marketplace. For details, see [Add Choreo-Managed Databases and Caches to the Marketplace](../../manage-databases-and-caches/add-choreo-managed-databases-and-caches-to-the-marketplace.md).

    Follow these steps to create a connection to a Choreo-managed database:

    1. In the Choreo Console, go to the top navigation menu and set the visibility level as [project](../../choreo-concepts/connections.md#project-connections) or [component](../../choreo-concepts/connections.md#component-connections) as follows: 

        - **Project Connection**: Select an organization and a project in that organization. 
        - **Component Connection**: Select an organization, a project in that organization, and a component in the selected project. 

    2. In the left navigation menu, click **Dependencies**  and then **Connections**. This page lists all the existing connections.
    3. Click **+Create**. This opens the Marketplace view where you can browse and search for services or databases.
    4. Click the **Databases** tab. You can search and apply filters to efficiently find a database.
    5. Click on the database you want to connect to. 
    6. To create the connection, follow these steps:

        1. Enter a name and description.
        2. Under **Environment Configuration**, select credentials for each environment.

            !!! note
                 By default, the selected database is applied to all environments. To use different databases for specific environments, select the appropriate database and provide the corresponding credentials for each environment.

        3. Click **Create**.  
    
    This creates the connection and displays the database connection details for each environment, along with an inline guide on how to use the connection in your component. 

    !!! note
        During connection creation, secret values for the lowest environment are visible, allowing you to copy them for local use if necessary. Secret values for higher environments remain hidden to ensure security
    
    For step-by-step instructions on using a database in your component, see [Use a Database Connection in Your Component](./use-a-database-connection-in-your-component.md).


# Use a Connection in Your Service

Choreo allows you to share and reuse your services, accelerating development and enhancing efficiency in building integrated applications through connections.

For step-by-step on instruction on creating a connection, see [Create a Connection](create-a-connection.md).

To learn more about Choreo Connections, see the documentation on [Connections](../../choreo-concepts/connections.md).

## Consume a service through a connection

You can consume a Choreo-deployed service within another service. Consuming connections from within Choreo services is seamless and straightforward. Follow the steps below to consume a Choreo service:

### Step 1: Add connection configurations

To integrate another service into your application, click the appropriate tab below based on your current configuration file and follow the step-by-step instructions:

=== "Component.yaml file (v1.1)"

    1. Copy and paste the snippet from the in-line developer guide into the `component.yaml` file.

        The following is a sample snippet: 

        ``` yaml

        dependencies:
            connectionReferences:
            - name: <CONNECTION_NAME>
              resourceRef: <RESOURCE_IDENTIFIER>

        ```

          | Field            | Description                                                         |
          |------------------|---------------------------------------------------------------------|
          | name             | The name given to the connection.                                   |
          | resourceRef      | A unique, readable identifier of the service being connected to.    |


    2. If you've previously added a `connectionReferences` section under `dependencies`, append this as another item under `connectionReferences`. Upon deploying the component, Choreo automatically creates a subscription if applicable and the necessary configurations to establish the connection will be injected into the Choreo-defined environment variables.
      
          The following table details the Choreo-defined environment variables:

          | Configuration Key       | Choreo-Defined Environment Variable Name                       |
          |-------------------------|----------------------------------------------------------------|
          | ServiceURL              | CHOREO_<CONNECTION_NAME\>_SERVICEURL                           |
          | ConsumerKey             | CHOREO_<CONNECTION_NAME\>_CONSUMERKEY                          |
          | ConsumerSecret          | CHOREO_<CONNECTION_NAME\>_CONSUMERSECRET                       |
          | TokenURL                | CHOREO_<CONNECTION_NAME\>_TOKENURL                             |
          | ChoreoAPIKey            | CHOREO_<CONNECTION_NAME\>CHOREOAPIKEY                          |


          If you want to use custom environment variable names instead of the Choreo-defined ones, you must define the environment configurations under the `configuration` section in the same file.
          The following is a sample snippet: 

          ``` yaml
          configuration:
            env:
              - name: HR_SERVICE_URL
                valueFrom:
                  connectionRef:
                    name: hr-connection
                    key: ServiceURL
          ```

          The following table provides details on the configuration keys associated with the connection. These keys can be referenced as `env[i].valueFrom.connectionRef.key`.

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | ServiceURL     | string     | Service URL of the Choreo service     | false         | false        |
          | ConsumerKey    | string     | Consumer key of the Choreo service    | false         | false        |
          | ConsumerSecret | string     | Consumer secret of the Choreo service | false         | true         |
          | TokenURL       | string     | Token URL of the STS                  | false         | false        |
          | ChoreoAPIKey   | string     | API key of the Choreo service         | false         | true         |

          For more details, see the instructions under the **component.yaml file (v1.1)** tab.

    ### Step 2: Read configurations within the application

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const serviceURL = process.env.CHOREO_<CONNECTION_NAME>_SERVICEURL;
    ```

=== "Component.yaml file (v1.0)"

    !!! note
        This `component.yaml v1.0` is a legacy configuration format. For new projects, we recommend using the latest version (v1.1) of `component.yaml` for improved usability and features.
  
    1. Copy and paste the snippet from the in-line developer guide into the `component.yaml` file.
      
        The following is a sample snippet:

        ``` yaml

        dependencies:
            serviceReferences:
            - name: <SERVICE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: ServiceURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerSecret
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: TokenURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ChoreoAPIKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>

        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the service you are connecting to.              |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added a service reference section under `dependencies`, append this as another item under `serviceReferences`. 

          Upon deploying the component, Choreo automatically creates a subscription if applicable and populates the specified environment variables with actual values.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | ServiceURL     | string     | Service URL of the Choreo service     | false         | false        |
          | ConsumerKey    | string     | Consumer key of the Choreo service    | false         | false        |
          | ConsumerSecret | string     | Consumer secret of the Choreo service | false         | true         |
          | TokenURL       | string     | Token URL of the STS                  | false         | false        |
          | ChoreoAPIKey   | string     | API key of the Choreo service         | false         | true         |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const serviceURL = process.env.SVC_URL;
    ```

=== "Component-config.yaml file"

    !!! note
        This `component-config.yaml` is a legacy configuration format. For new projects, we recommend using the latest version (v1.1) of `component.yaml` for improved usability and features.

    1. Copy and paste the snippet from the in-line developer guide into the `component-config` file under the `spec` section.

        The following is a sample snippet:

        ``` yaml

        outbound:
            serviceReferences:
            - name: <SERVICE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: ServiceURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ConsumerSecret
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: TokenURL
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: ChoreoAPIKey
                to: <YOUR_ENV_VARIABLE_NAME_HERE>

        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the service you are connecting to.              |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added an outbound service reference, append this as another item under `serviceReferences`. 

          Upon deploying the component, Choreo automatically creates a subscription if applicable and populates the specified environment variables with actual values.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | ServiceURL     | string     | Service URL of the Choreo service     | false         | false        |
          | ConsumerKey    | string     | Consumer key of the Choreo service    | false         | false        |
          | ConsumerSecret | string     | Consumer secret of the Choreo service | false         | true         |
          | TokenURL       | string     | Token URL of the STS                  | false         | false        |
          | ChoreoAPIKey   | string     | API key of the Choreo service         | false         | true         |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const serviceURL = process.env.SVC_URL;
    ```

If you're using the API key security scheme for the connection, skip Step 3 and follow the instructions in [Step 4: API key security scheme](#step-4-invoke-the-service) tab.

### Step 3: Acquire an OAuth 2.0 access token

To consume a Choreo service with the visibility level set to organization or public and secured by the OAuth 2.0 security scheme, you must obtain an OAuth 2.0 token from the token endpoint. Subsequently, you can use the token to invoke the service.

- For languages with OAuth 2.0-aware HTTP clients, you must pass the OAuth 2.0-related configurations such as client id, client secret and so on, obtained when creating the connection to your HTTP client configuration. The HTTP client autonomously manages token retrieval and refreshing.

- For languages without OAuth 2.0-aware HTTP clients, you must manually initiate a call to the token endpoint. This includes fetching the token and managing token expiration and refresh directly within your application code. The following is a sample curl command to obtain a token:


    ```bash
    CONSUMER_KEY="your_consumer_key"
    CONSUMER_SECRET="your_consumer_secret"
    TOKEN_URL="your_token_url"

    # Encode client credentials as Base64
    CLIENT_CREDENTIALS=$(echo -n "$CLIENT_ID:$CLIENT_SECRET" | base64)

    curl -X POST $TOKEN_URL \
      -H "Content-Type: application/x-www-form-urlencoded" \
      -H "Authorization: Basic $CLIENT_CREDENTIALS" \
      --data-urlencode "grant_type=client_credentials"

    ```

### Step 4: Invoke the service

Click the tab that matches the security scheme of your service and follow the instructions below:

=== "API key security scheme"

     To invoke the API, use the `choreo-api-key` header with the API key value retrieved from the corresponding environment variable as described in [step 2](#step-2-read-configurations-within-the-application).

     The following is a sample code snippet in NodeJS:

     ``` java
       const response = await axios.get(serviceURL/{RESOURCE_PATH}, {
           headers: {
             'Choreo-API-Key': `${choreoApiKey}`
           }
       });
     ```

=== "OAuth 2.0 security scheme"

     To invoke the service, use the following instructions based on your programming language:

      - For languages with OAuth 2.0-aware HTTP clients, use the service URL resolved in [Step 2](#step-2-read-configurations-within-the-application). The OAuth-aware client manages authentication automatically. For sample requests and responses, see the API definition provided via the Choreo marketplace for the service.

      - For languages without OAuth 2.0-aware HTTP clients, use the token obtained in [step 3](#step-3-acquire-an-oauth-20-access-token) to make calls to the dependent service. Subsequently, add the obtained token to the HTTP authorization header with the bearer prefix. As the service URL, use the URL resolved in [step 2](#step-2-read-configurations-within-the-application). For sample requests and responses, see the API definition of the service provided via the Choreo marketplace.

       The following is a sample code snippet in NodeJS:

       ``` java
       const response = await axios.get(serviceURL/{RESOURCE_PATH}, {
           headers: {
             'Authorization': `Bearer ${accessToken}`
             'Choreo-API-Key': `${choreoApiKey}`
           }
       });
       ```

    !!! note
        If you want to consume a Choreo service at the project visibility level, you don't need to obtain a token. You can directly invoke the service using the resolved URL.


# Use a Connection in Your Web Application

Choreo simplifies the process of integrating services into your web application. The approach to connect to a service can vary based on your web application. 

To connect to a selected service, follow the step-by-step instructions given below depending on the authentication mechanism used in your web application.

=== "Managed authentication"
    
    Choreo-managed authentication allows you to seamlessly handle authentication for your web application. You can configure your web application to work with the built-in identity provider of Choreo or any external identity provider that supports OIDC/OAuth2.0

    !!! note 
         Choreo's managed authentication is currently available only for web applications created with **React**, **Angular**, or **Vue.js** buildpacks.

    Follow the steps below to use an existing connection within your web application: 

    <h2> Step 1: Add the connection configuration</h2>

    To integrate a service into your application, you must first add the connection configuration as follows: 

    1. For single page applications (SPAs), you must add the connection configuration as a file mount. You can mount a file via the **Configurations** pane on the **Deploy** page. You must mount a file (for example, `config.js`) and add the configuration provided in the inline developer documentation into it. 

        The following is a sample configuration:

        ``` yaml
             window.configs = {
                 apiUrl: '<SERVICE_URL>',        
             };

        ```

    2.  To ensure accessibility of the `config.js` file via JavaScript at runtime, add a script tag as follows in the `index.html` file to reference the `config.js` file:

        ``` html
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="utf-8" />
            <title>My React App</title>
        </head>
        <body>
            <div id="root"></div>
            <script src="/public/config.js"></script>
        </body>
        </html>
        ``` 

        !!! note
             If you use an external IdP, you must add the IdP's configuration to the same file.
    
             For more information on working with IdPs, see [Configure Asgardeo as an External Identity Provider](https://wso2.com/choreo/docs/administer/configure-an-external-idp/configure-asgardeo-as-an-external-idp/).


    <h2> Step 2: Read the configuration</h2>

    Once you add the connection configuration, you can proceed to read the configuration from your application. The steps to read depend on the programming language you use.

    The following is a sample code snippet in NodeJS:

    ``` java
         const serviceURL = window?.configs?.apiUrl ? window.configs.apiUrl : "/";
    ```

    <h2> Step 3: Invoke the service</h2>

    If you use Choreo-managed authentication, Choreo handles the security handshaking for the application during deployment. The connected service will be accessible under the same domain as your application. Therefore, you can call the configured path directly using your preferred HTTP client.

    The following is a sample code snippet in NodeJS:

    ``` java
         const response = await axios.get(serviceURL/{RESOURCE_PATH});
    ```

    !!! note
         If you are using an external IdP provider instead of Choreo-managed authentication, you must obtain an access token from your IdP and add it to the HTTP authorization header with the bearer prefix.


=== "Custom authentication or no authentication"

    If you are not using Choreo-managed authentication or your web application lacks authentication, follow the steps below to connect to a service from your web application:

    <h2> Step 1: Add the connection configuration</h2>

    1. For single-page applications (SPAs), you must add the connection configuration as a file mount. You can mount a file via the **Configurations** pane on the **Deploy** page. You must mount a file (for example, `config.js`) and add the configuration provided in the inline developer documentation into it.
 
        The following is a sample configuration:

        ``` yaml
             window.configs = {
                 apiUrl: '<SERVICE_URL>',
                 consumerKey: '<CONSUMER_KEY>',
                 consumerSecret: '<CONSUMER_SECRET>',
                 tokenUrl: '<TOKEN_URL>',
             };
        ```

    2.  To ensure accessibility of the `config.js` file via JavaScript at runtime, add a script tag as follows in the `index.html` file to reference the `config.js` file:

        ``` html
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="utf-8" />
            <title>My React App</title>
        </head>
        <body>
            <div id="root"></div>
            <script src="/public/config.js"></script>
        </body>
        </html>
        ``` 

    For other types of web applications, you must add the respective configuration into your application.

    <h2> Step 2: Read the configuration</h2>

    Once you have added the connection configuration, you can proceed to read the configuration from your application. The steps to read depend on the programming language you use.

    The following is a sample code snippet in NodeJS:

    ``` java
         const serviceURL = window?.configs?.apiUrl ? window.configs.apiUrl : "/";
    ```

    <h2> Step 3: Acquire an OAuth 2.0 access token</h2>

    - For languages with OAuth 2.0-aware HTTP clients, you must pass the OAuth 2.0-related configurations such as client id, client secret and so on, obtained when creating the connection to your HTTP client configuration. The HTTP client autonomously manages token retrieval and refreshing.
  
    - For languages without OAuth 2.0-aware HTTP clients, you must manually initiate a call to the token endpoint. This includes fetching the token and managing token expiration and refresh directly within your application code. The following is a sample curl command to obtain a token:


        ```bash
        CONSUMER_KEY="your_consumer_key"
        CONSUMER_SECRET="your_consumer_secret"
        TOKEN_URL="your_token_url"

        # Encode client credentials as Base64
        CLIENT_CREDENTIALS=$(echo -n "$CLIENT_ID:$CLIENT_SECRET" | base64)

        curl -X POST $TOKEN_URL \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -H "Authorization: Basic $CLIENT_CREDENTIALS" \
        --data-urlencode "grant_type=client_credentials"

        ```

    <h2> Step 4: Invoke the service</h2>

    You can invoke the service as follows:

    - For languages with OAuth 2.0-aware HTTP clients, you can invoke the service in a straightforward manner. The HTTP client seamlessly manages OAuth 2.0 authentication without requiring additional intervention.

        As the service URL you can use the URL that you resolved in step 2 above. For sample requests and responses, see the API definition provided via the Choreo marketplace for the service.

    - For languages without OAuth 2.0-aware HTTP clients, you can use the token obtained in step 3 above to make calls to the dependent service. Subsequently, add the obtained token to the HTTP authorization header with the bearer prefix.

        As the service URL you can use the URL that you resolved in step 2 above. For sample requests and responses, see the API definition of the service provided via the Choreo marketplace.

        The following is a sample code snippet in NodeJS:

        ```java 
            const response = await axios.get(serviceURL/{RESOURCE_PATH}, {
                headers: {
                'Authorization': `Bearer ${accessToken}`
                }
            })
        ```


# Use a Database Connection in Your Component

Choreo allows you to share and reuse Choreo-managed databases, accelerating development and enhancing efficiency in building integrated applications through connections.

For step-by-step instructions on creating a database connection, see [Create a Connection](create-a-connection.md).

To learn more about Choreo Connections, see the documentation on [Connections](../../choreo-concepts/connections.md).

## Consume a database through a connection

To consume a Choreo-managed database via a connection, follow these steps:

### Step 1: Add connection configurations

To integrate a database into your application, click the appropriate tab below based on your current configuration file and follow the step-by-step instructions:

=== "Component.yaml file (v1.1)"

    1. Copy and paste the snippet from the  developer guide into the `component.yaml` file.

        The following is a sample snippet:

        ``` yaml

        dependencies:
            connectionReferences:
            - name: <CONNECTION_NAME>
              resourceRef: <RESOURCE_IDENTIFIER>

        ```

          | Field            | Description                                                         |
          |------------------|---------------------------------------------------------------------|
          | name             | The name given to the connection.                                   |
          | resourceRef      | A unique, readable identifier of the database being connected to.    |


    2. If you've previously added a `connectionReferences` section under `dependencies`, append this as another item under `connectionReferences`. Upon deploying the component, the necessary configurations to establish the connection will be injected into Choreo-defined environment variables.

          The following table details the Choreo-defined environment variables:

          | Configuration Key       | Choreo-Defined Environment Variable Name                       |
          |-------------------------|----------------------------------------------------------------|
          | HostName                | CHOREO_<CONNECTION_NAME\>_HOSTNAME                             |
          | Port                    | CHOREO_<CONNECTION_NAME\>_PORT                                 |
          | Username                | CHOREO_<CONNECTION_NAME\>_USERNAME                             |
          | Password                | CHOREO_<CONNECTION_NAME\>_PASSWORD                             |
          | DatabaseName            | CHOREO_<CONNECTION_NAME\>DATABASENAME                          |


          If you'd like to use custom environment variable names instead of the Choreo-defined ones, add the dependency as a service reference under `dependencies` in the same file. For more details, refer to the instructions under the `component.yaml file (v1.0)` tab.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | HostName       | string     | Hostname of the database server       | false         | false        |
          | Port           | string     | Port of the database server           | false         | false        |
          | Username | string           | Username of the database server       | false         | false        |
          | Password       | string     | Password of the database server       | false         | true         |
          | DatabaseName   | string     | Name of the database                  | false         | false        |
    ### Step 2: Read configurations within the application

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const hostName = process.env.CHOREO_<CONNECTION_NAME>_HOSTNAME;
    ```

=== "Component.yaml file (v1.0)"

    !!! note
        The `component.yaml v1.0` file is considered legacy. For new components, we recommend using the latest version, `component.yaml v1.1`, which offers enhanced usability and features.

    1. Copy and paste the snippet from the  developer guide into the `component.yaml` file.

        The following is a sample snippet:

        ``` yaml

        dependencies:
            serviceReferences:
            - name: database:<DATABASE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: HostName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Port
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Username
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Password
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: DatabaseName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>


        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the database you are connecting to.             |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added a service reference section under `dependencies`, append this as another item under `serviceReferences`.

          Upon deploying the component, Choreo automatically populates the specified environment variables with actual values.

          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | HostName       | string     | Hostname of the database server       | false         | false        |
          | Port           | string     | Port of the database server           | false         | false        |
          | Username | string           | Username of the database server       | false         | false        |
          | Password       | string     | Password of the database server       | false         | true         |
          | DatabaseName   | string     | Name of the database                  | false         | false        |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const hostName = process.env.HOSTNAME;
    ```

=== "Component-config.yaml file"

    !!! note
        The `component-config.yaml` file is considered legacy. For new components, we recommend using the latest version, `component.yaml v1.1`, which offers enhanced usability and features.

    1. Copy and paste the snippet from the  developer guide into the `component-config` file under the `spec` section.

        The following is a sample snippet:

        ``` yaml

        outbound:
            serviceReferences:
            - name: database:<DATABASE_NAME>
              connectionConfig: <CONNECTION_ID>
              env:
              - from: HostName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Port
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Username
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: Password
                to: <YOUR_ENV_VARIABLE_NAME_HERE>
              - from: DatabaseName
                to: <YOUR_ENV_VARIABLE_NAME_HERE>

        ```

          | Field            | Description                                                 |
          |------------------|-------------------------------------------------------------|
          | name             | The name of the database you are connecting to.              |
          | connectionConfig | The unique connection identifier for the connection.        |
          | env              | The environment variable mapping.                           |
          | from             | The key of the configuration entry.                         |
          | to               | The environment variable name to which Choreo will inject the value of the key.|


    2. Replace `<YOUR_ENV_VARIABLE_NAME_HERE>` with an appropriate environment variable name of your choice. If you have previously added an outbound service reference, append this as another item under `serviceReferences`.

          Upon deploying the component, Choreo automatically populates the specified environment variables with actual values.


          The following table provides details on the configuration keys associated with the connection:

          | Name           |  Type      |  Description                          |Optional       | Sensitive    |
          |----------------|------------|---------------------------------------|---------------|--------------|
          | HostName       | string     | Hostname of the database server       | false         | false        |
          | Port           | string     | Port of the database server           | false         | false        |
          | Username | string           | Username of the database server       | false         | false        |
          | Password       | string     | Password of the database server       | false         | true         |
          | DatabaseName   | string     | Name of the database                  | false         | false        |

    <h3> Step 2: Read configurations within the application </h3>

    Once you add the connection configuration snippet, you can proceed to read those configurations within your application. The steps to follow depend on the programming language you are using.

    The following is a sample code snippet in NodeJS:

    ``` java
    const hostName = process.env.HOSTNAME;
    ```

### Step 3: Initiate a database connection

To initiate a connection to the database, follow these steps:

In this example, you will connect to a MySQL database.

#### Step 3.1: Install the required packages

For the MySQL database, install the `mysql2` package using npm:

```bash
// Install the mysql2 package
npm install mysql2

```

#### Step 3.2: Import required packages

```java

const client = require('mysql2')

```

#### Step 3.3: Establish a connection

To establish the connection, use the environment variables for `hostName`, `username`, `password`, `databaseName`, and `port` as follows:

```java

var connection = client.createConnection({
      host: hostName,
      user: username,
      password: password,
      database: databaseName,
      port: port
});

connection.connect((err) => {
      if (err) {
          return;
      }
      // Connection is successful
});

```

By following these steps, your component can interact with the Choreo-managed database seamlessly.


